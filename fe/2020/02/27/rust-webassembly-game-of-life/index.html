<!DOCTYPE html><html lang="en" class="h-full relative" data-astro-cid-d3haqyqs><head><!-- Global Metadata --><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><meta name="generator" content="Astro v3.5.0"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="manifest" href="/site.webmanifest"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><meta name="msapplication-TileColor" content="#da532c"><meta name="theme-color" content="#ffffff"><!-- Font preloads --><!-- <link rel="preload" href="/fonts/atkinson-regular.woff" as="font" type="font/woff" crossorigin />
<link rel="preload" href="/fonts/atkinson-bold.woff" as="font" type="font/woff" crossorigin /> --><!-- Canonical URL --><link rel="canonical" href="https://growgen.xyz/fe/2020/02/27/rust-webassembly-game-of-life/"><!-- Primary Meta Tags --><title>GrowGen | 给我整 | 使用 rust 和 webassembly 开发 game of life</title><meta name="title" content="GrowGen | 给我整 | 使用 rust 和 webassembly 开发 game of life"><meta name="description" content="这是一篇翻译，原文，这可能是第一篇系统讲解 rustwasm 的文章了。

这本书适合谁？

这本书适合任何对快速编译 Rust 和 Webassembly 感兴趣的人，相关的代码已经发布在网上。你应该已经了解一些 Rust 的知识，对 J..."><!-- Open Graph / Facebook --><meta property="og:type" content="website"><meta property="og:url" content="https://growgen.xyz/fe/2020/02/27/rust-webassembly-game-of-life/"><meta property="og:title" content="GrowGen | 给我整 | 使用 rust 和 webassembly 开发 game of life"><meta property="og:description" content="这是一篇翻译，原文，这可能是第一篇系统讲解 rustwasm 的文章了。

这本书适合谁？

这本书适合任何对快速编译 Rust 和 Webassembly 感兴趣的人，相关的代码已经发布在网上。你应该已经了解一些 Rust 的知识，对 J..."><meta property="og:image" content="https://growgen.xyz/blog-placeholder-1.jpg"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://growgen.xyz/fe/2020/02/27/rust-webassembly-game-of-life/"><meta property="twitter:title" content="GrowGen | 给我整 | 使用 rust 和 webassembly 开发 game of life"><meta property="twitter:description" content="这是一篇翻译，原文，这可能是第一篇系统讲解 rustwasm 的文章了。

这本书适合谁？

这本书适合任何对快速编译 Rust 和 Webassembly 感兴趣的人，相关的代码已经发布在网上。你应该已经了解一些 Rust 的知识，对 J..."><meta property="twitter:image" content="https://growgen.xyz/blog-placeholder-1.jpg"><script>
      const getThemePreference = () => {
        const stored = localStorage?.getItem('theme')
        if (stored) {
          return stored
        }
        return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light'
      }
      const isDark = () => getThemePreference() === 'dark'
      document.documentElement.classList[isDark() ? 'add' : 'remove']('dark')
    
      if(localStorage) {
        const observer = new MutationObserver(() => {
          const isDark = document.documentElement.classList.contains('dark')
          localStorage.setItem('theme', isDark ? 'dark' : 'light')
        })
        observer.observe(document.documentElement, { attributes: true, attributeFilter: ['class'] })
      }
    </script><link rel="stylesheet" href="/_astro/_slug_.74c705b0.css" />
<link rel="stylesheet" href="/_astro/_slug_.28853c60.css" /></head><body class="min-h-full grid grid-cols-1" data-astro-cid-d3haqyqs><header class="h-16 sticky p-0 px-4 z-10 top-0  bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60" data-astro-cid-3ef6ksr2><nav class="flex items-center justify-between" data-astro-cid-3ef6ksr2><h2 data-astro-cid-3ef6ksr2><a href="/" data-astro-cid-3ef6ksr2>GrowGen | 给我整</a></h2><div class="flex items-center gap-4" data-astro-cid-3ef6ksr2><a href="/" data-astro-cid-3ef6ksr2 data-astro-cid-eimmu3lg>Home</a><a href="/all" data-astro-cid-3ef6ksr2 data-astro-cid-eimmu3lg>Blog</a><style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).load=e;window.dispatchEvent(new Event("astro:load"));})();;(()=>{var b=Object.defineProperty;var f=(c,o,i)=>o in c?b(c,o,{enumerable:!0,configurable:!0,writable:!0,value:i}):c[o]=i;var l=(c,o,i)=>(f(c,typeof o!="symbol"?o+"":o,i),i);var p;{let c={0:t=>m(t),1:t=>i(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(i(t)),5:t=>new Set(i(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t)},o=t=>{let[e,r]=t;return e in c?c[e](r):void 0},i=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([e,r])=>[e,o(r)]));customElements.get("astro-island")||customElements.define("astro-island",(p=class extends HTMLElement{constructor(){super(...arguments);l(this,"Component");l(this,"hydrator");l(this,"hydrate",async()=>{var d;if(!this.hydrator||!this.isConnected)return;let e=(d=this.parentElement)==null?void 0:d.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let r=this.querySelectorAll("astro-slot"),a={},h=this.querySelectorAll("template[data-astro-template]");for(let n of h){let s=n.closest(this.tagName);s!=null&&s.isSameNode(this)&&(a[n.getAttribute("data-astro-template")||"default"]=n.innerHTML,n.remove())}for(let n of r){let s=n.closest(this.tagName);s!=null&&s.isSameNode(this)&&(a[n.getAttribute("name")||"default"]=n.innerHTML)}let u;try{u=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(n){let s=this.getAttribute("component-url")||"<unknown>",y=this.getAttribute("component-export");throw y&&(s+=` (export ${y})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),n),n}await this.hydrator(this)(this.Component,u,a,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});l(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),r.disconnect(),this.childrenConnectedCallback()},r=new MutationObserver(()=>{var a;((a=this.lastChild)==null?void 0:a.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});r.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}start(){let e=JSON.parse(this.getAttribute("opts")),r=this.getAttribute("client");if(Astro[r]===void 0){window.addEventListener(`astro:${r}`,()=>this.start(),{once:!0});return}Astro[r](async()=>{let a=this.getAttribute("renderer-url"),[h,{default:u}]=await Promise.all([import(this.getAttribute("component-url")),a?import(a):()=>()=>{}]),d=this.getAttribute("component-export")||"default";if(!d.includes("."))this.Component=h[d];else{this.Component=h;for(let n of d.split("."))this.Component=this.Component[n]}return this.hydrator=u,this.hydrate},e,this)}attributeChangedCallback(){this.hydrate()}},l(p,"observedAttributes",["props"]),p))}})();</script><astro-island uid="1831nl" prefix="r0" component-url="/_astro/DarkModeToggle.123dfc23.js" component-export="ModeToggle" renderer-url="/_astro/client.97c1142b.js" props="{&quot;data-astro-cid-3ef6ksr2&quot;:[0,true]}" ssr="" client="load" opts="{&quot;name&quot;:&quot;ModeToggle&quot;,&quot;value&quot;:true}" await-children=""><button class="inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 border border-input bg-background hover:bg-accent hover:text-accent-foreground h-10 w-10" type="button" id="radix-:r0R0:" aria-haspopup="menu" aria-expanded="false" data-state="closed"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0"><circle cx="12" cy="12" r="4"></circle><path d="M12 2v2"></path><path d="M12 20v2"></path><path d="m4.93 4.93 1.41 1.41"></path><path d="m17.66 17.66 1.41 1.41"></path><path d="M2 12h2"></path><path d="M20 12h2"></path><path d="m6.34 17.66-1.41 1.41"></path><path d="m19.07 4.93-1.41 1.41"></path></svg><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg><span class="sr-only">Toggle theme</span></button><!--astro:end--></astro-island></div></nav></header><main class="min-h-full grid grid-cols-1 justify-items-center"><article class="markdown-body max-w-6xl"><h1 id="使用-rust-和-webassembly-开发-game-of-life">使用 rust 和 webassembly 开发 game of life</h1>
<p>这是一篇翻译，<a href="https://github.com/rustwasm/book.git" rel="noopener noreferrer nofollow" target="_blank">原文</a>，这可能是第一篇系统讲解 rustwasm 的文章了。</p>
<h2 id="这本书适合谁">这本书适合谁？</h2>
<p>这本书适合任何对快速编译 Rust 和 Webassembly 感兴趣的人，相关的代码已经发布在网上。你应该已经了解一些 Rust 的知识，对 JavaScript HTML 和 css 很熟悉，但你不需要是在这些方面的专家。</p>
<p>还不了解 rust？请先参阅<a href="https://doc.rust-lang.org/book/" rel="noopener noreferrer nofollow" target="_blank">开始使用 rust 语言</a>。
不了解 JavaScript 的 html 或者是 css？请参阅<a href="https://developer.mozilla.org/en-US/docs/Learn" rel="noopener noreferrer nofollow" target="_blank">MDN</a></p>
<h2 id="为什么用-rust-和-webassembly">为什么用 rust 和 webAssembly</h2>
<h3 id="底层支持和高效low-level-control-with-hign-level-ergonomics">底层支持和高效(Low-Level Control with Hign-Level Ergonomics)</h3>
<p>Javascript 的应用，纠结于如何保持高效运作。但是 JavaScript 的动态类型系统和垃圾回收机制，使他们不能高效。看起来很小的修改，如果不小心走出了 JIT 的舒适区，看起来很小的修改都会导致很严重的错误。</p>
<h3 id="wasm-文件大小">.wasm 文件大小</h3>
<p>因为要通过网络下载，代码的大小就变得异常重要。Rust 不需要运行环境，使得编译文件不需要包括垃圾回收器。这些文件包括的只有真正需要的函数。</p>
<h3 id="不要重写所有的东西">不要重写所有的东西</h3>
<p>现有的代码不需要被扔走，你可以把性能最严重的 JavaScript 函数，交给 rust 去执行。</p>
<h3 id="和其他工具交互融洽">和其他工具交互融洽</h3>
<p>Rust 和 WebAssembly 支持现有的工具链，它支持 ecmascript 模块，并且你依然可以使用现有的工具链如 NPM，webpack 和 greenkeeper。</p>
<h2 id="背景和相关概念">背景和相关概念</h2>
<h3 id="什么是-webassembly">什么是 WebAssembly</h3>
<p>WebAssembly（wasm）是一个简单的机器模块拥有大量的<a href="https://webassembly.github.io/spec/" rel="noopener noreferrer nofollow" target="_blank">定义</a>。它被设计得以相近于原生的速度便携紧密地执行。</p>
<p>作为一个开发语言，尽管是以两种方式展示的格式，wasm 依然表示于同样的结构。</p>
<ul>
<li><code>.wat</code>文本格式（叫做 WebAssembly Text），使用<a href="https://en.wikipedia.org/wiki/S-expression" rel="noopener noreferrer nofollow" target="_blank">S-expression</a>，有点类似于 Lisp 家族，像是 Scheme 和 Clojure。</li>
<li><code>.wasm</code>二机制格式，是一个底层的目标是让 wasm 虚拟机使用的格式，有些类似于 ELF 和 Mach-O。</li>
</ul>
<p>以<code>.wat</code>书写的斐波那契数列如下：</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">(</span><span style="color:#F97583">module</span></span>
<span class="line"><span style="color:#E1E4E8">  (</span><span style="color:#B392F0">func</span><span style="color:#B392F0"> $fac</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">param</span><span style="color:#B392F0"> f64</span><span style="color:#E1E4E8">) (</span><span style="color:#F97583">result</span><span style="color:#B392F0"> f64</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">    get_local </span><span style="color:#79B8FF">0</span></span>
<span class="line"><span style="color:#79B8FF">    f64</span><span style="color:#F97583">.const</span><span style="color:#79B8FF"> 1</span></span>
<span class="line"><span style="color:#79B8FF">    f64</span><span style="color:#F97583">.lt</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">result</span><span style="color:#B392F0"> f64</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#79B8FF">      f64</span><span style="color:#F97583">.const</span><span style="color:#79B8FF"> 1</span></span>
<span class="line"><span style="color:#F97583">    else</span></span>
<span class="line"><span style="color:#E1E4E8">      get_local </span><span style="color:#79B8FF">0</span></span>
<span class="line"><span style="color:#E1E4E8">      get_local </span><span style="color:#79B8FF">0</span></span>
<span class="line"><span style="color:#79B8FF">      f64</span><span style="color:#F97583">.const</span><span style="color:#79B8FF"> 1</span></span>
<span class="line"><span style="color:#79B8FF">      f64</span><span style="color:#F97583">.sub</span></span>
<span class="line"><span style="color:#F97583">      call</span><span style="color:#B392F0"> $fac</span></span>
<span class="line"><span style="color:#79B8FF">      f64</span><span style="color:#F97583">.mul</span></span>
<span class="line"><span style="color:#F97583">    end</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">  (</span><span style="color:#F97583">export</span><span style="color:#9ECBFF"> "fac"</span><span style="color:#E1E4E8"> (</span><span style="color:#B392F0">func</span><span style="color:#B392F0"> $fac</span><span style="color:#E1E4E8">)))</span></span></code></pre>
<p>如果感兴趣的话，可以使用<a href="https://webassembly.github.io/wabt/demo/wat2wasm/" rel="noopener noreferrer nofollow" target="_blank">此工具</a>执行上面的代码。</p>
<h4 id="线性内存">线性内存</h4>
<p>Wasm 使用的<a href="https://webassembly.github.io/spec/core/syntax/modules.html#syntax-mem" rel="noopener noreferrer nofollow" target="_blank">内存模式</a>很简单。一个 wasm 模块，可以访问的一系列内存，被限制于一个字节数组中。这些内存会<a href="https://webassembly.github.io/spec/core/syntax/instructions.html#syntax-instr-memory" rel="noopener noreferrer nofollow" target="_blank">增长</a>为多个页（64K）不会收缩。</p>
<h4 id="wasm-是仅仅为-web-开发的吗">Wasm 是仅仅为 web 开发的吗？</h4>
<p>尽管在 JavaScript 和 web 社区中有很多讨论。WASM 并没有考虑过它的运用环境。所以目前只能定义它为将来可以使用的便携运行格式。但就目前而言，wasm 仍然在很多方面与 JavaScript 有关。不仅仅是浏览器，还有 Node.js。</p>
<h2 id="关于本书">关于本书</h2>
<p>这一部分开始使用 Rust 和 WebAssembly 开发<a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life" rel="noopener noreferrer nofollow" target="_blank">Conway 的 Game of Life</a>。</p>
<p>本章会讲到以下内容。</p>
<ul>
<li>如何搭建编译 WebAssembly 的 Rust 工具链。</li>
<li>一个支持开发多语言程序（Rust、wasm、JavaScript、HTML 和 CSS）的工作流。</li>
<li>设计最大利用 rust 和 wasm 的优势配合 JavaScript 的优点的 API。</li>
<li>如何调试 wasm 模块。</li>
<li>如何查看 wasm 的时间日志（time profile）。</li>
<li>如何减少生成的二进制文件包大小。</li>
</ul>
<h2 id="安装工具">安装工具</h2>
<p>本节将会介绍编译 Rust 编译 WASM 并和 JavaScript 集成的工具链。</p>
<h3 id="rust-工具链">Rust 工具链</h3>
<p>你需要安装 rust 的标准工具链，<a href="https://www.rust-lang.org/tools/install" rel="noopener noreferrer nofollow" target="_blank">rustup，rustc 和 cargo</a>（强烈建议你们在 WSl 的环境下面工作）。</p>
<p>WASM 已经推动 Rust 新特性进入稳定版，所以我们需要有 1.30 或更新版本。</p>
<h3 id="wasm-pack">wasm-pack</h3>
<p><code>wasm-pack</code>是一站式的建造测试以及发布 rust 相关的 wasm 应用工具。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#B392F0">cargo</span><span style="color:#9ECBFF"> install</span><span style="color:#9ECBFF"> wasm-pack</span></span></code></pre>
<h3 id="cargo-generate">cargo-generate</h3>
<p><code>cargo-generate</code>帮助你使用现存的 Git 仓库作为模板新建 Rust 项目。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#B392F0">cargo</span><span style="color:#9ECBFF"> install</span><span style="color:#9ECBFF"> cargo-generate</span></span></code></pre>
<h3 id="npm">NPM</h3>
<p><code>npm</code>是 JavaScript 的包装管理器。我们将利用它，去安装和运行 JavaScript 的打包和测试部署。我们将把我们编译好的<code>.wasm</code>文件放到 npm 的包中。</p>
<p>如果你已经安装了 NPM 可以执行以下命令，安装最新版。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#B392F0">npm</span><span style="color:#9ECBFF"> install</span><span style="color:#9ECBFF"> npm@latest</span><span style="color:#79B8FF"> -g</span></span></code></pre>
<h2 id="你好世界">你好，世界</h2>
<p>通过本部分可以创建一个 Rust+WASM 页面，并能在页面弹窗展示<code>"Hello, World!"</code>。</p>
<h3 id="复制项目模板">复制项目模板</h3>
<p>这个项目的模板已经提前编译好，可以借此快速绑定、集成和打包成 Web 项目。</p>
<p>利用模板创建项目的命令：</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#B392F0">cargo</span><span style="color:#9ECBFF"> generate</span><span style="color:#79B8FF"> --git</span><span style="color:#9ECBFF"> https://github.com/rustwasm/wasm-pack-template</span></span></code></pre>
<p>它会提醒你新建一个项目名称，这里我们先使用”wasm-game-of-life”。</p>
<h3 id="文件结构">文件结构</h3>
<p>进入项目文件夹。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#79B8FF">cd</span><span style="color:#9ECBFF"> wasm-game-of-life</span></span></code></pre>
<p>以下是项目文件夹：</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>wasm-game-of-life/</span></span>
<span class="line"><span>├── Cargo.toml</span></span>
<span class="line"><span>├── LICENSE_APACHE</span></span>
<span class="line"><span>├── LICENSE_MIT</span></span>
<span class="line"><span>├── README.md</span></span>
<span class="line"><span>└── src</span></span>
<span class="line"><span>    ├── lib.rs</span></span>
<span class="line"><span>    └── utils.rs</span></span></code></pre>
<p>接下来详细看一下：</p>
<h4 id="wasm-game-of-lifecargotoml">wasm-game-of-life/Cargo.toml</h4>
<p><code>Cargo.toml</code>文件描述<code>cargo</code>的依赖和源文件，Rust 的包管理工具和编译工具。这个包括<code>wasm-bindgen</code>依赖，我们会稍后了解其他的依赖，还有一些用来初始化<code>.wasm</code>的<code>crate-type</code>库。</p>
<h4 id="wasm-game-of-lifesrclibrs">wasm-game-of-life/src/lib.rs</h4>
<p><code>src/lib</code>文件放在 Rust 项目的更目录下面。它使用<code>wasm-bindgen</code>去和 JavaScript 链接。它能引入<code>window.alert</code>这个 JavaScript 函数，并暴露<code>greet</code>函数，并弹出弹框。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>mod utils;</span></span>
<span class="line"><span>use wasm_bindgen::prelude::*;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 当wee_alloc特性被打开，将会使用wee_alloc作为全局分匹配器</span></span>
<span class="line"><span>#[cfg(feature = "wee_alloc")]</span></span>
<span class="line"><span>#[global_allocator]</span></span>
<span class="line"><span>static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#[wasm_bindgen]</span></span>
<span class="line"><span>extern {</span></span>
<span class="line"><span>    fn alert(s: &#x26;str);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#[wasm_bindgen]</span></span>
<span class="line"><span>pub fn greet() {</span></span>
<span class="line"><span>    alert("Hello, wasm-game-of-life!");</span></span>
<span class="line"><span>}</span></span></code></pre>
<h4 id="wasm-game-of-lifesrcutilsrs">wasm-game-of-life/src/utils.rs</h4>
<p><code>src/utils</code>模块为编译 Rust 到 WASM 提供工具函数，我们后面会在调试时提到它，现在先忽略。</p>
<h3 id="编译项目">编译项目</h3>
<p>使用<code>wasm-pack</code>依赖以下工具：</p>
<ul>
<li>保证 Rust 版本在 1.30 以上，且已经通过<code>rustup</code>安装<code>wasm32-unknown-unknown</code>工具链。</li>
<li>使用<code>cargo</code>编译 Rust 到 WASM。</li>
<li>使用<code>wasm-bindgen</code>去生成 JavaScript 的 API。</li>
</ul>
<p>为了完成以上内容，需要在根目录执行以下命令：</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#B392F0">wasm-pack</span><span style="color:#9ECBFF"> build</span></span></code></pre>
<p>编译完成后，我们可以看到<code>pkg</code>里面的结构，里面应该有如下文件。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>pkg/</span></span>
<span class="line"><span>├── package.json</span></span>
<span class="line"><span>├── README.md</span></span>
<span class="line"><span>├── wasm_game_of_life_bg.wasm</span></span>
<span class="line"><span>├── wasm_game_of_life.d.ts</span></span>
<span class="line"><span>└── wasm_game_of_life.js</span></span></code></pre>
<p><code>README.md</code>文件是直接从根目录复制的，但是其他文件完全是新生成的。</p>
<h4 id="wasm-game-of-lifepkgwasm_game_of_life_bgwasm">wasm-game-of-life/pkg/wasm_game_of_life_bg.wasm</h4>
<p><code>.wasm</code>文件是 Rust 工具链使用 Rust 源代码生成的 WASM 的二进制文件，它包括全部的函数和数据，比方说，爆露出来的<code>greet</code>函数。</p>
<h4 id="wasm-game-of-lifepkgwasm_game_of_lifejs">wasm-game-of-life/pkg/wasm_game_of_life.js</h4>
<p>这个<code>.js</code>文件是<code>wasm-bindgen</code>引入 DOM 和 JavaScript 方法到 Rust 中，并油耗地暴露 WASM 的 API 到 JavaScript 中。举个例子，这里个<code>greet</code>函数包裹了 WASM 中的<code>greet</code>函数，目前，这个粘合还没做任何功能，当我们逐渐从 WASM 和 JavaScript 中传输数据，他会提供帮助。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#79B8FF"> *</span><span style="color:#F97583"> as</span><span style="color:#E1E4E8"> wasm </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "./wasm_game_of_life_bg"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">export</span><span style="color:#F97583"> function</span><span style="color:#B392F0"> greet</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#E1E4E8"> wasm.</span><span style="color:#B392F0">greet</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<h4 id="wasm-game-of-lifepkgwasm_game_of_lifedts">wasm-game-of-life/pkg/wasm_game_of_life.d.ts</h4>
<p>这个<code>.d.ts</code>是 TypeScript 链接 JavaScript 的文件。如果你的项目中使用了 TypeScript，你可以让你的 WebAssembly 项目被类型检查，并且你的 IDE 会提供代码提醒和自动完成功能。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>export function greet(): void;</span></span></code></pre>
<h4 id="wasm-game-of-lifepkgpackagejson">wasm-game-of-life/pkg/package.json</h4>
<p>这个文件包括了所有生成的文件描述，并使得这个项目能够作为一个使用 WebAssembly 的 NPM 包，能够集成到 JavaScript 工具链并发布至 NPM。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">{</span></span>
<span class="line"><span style="color:#79B8FF">  "name"</span><span style="color:#E1E4E8">: </span><span style="color:#9ECBFF">"wasm-game-of-life"</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#79B8FF">  "collaborators"</span><span style="color:#E1E4E8">: [</span><span style="color:#9ECBFF">"Your Name &#x3C;your.email@example.com>"</span><span style="color:#E1E4E8">],</span></span>
<span class="line"><span style="color:#79B8FF">  "description"</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">null</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#79B8FF">  "version"</span><span style="color:#E1E4E8">: </span><span style="color:#9ECBFF">"0.1.0"</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#79B8FF">  "license"</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">null</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#79B8FF">  "repository"</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">null</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#79B8FF">  "files"</span><span style="color:#E1E4E8">: [</span><span style="color:#9ECBFF">"wasm_game_of_life_bg.wasm"</span><span style="color:#E1E4E8">, </span><span style="color:#9ECBFF">"wasm_game_of_life.d.ts"</span><span style="color:#E1E4E8">],</span></span>
<span class="line"><span style="color:#79B8FF">  "main"</span><span style="color:#E1E4E8">: </span><span style="color:#9ECBFF">"wasm_game_of_life.js"</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#79B8FF">  "types"</span><span style="color:#E1E4E8">: </span><span style="color:#9ECBFF">"wasm_game_of_life.d.ts"</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<h3 id="开始加入页面">开始加入页面</h3>
<p>想要<code>wasm-game-of-life</code>能够展示到页面中，需要使用<a href="https://github.com/rustwasm/create-wasm-app" rel="noopener noreferrer nofollow" target="_blank"><code>create-wasm-app</code> JavaScript 模板</a>。</p>
<p>在项目根目录执行以下命令：</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#B392F0">npm</span><span style="color:#9ECBFF"> init</span><span style="color:#9ECBFF"> wasm-app</span><span style="color:#9ECBFF"> www</span></span></code></pre>
<p>这是<code>wasm-game-of-life/www</code>文件夹包括的文件。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>wasm-game-of-life/www/</span></span>
<span class="line"><span>├── bootstrap.js</span></span>
<span class="line"><span>├── index.html</span></span>
<span class="line"><span>├── index.js</span></span>
<span class="line"><span>├── LICENSE-APACHE</span></span>
<span class="line"><span>├── LICENSE-MIT</span></span>
<span class="line"><span>├── package.json</span></span>
<span class="line"><span>├── README.md</span></span>
<span class="line"><span>└── webpack.config.js</span></span></code></pre>
<h4 id="wasm-game-of-lifewwwpackagejson">wasm-game-of-life/www/package.json</h4>
<p>这个文件包括已经配置好的<code>webpack</code>和<code>webpack-dev-server</code>依赖，和<code>hello-wasm-pack</code>，版本号为已经发布到 NPM 上面的版本号。</p>
<h4 id="wasm-game-of-lifewwwwebpackconfjs">wasm-game-of-life/www/webpack.conf.js</h4>
<p>这个是用来配置 webpack 和开发服务器的文件。该文件已经提前布置好，如果只是开发则无需过多关心这个文件。</p>
<h4 id="wasm-game-of-lifewwwindexhtml">wasm-game-of-life/www/index.html</h4>
<p>这是页面的 HTML 文件，它是来调用<code>bootstrap.js</code>的。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">&#x3C;!</span><span style="color:#85E89D">DOCTYPE</span><span style="color:#B392F0"> html</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">&#x3C;</span><span style="color:#85E89D">html</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">  &#x3C;</span><span style="color:#85E89D">head</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">    &#x3C;</span><span style="color:#85E89D">meta</span><span style="color:#B392F0"> charset</span><span style="color:#E1E4E8">=</span><span style="color:#9ECBFF">"utf-8"</span><span style="color:#E1E4E8"> /></span></span>
<span class="line"><span style="color:#E1E4E8">    &#x3C;</span><span style="color:#85E89D">title</span><span style="color:#E1E4E8">>Hello wasm-pack!&#x3C;/</span><span style="color:#85E89D">title</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">  &#x3C;/</span><span style="color:#85E89D">head</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">  &#x3C;</span><span style="color:#85E89D">body</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">    &#x3C;</span><span style="color:#85E89D">script</span><span style="color:#B392F0"> src</span><span style="color:#E1E4E8">=</span><span style="color:#9ECBFF">"./bootstrap.js"</span><span style="color:#E1E4E8">>&#x3C;/</span><span style="color:#85E89D">script</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">  &#x3C;/</span><span style="color:#85E89D">body</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">&#x3C;/</span><span style="color:#85E89D">html</span><span style="color:#E1E4E8">></span></span></code></pre>
<h4 id="wasm-game-of-lifewwwindexjs">wasm-game-of-life/www/index.js</h4>
<p>这是 JavaScript 的入口文件，他引入了<code>hello-wasm-pack</code>，并带哦用了 greet 函数。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>import * as wasm from "hello-wasm-pack";</span></span>
<span class="line"><span></span></span>
<span class="line"><span>wasm.greet();</span></span></code></pre>
<h4 id="安装-npm-依赖">安装 NPM 依赖</h4>
<p>首先保证已经在<code>www</code>文件夹下面执行过<code>npm i</code>，这个命令会安装好现有依赖包括 webpack 和开发服务器。</p>
<blockquote>
<p>注意 webpack 并不是必须的，他只是个打包器并提供了开发服务器，这是我们选择它的原因。Parcel 和 Rollup 一样支持 WebAssembly 模块。你也可以选择<a href="https://rustwasm.github.io/docs/wasm-bindgen/examples/without-a-bundler.html" rel="noopener noreferrer nofollow" target="_blank">不使用打包器</a>。</p>
</blockquote>
<h4 id="在-www-文件夹中使用本地-wasm-game-of-life-包">在 www 文件夹中使用本地 wasm-game-of-life 包</h4>
<p>相比于使用 NPM 线上的<code>hello-wasm-pack</code>，使用本地文件会提高我们的开发舒适度。</p>
<p>打开<code>www/package.json</code>，找到<code>devDependencies</code>，在兄弟节点增加<code>dependencies</code>字段，并在里面增加<code>"wasm-game-of-life": "file:../pkg"</code>。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>{</span></span>
<span class="line"><span>  // ...</span></span>
<span class="line"><span>  "dependencies": {                     // Add this three lines block!</span></span>
<span class="line"><span>    "wasm-game-of-life": "file:../pkg"</span></span>
<span class="line"><span>  },</span></span>
<span class="line"><span>  "devDependencies": {</span></span>
<span class="line"><span>    //...</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>接下来修改<code>www/index.js</code>引入 greet 函数。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>import * as wasm from "wasm-game-of-life";</span></span>
<span class="line"><span></span></span>
<span class="line"><span>wasm.greet();</span></span></code></pre>
<p>既然修改了 package.json，则需要重新安装他。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#B392F0">npm</span><span style="color:#9ECBFF"> install</span></span></code></pre>
<p>好了，现在服务器可以成功运行了。</p>
<h4 id="启动本地服务">启动本地服务</h4>
<p>接下来，打开一个新终端来在后台运行服务器，请在<code>www</code>文件夹下执行如下命令。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#B392F0">npm</span><span style="color:#9ECBFF"> run</span><span style="color:#9ECBFF"> start</span></span></code></pre>
<p>打开<a href="http://localhost:8080%EF%BC%8C%E5%BA%94%E5%BD%93%E4%BC%9A%E5%BC%B9%E5%87%BA%E5%A6%82%E4%B8%8B%E5%BC%B9%E7%AA%97%E3%80%82" rel="noopener noreferrer nofollow" target="_blank">http://localhost:8080，应当会弹出如下弹窗。</a></p>
<p><img src="https://rustwasm.github.io/book/images/game-of-life/hello-world.png" alt="弹窗"></p>
<h3 id="练习">练习</h3>
<p>修改 greet 函数，引入参数<code>name: &#x26;str</code>，重新执行<code>wasm-pack build</code>，并刷新页面使得弹窗中能够显示”Hello, {name}“。</p>
<p><strong><em>答案，不许看！</em></strong></p>
<p>修改<code>src/lib.rs</code></p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>#[wasm_bindgen]</span></span>
<span class="line"><span>pub fn greet(name: &#x26;str) {</span></span>
<span class="line"><span>    alert(&#x26;format!("Hello, {}!", name));</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>再修改 JavaScript 绑定<code>www/index.js</code></p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>wasm.greet("Your name");</span></span></code></pre>
<h2 id="conway-的生命游戏的游戏规则">Conway 的生命游戏的游戏规则</h2>
<p>如果你已经了解<a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life" rel="noopener noreferrer nofollow" target="_blank">Conway 的生命游戏</a>，可以跳过这部分。</p>
<p>整个 Conway 的生命游戏是在一个无限的二维的正交格子宇宙中，每一个细胞拥有两种生命状态，生或者死。或者说可增殖或者不可增殖。每一个细胞都和它的 8 个邻居交互，它们分别是纵向的，斜向的，横向的相邻。并且每一步都会发生如下的变化。</p>
<ol>
<li>任何一个活着的细胞，如果有少于两个邻居就会死亡。</li>
<li>任何一个活细胞拥有两个或三个活着的邻居，则会继续增殖。</li>
<li>任何一个活着的细胞拥有三个以上活着的的邻居，则会死亡。</li>
<li>任何一个死掉的细胞，如果有三个活着的邻居，则会重生。</li>
</ol>
<p>最初的图案组成了最初的世界。第 1 代是按照以上的规则生成的，每一个细胞的生成和死亡都是同时的。他们的生存和死亡这一个时间我们称之为一刻。用程序的语言来说，这一刻是上一次生成的纯函数。这个规则一直有效。</p>
<p>考虑设置如下的初始宇宙：</p>
<p><img src="https://rustwasm.github.io/book/images/game-of-life/initial-universe.png" alt="初始宇宙"></p>
<p>我们可以通过考虑每一个细胞来确定下一代。最左上角的细胞已经死亡，第 4 条规则是唯一一个能够处理死亡细胞的规则。所以第 1 排的所有细胞都有相同的规则。他们都没有三个活着的邻居。只能保持死亡。</p>
<p>当我们看到最上面的活着的细胞时，这个游戏开始变得有趣了。在第 2 排第 3 列。对于活着细胞前三个规则都可以应用。对于这一个细胞，他只有一个活着的邻居，所以规则一可用。这个细胞会在下一次争执死亡。下面那几个活着的细胞也是有一样的命运。</p>
<p>中间的活着的细胞，还有两个邻居，上面的和下面的，这就意味着它符合规则二，他可以活到下一次增值。</p>
<p>最后一个比较有趣的例子，就是当我们看到死掉的细胞。嗯。在中间这活着的细胞的左边和右边。这三个活着的细胞都是他们的邻居。这使得他们按照规则是可以在下一轮重生。</p>
<p>将这些规则放在一起，我们可以获得下一刻的世界。</p>
<p><img src="https://rustwasm.github.io/book/images/game-of-life/next-universe.png" alt="下一刻的世界"></p>
<p>根据这个例子，和确定的规则。不去并精彩的事情将会发生。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/e/e5/Gospers_glider_gun.gif" alt="Gosper&#x27;s glider gun"></p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/07/Game_of_life_pulsar.gif" alt="Pulsar"></p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/3/37/Game_of_life_animated_LWSS.gif" alt="Space ship"></p>
<h3 id="练习-1">练习</h3>
<p>手动计算出下一刻，宇宙应该是什么样</p>
<p><strong><em>答案，不许看！</em></strong></p>
<p><img src="https://rustwasm.github.io/book/images/game-of-life/initial-universe.png" alt="下一刻宇宙"></p>
<p>你能找到一个稳定的没有变化的宇宙吗？</p>
<p><strong><em>答案，不许看！</em></strong></p>
<p>这个答案，不许看！其实有无数个，最平凡的答案，不许看！就是它是一个空宇宙。如果是一个 2×2 的方格，也可以形成一个稳定的宇宙。</p>
<h2 id="实现-conway-的生命游戏">实现 Conway 的生命游戏</h2>
<h3 id="设计">设计</h3>
<p>在开始之前呢，我们要先考虑以下几种设计模式。</p>
<h4 id="无限宇宙">无限宇宙</h4>
<p>生命游戏是在一个无限宇宙中玩的。但是我们没有无限的内存和计算能力。在这种情况下，我们往往会有三个选项。</p>
<ol>
<li>始终追踪这个宇宙的发展，并适当的扩展宇宙。这个扩张是无限的，所以这个实现实现了就会逐渐逐渐的变得越来越慢，直到把内存全部用完。</li>
<li>创建一个固定的宇宙，当细胞碰到宇宙的边缘的时候，将会有更少的邻居。更简单的策略就是当他们已经达到边缘的时候，直接被宇宙剪掉。</li>
<li>创建一个固定的宇宙，当细胞达到边缘的时候，将会从另外一边滑入这样，我的我们的应用就可以一直跑下去。</li>
</ol>
<p>我们会按照第 3 个选项来实现。</p>
<h4 id="连接-rust-和-javascript">连接 Rust 和 JavaScript</h4>
<blockquote>
<p>此部分是本人最重要的一节。</p>
</blockquote>
<p>JavaScript 的垃圾回收堆内存，是用来调用 Object 和 Array 还有 DOM 结点的。而 Rust 存在的 WebAssembly 线性内存和它是截然不同的。WebAssembly 目前还不能直接操作垃圾回收堆内存（在 2018 年 4 月，一个关于<a href="https://github.com/WebAssembly/interface-types/blob/master/proposals/interface-types/Explainer.md" rel="noopener noreferrer nofollow" target="_blank">接口类型（Interface Type）</a>的提案将会改变这一局面）。JavaScript 却可以读写 WebAssembly 的线性内存，但仅限于 ArrayBuffe 支持的标量（u8, i32, f64 等等）。WebAssembly 行数一样能处理和返回这些标量。以下讲解 WebAssembly 和 JavaScript 如何链接。</p>
<p>wasm_bindgen 定义了如何穿过这段链接计算数据结构的方法。它包括装箱 Rust 结构，并包装指针成为一个 JavaScript 类以供使用，或者提供 JavaScript 对象给 Rust 使用。wasm_bindgen 非常便利，但并不是无需考虑怎样在这个链接上传输数据结构。你应该把它当作一个实现接口的工具。</p>
<p>当设计 WebAssembly 和 JavaScript 的接口时，我们需要考虑到以下内容。</p>
<ol>
<li><strong>减少复制到和移出 WebAssembly 线性内存中的值</strong>，无效的复制会造成无用的性能损耗。</li>
<li><strong>最小的序列化和解序列化</strong>，和复制类似，序列化和解序列化一样造成性能损耗，如果想要把数据无副作用地从一端传到另一端，与其说在一端序列化，到另一端解序列化，不如使用 wasm_bindgen 帮助我们将 JavaScript 的 Object 装箱成 Rust 的 structure。</li>
</ol>
<p>一个结论，处理 JavaScript 和 WebAssembly 接口设计时，经常将大的、生命周期长的数据结构作为 Rust 类型，存储在 WebAssembly 线性内存中，并给 JavaScript 暴露一个处理方法，JavaScript 调用 WebAssembly 转换文件，处理运算，并最终得到一个小的，可复制的结果。通过只返回计算结果，我们可以躲过复制和序列化数据的过程。</p>
<h4 id="在生命游戏中链接-rust-和-javascript">在生命游戏中链接 Rust 和 JavaScript</h4>
<p>接下来结局几个要规避的问题。我们不想每刻都复制整个宇宙到 WebAssembly 的内存中，我们不想处理宇宙中所有的细胞，也不想在每次读写细胞的时候都穿过 WebAssembly 和 JavaScript 的分界。</p>
<p>这是我们的 4x4 宇宙在内存中的结构。</p>
<p><img src="https://rustwasm.github.io/docs/book/images/game-of-life/universe.png" alt="4x4宇宙在内存中的结构"></p>
<p>为了寻找细胞在内存中的位置，我们可以使用下面的公式。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>index(row, column, universe) = row * width(universe) + column</span></span></code></pre>
<p>我们有很多方法来给 JavaScript 暴露宇宙中的细胞。开始我们要为宇宙实现一个<code>std::fmt::Display</code>。我们可以使用一个 Rust 的 String，每个字符代表一个细胞。这个 Rust 的 string 将会从 WebAssembly 的内存中复制到 JavaScript 的内存里，并接下来作为 textContent 展示到 HTML 里面。本节的后面，将会讲到如何把细胞展示到 canvas 中。</p>
<blockquote>
<p>另一种设计是让 Rust 返回每个细胞的生存状态列表，这样 JavaScript 就不需要在渲染时解析整个宇宙，这不过这个是先更加复杂些。</p>
</blockquote>
<h4 id="rust-的实现">Rust 的实现</h4>
<p>上一章，我们复制了初始化模板，我们现在要修改这个模板。</p>
<p>从删除 greet 函数，并定义宇宙中的细胞开始。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>#[wasm_bindgen]</span></span>
<span class="line"><span>#[repr(u8)]</span></span>
<span class="line"><span>#[derive(Clone, Copy, Debug, PartialEq, Eq)]</span></span>
<span class="line"><span>pub enum Cell {</span></span>
<span class="line"><span>    Dead = 0,</span></span>
<span class="line"><span>    Alive = 1,</span></span>
<span class="line"><span>}</span></span></code></pre>
<p><code>#[repr(u8)]</code>很重要，这样每个细胞都会以一个字节存储，另外 Alive 为 1，Dead 为 0 也很重要，这样我们就可以使用加法计算邻居数目。</p>
<p>接下来定义宇宙，一个宇宙包括宽度，高度和一个向量的细胞。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>#[wasm_bindgen]</span></span>
<span class="line"><span>pub struct Universe {</span></span>
<span class="line"><span>    width: u32,</span></span>
<span class="line"><span>    height: u32,</span></span>
<span class="line"><span>    cells: Vec&#x3C;Cell>,</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>访问并转换细胞的实现如下。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>impl Univers {</span></span>
<span class="line"><span>    fn get_index(&#x26;self, row: u32, column: u32) -> usize {</span></span>
<span class="line"><span>        (row*self.width + column) as usize</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>为了计算细胞接下来的状态，我们要统计某个细胞有多少个邻居存活。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>impl Univers {</span></span>
<span class="line"><span>    fn live_neighbor_count(&#x26;self, row: u32, column: u32) -> u8 {</span></span>
<span class="line"><span>        let mut count = 0;</span></span>
<span class="line"><span>        for delta_row in [self.height - 1, 0, 1].iter().cloned() {</span></span>
<span class="line"><span>            for delta_col in [self.width - 1, 0, 1].iter().cloned() {</span></span>
<span class="line"><span>                if delta_row == 0 &#x26;&#x26; delta_col ==0 {</span></span>
<span class="line"><span>                    continue;</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>                let neighbor_row = (row + delta_row) % self.height;</span></span>
<span class="line"><span>                let neighbor_col = (column + delta_col) % self.width;</span></span>
<span class="line"><span>                let idx = self.get_index(neighbor_row, neighbor_col);</span></span>
<span class="line"><span>                count += self.cells[idx] as u8</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        count</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>这个函数使用取余处理边界问题。现在我们已经有所有的必须函数了，最后只需要生成下一刻的状态即可（记住，每个函数必须在<code>#[wasm_bindgen]</code>属性之下，这样 JavaScript 才能接到暴露的函数）。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>#[wasm_bindgen]</span></span>
<span class="line"><span>impl Universe {</span></span>
<span class="line"><span>    pub fn tick(&#x26;mut self) {</span></span>
<span class="line"><span>        let mut next = self.cells.clone();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        for row in 0..self.height {</span></span>
<span class="line"><span>            for col in 0..self.width {</span></span>
<span class="line"><span>                let idx = self.get_index(row, col);</span></span>
<span class="line"><span>                let cell = self.cells[idx];</span></span>
<span class="line"><span>                let live_neighbors = self.live_neighbor_count(row, col);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>                let next_cell = match (cell, live_neighbors) {</span></span>
<span class="line"><span>                    (Cell::Alive, x) if x &#x3C; 2 => Cell::Dead,</span></span>
<span class="line"><span>                    (Cell::Alive, 2) | (Cell::Alive, 3) => Cell::Alive,</span></span>
<span class="line"><span>                    (Cell::Alive, x) if x > 3 => Cell::Dead,</span></span>
<span class="line"><span>                    (Cell::Dead, 3) => Cell::Alive,</span></span>
<span class="line"><span>                    (otherwise, _) => oterwise,</span></span>
<span class="line"><span>                };</span></span>
<span class="line"><span></span></span>
<span class="line"><span>                next[idx] = next_cell;</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        self.cells = next;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>目前为止，一个宇宙的状态就都被存储在 cell 这个向量里面了。为了提高它的可读性，让我们实现一个文本渲染器，目的是将整个宇宙按行输出为文字，每一个活着的细胞标注为 Unicode 符号“■”，死掉的细胞则为“□”。</p>
<p>通过实现 Rust 标准库中的<code>Display</code>trait，我们可以将数据结构以一种用户交互方式输出，它也提供了一个<code>to_string</code>方法。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>use std::fmt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>impl fmt::Display for Universe {</span></span>
<span class="line"><span>  fn fmt(&#x26;self, f: &#x26;mut fmt::Formatter) -> fmt::Result {</span></span>
<span class="line"><span>    for line in self.cells.as_slice().chunks(self.width as usize) {</span></span>
<span class="line"><span>      for &#x26;cell in line {</span></span>
<span class="line"><span>        let symbol = if cell == Cell::Dead {"□"} else {"■"};</span></span>
<span class="line"><span>        write!(f, "\n")?;</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    Ok(())</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>最后，我们定义一个构造器去初始化一个有趣的图案和一个渲染函数。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>#[wasm_bindgen]</span></span>
<span class="line"><span>impl Universe {</span></span>
<span class="line"><span>  pub fn new() -> {</span></span>
<span class="line"><span>    let width = 64;</span></span>
<span class="line"><span>    let height = 64;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    let cells = (0..width * height)</span></span>
<span class="line"><span>      .map(|i| {</span></span>
<span class="line"><span>        if i%2 == 0 || i%7 == 0 {</span></span>
<span class="line"><span>          Cell::Alive</span></span>
<span class="line"><span>        } else {</span></span>
<span class="line"><span>          Cell::Dead</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>      }).collect();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    Universe {</span></span>
<span class="line"><span>      width,</span></span>
<span class="line"><span>      height,</span></span>
<span class="line"><span>      cells,</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  pub fn render(&#x26;self) -> String {</span></span>
<span class="line"><span>    self.to_string()</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>以上，Rust 部分已经完工。</p>
<h4 id="使用-javascript-渲染">使用 JavaScript 渲染</h4>
<p>首先在 HTML 中插入</p><pre>标签用来展示整个宇宙。<p></p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">&#x3C;</span><span style="color:#85E89D">body</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">  &#x3C;</span><span style="color:#85E89D">pre</span><span style="color:#B392F0"> id</span><span style="color:#E1E4E8">=</span><span style="color:#9ECBFF">"game-of-life-canvas"</span><span style="color:#E1E4E8">>&#x3C;/</span><span style="color:#85E89D">pre</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">  &#x3C;</span><span style="color:#85E89D">script</span><span style="color:#B392F0"> src</span><span style="color:#E1E4E8">=</span><span style="color:#9ECBFF">"./bootstrap.js"</span><span style="color:#E1E4E8">>&#x3C;/</span><span style="color:#85E89D">script</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">&#x3C;/</span><span style="color:#85E89D">body</span><span style="color:#E1E4E8">></span></span></code></pre>
<p>另外我们希望</p><pre>标签能处于页面中央。我们可以通过 CSS flex box 实现这个任务，在 html 中增加<style>标签。</style>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#85E89D">body</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#79B8FF">  position</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">absolute</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#79B8FF">  top</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#79B8FF">  left</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#79B8FF">  width</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">100</span><span style="color:#F97583">%</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#79B8FF">  height</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">100</span><span style="color:#F97583">%</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#79B8FF">  display</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">flex</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#79B8FF">  flex-direction</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">column</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#79B8FF">  align-items</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">center</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#79B8FF">  justify-content</span><span style="color:#E1E4E8">: </span><span style="color:#79B8FF">center</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>修改 JavaScript 入口文件，将原来引入的 greet 函数改为 Universe。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>import { Universe } from "wasm-game-of-life";</span></span></code></pre>
<p>让我们在那个</p><pre>标签中增加新的宇宙实例吧。<p></p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>const pre = document.getElementById("game-of-life-canvas");</span></span>
<span class="line"><span>const universe = Universe.new();</span></span></code></pre>
<p>使用 JavaScript 创建一个 requestAnimationFrame 循环，每一次循环，就在</p><pre>标签中绘制一遍宇宙，并执行一次<code>Universe::tick</code>。<p></p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>function renderLoop() {</span></span>
<span class="line"><span>  pre.textContent = universe.render();</span></span>
<span class="line"><span>  universe.tick();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  requestAnimationFrame(renderLoop);</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>想要实现渲染，只需执行<code>requestAnimationFrame(renderLoop)</code>。</p>
<p>确保你的本地服务任然在运行，此时你的页面应该如下所示。</p>
<p><img src="https://rustwasm.github.io/book/images/game-of-life/initial-game-of-life-pre.png" alt="浏览器页面"></p>
<h4 id="渲染到-canvas-上">渲染到 Canvas 上</h4>
<p>在 Rust 中生成字符串并通过 wasm-bindgen 拷贝到 JavaScript 中做了很多无关的复制。既然 JavaScript 已经知道宇宙的长度和宽度，而且 JavaScript 本来可以直接读 WebAssembly 的内存，我们将要修改 render 方法，直接返回细胞向量的指针。</p>
<p>同时，与其渲染 Unicode 字符，不如开始用 Canvas API。接下来我们会开始设计这些。</p>
<p>在 html 中，修改</p><pre>为<canvas>。<p></p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">&#x3C;</span><span style="color:#85E89D">body</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">  &#x3C;</span><span style="color:#85E89D">canvas</span><span style="color:#B392F0"> id</span><span style="color:#E1E4E8">=</span><span style="color:#9ECBFF">"game-of-life-canvas"</span><span style="color:#E1E4E8">>&#x3C;/</span><span style="color:#85E89D">canvas</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">  &#x3C;</span><span style="color:#85E89D">script</span><span style="color:#B392F0"> src</span><span style="color:#E1E4E8">=</span><span style="color:#9ECBFF">"./bootstrap.js"</span><span style="color:#E1E4E8">>&#x3C;/</span><span style="color:#85E89D">script</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">&#x3C;/</span><span style="color:#85E89D">body</span><span style="color:#E1E4E8">></span></span></code></pre>
<p>为了能拿到 Rust 中的相关数据结构，我们需要为宇宙增加 getter 函数，暴露宇宙的宽度、高度和细胞的向量。增加如下函数。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>#[wasm_bindgen]</span></span>
<span class="line"><span>impl Universe {</span></span>
<span class="line"><span>  pub fn width(&#x26;self) -> u32 {</span></span>
<span class="line"><span>    self.width</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  pub fn height(&#x26;self) -> u32 {</span></span>
<span class="line"><span>    self.height</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  pub fn cells(&#x26;self) -> *const Cell {</span></span>
<span class="line"><span>    self.cells.as_ptr()</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>接下来，在 JavaScript 中，引入 Cell，并设置几个渲染画布的常量。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>import { Universe, Cell } from "wasm-game-of-life";</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const CELL_SIZE = 5;</span></span>
<span class="line"><span>const GRID_COLOR = "#CCCCCC";</span></span>
<span class="line"><span>const DEAD_COLOR = "#FFFFFF";</span></span>
<span class="line"><span>const LIVE_COLOR = "#000000";</span></span></code></pre>
<p>接下来修改实现 canvas 的部分。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>const universe = Universe.new();</span></span>
<span class="line"><span>const width = universe.width();</span></span>
<span class="line"><span>const height = universe.height();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const canvas = documnet.getElementById("game-of-life-canvas");</span></span>
<span class="line"><span>canvas.height = (CELL_SIZE+1)*height + 1;</span></span>
<span class="line"><span>canvas.width = (CELL_SIZE+1)*width + 1;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const ctx = canvas.getContext("2d");</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function renderLoop() {</span></span>
<span class="line"><span>  universe.tick();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  drawGrid();</span></span>
<span class="line"><span>  drawCells();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  requestAnimationFrame(renderLoop);</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>世界的网格，是一系列等宽的竖线和横线。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>function drawGrid() {</span></span>
<span class="line"><span>  ctx.beginPath();</span></span>
<span class="line"><span>  ctx.strokeStyle = GRID_COLOR;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  for(let i =0; i &#x3C;= width; i+=1) {</span></span>
<span class="line"><span>    ctx.moveTo(i*(CELL_SIZE+1) + 1, 0);</span></span>
<span class="line"><span>    ctx.lineTo(i*(CELL_SIZE+1) + 1, (CELL_SIZE+1)*height+1);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  for(let i=0; i&#x3C;=height; j++) {</span></span>
<span class="line"><span>    ctx.moveTo(0, i*(CELL_SIZE+1)+1);</span></span>
<span class="line"><span>    ctx.lineTo((CELL_SIZE+1)*width+1, i*(CELL_SIZE+1)+1);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  ctx.stroke();</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>我们可以直接访问 WebAssembly 的内存，他是直接定义在<code>wasm_game_of_life_bg</code>。为了画细胞，我们先找到一个细胞的指针，并将它们转换成 Unit8Array，迭代这些细胞，并按照他们的生命状态绘制白色和黑色方块。计量避免复制所有细胞。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>import { memory } from "wasm-game-of-life/wasm_game_of_life_bg";</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function getIndex(row, column) {</span></span>
<span class="line"><span>  return row*width+column;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function drawCells() {</span></span>
<span class="line"><span>  const cellsPtr = universe.cells();</span></span>
<span class="line"><span>  const cells = new Unit8Array(</span></span>
<span class="line"><span>    memory.buffer,</span></span>
<span class="line"><span>    cellPtr,</span></span>
<span class="line"><span>    width*height,</span></span>
<span class="line"><span>  );</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  ctx.beginPath();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  for(let row=0; row&#x3C;height; row+=1) {</span></span>
<span class="line"><span>    for (let col=0; col&#x3C;width; col+=1) {</span></span>
<span class="line"><span>      const idx = getIndex(row, col);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>      ctx.fillStyle = cells[idx] === CellDead</span></span>
<span class="line"><span>        ? DEAD_COLOR</span></span>
<span class="line"><span>        : LIVE_COLOR;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>      ctx.fillRect(</span></span>
<span class="line"><span>        cell*(CELL_SIZE+1) + 1,</span></span>
<span class="line"><span>        row*(CELL_SIZE+1) + 1,</span></span>
<span class="line"><span>        CELL_SIZE,</span></span>
<span class="line"><span>        CELL_SIZE,</span></span>
<span class="line"><span>      );</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  ctx.stroke();</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>开始渲染，需要添加以下表达式。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>drawGrid();</span></span>
<span class="line"><span>drawCells();</span></span>
<span class="line"><span>requestAnimationFrame(renderLoop);</span></span></code></pre>
<p>注意 drawGrid 和 drawCell 必须要在 requestAnimationFrame 之前执行。</p>
<h4 id="成功了">成功了！</h4>
<p>重建 WebAssembly 绑定。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#B392F0">wasm-pack</span><span style="color:#9ECBFF"> build</span></span></code></pre>
<p>确定开发服务器还在运行，如果不是，需要执行以下命令。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#B392F0">npm</span><span style="color:#9ECBFF"> run</span><span style="color:#9ECBFF"> start</span></span></code></pre>
<p>刷新<code>http://localhost:8080/</code>，你应该能看到如下结果。</p>
<p><img src="https://rustwasm.github.io/docs/book/images/game-of-life/initial-game-of-life.png" alt="页面"></p>
<p>结束之前，这里还有一个不错的实现生命游戏的算法，<a href="https://en.wikipedia.org/wiki/Hashlife" rel="noopener noreferrer nofollow" target="_blank">hashlife</a>。它使用缓存，使得程序有指数级性能提升！但是为什么我们不实现它呢？它已经超出本文涉及的范围了，本文只是专注于 Rust 和 WebAssembly 集成，但是我们强烈期望你能实现这一算法。</p>
<h3 id="练习-2">练习</h3>
<h4 id="实现一台宇宙飞船">实现一台宇宙飞船</h4>
<h4 id="生成一个随机的初始环境每个细胞有-50的生存可能">生成一个随机的初始环境，每个细胞有 50%的生存可能</h4>
<p><strong><em>答案，不许看！</em></strong></p>
<p>先增加 js-sys 依赖</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">[</span><span style="color:#B392F0">dependencies</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#E1E4E8">js-sys=</span><span style="color:#9ECBFF">"0.3"</span></span></code></pre>
<p>接下来使用 js 的随机函数</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>extern crate js_sys;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>if js_sys::Math::random() &#x3C; 0.5 {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>} else {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span></code></pre>
<h4 id="以-bit-形式存储每个-cell">以 bit 形式存储每个 cell</h4>
<p><strong><em>答案，不许看！</em></strong></p>
<p>在 Rust 中，使用 fixedbitset 代替<code>Vec&#x3C;Cell></code>;</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>extern crate fixedbitset;</span></span>
<span class="line"><span>use fixedbitset::FixedBitSet;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#[wasm_bindgen]</span></span>
<span class="line"><span>pub struct Universe {</span></span>
<span class="line"><span>  width: u32,</span></span>
<span class="line"><span>  height: u32,</span></span>
<span class="line"><span>  cells: FixedBitSet,</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>宇宙的构造器应该这么修改。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>pub fn new() -> Universe {</span></span>
<span class="line"><span>  let width = 64;</span></span>
<span class="line"><span>  let height = 64;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  let size = (width*height) as usize;</span></span>
<span class="line"><span>  let mut cells = FixedBitSet::with_capacity(size);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  for i in 0..size {</span></span>
<span class="line"><span>    cells.set(i, i%2==0 || i%7==0);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  Universe {</span></span>
<span class="line"><span>    width,</span></span>
<span class="line"><span>    height,</span></span>
<span class="line"><span>    cells,</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>使用 FixedBitSet 的 set 方法更新宇宙的下一刻。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>next.set(idx, match (cell, live_neighbors) {</span></span>
<span class="line"><span>  (true, x) if x&#x3C;2 => false,</span></span>
<span class="line"><span>  (true, 2) | (true, 3) => true,</span></span>
<span class="line"><span>  (true, x) if x>3 => false,</span></span>
<span class="line"><span>  (false, 3) => true,</span></span>
<span class="line"><span>  (otherwise, _) => otherwise</span></span>
<span class="line"><span>});</span></span></code></pre>
<p>传输指针的时候，需要返回 slice。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>#[wasm_bindgen]</span></span>
<span class="line"><span>impl Universe {</span></span>
<span class="line"><span>  pub fn cells(&#x26;self) -> *const u32 {</span></span>
<span class="line"><span>    self.cells.as_slice().as_ptr()</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>在 JavaScript 中，构造 Unit8Array 的时候需要除以 8，以为我们是以 bit 存储细胞的。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>const cells = new Unit8Array(</span></span>
<span class="line"><span>  memory.buffer,</span></span>
<span class="line"><span>  cellsPtr,</span></span>
<span class="line"><span>  width*height/8</span></span>
<span class="line"><span>);</span></span></code></pre>
<p>通过判断 Unit8Array 是否被赋值而判断细胞是否是活着的。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>function bitIsSet(n, arr) {</span></span>
<span class="line"><span>  const byte = Math.floor(n/8);</span></span>
<span class="line"><span>  const mask = 1&#x3C;&#x3C;(n%8);</span></span>
<span class="line"><span>  return (arr[byte] &#x26; mask) == mask;</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>根据以上变化，新版本的 drawCells 如下。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>function drawCells() {</span></span>
<span class="line"><span>  const cellsPtr = universe.cells();</span></span>
<span class="line"><span>  const cells = new Unit8Array(</span></span>
<span class="line"><span>    memory.buffer,</span></span>
<span class="line"><span>    cellsPtr,</span></span>
<span class="line"><span>    width*height/8</span></span>
<span class="line"><span>  );</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  ctx.beginPath();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  for (let row=0; row&#x3C;height; row+=1) {</span></span>
<span class="line"><span>    for(let col=0; col&#x3C;width; col+=1) {</span></span>
<span class="line"><span>      const idx = getIndex(row, col);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>      ctx.fillStyle = bitIsSet(idex, cells)</span></span>
<span class="line"><span>        ? LIVE_COLOR</span></span>
<span class="line"><span>        : DEAD_COLOR;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>      ctx.fillRect(</span></span>
<span class="line"><span>        col*(CELL_SIZE+1)+1,</span></span>
<span class="line"><span>        row*(CELL_SIZE+1)+1,</span></span>
<span class="line"><span>        CELL_SIZE,</span></span>
<span class="line"><span>        CELL_SIZE,</span></span>
<span class="line"><span>      );</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  ctx.stroke();</span></span>
<span class="line"><span>}</span></span></code></pre>
<h2 id="测试">测试</h2>
<p>现在我们已经实现了 Rust 的实现，并成功渲染在浏览器中。现在来谈谈测试 WebAssembly 中的 Rust 函数。</p>
<p>我们将要测试 tick 函数，确保它能返回正确的值。</p>
<p>接下来，我们将处理 Universe 的 setter 函数，让我们能构造不同大小的 universe。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>#[wasm_bindgen]</span></span>
<span class="line"><span>impl Universe {</span></span>
<span class="line"><span>  pub fn set_width(&#x26;mut self, width: u32) {</span></span>
<span class="line"><span>    self.width = width;</span></span>
<span class="line"><span>    self.cells = (0..width * self.height).map(|_| Cell::Dead).collect()</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  pub fn set_height(&#x26;mut self, height: u32) {</span></span>
<span class="line"><span>    self.height = height;</span></span>
<span class="line"><span>    self.cells = (0..self.width * height).map(|_| Cell::Dead).collect()</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>我们将会创建另一个不需要<code>#[wasm_bindgen]</code>的<code>impl Universe</code>实现，因为我们不能把所有的 WebAssembly 函数暴露给 JavaScript，Rust 生成的 WebAssembly 函数是不能返回引用的。可以尝试让 Rust 返回一个引用，查看一下编译结果中是什么错误。</p>
<p>接下来我们要写一个 get_cells 来获得细胞，和一个 set_cells 来设置哪些细胞是活的，哪些是死的。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>impl Universe {</span></span>
<span class="line"><span>  pub fn get_cells(&#x26;self) -> &#x26;[Cell] {</span></span>
<span class="line"><span>    &#x26;self.cells</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  pub fn set_cells(&#x26;mut self, cells: &#x26;[(u32, u32)]) {</span></span>
<span class="line"><span>    for (row, col) in cells.iter().cloned() {</span></span>
<span class="line"><span>      let idx = self.get_index(row, col);</span></span>
<span class="line"><span>      self.cells[idx] = Cell::Alive;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>现在我们将创建测试文件<code>tests/web.rs</code>。</p>
<p>在这之前，测试环境已经配置好，请确定<code>wasm-pack test --chrome --headless</code>能够在根目录下运行。你也可以使用<code>--firefox</code>，<code>--safari</code>和<code>--node</code>选项来在其他浏览器测试你的代码。</p>
<p>在<code>test/web.rs</code>中，我们需要到处 Universe 类型。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>extern crate wasm_game_of_life;</span></span>
<span class="line"><span>use wasm_game_of_life:Universe;</span></span></code></pre>
<p>在测试文件中，我们要创建一个飞船构造函数。</p>
<p>我们要构造一个 tick 函数执行之前的飞船，和一个 tick 函数执行后的期望值。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>#[cfg(test)]</span></span>
<span class="line"><span>pub fn input_spaceship() -> Universe {</span></span>
<span class="line"><span>  let mut universe = Universe::new();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  universe.set_width(6);</span></span>
<span class="line"><span>  universe_set_height(6);</span></span>
<span class="line"><span>  universe_set_cells(</span></span>
<span class="line"><span>    &#x26;[</span></span>
<span class="line"><span>      (1,2),</span></span>
<span class="line"><span>      (2,3),</span></span>
<span class="line"><span>      (3,1), (3,2),(3,3)</span></span>
<span class="line"><span>    ]</span></span>
<span class="line"><span>  );</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  universe</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#[cfg(test)]</span></span>
<span class="line"><span>pub fn expected_spaceship() -> Universe {</span></span>
<span class="line"><span>  let mut universe = Universe::new();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  universe.set_width(6);</span></span>
<span class="line"><span>  universe_set_height(6);</span></span>
<span class="line"><span>  universe_set_cells(</span></span>
<span class="line"><span>    &#x26;[</span></span>
<span class="line"><span>      (2,1), (2,3),</span></span>
<span class="line"><span>      (3,2), (3,3),(4,2)</span></span>
<span class="line"><span>    ]</span></span>
<span class="line"><span>  );</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  universe</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>现在我们写一个 test_tick 函数，创建以上的两个飞船。最后使用<code>assert_eq!</code>宏比较 expected_ship 来确保 tick 函数运行正确。我们添加<code>#[wasm_bindgen_test]</code>属性保证这个函数可以在 WebAssembly 环境下测试。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>#[wasm_bindgen_test]</span></span>
<span class="line"><span>pub fn test_tick() {</span></span>
<span class="line"><span>  let mut input_universe = input_spaceship();</span></span>
<span class="line"><span>  let expected_universe = expected_spaceship();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  input_universe.tick();</span></span>
<span class="line"><span>  assert_eq!(</span></span>
<span class="line"><span>    &#x26;input_universe.get_cells(),</span></span>
<span class="line"><span>    &#x26;expected_universe.get_cells(),</span></span>
<span class="line"><span>  )</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>测试这个测试函数使用<code>wasm-pack test --firefox --headless</code>。</p>
<h2 id="调试">调试</h2>
<p>写这么多代码之前（虽然上面都写完了，我也不知道原作者抽什么风），先看一看 Rust 的调试工具。</p>
<h3 id="调试工具">调试工具</h3>
<p>此部分将会介绍 WebAssembly 的调试工具。</p>
<h4 id="使用-debug-标记编译">使用 debug 标记编译</h4>
<p>如果没有打开 debug 标记，“name”这个部分就不会被编译到二进制程序中，错误栈也不会显示函数名，你会收到<code>wasm-functions[42]</code>而不是<code>wasm_game_of_file::Universe::live_neighbor_count</code>。</p>
<p>调试编译，<code>wasm-pack build --debug</code>或者<code>cargo build</code>总是会默认打开 debug 标记。</p>
<p>版本编译（release build），debug 标记是默认关闭的，要打开 debug 标记，需要声明<code>debug=true</code>。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">[</span><span style="color:#B392F0">profile</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">release</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#E1E4E8">debug = </span><span style="color:#79B8FF">true</span></span></code></pre>
<h4 id="使用-console-api-打印日志">使用 console API 打印日志</h4>
<p>打印日志是最好的判断程序是否是有错的方式。在浏览器中，<code>console.log</code>函数可以将日志打印到浏览器的 dev 工具里。</p>
<p>我们可以使用 web-sys 包去调用 console API。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>extern crate web_sys;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>web_sys::console::log_1(&#x26;"Hello, world!".into());</span></span></code></pre>
<p>相应的<code>console.error</code>函数用法一致，但是浏览器的调用栈还是按照<code>console.error</code>来打印。</p>
<p>使用<code>console.log</code>：</p>
<ul>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.log.html" rel="noopener noreferrer nofollow" target="_blank"><code>web_sys::console::log</code>，接受一个向量的数据做参数</a>。</li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.log_1.html" rel="noopener noreferrer nofollow" target="_blank"><code>web_sys::console::log_1</code>，接受一个数据做参数</a>。</li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.log_2.html" rel="noopener noreferrer nofollow" target="_blank"><code>web_sys::console::log_2</code>，接受两个数据做参数</a>。</li>
<li>…</li>
</ul>
<p>使用<code>console.error</code>：</p>
<ul>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.error.html" rel="noopener noreferrer nofollow" target="_blank"><code>web_sys::console::error</code>，接受一个向量的数据做参数</a>。</li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.error_1.html" rel="noopener noreferrer nofollow" target="_blank"><code>web_sys::console::error_1</code>，接受一个数据做参数</a>。</li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.error_2.html" rel="noopener noreferrer nofollow" target="_blank"><code>web_sys::console::error_2</code>，接受两个数据做参数</a>。</li>
<li>…</li>
</ul>
<h4 id="打印崩溃日志">打印崩溃日志</h4>
<p><a href="https://github.com/rustwasm/console_error_panic_hook" rel="noopener noreferrer nofollow" target="_blank"><code>console_error_panic_hook</code>包能通过<code>console.error</code>打印崩溃日志</a>。他能打印出格式化的崩溃信息而不是难以理解的<code>RuntimeError: unreachable executed</code>。</p>
<p>你只需要增加调用这个钩子函数。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>#[wasm_bindgen]</span></span>
<span class="line"><span>pub fn init_panic_hook() {</span></span>
<span class="line"><span>  console_error_panic_hook::set_once();</span></span>
<span class="line"><span>}</span></span></code></pre>
<h4 id="使用调试器">使用调试器</h4>
<p>不幸的，WebAssembly 的调试器依然不成熟，在很多 unix 系统中，DWARF 是用来解析调试程序需要的数据的工具。虽然，Windows 上面也有一个类似的工具。但还没有相当的工具提供给 WebAssembly。所以，调试器目前能给予的功能有限，我们只能收到 WebAssembly 的错误而不是 Rust 源代码的错误。</p>
<blockquote>
<p>这里有一个故事是<a href="https://github.com/WebAssembly/debugging" rel="noopener noreferrer nofollow" target="_blank">跟踪 WebAssembly 的调试</a>的，我们希望它将来会有所改善！</p>
</blockquote>
<p>尽管如此，调试器还是能够给调试 JavaScript 方面提供效力。</p>
<h4 id="一开始就规避在-webassembly-上面使用调试">一开始就规避在 WebAssembly 上面使用调试</h4>
<p>如果错误和交互 JavaScript 和 Web API 有关，则使用<code>wasm-bindgen-test</code>写测试。</p>
<p>如果和 JavaScript 和 Web API 无关，这是用默认的<code>#[test]</code>属性。使用<a href="https://crates.io/crates/quickcheck" rel="noopener noreferrer nofollow" target="_blank"><code>quickcheck</code>包</a>可以减少写测试上面的时间。</p>
<p>为了避免<code>#[test]</code>编译器出现连接错误，你需要一个 rlib 依赖，在<code>Cargo.toml</code>文件按照如下修改。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">[</span><span style="color:#B392F0">lib</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#FDAEB7;font-style:italic">crate-type ["cdylib", "rlib"]</span></span></code></pre>
<h3 id="在生命游戏中打开崩溃日志">在生命游戏中打开崩溃日志</h3>
<p>如果程序崩溃，最好是能够在审查工具中看到日志。</p>
<p>在“src/utils.rs`里面有一个可选的 console_error_panic_hook 包，可以在 Universe 初始化的时候调用它。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>pub fn new() -> Universe {</span></span>
<span class="line"><span>  utils::set_panic_hook();</span></span>
<span class="line"><span>}</span></span></code></pre>
<h3 id="为生命游戏增加日志">为生命游戏增加日志</h3>
<p>让我们在 Rust 中利用 web-sys 调用 console，打印出每一刻的细胞状态。</p>
<p>首先在以来中增加 web-sys，修改 Cargo.toml。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">[</span><span style="color:#B392F0">dependencies</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">web-sys</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#E1E4E8">version = </span><span style="color:#9ECBFF">"0.3"</span></span>
<span class="line"><span style="color:#E1E4E8">features = [</span></span>
<span class="line"><span style="color:#9ECBFF">  "console"</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">]</span></span></code></pre>
<p>为了高效，我们把<code>console.log</code>函数封装到<code>println!</code>一样的宏中。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>extern crate web_sys;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>macro_rules! log {</span></span>
<span class="line"><span>  ($( $t:tt )*) => {</span></span>
<span class="line"><span>    web_sys::console::log_1(&#x26;format!( $( $t )* ).into());</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>现在可以通过调用 log 发送日志了。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>log!(</span></span>
<span class="line"><span>  "cell[{}, {}] is initially {:?} and has {} live neighbors",</span></span>
<span class="line"><span>  row,</span></span>
<span class="line"><span>  col,</span></span>
<span class="line"><span>  cell,</span></span>
<span class="line"><span>  live_neighbors,</span></span>
<span class="line"><span>)</span></span></code></pre>
<h3 id="使用调试器-1">使用调试器</h3>
<p>浏览器的调试器在调试 JavaScript 和 Rust 生成的 WebAssembly 很有效。</p>
<p>举个例子，在 renderLoop 函数中增加<code>debugger;</code>可以暂停页面执行的某一刻。</p>
<p>者给予我们查看每一刻细胞状态的能力。</p>
<p><img src="https://rustwasm.github.io/docs/book/images/game-of-life/debugging.png" alt="调试画面"></p>
<h3 id="练习-3">练习</h3>
<ol>
<li>给 tick 方法增加 log，查看细胞状态。</li>
<li>加入<code>panic!()</code>查看打印出来的崩溃日志。</li>
</ol>
<h2 id="增加交互">增加交互</h2>
<p>接下来我们要给这个游戏增加一些交互，我们会允许用户选择细胞的生死，并且允许暂停游戏，并使绘制初始图案更加简单。</p>
<h3 id="暂停和继续游戏">暂停和继续游戏</h3>
<p>首先修改 html，在画布上面增加一个<button>标签。<p></p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">&#x3C;</span><span style="color:#85E89D">button</span><span style="color:#B392F0"> id</span><span style="color:#E1E4E8">=</span><span style="color:#9ECBFF">"play-pause"</span><span style="color:#E1E4E8">>&#x3C;/</span><span style="color:#85E89D">button</span><span style="color:#E1E4E8">></span></span></code></pre>
<p>在 JavaScript 中，我们要做以下几点改动。</p>
<ul>
<li>追踪调用 requestAnimationFrame 的标识符，这样我们就能通过调用 cancelAnimationFrame 来终止动画。</li>
<li>当点击播放或者暂停键的时候，先检查标识符是否存在，一旦存在，则表示动画正在运行，我们需要取消动画以保证 renderLoop 不再被调用。如果标识符不存在，我们需要调用 requestAnimationFrame 以保证动画继续运行。</li>
</ul>
<p>因为是 JavaScript 控制着 Rust 和 WebAssembly，我们不需要修改 Rust 部分。</p>
<p>我们引入 animationId 变量，保存 requestAnimationFrame 的结果。当没有排队的动画时，这个变量值为 null。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>let animationId = null;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function renderLoop() {</span></span>
<span class="line"><span>  drawGrid();</span></span>
<span class="line"><span>  drawCells();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  universe.tick();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  animationId = requestAnimationFrame(renderLoop);</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>任何一个时间，我们可以通过判断 animationId 来判断这个动画是否被暂停。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>function isPaused() {</span></span>
<span class="line"><span>  return animationId === null;</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>现在，当播放暂停键被点击，当正在播放时，暂停动画。并把按钮的状态改为播放。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>const playPauseButton = document.getElementById("play-pause");</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function play() {</span></span>
<span class="line"><span>  playPauseButton.textContent = "⏸";</span></span>
<span class="line"><span>  renderLoop();</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function pause() {</span></span>
<span class="line"><span>  playPauseButton.textContent = "▶";</span></span>
<span class="line"><span>  cancelAnimationFrame(animationId);</span></span>
<span class="line"><span>  animationId = null;</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>playPauseButton.addEventListener("click", function playBtnListener(event) {</span></span>
<span class="line"><span>  if (isPaused()) {</span></span>
<span class="line"><span>    play();</span></span>
<span class="line"><span>  } else {</span></span>
<span class="line"><span>    pause();</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>});</span></span></code></pre>
<p>最后我们把之前的 requestAnimationFrame 函数封装成<code>play()</code>。刷新本地服务器，可以看到网页上已经有暂停按钮了。尝试点击一下它吧。</p>
<h3 id="修改一个细胞的状态">修改一个细胞的状态</h3>
<p>现在我们能暂停这个游戏了，是时候增加一个修改细胞的功能了。</p>
<p>想控制细胞的生死，需要给<code>src/lib.rs</code>下的 Cell 增加一个 toggle 函数。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>impl Cell {</span></span>
<span class="line"><span>    fn toggle(&#x26;mut self) {</span></span>
<span class="line"><span>        *self = match *self {</span></span>
<span class="line"><span>            Cell::Dead => Cell::Alive,</span></span>
<span class="line"><span>            Cell::Alive => Cell::Dead,</span></span>
<span class="line"><span>        };</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>想要修改在宇宙中的细胞需要获得细胞的行纵值，并转换为细胞的序号。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>#[wasm_bindgen]</span></span>
<span class="line"><span>impl Universe {</span></span>
<span class="line"><span>    pub fn toggle_cell(&#x26;mut self, row: u32, column: u32) {</span></span>
<span class="line"><span>        let idx = self.get_index(row, column);</span></span>
<span class="line"><span>        self.cells[idx].toggle();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>这个方法增加第 1 行的属性声明是为了能够在 JavaScript 环境里面直接调用。在 JavaScript 文件中，监听<canvas>标签，将页面上的点击事件转换成画布上的点击事件，并调用 toggle_cell 方法重绘场景。</canvas></p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>canvas.addEventListener("click", function canvasClickListener(event) {</span></span>
<span class="line"><span>  const boundingRect = canvas.getBoundingClientRect();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  const scaleX = canvas.width / boundingRect.width;</span></span>
<span class="line"><span>  const scaleY = canvas.height / boundingRect.height;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  const canvasLeft = (event.clientX - boundingRect.left) * scaleX;</span></span>
<span class="line"><span>  const canvasTop = (event.clientY - boundingRect.top) * scaleY;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  const row = Math.min(Math.floor(canvasTop/(CELL_SIZE + 1)), height - 1);</span></span>
<span class="line"><span>  const col = Math.min(Math.floor(canvasLeft/(CELL_SIZE + 1)), width - 1);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  universe.toggle_cell(row, col);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  drawGrid();</span></span>
<span class="line"><span>  drawCells();</span></span>
<span class="line"><span>});</span></span></code></pre>
<p>使用<code>wasm-pack build</code>重新编译，刷新网页，并更新细胞状态。</p>
<h3 id="练习-4">练习</h3>
<ul>
<li>新建一个<input>标签来处理每帧更新多少个刻。</li>
<li>增加一个重置按钮，把宇宙恢复到初始状态；再增加一个消灭按钮，毁灭所有细胞。</li>
<li>当使用<code>Ctrl+Click</code>的时候，增加一个<a href="https://en.wikipedia.org/wiki/Glider_(Conway%27s_Life)" rel="noopener noreferrer nofollow" target="_blank">glider</a>，使用<code>Shift+Click</code>增加一个 pulsar。</li>
</ul>
<h2 id="性能日志time-profiling">性能日志(Time Profiling)</h2>
<p>本节我们将会提高这个游戏的性能，我们将会用 time profiling 来完成。</p>
<h3 id="time-profiling">Time Profiling</h3>
<p>此部分将会讲解如何获得页面的性能分析，目标是提高 JavaScript 和 WebAssembly 之间的吞吐。</p>
<blockquote>
<p>永远使用<code>wasm-pack build</code>编译最新的代码，以确定你的优化正确。</p>
</blockquote>
<h4 id="windowsperformancenow">windows.performance.now()</h4>
<p>这个函数会返回以毫秒为单位的时间戳来计算页面加载速度。</p>
<p>调用<code>performance.now()</code>的性能损耗低，所以我们可以利用它创造一个简单的测算工具而不是产生很大误差值。</p>
<p>我们可以通过<code>web-sys</code>调用时间函数。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>extern crate web_sys;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>fn now() -> f64 {</span></span>
<span class="line"><span>  web_sys::window()</span></span>
<span class="line"><span>    .expect("should have window")</span></span>
<span class="line"><span>    .performance()</span></span>
<span class="line"><span>    .expect("should have a Performance")</span></span>
<span class="line"><span>    .now()</span></span>
<span class="line"><span>}</span></span></code></pre>
<h4 id="开发者工具的性能查看器">开发者工具的性能查看器</h4>
<p>所有的浏览器的开发者工具都有性能查看器。这个查看器通过火焰图展示函数调用栈来表示哪一个函数耗时更长。</p>
<p>如果你编译的时候打开了调试，则函数名将会显示在这里（如果没打开则显示一个不透明的名字，比如<code>wasm-function[123]</code>）。</p>
<p>注意，因为性能查看器不会显示内联函数，又因为 Rust 和 LVVM 很重地依赖于内联函数，其结果就会让人感到头疼。</p>
<p><img src="https://rustwasm.github.io/docs/book/images/game-of-life/profiler-with-rust-names.png" alt="性能查看器无法处理内联函数"></p>
<h4 id="consoletime-和-consoletimeend">console.time 和 console.timeEnd</h4>
<p>这两个函数是浏览器的内置函数。以调用<code>console.time("foo")</code>作为开始，以<code>console.time("foo")</code>作为结束，参数是可选的。</p>
<p>你可以通过 web-sys 调用<code>web_sys::console::time_with_label("foo")</code>和<code>web_sys::console::time_end_with_label("foo")</code>。</p>
<p>如下是浏览器的截图。</p>
<p><img src="https://rustwasm.github.io/docs/book/images/game-of-life/console-time.png" alt="使用console.time的截图"></p>
<p>另外，<code>console.time</code>和<code>console.timeEnd</code>会调用性能检查器统计出瀑布图。</p>
<h4 id="使用bench调用原生代码">使用#[bench]调用原生代码</h4>
<p>就像我们能使用原生的测试方法<code>#[test]</code>来测试代码，我们可以使用<code>#[bench]</code>通过操作系统的工具来查看函数性能。</p>
<p>写好标准函数并放到<code>benches</code>文件夹下。确保<code>crate-type</code>已经引入 rlib，能使测试代码能够链接。</p>
<p>无论如何，先搞明白你知道 WebAssembly 里面的瓶颈之后再花费精力去调查原生的性能调查器！用你的浏览器的性能调查器，或者使用这些时间去优化你的代码不是更好？</p>
<h3 id="利用-windowperformancenow-创建一个计时器">利用 window.performance.now 创建一个计时器</h3>
<p>创建一个 FPS 的计时器用来调查游戏的渲染速度不失为一个好办法。</p>
<p>我们在 JavaScript 增加 fps 对象。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>const fps = new class {</span></span>
<span class="line"><span>  constructor() {</span></span>
<span class="line"><span>    this.fps = document.getElementById("fps");</span></span>
<span class="line"><span>    this.frames = [];</span></span>
<span class="line"><span>    this.lastFrameTimeStamp = performance.now();</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  render() {</span></span>
<span class="line"><span>    // Convert the delta time since the last frame render into a measure</span></span>
<span class="line"><span>    // of frames per second.</span></span>
<span class="line"><span>    const now = performance.now();</span></span>
<span class="line"><span>    const delta = now - this.lastFrameTimeStamp;</span></span>
<span class="line"><span>    this.lastFrameTimeStamp = now;</span></span>
<span class="line"><span>    const fps = 1 / delta * 1000;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // Save only the latest 100 timings.</span></span>
<span class="line"><span>    this.frames.push(fps);</span></span>
<span class="line"><span>    if (this.frames.length > 100) {</span></span>
<span class="line"><span>      this.frames.shift();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // Find the max, min, and mean of our 100 latest timings.</span></span>
<span class="line"><span>    let min = Infinity;</span></span>
<span class="line"><span>    let max = -Infinity;</span></span>
<span class="line"><span>    let sum = 0;</span></span>
<span class="line"><span>    for (let i = 0; i &#x3C; this.frames.length; i++) {</span></span>
<span class="line"><span>      sum += this.frames[i];</span></span>
<span class="line"><span>      min = Math.min(this.frames[i], min);</span></span>
<span class="line"><span>      max = Math.max(this.frames[i], max);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    let mean = sum / this.frames.length;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // Render the statistics.</span></span>
<span class="line"><span>    this.fps.textContent = `</span></span>
<span class="line"><span>Frames per Second:</span></span>
<span class="line"><span>         latest = ${Math.round(fps)}</span></span>
<span class="line"><span>avg of last 100 = ${Math.round(mean)}</span></span>
<span class="line"><span>min of last 100 = ${Math.round(min)}</span></span>
<span class="line"><span>max of last 100 = ${Math.round(max)}</span></span>
<span class="line"><span>`.trim();</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>};</span></span></code></pre>
<p>接下来再每次迭代中调用 fps render 函数。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>const renderLoop = () => {</span></span>
<span class="line"><span>    fps.render(); //new</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    universe.tick();</span></span>
<span class="line"><span>    drawGrid();</span></span>
<span class="line"><span>    drawCells();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    animationId = requestAnimationFrame(renderLoop);</span></span>
<span class="line"><span>};</span></span></code></pre>
<p>最后在 HTML 中增加 fps 的展示。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>&#x3C;div id="fps">&#x3C;/div></span></span></code></pre>
<p>增加 CSS，让它展示得更好。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>#fps {</span></span>
<span class="line"><span>  white-space: pre;</span></span>
<span class="line"><span>  font-family: monospace;</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>好了，现在可以在页面上看到 FPS 计数器了。</p>
<h3 id="给每一刻计算时间">给每一刻计算时间</h3>
<p>每一刻开始调用<code>console.time</code>，结束的时候调用<code>console.timeEnd</code>。</p>
<p>首先，要在<code>Cargo.toml</code>里面增加 web-sys。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">[</span><span style="color:#B392F0">dependencies</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">web-sys</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#E1E4E8">version = </span><span style="color:#9ECBFF">"0.3"</span></span>
<span class="line"><span style="color:#E1E4E8">features = [</span></span>
<span class="line"><span style="color:#9ECBFF">  "console"</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">]</span></span></code></pre>
<p>因为每次执行<code>console.time</code>后总要执行<code>console.timeEnd</code>，把他们包再<a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization" rel="noopener noreferrer nofollow" target="_blank">RAII</a>类型下就会更加便利。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>extern crate web_sys;</span></span>
<span class="line"><span>use web_sys::console;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>pub struct Timer&#x3C;'a> {</span></span>
<span class="line"><span>    name: &#x26;'a str,</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>impl&#x3C;'a> Timer&#x3C;'a> {</span></span>
<span class="line"><span>    pub fn new(name: &#x26;'a str) -> Timer&#x3C;'a> {</span></span>
<span class="line"><span>        console::time_with_label(name);</span></span>
<span class="line"><span>        Timer { name }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>impl&#x3C;'a> Drop for Timer&#x3C;'a> {</span></span>
<span class="line"><span>    fn drop(&#x26;mut self) {</span></span>
<span class="line"><span>        console::time_end_with_label(self.name);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>接下来，统计每一刻用的时间是多久，只需把初始化 Timer 放到 Universe 的构造函数里。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>let _timer = Timer::new("Universe::tick");</span></span></code></pre>
<p>如下是每一刻执行的时间。</p>
<p><img src="https://rustwasm.github.io/book/images/game-of-life/console-time.png" alt="每一刻的执行时间"></p>
<p>另外，通过使用<code>console.time</code>和<code>console.timeEnd</code>也能获得执行性能数据。</p>
<p><img src="https://rustwasm.github.io/book/images/game-of-life/console-time-in-profiler.png" alt="性能数据"></p>
<h3 id="增加宇宙大小">增加宇宙大小</h3>
<blockquote>
<p>本部分是拿火狐浏览器做例子，当然还有很多浏览器有类似的功能，只是有细微的差别。这个数据是一致的，但是部分命名和标量可能不一样。</p>
</blockquote>
<p>如果我们把宇宙修改的大一些，会发生什么？把 64x64 改成 128x128，结果会把 fps 从 60 降到 40。</p>
<p>如果我们打开性能监控器，并看到它的瀑布图，我们可以看到动画帧用了 20 毫秒，回顾 60fps 时渲染一页则需要 16 毫秒，这不仅仅是 JavaScript 和 WebAssembly，还包括重绘的部分。</p>
<p><img src="https://rustwasm.github.io/book/images/game-of-life/drawCells-before-waterfall.png" alt="性能监视"></p>
<p>如果仔细查看，可以看到<code>CanvasRenderingContext2D.fillStyle</code>的 setter 是很耗费时间的。</p>
<blockquote>
<p>再火狐，你可能看到的是”DOM”而不是”CanvasRenderingContext2D.fillStyle”，你需要打开”展示 Gecko 平台数据”。</p>
</blockquote>
<p><img src="https://rustwasm.github.io/book/images/game-of-life/profiler-firefox-show-gecko-platform.png" alt="火狐的性能监视器"></p>
<p>当然，这并不稀奇，40%的的时间都浪费在这个 setter 上面。</p>
<blockquote>
<p>我们可能期望性能瓶颈再 tik 函数上，但并不是。永远选择性能监视器观察，因为你可能浪费很多时间在无关的地方上面。</p>
</blockquote>
<p>在 drawCell 上面，fillStyle 在每次动画和每个细胞上面使用。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>for (let row = 0; row &#x3C; height; row++) {</span></span>
<span class="line"><span>  for (let col = 0; col &#x3C; width; col++) {</span></span>
<span class="line"><span>    const idx = getIndex(row, col);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    ctx.fillStyle = cells[idx] === DEAD</span></span>
<span class="line"><span>      ? DEAD_COLOR</span></span>
<span class="line"><span>      : ALIVE_COLOR;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    ctx.fillRect(</span></span>
<span class="line"><span>      col * (CELL_SIZE + 1) + 1,</span></span>
<span class="line"><span>      row * (CELL_SIZE + 1) + 1,</span></span>
<span class="line"><span>      CELL_SIZE,</span></span>
<span class="line"><span>      CELL_SIZE</span></span>
<span class="line"><span>    );</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>现在我们知道 fillStyle 资源耗费比较多，那么我们该怎么避免他呢？我们需要判断细胞的生命状态来自决定 fillStyle 的值，设想，如果先设定<code>fillStyle = ALIVE_COLOR</code>，再绘制所有的活着的细胞，然后设置<code>fillStyle = DEAD_COLOR</code>，再设置所有的死细胞，最后我们只设置 fillStyle 两次。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>// Alive cells.</span></span>
<span class="line"><span>ctx.fillStyle = ALIVE_COLOR;</span></span>
<span class="line"><span>for (let row = 0; row &#x3C; height; row++) {</span></span>
<span class="line"><span>  for (let col = 0; col &#x3C; width; col++) {</span></span>
<span class="line"><span>    const idx = getIndex(row, col);</span></span>
<span class="line"><span>    if (cells[idx] !== Cell.Alive) {</span></span>
<span class="line"><span>      continue;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    ctx.fillRect(</span></span>
<span class="line"><span>      col * (CELL_SIZE + 1) + 1,</span></span>
<span class="line"><span>      row * (CELL_SIZE + 1) + 1,</span></span>
<span class="line"><span>      CELL_SIZE,</span></span>
<span class="line"><span>      CELL_SIZE</span></span>
<span class="line"><span>    );</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Dead cells.</span></span>
<span class="line"><span>ctx.fillStyle = DEAD_COLOR;</span></span>
<span class="line"><span>for (let row = 0; row &#x3C; height; row++) {</span></span>
<span class="line"><span>  for (let col = 0; col &#x3C; width; col++) {</span></span>
<span class="line"><span>    const idx = getIndex(row, col);</span></span>
<span class="line"><span>    if (cells[idx] !== Cell.Dead) {</span></span>
<span class="line"><span>      continue;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    ctx.fillRect(</span></span>
<span class="line"><span>      col * (CELL_SIZE + 1) + 1,</span></span>
<span class="line"><span>      row * (CELL_SIZE + 1) + 1,</span></span>
<span class="line"><span>      CELL_SIZE,</span></span>
<span class="line"><span>      CELL_SIZE</span></span>
<span class="line"><span>    );</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>修改之后，刷新页面，此时的 fps 已经上升到 60。</p>
<p>如果重新看原来的数据，现在每一刻只使用 10 毫秒。</p>
<p><img src="https://rustwasm.github.io/book/images/game-of-life/drawCells-after-waterfall.png" alt="更新后的性能检查"></p>
<p>消除了 fillStyle 的性能瓶颈，发现比较消耗资源的是 fillRect，用来绘制每一个细胞的。</p>
<p><img src="https://rustwasm.github.io/book/images/game-of-life/drawCells-after-flamegraph.png" alt="目前的性能损耗都在fillRect上面"></p>
<h3 id="让时间变快">让时间变快</h3>
<p>有些人可能不喜欢等待，更希望一帧跑完九刻而不是一刻。我们可以通过修改 renderLoop 函数实现。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>for (let i = 0; i &#x3C; 9; i++) {</span></span>
<span class="line"><span>  universe.tick();</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>在机器上，fps 降到了 35，但是我们一定要到 60fps！</p>
<p>现在我们知道性能瓶颈在 tick 函数上面，所以我们给函数的每一步都加上 Timer 监视，我猜测是创建向量和释放向量占用了很多资源造成的。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>pub fn tick(&#x26;mut self) {</span></span>
<span class="line"><span>    let _timer = Timer::new("Universe::tick");</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    let mut next = {</span></span>
<span class="line"><span>        let _timer = Timer::new("allocate next cells");</span></span>
<span class="line"><span>        self.cells.clone()</span></span>
<span class="line"><span>    };</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    {</span></span>
<span class="line"><span>        let _timer = Timer::new("new generation");</span></span>
<span class="line"><span>        for row in 0..self.height {</span></span>
<span class="line"><span>            for col in 0..self.width {</span></span>
<span class="line"><span>                let idx = self.get_index(row, col);</span></span>
<span class="line"><span>                let cell = self.cells[idx];</span></span>
<span class="line"><span>                let live_neighbors = self.live_neighbor_count(row, col);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>                let next_cell = match (cell, live_neighbors) {</span></span>
<span class="line"><span>                    // Rule 1: Any live cell with fewer than two live neighbours</span></span>
<span class="line"><span>                    // dies, as if caused by underpopulation.</span></span>
<span class="line"><span>                    (Cell::Alive, x) if x &#x3C; 2 => Cell::Dead,</span></span>
<span class="line"><span>                    // Rule 2: Any live cell with two or three live neighbours</span></span>
<span class="line"><span>                    // lives on to the next generation.</span></span>
<span class="line"><span>                    (Cell::Alive, 2) | (Cell::Alive, 3) => Cell::Alive,</span></span>
<span class="line"><span>                    // Rule 3: Any live cell with more than three live</span></span>
<span class="line"><span>                    // neighbours dies, as if by overpopulation.</span></span>
<span class="line"><span>                    (Cell::Alive, x) if x > 3 => Cell::Dead,</span></span>
<span class="line"><span>                    // Rule 4: Any dead cell with exactly three live neighbours</span></span>
<span class="line"><span>                    // becomes a live cell, as if by reproduction.</span></span>
<span class="line"><span>                    (Cell::Dead, 3) => Cell::Alive,</span></span>
<span class="line"><span>                    // All other cells remain in the same state.</span></span>
<span class="line"><span>                    (otherwise, _) => otherwise,</span></span>
<span class="line"><span>                };</span></span>
<span class="line"><span></span></span>
<span class="line"><span>                next[idx] = next_cell;</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    let _timer = Timer::new("free old cells");</span></span>
<span class="line"><span>    self.cells = next;</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>看这些时间戳，很明显我的猜测是错误的：大部分时间确实用在计算下一代细胞上面，每一刻都调用和释放向量竟然无足轻重。所以一定要使用性能监视器！</p>
<p><img src="https://rustwasm.github.io/book/images/game-of-life/console-time-in-universe-tick.png" alt="性能监视"></p>
<p>下一部分需要<code>nightly</code>编译，因为我们将会使用<a href="https://doc.rust-lang.org/unstable-book/library-features/test.html" rel="noopener noreferrer nofollow" target="_blank">test-feature-gate</a>来跑 benchmark（性能测试）。我们将会安装另一个工具<a href="https://github.com/BurntSushi/cargo-benchcmp" rel="noopener noreferrer nofollow" target="_blank">cargo-benchcmp</a>。一个迷你的有<code>cargo bench</code>支持的性能测试工具。</p>
<p>让我们写一个函数使用<code>#[bench]</code>属性，我们可以使用更成熟的测试工具测试它。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>#![feature(test)]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>extern crate test;</span></span>
<span class="line"><span>extern crate wasm_game_of_life;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#[bench]</span></span>
<span class="line"><span>fn universe_ticks(b: &#x26;mut test::Bencher) {</span></span>
<span class="line"><span>    let mut universe = wasm_game_of_life::Universe::new();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    b.iter(|| {</span></span>
<span class="line"><span>        universe.tick();</span></span>
<span class="line"><span>    });</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>我们也要注释掉所有<code>#[wasm_bindgen]</code>，否则”cdylib”或则其他编译流程会失败，</p>
<p>此时，我们可以跑<code>cargo bench | tee before.txt</code>来编译项目查看性能日志了！</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#B392F0">$</span><span style="color:#9ECBFF"> cargo</span><span style="color:#9ECBFF"> bench</span><span style="color:#F97583"> |</span><span style="color:#B392F0"> tee</span><span style="color:#9ECBFF"> before.txt</span></span>
<span class="line"><span style="color:#B392F0">    Finished</span><span style="color:#9ECBFF"> release</span><span style="color:#E1E4E8"> [optimized </span><span style="color:#9ECBFF">+</span><span style="color:#9ECBFF"> debuginfo]</span><span style="color:#9ECBFF"> target</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">s</span><span style="color:#E1E4E8">) </span><span style="color:#9ECBFF">in</span><span style="color:#79B8FF"> 0.0</span><span style="color:#9ECBFF"> secs</span></span>
<span class="line"><span style="color:#B392F0">     Running</span><span style="color:#9ECBFF"> target/release/deps/wasm_game_of_life-91574dfbe2b5a124</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">running</span><span style="color:#79B8FF"> 0</span><span style="color:#9ECBFF"> tests</span></span>
<span class="line"></span>
<span class="line"><span style="color:#79B8FF">test</span><span style="color:#9ECBFF"> result:</span><span style="color:#9ECBFF"> ok.</span><span style="color:#79B8FF"> 0</span><span style="color:#9ECBFF"> passed</span><span style="color:#E1E4E8">; </span><span style="color:#B392F0">0</span><span style="color:#9ECBFF"> failed</span><span style="color:#E1E4E8">; </span><span style="color:#B392F0">0</span><span style="color:#9ECBFF"> ignored</span><span style="color:#E1E4E8">; </span><span style="color:#B392F0">0</span><span style="color:#9ECBFF"> measured</span><span style="color:#E1E4E8">; </span><span style="color:#B392F0">0</span><span style="color:#9ECBFF"> filtered</span><span style="color:#9ECBFF"> out</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">     Running</span><span style="color:#9ECBFF"> target/release/deps/bench-8474091a05cfa2d9</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">running</span><span style="color:#79B8FF"> 1</span><span style="color:#9ECBFF"> test</span></span>
<span class="line"><span style="color:#79B8FF">test</span><span style="color:#9ECBFF"> universe_ticks</span><span style="color:#9ECBFF"> ...</span><span style="color:#9ECBFF"> bench:</span><span style="color:#79B8FF">     664</span><span style="color:#9ECBFF">,421</span><span style="color:#9ECBFF"> ns/iter</span><span style="color:#E1E4E8"> (+/- </span><span style="color:#79B8FF">51</span><span style="color:#9ECBFF">,926</span><span style="color:#E1E4E8">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#79B8FF">test</span><span style="color:#9ECBFF"> result:</span><span style="color:#9ECBFF"> ok.</span><span style="color:#79B8FF"> 0</span><span style="color:#9ECBFF"> passed</span><span style="color:#E1E4E8">; </span><span style="color:#B392F0">0</span><span style="color:#9ECBFF"> failed</span><span style="color:#E1E4E8">; </span><span style="color:#B392F0">0</span><span style="color:#9ECBFF"> ignored</span><span style="color:#E1E4E8">; </span><span style="color:#B392F0">1</span><span style="color:#9ECBFF"> measured</span><span style="color:#E1E4E8">; </span><span style="color:#B392F0">0</span><span style="color:#9ECBFF"> filtered</span><span style="color:#9ECBFF"> out</span></span></code></pre>
<p>他也告诉我们二进制文件的位置，我们可以跑第二次性能测试。但这次可以使用系统的性能测试工具。因为我用的是 Linux，所以 perf 就是我的测试工具。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#B392F0">$</span><span style="color:#9ECBFF"> perf</span><span style="color:#9ECBFF"> record</span><span style="color:#79B8FF"> -g</span><span style="color:#9ECBFF"> target/release/deps/bench-8474091a05cfa2d9</span><span style="color:#79B8FF"> --bench</span></span>
<span class="line"><span style="color:#B392F0">running</span><span style="color:#79B8FF"> 1</span><span style="color:#9ECBFF"> test</span></span>
<span class="line"><span style="color:#79B8FF">test</span><span style="color:#9ECBFF"> universe_ticks</span><span style="color:#9ECBFF"> ...</span><span style="color:#9ECBFF"> bench:</span><span style="color:#79B8FF">     635</span><span style="color:#9ECBFF">,061</span><span style="color:#9ECBFF"> ns/iter</span><span style="color:#E1E4E8"> (+/- </span><span style="color:#79B8FF">38</span><span style="color:#9ECBFF">,764</span><span style="color:#E1E4E8">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#79B8FF">test</span><span style="color:#9ECBFF"> result:</span><span style="color:#9ECBFF"> ok.</span><span style="color:#79B8FF"> 0</span><span style="color:#9ECBFF"> passed</span><span style="color:#E1E4E8">; </span><span style="color:#B392F0">0</span><span style="color:#9ECBFF"> failed</span><span style="color:#E1E4E8">; </span><span style="color:#B392F0">0</span><span style="color:#9ECBFF"> ignored</span><span style="color:#E1E4E8">; </span><span style="color:#B392F0">1</span><span style="color:#9ECBFF"> measured</span><span style="color:#E1E4E8">; </span><span style="color:#B392F0">0</span><span style="color:#9ECBFF"> filtered</span><span style="color:#9ECBFF"> out</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">[ perf record: Woken up </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8"> times to write data ]</span></span>
<span class="line"><span style="color:#E1E4E8">[ perf record: Captured and wrote </span><span style="color:#79B8FF">0.178</span><span style="color:#E1E4E8"> MB perf.data (</span><span style="color:#79B8FF">2349</span><span style="color:#E1E4E8"> samples) ]</span></span></code></pre>
<p>查看性能测试报告，得知所有的时间都如期使用在<code>Universe::tick</code>。</p>
<p><img src="https://rustwasm.github.io/book/images/game-of-life/bench-perf-report.png" alt="perf的结果"></p>
<p>perf 会指明函数中到底是什么操作引起的性能损耗（译者：虽然我也没看出来）。</p>
<p><img src="https://rustwasm.github.io/book/images/game-of-life/bench-perf-annotate.png" alt="perf的结果"></p>
<p>它告诉我们 26.67%的时间花在总和细胞数目，23.41%的时间花在获取列序号，另外 15.42%花在取得行序号。这三个性能瓶颈中，第二和第三都使用了比较耗费性能的 DIV 命令。这些 DIV 的实现是在<code>Universe::live_neighbor_count</code>。</p>
<p>回想这个函数的定义：</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>fn live_neighbor_count(&#x26;self, row: u32, column: u32) -> u8 {</span></span>
<span class="line"><span>    let mut count = 0;</span></span>
<span class="line"><span>    for delta_row in [self.height - 1, 0, 1].iter().cloned() {</span></span>
<span class="line"><span>        for delta_col in [self.width - 1, 0, 1].iter().cloned() {</span></span>
<span class="line"><span>            if delta_row == 0 &#x26;&#x26; delta_col == 0 {</span></span>
<span class="line"><span>                continue;</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            let neighbor_row = (row + delta_row) % self.height;</span></span>
<span class="line"><span>            let neighbor_col = (column + delta_col) % self.width;</span></span>
<span class="line"><span>            let idx = self.get_index(neighbor_row, neighbor_col);</span></span>
<span class="line"><span>            count += self.cells[idx] as u8;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    count</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>使用取余运算是为了避免使用杂乱的 if 代码来处理边界，但导致我不得不用 DIV 这样比较耗费性能的指令。相反，如果用 if 处理边界，并展开循环，则分支条件将会比较适合 CPU 处理。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>fn live_neighbor_count(&#x26;self, row: u32, column: u32) -> u8 {</span></span>
<span class="line"><span>    let mut count = 0;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    let north = if row == 0 {</span></span>
<span class="line"><span>        self.height - 1</span></span>
<span class="line"><span>    } else {</span></span>
<span class="line"><span>        row - 1</span></span>
<span class="line"><span>    };</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    let south = if row == self.height - 1 {</span></span>
<span class="line"><span>        0</span></span>
<span class="line"><span>    } else {</span></span>
<span class="line"><span>        row + 1</span></span>
<span class="line"><span>    };</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    let west = if column == 0 {</span></span>
<span class="line"><span>        self.width - 1</span></span>
<span class="line"><span>    } else {</span></span>
<span class="line"><span>        column - 1</span></span>
<span class="line"><span>    };</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    let east = if column == self.width - 1 {</span></span>
<span class="line"><span>        0</span></span>
<span class="line"><span>    } else {</span></span>
<span class="line"><span>        column + 1</span></span>
<span class="line"><span>    };</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    let nw = self.get_index(north, west);</span></span>
<span class="line"><span>    count += self.cells[nw] as u8;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    let n = self.get_index(north, column);</span></span>
<span class="line"><span>    count += self.cells[n] as u8;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    let ne = self.get_index(north, east);</span></span>
<span class="line"><span>    count += self.cells[ne] as u8;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    let w = self.get_index(row, west);</span></span>
<span class="line"><span>    count += self.cells[w] as u8;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    let e = self.get_index(row, east);</span></span>
<span class="line"><span>    count += self.cells[e] as u8;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    let sw = self.get_index(south, west);</span></span>
<span class="line"><span>    count += self.cells[sw] as u8;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    let s = self.get_index(south, column);</span></span>
<span class="line"><span>    count += self.cells[s] as u8;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    let se = self.get_index(south, east);</span></span>
<span class="line"><span>    count += self.cells[se] as u8;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    count</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>接下来再跑一次性能测试，将他输出到<code>after.txt</code>。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#B392F0">$</span><span style="color:#9ECBFF"> cargo</span><span style="color:#9ECBFF"> bench</span><span style="color:#F97583"> |</span><span style="color:#B392F0"> tee</span><span style="color:#9ECBFF"> after.txt</span></span>
<span class="line"><span style="color:#B392F0">   Compiling</span><span style="color:#9ECBFF"> wasm_game_of_life</span><span style="color:#9ECBFF"> v0.1.0</span><span style="color:#E1E4E8"> (file:///home/fitzgen/wasm_game_of_life)</span></span>
<span class="line"><span style="color:#B392F0">    Finished</span><span style="color:#9ECBFF"> release</span><span style="color:#E1E4E8"> [optimized </span><span style="color:#9ECBFF">+</span><span style="color:#9ECBFF"> debuginfo]</span><span style="color:#9ECBFF"> target</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">s</span><span style="color:#E1E4E8">) </span><span style="color:#9ECBFF">in</span><span style="color:#79B8FF"> 0.82</span><span style="color:#9ECBFF"> secs</span></span>
<span class="line"><span style="color:#B392F0">     Running</span><span style="color:#9ECBFF"> target/release/deps/wasm_game_of_life-91574dfbe2b5a124</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">running</span><span style="color:#79B8FF"> 0</span><span style="color:#9ECBFF"> tests</span></span>
<span class="line"></span>
<span class="line"><span style="color:#79B8FF">test</span><span style="color:#9ECBFF"> result:</span><span style="color:#9ECBFF"> ok.</span><span style="color:#79B8FF"> 0</span><span style="color:#9ECBFF"> passed</span><span style="color:#E1E4E8">; </span><span style="color:#B392F0">0</span><span style="color:#9ECBFF"> failed</span><span style="color:#E1E4E8">; </span><span style="color:#B392F0">0</span><span style="color:#9ECBFF"> ignored</span><span style="color:#E1E4E8">; </span><span style="color:#B392F0">0</span><span style="color:#9ECBFF"> measured</span><span style="color:#E1E4E8">; </span><span style="color:#B392F0">0</span><span style="color:#9ECBFF"> filtered</span><span style="color:#9ECBFF"> out</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">     Running</span><span style="color:#9ECBFF"> target/release/deps/bench-8474091a05cfa2d9</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">running</span><span style="color:#79B8FF"> 1</span><span style="color:#9ECBFF"> test</span></span>
<span class="line"><span style="color:#79B8FF">test</span><span style="color:#9ECBFF"> universe_ticks</span><span style="color:#9ECBFF"> ...</span><span style="color:#9ECBFF"> bench:</span><span style="color:#79B8FF">      87</span><span style="color:#9ECBFF">,258</span><span style="color:#9ECBFF"> ns/iter</span><span style="color:#E1E4E8"> (+/- </span><span style="color:#79B8FF">14</span><span style="color:#9ECBFF">,632</span><span style="color:#E1E4E8">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#79B8FF">test</span><span style="color:#9ECBFF"> result:</span><span style="color:#9ECBFF"> ok.</span><span style="color:#79B8FF"> 0</span><span style="color:#9ECBFF"> passed</span><span style="color:#E1E4E8">; </span><span style="color:#B392F0">0</span><span style="color:#9ECBFF"> failed</span><span style="color:#E1E4E8">; </span><span style="color:#B392F0">0</span><span style="color:#9ECBFF"> ignored</span><span style="color:#E1E4E8">; </span><span style="color:#B392F0">1</span><span style="color:#9ECBFF"> measured</span><span style="color:#E1E4E8">; </span><span style="color:#B392F0">0</span><span style="color:#9ECBFF"> filtered</span><span style="color:#9ECBFF"> out</span></span></code></pre>
<p>感觉性能提高了不少，现在对比一下前后的数据。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#B392F0">$</span><span style="color:#9ECBFF"> cargo</span><span style="color:#9ECBFF"> benchcmp</span><span style="color:#9ECBFF"> before.txt</span><span style="color:#9ECBFF"> after.txt</span></span>
<span class="line"><span style="color:#B392F0"> name</span><span style="color:#9ECBFF">            before.txt</span><span style="color:#9ECBFF"> ns/iter</span><span style="color:#9ECBFF">  after.txt</span><span style="color:#9ECBFF"> ns/iter</span><span style="color:#9ECBFF">  diff</span><span style="color:#9ECBFF"> ns/iter</span><span style="color:#9ECBFF">   diff</span><span style="color:#9ECBFF"> %</span><span style="color:#9ECBFF">  speedup</span></span>
<span class="line"><span style="color:#B392F0"> universe_ticks</span><span style="color:#79B8FF">  664</span><span style="color:#9ECBFF">,421</span><span style="color:#79B8FF">             87</span><span style="color:#9ECBFF">,258</span><span style="color:#79B8FF">                 -577,163</span><span style="color:#79B8FF">  -86.87%</span><span style="color:#9ECBFF">   x</span><span style="color:#79B8FF"> 7.61</span></span></code></pre>
<p>哇！提高了 7.61 倍！</p>
<p>WebAssembly 意图和原生系统贴近，但是我们确实需要在 WebAssembly 环境下也作一次测试。</p>
<p>从新编译程序，刷新浏览器页面，画面重新跑在 60fps，每一帧大概是 10 毫秒。</p>
<p>成功！</p>
<p><img src="https://rustwasm.github.io/book/images/game-of-life/waterfall-after-branches-and-unrolling.png" alt="测试结果"></p>
<h3 id="练习-5">练习</h3>
<ul>
<li>现在，下一个性能瓶颈是<code>Universe::tick</code>调用和释放函数的部分，尝试缓存细胞状态，让 Universe 维护两个向量，永远不释放他们，也不掉用新的区间。</li>
<li>换一种方式实现游戏，让 Rust 和 JavaScript 以细胞的列表交互，这样能让渲染画布更快吗？你能实现这个设计同时不在每个 tick 函数中调用新的列表吗？</li>
<li>就性能显示来看 2D 画布渲染显然不够快，使用 WebGL 画布重新渲染，WebGL 能多快？使用 WebGL 能在遇到瓶颈前创建多大的宇宙空间？</li>
</ul>
<h2 id="压缩wasm-文件大小">压缩.wasm 文件大小</h2>
<p>rustc 有很多配置项，可以让<code>.wasm</code>二进制文件更加小。在很多情况下更小的生成文件意味着更长的编译时间。另外更小的文件使得 WebAssembly 的运行时间更长。我们应该意识到这些方面上的牺牲。在这些情况下，当我们要减少编译文件大小时，我们应该考虑到使用性能监视器衡量一下这种改动是否值得。</p>
<h3 id="使用链接配置器编译">使用链接配置器编译</h3>
<p>在<code>Cargo.toml</code>，增加<code>lto=true</code>：</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">[</span><span style="color:#B392F0">profile</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">release</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#E1E4E8">lto = </span><span style="color:#79B8FF">true</span></span></code></pre>
<p>者给予 LLVM 更多机会去内联和简化函数，不仅仅会使<code>.wasm</code>更小，还会让他在运行时运行得更快！但是会让他编译得更长。</p>
<h3 id="配置-llvm-牺牲速度换文件大小">配置 LLVM 牺牲速度换文件大小</h3>
<p>LLVM 默认配置是为了运行速度，并不是大小。我们可以通过更改<code>Cargo.toml</code>去修改这一配置。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">[</span><span style="color:#B392F0">profile</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">release</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#E1E4E8">opt-level = </span><span style="color:#9ECBFF">'s'</span></span></code></pre>
<p>或者，更激进的可以把它改成”z”。</p>
<p>但是，配置为”s”的时候有的时候会比”z”更小，所以一定要做测量！</p>
<h3 id="使用-wasm-opt-工具">使用 wasm-opt 工具</h3>
<p><a href="https://github.com/WebAssembly/binaryen" rel="noopener noreferrer nofollow" target="_blank">Binaryen</a>是一个关于 WebAssembly 编译工具的集合。他比 LLVM 更加后端，使用<code>wasm-opt</code>处理生成文件常常会节省 15%~20%的代码，同时又会提高运行速度。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span># 输出为压缩的文件大小。</span></span>
<span class="line"><span>wasm-opt -Os -o output.wasm input.wasm</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 更激进的输出为压缩的文件大小。</span></span>
<span class="line"><span>wasm-opt -Oz -o output.wasm input.wasm</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 输出文件追求运行速度。</span></span>
<span class="line"><span>wasm-opt -O -o output.wasm input.wasm</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 输出文件更激进的追求运行速度。</span></span>
<span class="line"><span>wasm-opt -O3 -o output.wasm input.wasm</span></span></code></pre>
<h4 id="注意调试信息">注意调试信息</h4>
<p>占用生成文件大小的主要成分是调试信息和函数名。<code>wasm-pack</code>能够默认移除调试信息。然而<code>wasm-opt</code>在使用<code>-g</code>参数时能删除函数名。</p>
<p>这意味着，如果你按照以上操作，生成文件应该既没有调试信息也没有函数名。如果你想保留某些调试信息，请一定注意这一点。</p>
<h3 id="文件大小检查调查">文件大小检查调查</h3>
<p>如果修改编译配置不能获得更小的文件大小，就应该调查一下是什么代码导致文件太大。</p>
<blockquote>
<p>就像做性能测试，我们应让工具来判断哪里出了问题，否则我们会浪费更多自己的时间。</p>
</blockquote>
<h4 id="twiggy-代码检查器">twiggy 代码检查器</h4>
<p><a href="https://github.com/rustwasm/twiggy" rel="noopener noreferrer nofollow" target="_blank">twiggy</a>是一个支持 WebAssembly 的代码大小检查器，他能分析二进制代码的调用图，并解决如下问题：</p>
<ul>
<li>为什么这个函数被编译到这段代码中。</li>
<li>这个函数占用大小是多少？如果我删除这个函数以及其相关函数我能节省多大的空间？</li>
</ul>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>$ twiggy top -n 20 pkg/wasm_game_of_life_bg.wasm</span></span>
<span class="line"><span> Shallow Bytes │ Shallow % │ Item</span></span>
<span class="line"><span>───────────────┼───────────┼────────────────────────────────────────────────────────────────────────────────────────</span></span>
<span class="line"><span>          9158 ┊    19.65% ┊ "function names" subsection</span></span>
<span class="line"><span>          3251 ┊     6.98% ┊ dlmalloc::dlmalloc::Dlmalloc::malloc::h632d10c184fef6e8</span></span>
<span class="line"><span>          2510 ┊     5.39% ┊ &#x3C;str as core::fmt::Debug>::fmt::he0d87479d1c208ea</span></span>
<span class="line"><span>          1737 ┊     3.73% ┊ data[0]</span></span>
<span class="line"><span>          1574 ┊     3.38% ┊ data[3]</span></span>
<span class="line"><span>          1524 ┊     3.27% ┊ core::fmt::Formatter::pad::h6825605b326ea2c5</span></span>
<span class="line"><span>          1413 ┊     3.03% ┊ std::panicking::rust_panic_with_hook::h1d3660f2e339513d</span></span>
<span class="line"><span>          1200 ┊     2.57% ┊ core::fmt::Formatter::pad_integral::h06996c5859a57ced</span></span>
<span class="line"><span>          1131 ┊     2.43% ┊ core::str::slice_error_fail::h6da90c14857ae01b</span></span>
<span class="line"><span>          1051 ┊     2.26% ┊ core::fmt::write::h03ff8c7a2f3a9605</span></span>
<span class="line"><span>           931 ┊     2.00% ┊ data[4]</span></span>
<span class="line"><span>           864 ┊     1.85% ┊ dlmalloc::dlmalloc::Dlmalloc::free::h27b781e3b06bdb05</span></span>
<span class="line"><span>           841 ┊     1.80% ┊ &#x3C;char as core::fmt::Debug>::fmt::h07742d9f4a8c56f2</span></span>
<span class="line"><span>           813 ┊     1.74% ┊ __rust_realloc</span></span>
<span class="line"><span>           708 ┊     1.52% ┊ core::slice::memchr::memchr::h6243a1b2885fdb85</span></span>
<span class="line"><span>           678 ┊     1.45% ┊ &#x3C;core::fmt::builders::PadAdapter&#x3C;'a> as core::fmt::Write>::write_str::h96b72fb7457d3062</span></span>
<span class="line"><span>           631 ┊     1.35% ┊ universe_tick</span></span>
<span class="line"><span>           631 ┊     1.35% ┊ dlmalloc::dlmalloc::Dlmalloc::dispose_chunk::hae6c5c8634e575b8</span></span>
<span class="line"><span>           514 ┊     1.10% ┊ std::panicking::default_hook::{{closure}}::hfae0c204085471d5</span></span>
<span class="line"><span>           503 ┊     1.08% ┊ &#x3C;&#x26;'a T as core::fmt::Debug>::fmt::hba207e4f7abaece6</span></span></code></pre>
<h4 id="手动修改-llvm-ir">手动修改 LLVM-IR</h4>
<p>LLVM-IR 是 LLVM 生成 WebAssembly 代码的最后一步。所以，他和最终生成的 WebAssembly 很像。更多的 LLVM-IR 代码意味着生成的文件越大，当一个函数占用了 LLVM-IR 中 25%的位置，则代表他占用了 25%的文件大小。当然这些数字只是个经验值，因为 LLVM-IR 还有一些 WebAssembly 没有的重要的信息（因为 WebAssembly 没有诸如 DWARF 调试信息）。</p>
<p>你可以使用 cargo 生成 LLVM-IR 代码：</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#B392F0">cargo</span><span style="color:#9ECBFF"> rustc</span><span style="color:#79B8FF"> --release</span><span style="color:#79B8FF"> --</span><span style="color:#79B8FF"> --emit</span><span style="color:#9ECBFF"> llvm-ir</span></span></code></pre>
<p>接下来你可以使用 find 命令去寻找存储在 cargo 生成目录(target)下的<code>.ll</code>文件。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#B392F0">find</span><span style="color:#9ECBFF"> target/release</span><span style="color:#79B8FF"> -type</span><span style="color:#9ECBFF"> f</span><span style="color:#79B8FF"> -name</span><span style="color:#9ECBFF"> '*.ll'</span></span></code></pre>
<p>相关可以参考<a href="https://llvm.org/docs/LangRef.html" rel="noopener noreferrer nofollow" target="_blank">LLVM 语言</a></p>
<h4 id="更激进的工具">更激进的工具</h4>
<p>修改编译配置是比较好上手的。如果你想前进一个里程，你可以使用一些更激进的工具，像是重写代码以减少冗余。以下是一些不太优雅的代码，但是的确能减少生成文件大小。</p>
<h5 id="避免字符串格式化">避免字符串格式化</h5>
<p><code>format!</code>,<code>to_string</code>等，能加入很多冗余代码。如果可能，在调试环境用格式化，而在发布环境使用静态字符串。</p>
<h5 id="避免使用崩溃">避免使用崩溃</h5>
<p>这很明显，使用 twiggy 之类的工具或者人工检查 LLVM-IR 能帮助你查出到底哪个函数崩溃。</p>
<p>崩溃并不总是出现在<code>panic!()</code>宏，他们会在很多情况下出现。</p>
<ul>
<li>访问切片越界，如：<code>my_slice[i]</code></li>
<li>除 0，如：<code>dividend/divider</code></li>
<li>解 Option 类型或者 Result 类型，如：<code>opt.unwrap()</code>或者<code>res.unwrap()</code></li>
</ul>
<p>前两个可以被改成第三个，访问切片可以使用<code>my_slice.get(i)</code>。除法可以使用<code>checked_div</code>，所以你只有一种需要处理的情况。</p>
<p>解开<code>Option</code>或者<code>Result</code>有两种方法安全的和不安全的。</p>
<p>安全的方式是使用 abort 方法而不是返回 None 和 Error 值。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>#[inline]</span></span>
<span class="line"><span>pub fn unwrap_abort&#x3C;T>(o: Option&#x3C;T>) -> T {</span></span>
<span class="line"><span>  use std::process;</span></span>
<span class="line"><span>  match o {</span></span>
<span class="line"><span>    Some(t) => t,</span></span>
<span class="line"><span>    None => process::abort(),</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>最终，崩溃在<code>wasm32-unknown-unknown</code>被翻译成退出，因此不会造成代码冗余。</p>
<p>相反的，<a href="https://crates.io/crates/unreachable" rel="noopener noreferrer nofollow" target="_blank">unreachable</a>包为 Option 和 Result 类型提供不安全的<a href="https://docs.rs/unreachable/1.0.0/unreachable/trait.UncheckedOptionExt.html#tymethod.unchecked_unwrap" rel="noopener noreferrer nofollow" target="_blank">unchecked_unwrap</a>方法。让 Rust 编译器假定 Option 类型是 Some 类型而 Result 类型是 Ok 类型。如果值是不正确的的情况是未被考虑的。你一定要在 110%确认的情况下使用这个包，因为编译器可没那么聪明能预估出错误。即使你这么做了，你一定要在调试环境下面做检查，而在发布环境下去掉检查。</p>
<h4 id="避免调用内存或者使用-wee_alloc">避免调用内存或者使用 wee_alloc</h4>
<p>Rust 的默认调用器是<code>dlmalloc</code>的一部分。它能达到 10KB。如果能够避免动态调用，你应该能省下 10KB。</p>
<p>完全避免动态语言调用可能会非常困难。但是删除调用却在某些情况下很简单，在这些情况下，可以使用<a href="https://github.com/rustwasm/wee_alloc" rel="noopener noreferrer nofollow" target="_blank"><code>wee_alloc</code></a>代替全局的调用器可以从 10KB 中节省很多。<code>we_alloc</code>是当你想要一些调用器时的一个选择，并能同时减少代码大小。</p>
<h4 id="使用-trait-来替代泛型">使用 trait 来替代泛型</h4>
<p>当你创建一些泛型函数。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>fn whatever&#x3C;T: MyTrait>(t: T) { ... }</span></span></code></pre>
<p><code>rustc</code>和 LLVM 会为不同类型生成新的函数拷贝。这为编译器提供了各种类型使用这个函数的机会。但会增加代码大小。</p>
<p>如果你为对象提供 trait，如下：</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>fn whatever(t: Box&#x3C;MyTrait>) { ... }</span></span>
<span class="line"><span>// or</span></span>
<span class="line"><span>fn whatever(t: &#x26;MyTrait) { ... }</span></span>
<span class="line"><span>// etc...</span></span></code></pre>
<p>这样经过虚调用动态派遣（dynamic dispatch）的方法就被使用了，如此只会用一个函数会放在<code>.wasm</code>。这样的缺点是丢失了编译器自定义的机会，并且增加了不直接的，动态的语言调用。</p>
<h4 id="使用-wasm-snip-工具">使用 wasm-snip 工具</h4>
<p><a href="https://github.com/fitzgen/wasm-snip" rel="noopener noreferrer nofollow" target="_blank"><code>wasm-snip</code></a>使用<code>unreachable</code>方法代替了 WebAssembly 的函数。这是一个又沉又钝的锤子，更像是徒手。</p>
<p>也许你知道有些函数可能永远不会在运行时被调用，但是编译器不能保证？掐了他！执行<code>wasm-opt</code>加上<code>--dce</code>参数，所有无关函数就会被剪掉。</p>
<p>这个工具对删除崩溃及其有用。</p>
<h3 id="我们能把生命游戏缩到多小">我们能把生命游戏缩到多小？</h3>
<p>默认的配置下，WebAssembly 二进制大小为 29410 字节。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#B392F0">$</span><span style="color:#9ECBFF"> wc</span><span style="color:#79B8FF"> -c</span><span style="color:#9ECBFF"> pkg/wasm_game_of_life_bg.wasm</span></span>
<span class="line"><span style="color:#B392F0">29410</span><span style="color:#9ECBFF"> pkg/wasm_game_of_life_bg.wasm</span></span></code></pre>
<p>打开 LTO 之后设置<code>opt-level="z"</code>执行<code>wasm-opt -Oz</code>，结果是 17317 字节。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#B392F0">$</span><span style="color:#9ECBFF"> wc</span><span style="color:#79B8FF"> -c</span><span style="color:#9ECBFF"> pkg/wasm_game_of_life_bg.wasm</span></span>
<span class="line"><span style="color:#B392F0">17317</span><span style="color:#9ECBFF"> pkg/wasm_game_of_life_bg.wasm</span></span></code></pre>
<p>如果使用 gzip 压缩，你能搞到 9045 字节！</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#B392F0">$</span><span style="color:#9ECBFF"> gzip</span><span style="color:#79B8FF"> -9</span><span style="color:#F97583"> &#x3C;</span><span style="color:#9ECBFF"> pkg/wasm_game_of_life_bg.wasm</span><span style="color:#F97583"> |</span><span style="color:#B392F0"> wc</span><span style="color:#79B8FF"> -c</span></span>
<span class="line"><span style="color:#B392F0">9045</span></span></code></pre>
<h3 id="练习-6">练习</h3>
<ul>
<li>使用<code>wasm-snp</code>工具删掉会有崩溃的函数，它能减少多少字节？</li>
<li>使用<code>wee_alloc</code>作为全局调用器，，修改<code>Cargo.toml</code>：</li>
</ul>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>[features]</span></span>
<span class="line"><span>default = ["wee_alloc"]</span></span></code></pre>
<p>能够减少多少大小呢？</p>
<ul>
<li>我们只实现了一个 Universe，所以相比使用构造器，我们可以导出一个<code>static mut</code>实例，如果这个实例使用的是双向缓存，我们也可以让这些缓存也是全局<code>staic mut</code>。这样就移除了所有的动态调用，我们可以增加<code>#![no_std]</code>包取消掉调用器。这回能缩小多少大小？</li>
</ul>
<h2 id="发布到-npm">发布到 NPM</h2>
<p>首先，确保你登入了 npm。</p>
<p>接着，使用<code>wasm-pack login</code>登入。</p>
<h3 id="发布">发布</h3>
<p>确保已经执行<code>wasm-pack build</code>并且 pkg 文件已经编译好。</p>
<p>已经准备好之后，跑<code>wasm-pack publish</code>上传包到 npm。</p>
<p>这样就发布了！</p>
<p>有哥们照着这个指导做完发布失败，是因为”name”字段存在重名</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">[</span><span style="color:#B392F0">package</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#E1E4E8">name = </span><span style="color:#9ECBFF">"wasm-game-of-life-my-username"</span></span></code></pre>
<p>接着，重新编译并发布</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#B392F0">wasm-pack</span><span style="color:#9ECBFF"> build</span></span>
<span class="line"><span style="color:#B392F0">wasm-pack</span><span style="color:#9ECBFF"> publish</span></span></code></pre>
<p>这会应该能行。</p>
<h2 id="与-javascript-相互交互">与 JavaScript 相互交互</h2>
<h3 id="javascript-函数的输出和引用">JavaScript 函数的输出和引用</h3>
<h4 id="在-rust-一边">在 Rust 一边</h4>
<p>在 JavaScript 为主的世界里使用 WebAssembly，引入和输出函数比较直接，有点类似于 C。</p>
<p>WebAssembly 模块声明了一系列引入，每一个都有模块名。模块名可以使用<code>#[link(wasm_import_module)]</code>提供给<code>extern {...}</code>。</p>
<p>导出的 WebAssembly 线性内存被导出作”memory”。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>// import a JS function called `foo` from the module `mod`</span></span>
<span class="line"><span>#[link(wasm_import_module = "mod")]</span></span>
<span class="line"><span>extern { fn foo(); }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// export a Rust function called `bar`</span></span>
<span class="line"><span>#[no_mangle]</span></span>
<span class="line"><span>pub extern fn bar() { /* ... */ }</span></span></code></pre>
<p>因为 WebAssembly 的值类型有局限，这些函数只有基础的数字类型。</p>
<h4 id="在-javascript-一边">在 JavaScript 一边</h4>
<p>在 JavaScript 中，wasm 二进制文件转换成 ES6 模块。它必须被实例化为线性内存并由一系列函数能对应到这些引入。细节描述可在<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiateStreaming" rel="noopener noreferrer nofollow" target="_blank">MDN</a>找到。</p>
<p>ES6 的模块包括从 Rust 暴露给 JavaScript 的函数，现在可以用 JavaScript 调用。</p>
<p><a href="https://www.hellorust.com/demos/add/index.html" rel="noopener noreferrer nofollow" target="_blank">这里</a>有一个很简单的构建流程。</p>
<h3 id="除了数字">除了数字</h3>
<p>当在 JavaScript 中使用 WebAssembly，WebAssembly 的内存和 JavaScript 的内存有很大的不同。</p>
<ul>
<li>每个 WebAssembly 模块的线性内存，JavaScript 可以自由访问。</li>
<li>对应之下，WebAssembly 不能访问 JavaScript 的内存。</li>
</ul>
<p>所以，有两种复杂的交互。</p>
<ul>
<li>复制二进制数据到 WebAssembly 内存。</li>
<li>建立一个在 JavaScript 上的堆内存，提供一堆地址。这样 WebAssembly 访问 JavaScript 对象，间接通过 JavaScript 访问。</li>
</ul>
<p>幸运的是，通过<code>bindgen</code>框架<a href="https://github.com/rustwasm/wasm-bindgen" rel="noopener noreferrer nofollow" target="_blank"><code>wasm-bindgen</code></a>可以帮助交互。这个框架可以将已习惯的 Rust 语言自动翻译到 JavaScript。</p>
<h3 id="自定义部分译者所以这个到底是干什么用的">自定义部分（译者：所以这个到底是干什么用的？）</h3>
<p>自定义部分允许随意继承人一的数据进入 WebAssembly 模块，这个数据是在编译时设置，不能在运行时修改。</p>
<p>在 Rust 中，自定义部分是通过<code>#[link_section]</code>属性暴露的静态数组([T; size])。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>#[link_section = "hello"]</span></span>
<span class="line"><span>pub static SECTION: [u8; 24] = *b"This is a custom section";</span></span></code></pre>
<p>这样给 wasm 增加一个 hello 部分，这个 SECTION 变量是随意的，但是无论怎么赋值，内容总是这些文字。</p>
<p>这个自定义内容可以被 JavaScript 通过<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Module/customSections" rel="noopener noreferrer nofollow" target="_blank"><code>WebAssembly.Module.customSections</code></a>获得自定义部分，它返回一个<code>ArrayBuffer</code>，如果有同名的部分，他们会被放到一个数组中。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span>WebAssembly.compileStreaming(fetch("sections.wasm"))</span></span>
<span class="line"><span>.then(mod => {</span></span>
<span class="line"><span>  const sections = WebAssembly.Module.customSections(mod, "hello");</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  const decoder = new TextDecoder();</span></span>
<span class="line"><span>  const text = decoder.decode(sections[0]);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  console.log(text); // -> "This is a custom section"</span></span>
<span class="line"><span>});</span></span></code></pre>
<h2 id="哪些包能在-webassembly-下面使用">哪些包能在 WebAssembly 下面使用</h2>
<p>最简单的就是列出 WebAssembly 上能用的 Rust 包：如果避开了以下内容，则这些包可以在 WebAssembly 使用。如果一个包支持<code>#![no_std]</code>
的包，这个包也可能支持 WebAssembly。</p>
<h3 id="以下包不能使用">以下包不能使用</h3>
<h4 id="c-和系统级依赖">C 和系统级依赖</h4>
<p>WebAssembly 不提供系统一级别的库，所以任何链接系统库的地方都无法成功。</p>
<p>使用 C 库可能不会成功，既然没有稳定的交叉编译 ABI，和提供给 WebAssembly 交叉链接的连接库。虽然 clang 已经发布 wasm32 的生成，但是还远远不足。</p>
<h4 id="文件-io">文件 I/O</h4>
<p>WebAssembly 没有访问文件系统的功能，所以访问文件系统的库都不能使用。</p>
<h4 id="调用线程">调用线程</h4>
<p>目前有计划<a href="https://rustwasm.github.io/2018/10/24/multithreading-rust-and-wasm.html" rel="noopener noreferrer nofollow" target="_blank">加入线程</a>，但是还没被发布。尝试调用线程会导致崩溃。</p>
<h3 id="有哪些目的的包能在-webassembly-下面使用">有哪些目的的包能在 WebAssembly 下面使用</h3>
<p>如果只是提供<a href="https://crates.io/categories/algorithms" rel="noopener noreferrer nofollow" target="_blank">算法</a>和<a href="https://crates.io/categories/data-structures" rel="noopener noreferrer nofollow" target="_blank">数据结构</a>的包。</p>
<h4 id="no-std">#![no-std]</h4>
<p><a href="https://crates.io/categories/no-std" rel="noopener noreferrer nofollow" target="_blank">不依赖于标准库的包</a>能够运行在 WebAssembly 下面。</p>
<h4 id="解析器">解析器</h4>
<p>只要是接受输入且无需文件操作的<a href="https://crates.io/categories/parser-implementations" rel="noopener noreferrer nofollow" target="_blank">解析器</a>就可能运行在 WebAssembly 下。</p>
<h4 id="文字处理">文字处理</h4>
<p><a href="https://crates.io/categories/text-processing" rel="noopener noreferrer nofollow" target="_blank">复杂的语言处理</a>可能会运行在 WebAssembly 下面。</p>
<h4 id="rust-范式">Rust 范式</h4>
<p><a href="https://crates.io/categories/rust-patterns" rel="noopener noreferrer nofollow" target="_blank">适用于不同情况下的包</a>可能运行在 WebAssembly 下。</p>
<h2 id="如何给常用库增加-webassembly-支持">如何给常用库增加 WebAssembly 支持</h2>
<p>本部分讲解如何将常用库增加 WebAssembly 支持。后面的内容我就捡感兴趣的写了。</p>
<h3 id="在-ci-增加-wasm32-unknown-unknown">在 CI 增加 wasm32-unknown-unknown</h3>
<p>保证 CI 中增加如下命令</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#B392F0">rustup</span><span style="color:#9ECBFF"> target</span><span style="color:#9ECBFF"> add</span><span style="color:#9ECBFF"> wasm32-unknown-unknown</span></span>
<span class="line"><span style="color:#B392F0">cargo</span><span style="color:#9ECBFF"> check</span><span style="color:#79B8FF"> --target</span><span style="color:#9ECBFF"> wasm32-unknown-unknown</span></span></code></pre>
<p>举个例子，在 travis 的配置中增加如下配置：</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#85E89D">matrix</span><span style="color:#E1E4E8">:</span></span>
<span class="line"><span style="color:#85E89D">  include</span><span style="color:#E1E4E8">:</span></span>
<span class="line"><span style="color:#E1E4E8">    - </span><span style="color:#85E89D">language</span><span style="color:#E1E4E8">: </span><span style="color:#9ECBFF">rust</span></span>
<span class="line"><span style="color:#85E89D">      rust</span><span style="color:#E1E4E8">: </span><span style="color:#9ECBFF">stable</span></span>
<span class="line"><span style="color:#85E89D">      name</span><span style="color:#E1E4E8">: </span><span style="color:#9ECBFF">"check wasm32 support"</span></span>
<span class="line"><span style="color:#85E89D">      install</span><span style="color:#E1E4E8">: </span><span style="color:#9ECBFF">rustup target add wasm32-unknown-unknown</span></span>
<span class="line"><span style="color:#85E89D">      script</span><span style="color:#E1E4E8">: </span><span style="color:#9ECBFF">cargo check --target wasm32-unknown-unknown</span></span></code></pre>
<h3 id="在-nodejs-或者无头浏览器译者卧槽是这么翻译么">在 node.js 或者无头浏览器（译者：卧槽是这么翻译么）</h3>
<p>你可以使用<code>wasm-bindgen-test</code>和<code>wasm-pack test</code>去跑测试，详细内容上面已经提到。</p>
<h2 id="发布-webassembly-到线上">发布 WebAssembly 到线上</h2>
<blockquote>
<p>发布过程几乎和任何 web 应用发布是一样的。</p>
</blockquote>
<p>为了发布 Web 应用，复制生成文件到线上环境，配置你的 HTTP 服务器让他们可访问。</p>
<h3 id="保证服务器支持-applicationwasm">保证服务器支持 application/wasm</h3>
<p>为了让浏览器加载变快，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiateStreaming" rel="noopener noreferrer nofollow" target="_blank">WebAssembly.instantiateStreaming</a>函数会使用管道传输文件（请确定你的打包器能够使用这个函数）。但是 instantiateStreaming 需要 HTTP 返回类型支持<code>application/wasm</code>，否则会丢出错误。</p>
<ul>
<li><a href="https://httpd.apache.org/docs/2.4/mod/mod_mime.html#addtype" rel="noopener noreferrer nofollow" target="_blank">如何配置 Apache 服务器</a></li>
<li><a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#types" rel="noopener noreferrer nofollow" target="_blank">如何配置 Nginx 服务器</a></li>
</ul>
<h3 id="更多内容">更多内容</h3>
<ul>
<li><a href="https://webpack.js.org/guides/production/" rel="noopener noreferrer nofollow" target="_blank">webpack 线上打包的最佳实践</a></li>
</ul></button></p></canvas></pre></pre></pre></pre></pre></article><footer data-astro-cid-sz7xmlte>
&copy; 2023 宫不上, built with <span class="heart" data-astro-cid-sz7xmlte>❤️</span>. All rights reserved.
</footer></main></body></html>