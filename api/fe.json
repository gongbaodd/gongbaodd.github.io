{"posts":[{"id":"2015/02/08/jQuery.md","slug":"2015/02/08/jquery","body":"\n#jQuery.fn.init()\n>   接收三个参数，selector,context,rootjQuery\n\n默认的$()传的值实际上考虑了很多种情况，下面是返回值\n\n1. false,undefined,null\n    \n        return this;\n2. node节点\n        \n        this.context = this[0] = selector;\n        this.length = 1;\n        return this;\n        \n3. \"body\"\n\n        this.context = document;\n        this[0] = document.body;\n        this.selector = selector;\n        this.length = 1;\n        return this;\n        \n4. 字符串，单独标签&lt;tag&gt;&lt;/tag&gt;\n\n        document.createElement;\n        return jQuery.merge(this,selector)\n        \n5. 字符串，复杂的HTML代码&lt;span class=\"a\" &gt;\n\n        jQuery.buildFragment;\n        return jQuery.merge(this,selector)\n        \n6. 字符串，#id\n        \n        document.getElementById;\n        this.context = document;\n        this.selector = selector;\n        return this;\n        \n7. 字符串，选择器\n\n        return jQuery.find(selector);\n        \n8. 字符串，选择器，context传值为$(...)\n\n        return context.find(selector);\n        \n9. 字符串，选择器，context传值为非jquery对象\n\n        return this.constructor(context).find(selector);\n    \n    > 7、8、9可以写成\n        return (context || rootjQuery).find(selector);\n        \n10. 函数\n    \n        return rootjQuery.ready(selector);\n        \n11. jquery对象//深拷贝\n\n        this.selector = selector.selector;\n        this.context = selector.context;\n        \n12. 其它\n\n        return jQuery.makeArray(selector,this);\n\n        \n        ","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2015/03/14/LearningInThreeJS-1.md","slug":"2015/03/14/learninginthreejs-1","body":"\n# LearningInThreeJS\n## （一）基本之基本\n\n> 这些是嚼the Packt book \"Learning Threejs\"出来的一些干货，捡了些觉得可学的代码放到我的myExpirements下面的learning-in-threejs分支里面了。\n\n### 1. 简单实现(basic.html)\n\nhttps://github.com/gongbaodd/myExperinments/blob/learning-threejs/01-basic.html\n\n* 必须要有的\n\n        var scene = new THREE.Scene();\n        var camera = new THREE.PerspectiveCamera(45,window.innerWidth/window.innerHeight,0.1,1000);\n        var renderer = new THREE.WebGLRenderer();\n        document.getElementById(\"WebGL-output\").appendChild(renderer.domElement);\n        \n* 坐标帮助\n\n        var axes = new THREE.AxisHelper(20);\n        scenne.add(axes);\n        \n* initStates\n\n        ()=>\n            var stats = new Stats();\n\n                stats.setMode(0);\n\n                stats.domElement.style.position = 'absolute';\n                stats.domElement.style.left = '0px';\n                stats.domElement.style.top = '0px';\n\n                document.getElementById(\"Stats-output\").appendChild(stats.domElement);\n\n                return stats;\n                \n* onResize()\n\n        window.addEventListener('resize',onResize,false);\n        \n* controller\n\n            var controls = new function () {\n                this.rotationSpeed = 0.02;\n                this.bouncingSpeed = 0.03;\n            };\n\n            var gui = new dat.GUI();\n            gui.add(controls,'rotationSpeed',0,0.5);\n            gui.add(controls,'bouncingSpeed',0,0.5);\n\n### 2. 场景Scene\nhttps://github.com/gongbaodd/myExperinments/blob/learning-threejs/02-scene.html\n    \n        var scene = new THREE.Scene();\n            scene.fog = new THREE.Fog(0xffffff,0.015,100);\n            scene.overrideMaterial = new THREE.MeshLambertMaterial({color:0xffffff});\n            \n### 3. 内置几何图形 \nhttps://github.com/gongbaodd/myExperinments/blob/learning-threejs/03-geometery.html\n\n### 4. 拼装几何图形\nhttps://github.com/gongbaodd/myExperinments/blob/learning-threejs/04-basic-geometry.html\n\n### 5. 网格操作\nhttps://github.com/gongbaodd/myExperinments/blob/learning-threejs/05-mesh.html\n\n### 6. 摄像头操作\nhttps://github.com/gongbaodd/myExperinments/blob/learning-threejs/06-camera.html","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2015/03/15/THREE.JS.md","slug":"2015/03/15/threejs","body":"\n#THREE.JS参数记录\n## Renderer\n\n    var renderer = new THREE.WebGLRenderer({\n        canvas:document.getElementById('WebGL-output')\n    });\n    \n    //or\n    \n    document.getElementById('WebGL-output').appendChild(renderer.domElement);\n    \n### setClearColor\n\n    renderer.setClearColor(new THREE.Color(0x000000,1.0));\n    \n### Others\n\n    renderer.shadowMapEnabled = true;\n    renderer.setSize(w,h);\n    \n***\n\n## Scene\n\n    scene.add(mesh);\n        \n    scene.fog = new THREE.Fog(0xffffff,near,far);\n        \n***\n\n## Camera\n\n    THREE.OrthgraphicCamera(left,right,top,bottom,near,far);\n    \n    THREE.PerspectiveCamera(fov,//45\n                            width/height,\n                            near,\n                            far);\n                            \n***\n\n## Geometry\n\n* Cube\n\n        THREE.CubeGeometry(width, height, depth, widthSegments, heightSegments, depthSegments)\n    \n* Plane\n\n        THREE.PlaneGeometry(width, height, widthSegments, heightSegments)\n        \n* Sphere\n\n        THREE.SphereGeometry(radius, segmentsWidth, segmentsHeight, phiStart, phiLength, thetaStart, thetaLength)\n\n        ","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2015/05/04/ionic.md","slug":"2015/05/04/ionic","body":"\n#ionic的安装配置的坑\n>前一阵子react-native很火，甚是嫉妒啊，目前只支持iOS。。。T_T<br>\n不必要一直追求native，（虽然我还是试验了nativescript），在安卓上面还是可以尝试写写hybrid应用。\n\n---\n1. 安装ionic，安装android-sdk-r22（可以用hx.gy:1080代理）\n\n        npm install -g cordova ionic\n        \n2. 创建一个空/标签/侧边栏工程\n\n        ionic start myApp blank/tabs/sidemenu\n        \n3. 运行\n\n        cd myApp\n        chmod 777 * -R\n        ionic platform add android\n        ionic build android\n        ionic run android\n        \n4. 用浏览器测试\n\n        ionic serve","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2015/05/04/nativescript.md","slug":"2015/05/04/nativescript","body":"\n#nativescript试探报告\n>上一周得流感，再加上react-native只支持iOS，头脑一热，除了研究了ionic，还看了nativescript。感觉吧，nativescript比起QML之类的语言，最大的优点就是不必再去学习一门新的语言，因为它不是js的超集，而是完全的js，并且支持双向绑定，完全迎合现在的web开发。<br>\n用完nativescript有这么几个感受：<br>\n1. 用telerik platform ide感觉还是不错的，在安卓安装app可以同步更新软件，可惜这个ide只能使用30day。\n2. 官方给的文档经过证实已经部分过期。。。我只能拿现成的project当例子。\n3. css使能够用的，但是和react-native一样，都是真正的css的子集。\n4. 安卓上的性能不比hybrid好，等更新吧～\n5. 不用像QML一样，的确是mvvm，顶多需要学学安卓里面的xml就好了。\n6. cli需要<font color=red>翻墙！！！</font>\n\n***\n1. 安装nativescript,安卓需要r17\n\n        npm install -g nativescript\n        \n2. 创建工程\n\n        tns create app\n        \n3. 添加安卓支持\n\n        tns platform add android\n        \n4. 编译及调试\n\n        tns build android\n        tns run android","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2015/05/09/ionic-Todo guide.md","slug":"2015/05/09/ionic-todo-guide","body":"\n#ionic官方Todo Guide\n>代码在<br>https://github.com/gongbaodd/myExperinments/tree/ionic_todo\n一直想写一个app，但是懒得设计，看到ionic官方有个guide而且没有中文版，所以写一个。\n\n---\n1. 在head中添加对应的css和js\n        <meta charset=\"utf-8\">\n        <meta name=\"viewport\" content=\"initial-scale=1, maximum-scale=1, user-scalable=no, width=device-width\">\n        <title></title>\n        <link href=\"lib/ionic/css/ionic.css\" rel=\"stylesheet\">\n        <link href=\"css/style.css\" rel=\"stylesheet\">\n        <script src=\"lib/ionic/js/ionic.bundle.js\"></script>\n        <script src=\"cordova.js\"></script>\n        <script src=\"js/app.js\"></script>\n        \n2. body添加controller\n        <body ng-app=\"todo\" ng-controller=\"TodoCtrl\">\n        \n3. Todo的界面，分别是左边栏（负责分配todo的类型——projects）和主界面（负责分配每一个todo项——tasks）\n        <ion-side-menus>\n            <ion-side-menu-content>...</ion-side-menu-content>\n            <ion-side-menu side=\"left\">...</ion-side-menu>\n        </ion-side-menus>\n      \n4. Todo的行为\n        angular.module('todo',['ionic'])\n        .factory('Projects',function() {\n            ...\n        }）\n        .controller('TodoCtrl',function($scope,$timeout,$ionicModal,Projects,$ionicSideMenuDelegate) {\n            ...\n        })\n\n5. 左边栏结构\n        <ion-header-bar class=\"bar-dark\">\n            <h1 class=\"title\">Projects</h1>\n            <button class=\"button button-icon ion-plus\" ng-click=\"newProject()\"></button>\n        </ion-header-bar>\n        <ion-content scroll=\"false\">\n            <ion-list>\n                <ion-item ng-repeat=\"project in projects\" ng-click=\"selectProject(project,$index)\" ng-class=\"{active:activeProject == project}\">\n                    {{project.title}}\n                </ion-item>\n            </ion-list>\n        </ion-content>\n        \n6. 左边栏行为\n        .factory('Projects',function() {\n        return {\n            all:function(){\n                var projectString = window.localStorage['projects'];\n                if(projectString){\n                    return angular.fromJson(projectString);\n                }\n                return [];\n            },\n            save:function(projects){\n                window.localStorage['projects'] = angular.toJson(projects);\n            },\n            newProject:function(projectTitle){\n                return {\n                    title:projectTitle,\n                    tasks:[]\n                };\n            },\n            getLastActiveIndex:function(){\n                return parseInt(window.localStorage['lastActiveProject'])||0;\n            },\n            setLastActiveIndex:function(index){\n                window.localStorage['lastActiveProject'] = index;\n            }\n        }\n        })\n        \n7. 主界面结构\n        <ion-header-bar class=\"bar-dark\">\n            <h1 class=\"title\">Todo</h1>\n            <!--                New Task button-->\n            <button class=\"button button-icon\" ng-click=\"newTask()\">\n                <i class=\"icon ion-compose\"></i>\n            </button>\n        </ion-header-bar>\n        <ion-content scroll=\"false\">\n        <!--                our list and list items-->\n            <ion-list>\n               <ion-item ng-repeat=\"task in activeProject.tasks\">\n                   {{task.title}}\n               </ion-item>\n            </ion-list>\n        </ion-content>\n        \n8. 主界面行为\n        .controller('TodoCtrl',function($scope,$timeout,$ionicModal,Projects,$ionicSideMenuDelegate) {\n    \n        var createProject = function(projectTitle){\n            var newProject = Projects.newProject(projectTitle);\n            $scope.projects.push(newProject);\n            Projects.save($scope.projects);\n            $scope.selectProject(newProject,$scope.projects.length-1);\n        }\n    \n        $scope.projects = Projects.all();\n    \n        $scope.activeProject = $scope.projects[Projects.getLastActiveIndex()];\n    \n        $scope.newProject = function() {\n            var projectTitle = prompt(\"Project name\");\n            if(projectTitle){\n                createProject(projectTitle);\n            }\n        };\n    \n        $scope.selectProject = function(project,index){\n            $scope.activeProject = project;\n            Projects.setLastActiveIndex(index);\n            $ionicSideMenuDelegate.toggleLeft(false);\n        };\n    \n        $ionicModal.fromTemplateUrl('new-task.html',function(modal) {\n            $scope.taskModal = modal;\n        },{\n            scope:$scope,\n            animation:'slide-in-up'\n        });\n    \n        $scope.createTask = function(task) {\n\n            if(!$scope.activeProject||!task){\n                return ;\n            }\n            $scope.activeProject.tasks.push({\n                title:task.title\n            });\n            $scope.taskModal.hide();\n        \n            Projects.save($scope.projects);\n        \n            task.title = \"\";\n        };\n    \n        $scope.newTask = function() {\n            $scope.taskModal.show();\n        };\n        $scope.closeNewTask = function() {\n            $scope.taskModal.hide();\n        };\n        $scope.toggleProjects = function() {\n            $ioncSideMenuDelegate.toggleLeft();\n        };\n    \n        $timeout(function() {\n            if($scope.projects.length == 0){\n                while(true){\n                    var projectTitle = prompt('Your first project title');\n                    if(projectTitle){\n                        createProject(projectTitle);\n                        break;\n                    }\n                }\n            }\n        })\n        });\n        \n9. 新建项目的模态对话框\n        <script id=\"new-task\" class=\"html\" type=\"text/ng-template\">\n            <div class=\"modal\">\n            <!--        Modal header bar-->\n                <ion-header-bar class=\"bar-secndary\">\n                    <h1 class=\"title\">New Task</h1>\n                    <button class=\"button button-clear button-positive\" ng-click=\"closeNewTask()\">Cancel</button>\n                </ion-header-bar>\n                <!--        Modal content area-->\n                <ion-content>\n                    <form action=\"\" ng-submit=\"createTask(task)\">\n                        <div class=\"list\">\n                        <label for=\"\" class=\"item item-input\">\n                            <input type=\"text\" placeholder=\"What do you need to do?\" ng-model=\"task.title\">\n                        </label>\n                        </div>\n                        <div class=\"padding\">\n                            <button type=\"submit\" class=\"button button-block button-positive\">Create Task</button>\n                        </div>\n                    </form>\n                </ion-content>\n            </div>\n        </script>","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2015/08/25/fekit extension.md","slug":"2015/08/25/fekit-extension","body":"\n> 这几天公司里面的 QA 资源紧张，手上压了 4 个分支还没有发布，\n> 干脆腾出时间研究研究 fekit 的 extension，最好能贡献点代码。\n\n> Fekit 是去哪儿网的前端部署及开发工具，相比于 gulp、grunt 等工具\n> ，Fekit 需要用户的学习成本较低，上手比较快。\n\n> [Fekit 的 github 地址](https://github.com/rinh/fekit)<br> >[FekitExtension 的模板地址](https://github.com/rinh/fekit-extension-template)<br> >[FekitExtension 的一个示例](https://github.com/rinh/fekit-extension-hf)\n\n# 谈谈需求\n\n我想写一个工具，在运行 fekit server 之前把项目中的每个 js 加入一个 DOM 的插入供作，\n插入一个显示编译 ip 地址的 div，在 server 结束之后将这句 js 删掉。\n\n# 怎么写？\n\n单独按照 Extension 模板里面写，没办法调试啊！！！怎么办？我干脆在\n`/usr/local/lib/node_modules/fekit/lib/commands/`\n下面开刀，在里面新建一个 msg.js,它大概是这个样子的\n\n    (function(){\n        exports.usage = \"在js里面插一个插入DOM的脚本\";\n        exports.set_options = function(optimist) {\n            optimist.alias('p','pack');\n            optimist.describe('p','插入');\n            optimist.alias('u','unpack');\n            optimist.describe('u','删除');\n            return optimist;\n        }\n        exports.run = function(options) {\n\n        }\n    }).call(this);\n\n可以运行`fekit msg`试试了\n\n# 都是些什么玩意儿\n\n## optimist\n\n看了许多现成的示例，optimist 就是给命令添加参数\n\n## options\n\n    {\n         _: [ 'msg' ],\n         '$0': 'fekit',\n         p:true,\n         cwd: '~'\n     }\n\n## module\n\n> 全局对象\n\n    {\n        id: '/usr/local/lib/node_modules/fekit/lib/commands/msg.js',\n        exports:{\n            usage: '在js里面插一个插入DOM的脚本',\n            set_options: [Function],\n            run: [Function]\n            },\n            parent:{\n                id: '/usr/local/lib/node_modules/fekit/lib/cli.js',\n                exports: {\n                     help: [Function],\n                     run: [Function]\n            },\n            parent:{\n                 id: '.',\n                 exports: {},\n                 parent: null,\n                 filename: '/usr/local/lib/node_modules/fekit/bin/fekit',\n                 loaded: false,\n                 children: [Object],\n                 paths: [Object] },\n                 filename: '/usr/local/lib/node_modules/fekit/lib/cli.js',\n                 loaded: true,\n                 children: [ [Object], [Object], [Object], [Circular] ],\n                 paths:[\n                  '/usr/local/lib/node_modules/fekit/lib/node_modules',\n                  '/usr/local/lib/node_modules/fekit/node_modules',\n                  '/usr/local/lib/node_modules',\n                  '/usr/local/node_modules',\n                  '/usr/node_modules',\n                  '/node_modules'\n                  ]\n            },\n            filename: '/usr/local/lib/node_modules/fekit/lib/commands/msg.js',\n            loaded: true,\n            children: [],\n            paths:[\n             '/usr/local/lib/node_modules/fekit/lib/commands/node_modules',\n             '/usr/local/lib/node_modules/fekit/lib/node_modules',\n             '/usr/local/lib/node_modules/fekit/node_modules',\n             '/usr/local/lib/node_modules',\n             '/usr/local/node_modules',\n             '/usr/node_modules',\n             '/node_modules'\n             ]\n        }\n\n# 开始大干一场吧\n\n通过判断 options 里面是否有 p 和 u 来判断是否打包，读 option 得 cwd 判断项目根目录，这样就能读取\nfekit.config 了，将 fekit.config 里面的每个 js 插一段脚本，在 u 里面将这段脚本删除，大功告成。\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2015/12/25/esprima-js.md","slug":"2015/12/25/esprima-js","body":"\n# esprima 分析 js 代码\n\n```javascript\nvar fs = require(\"fs\"),\n  esprima = require(\"esprima\"),\n  estraverse = require(\"estraverse\"),\n  escodegen = require(\"escodegen\"),\n  escope = require(\"escope\");\n\nvar funcStats = {},\n  API = [\"tag\", \"tag2\", \"mount\", \"update\", \"Tag\", \"observable\", \"Router\"];\n\nfunction addStats(name) {\n  if (!funcStats[name]) {\n    funcStats[name] = { calls: [], declarations: [], func: \"\", calling: [] };\n  }\n}\n\nvar a = {};\n\nfunction analyze(code) {\n  var ast = esprima.parse(code);\n  // var scopeMan = escope.analyze(ast);\n\n  estraverse.traverse(ast, {\n    enter: function(node, parent) {\n      if (node.type === \"FunctionDeclaration\") {\n        var name = node.id.name;\n        addStats(name);\n        funcStats[name].declarations.push(node);\n        funcStats[name].func = escodegen.generate(node);\n        recurBody(node);\n\n        function recurBody(node) {\n          if (node.body) {\n            node.body.body &&\n              node.body.body.forEach(function(n) {\n                recurBody(n);\n              });\n            if (node.type === \"WhileStatement\") {\n              node.test && recurBody(node.test);\n            }\n          } else {\n            switch (node.type) {\n              case \"CallExpression\":\n                var _name = \"\",\n                  calling = funcStats[name].calling,\n                  count = 0;\n                if (node.callee.type === \"Identifier\") {\n                  _name = node.callee.name;\n                } else if (node.callee.type === \"MemberExpression\") {\n                  _name = node.callee.property.name;\n                }\n\n                calling.forEach(function(call) {\n                  if (call === _name) {\n                    count++;\n                  }\n                });\n\n                if (count === 0) {\n                  calling.push(_name);\n                }\n\n                node.arguments.forEach(function(n) {\n                  recurBody(n);\n                });\n                break;\n              case \"IfStatement\":\n                node.test && recurBody(node.test);\n                node.consequent && recurBody(node.consequent);\n                node.alternate && recurBody(node.alternate);\n                break;\n              case \"LogicalExpression\":\n                node.left && recurBody(node.left);\n                node.right && recurBody(node.right);\n                break;\n              case \"UnaryExpression\":\n                node.argument && recurBody(node.argument);\n                break;\n              case \"AssignmentExpression\":\n                node.right && recurBody(node.right);\n                break;\n              case \"VariableDeclaration\":\n                node.declarations.forEach(function(n) {\n                  recurBody(n);\n                });\n                break;\n              case \"VariableDeclarator\":\n                node.init && recurBody(node.init);\n                break;\n              case \"ExpressionStatement\":\n                node.expression && recurBody(node.expression);\n                break;\n              case \"ReturnStatement\":\n                node.argument && recurBody(node.argument);\n                break;\n            }\n          }\n        }\n      } else if (\n        node.type === \"CallExpression\" &&\n        node.callee.type === \"Identifier\"\n      ) {\n        addStats(node.callee.name);\n        funcStats[node.callee.name].calls.push(parent);\n      } else if (\n        node.type === \"CallExpression\" &&\n        node.callee.type === \"MemberExpression\"\n      ) {\n        addStats(node.callee.property.name);\n        funcStats[node.callee.property.name].calls.push(parent);\n      }\n    },\n  });\n\n  var data = {},\n    statistic = {\n      count: 0,\n      nodes: [],\n      links: [],\n    },\n    list = [];\n\n  Object.keys(funcStats).forEach(function(key) {\n    statistic.count++;\n    data[key] = {\n      calls: funcStats[key].calls.length,\n      declarations: funcStats[key].declarations.length,\n      func: funcStats[key].func,\n      calling: [],\n      weight: 0,\n      category: 0, //0=>normal 1=>API\n    };\n\n    API.forEach(function(a) {\n      if (a === key) {\n        data[key].category = 1;\n      }\n    });\n\n    funcStats[key].calling.forEach(function(c) {\n      funcStats[c] && data[key].calling.push(c);\n    });\n\n    data[key].weight = data[key].calling.length;\n\n    statistic.nodes.push({\n      category: data[key].category,\n      value: data[key].weight,\n      name: key,\n    });\n  });\n\n  statistic.nodes.forEach(function(node, source) {\n    data[node.name].calling.forEach(function(call) {\n      statistic.nodes.forEach(function(n, t) {\n        if (n.name === call) {\n          statistic.links.push({\n            source: source,\n            target: t + 1,\n            weight: 1,\n          });\n        }\n      });\n    });\n  });\n  Object.keys(funcStats).forEach(function(key) {\n    var d = data[key],\n      w = d.weight;\n    d.name = key;\n    if (list.length) {\n      var inserted = 0;\n      list.forEach(function(item, index) {\n        if (inserted) return;\n        if (item.weight < w) {\n          list = list.slice(0, index).concat([d], list.slice(index));\n          inserted++;\n        }\n      });\n    } else {\n      list.push(d);\n    }\n  });\n  fs.writeFileSync(\"ast.json\", JSON.stringify(list));\n}\n\nif (process.argv.length < 3) {\n  throw new Error(\"Usage: index.js file.js\");\n}\n\nvar filename = process.argv[2];\nconsole.log(\"[READ]\\t\" + filename);\nvar code = fs.readFileSync(filename);\nanalyze(code);\nconsole.log(\"[DONE]\");\n```\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2016/01/20/webpack-riot-loader.md","slug":"2016/01/20/webpack-riot-loader","body":"\n# webpack 里面使用 riot-loader\n\n```javascript\nvar webpack = require(\"webpack\");\nvar HtmlWebpackPlugin = require(\"html-webpack-plugin\");\nvar plugins = [\n  new webpack.ProvidePlugin({\n    riot: \"riot\",\n  }),\n  new webpack.HotModuleReplacementPlugin(),\n  new HtmlWebpackPlugin(),\n];\n\nmodule.exports = {\n  entry: \"./src/app\",\n  output: {\n    path: __dirname + \"/prd\",\n    filename: \"app.js\",\n  },\n  plugins: plugins,\n  module: {\n    preLoaders: [\n      {\n        test: /\\.tag$/,\n        loader: \"riotjs-loader\",\n        exclude: /node_modules/,\n        query: { type: \"none\" },\n      },\n    ],\n    loaders: [\n      {\n        test: /\\.js|\\.tag|\\.es6$/,\n        loader: \"babel-loader\",\n        exclude: /node_modules/,\n        query: {\n          presets: [\"es2015\"],\n        },\n      },\n      {\n        test: /\\.scss$/,\n        loaders: [\"style\", \"css?sourceMap\", \"sass?sourceMap\"],\n      },\n    ],\n  },\n  resolve: {\n    alias: {\n      yo: __dirname + \"/bower_components/Yo\",\n      zepto: __dirname + \"/bower_components/zepto/zepto.js\",\n      qrcode:\n        __dirname + \"/bower_components/qrcode/dist/arale-qrcode/3.0.5/index.js\",\n    },\n  },\n  devtool: \"source-map\",\n  devServer: {\n    contentBase: \"./prd\",\n    historyApiFallback: true,\n    hot: true,\n    inline: true,\n    progress: true,\n  },\n};\n```\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2016/01/22/jshint.md","slug":"2016/01/22/jshint","body":"\n# jshint 配置笔记\n\n```javascript\n{\n  \"undef\": true,\n  \"unused\": true,\n  \"curly\": true,\n  \"freeze\": true,\n  \"funcscope\": true,\n  \"nocomma\": true,\n  \"notypeof\": true,\n  \"shadow\": true,\n  \"debug\": true,\n  \"indent\": true,\n  \"predef\": [\n      \"require\",\n      \"document\",\n      \"window\",\n      \"QApp\",\n      \"module\",\n      \"setTimeout\",\n      \"setInterval\",\n      \"encodeURI\",\n      \"encodeURIComponent\"\n   ]\n}\n\n```\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2016/01/25/Fekit-es6-riot-tag.md","slug":"2016/01/25/fekit-es6-riot-tag","body":"\n# Fekit 支持 es6 和 riot 的 tag\n\n在如下目录里面添加 tag.js 和 es6.js\n\n```shell\n/usr/local/lib/node_modules/fekit/lib/compiler/plugins\n```\n\n```javascript\n// tag.js\n(function() {\n  var compiler = require(\"riot-compiler\");\n\n  exports.contentType = \"javascript\";\n\n  exports.process = function(txt, path, module, cb) {\n    try {\n      var prefix = 'var riot = require(\"riot\");\\n';\n      return cb(null, prefix + compiler.compile(txt));\n    } catch (err) {\n      return cb(err);\n    }\n  };\n})();\n```\n\n```javascript\n// es6.js\n(function() {\n  var babel;\n\n  babel = require(\"babel-core\");\n\n  exports.contentType = \"javascript\";\n\n  exports.process = function(txt, path, module, cb) {\n    try {\n      return cb(\n        null,\n        babel.transform(txt, {\n          presets: [\"es2015\"],\n        }).code\n      );\n    } catch (err) {\n      return cb(err);\n    }\n  };\n}.call(this));\n```\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2016/01/25/chrome.md","slug":"2016/01/25/chrome","body":"\n# chrome 插件开发笔记\n\n> [360 真是一个良心企业，这样不用翻墙就能看 API 了](http://open.chrome.360.cn/extension_dev/overview.html)\n\n# manifest.json\n\n```javascript\n{\n    \"name\": \"qunar schema qrcode\",\n    \"manifest_version\": 2,\n    \"version\": \"0.0.1\",\n    \"description\": \"generates qrcode\",\n    \"background\": {\n        \"scripts\": [\n            \"background.js\"\n        ]\n    },\n    \"page_action\": {\n        \"default_icon\": \"icon.png\",\n        \"default_title\": \"QunarQRCode\",\n        \"default_popup\": \"index.html\"\n    },\n    \"permissions\": [\n        \"http://*/\",\n        \"https://*/\",\n        \"tabs\"\n    ],\n    \"content_security_policy\": \"script-src 'self' 'unsafe-eval'; object-src 'self'\"\n}\n```\n\n# background.js 判断 url 并添加 page action\n\n```javascript\nfunction getDomainFromUrl(url) {\n  var a = document.createElement(\"a\");\n  a.href = url;\n  var o = a.origin;\n  setTimeout(function() {\n    a.remove();\n  }, 100);\n  return o.replace(a.protocol + \"//\", \"\");\n}\n\nfunction checkForValidUrl(tabId, changeInfo, tab) {\n  if (\n    getDomainFromUrl(tab.url)\n      .toLowerCase()\n      .indexOf(\"qunar\") > -1\n  ) {\n    chrome.pageAction.show(tabId);\n  }\n}\n\nchrome.tabs.onUpdated.addListener(checkForValidUrl);\n```\n\n# popup 里面获取本页 url\n\n```javascript\nchrome.tabs.getSelected(null, tab => {\n  callback(tab.url);\n});\n```\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2016/01/26/karma.md","slug":"2016/01/26/karma","body":"\n# 使用 karma 来做单元测试\n\n> 最近一直在搞 riot，想弄一个单测，正好官网提供了 karma 组件，搞起来吧\n\n# 安装\n\n```shell\ncnpm install --save-dev karma-riot\n```\n\n# 配置\n\n```javascript\n// karma.conf.js\nmodule.exports = function(config) {\n  config.set({\n    frameworks: [\"mocha\", \"riot\"],\n    plugins: [\n      \"karma-mocha\",\n      \"karma-mocha-reporter\",\n      \"karma-phantomjs-launcher\",\n      \"karma-riot\",\n    ],\n    files: [\"**/*.tag\", \"test/**/*.js\"],\n    preprocessors: {\n      \"**/*.tag\": [\"riot\"],\n    },\n    browsers: [\"PhantomJS\"],\n    reporters: [\"mocha\"],\n  });\n};\n```\n\n# 运行\n\n```shell\nkarma run\n```\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2016/01/27/commitment.md","slug":"2016/01/27/commitment","body":"\n# 写最正规的 commitment\n\n需要一个工具 Commitizen\n\n```shell\ncnpm install -g commitizen\n```\n\n在工程目录里面使用 angular 的 message 格式\n\n```shell\ncommitizen init cz-conventinl-changelog --save --save-exact\n```\n\n以后写 commit 的时候不用`git commit`改用`git cz`\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2016/03/31/VUE-Riot-React.md","slug":"2016/03/31/vue-riot-react","body":"\n# vue+riot+react 试用报告\n\n# 前言\n\n**_本报告不是针对哪个框架，单独说哪个框架好，撕逼的出门右拐微博谢谢_**\n\n最近迷上了组件化开发，感觉这是一种非常高效率的开发模式（说模式有点不对）。于是我第一时间找到了这仨库来做比较，下面请听我细细道来。\n\n## 本报告拢共扯了这些蛋\n\n- 三个库列表渲染性能比较\n- 三个库的学习曲线(自己体会吧)\n- 三个库静态页面动态渲染行为的方式(呵，这话说得)\n- rollup、postcss、webpack\n- 对 ES2015 使用的建议\n\n![测试结果](http://ww1.sinaimg.cn/large/89d0a2e1gw1f2u8fh7uygj20tv0n4473.jpg)\n\n# 关于项目\n\n## 工具\n\n> 1.分别使用三个库创建一个模拟 native 的无线滚动列表<br/> 2.体验一下三个库的开发效率、文件大小、学习曲线以及最终性能\n\n由于时间问题，这几个项目都没有使用 fekit 开发，并且都用了 ES6 的一部分功能\n\n- riot -> rollup\n- react -> webpack\n- vue -> vue-cli(webpack)\n\n## 组件\n\n三个项目都有基于组件化的思想，所以架构设计相同\n\n- App\n  - Scroller\n    - Card\n    - Card\n    - Card\n    - ...\n\n## 用的 ES2015 功能\n\n- 箭头函数\n- 解构\n- import\n- JSX（算是吧）\n\n## 文件大小\n\n- riot\n  - origin: 93k\n  - uglified: 40k\n  - gzip: 14k\n- react\n  - origin: 689k\n  - uglified: 356k\n  - gzip: 76k\n- vue\n  - origin: null\n  - uglified: 79.8k\n  - gzip: 27k\n\n# 性能分析\n\n1. 渲染一个富文本列表，项目数 n\n\n```javascript\nvar t1 = performance.now();\nself.items = res;\n\nsetTimeout(() => {\n  var t2 = performance.now();\n  console.log(\"[1]渲染节点数：\" + res.length + \"::lastTime:\" + (t2 - t1));\n}, 1);\n```\n\n2. 列表添加内容，项目数 n\n\n```javascript\nvar t3 = performance.now();\nself.items = self.items.concat(res);\nsetTimeout(() => {\n  var t4 = performance.now();\n  console.log(\"[2]增加节点数：\" + res.length + \"::lastTime:\" + (t4 - t3));\n}, 1);\n```\n\n3. 删除部分内容，项目数 n\n\n```javascript\nvar t5 = performance.now();\nself.items = self.items.slice(0, res.length);\nsetTimeout(() => {\n  var t6 = performance.now();\n  console.log(\"[3]部分删除：\" + res.length + \"::lastTime:\" + (t6 - t5));\n}, 1);\n```\n\n4. 列表倒置\n\n```javascript\nvar t7 = performance.now();\nself.items = self.items.reverse();\nsetTimeout(() => {\n  var t8 = performance.now();\n  console.log(\"[4]数组回转：\" + res.length + \"::lastTime:\" + (t8 - t7));\n}, 1);\n```\n\n## n===400\n\n- riot\n  1. 300ms\n  2. 38ms\n  3. 15ms\n  4. 150ms\n- react\n  1. 357ms\n  2. 478ms\n  3. 177ms\n  4. 278ms\n- vue\n  1. 480ms\n  2. 403ms\n  3. 124ms\n  4. 152ms\n\n## n===800\n\n- riot\n  1. 477ms\n  2. 287ms\n  3. 261ms\n  4. 273ms\n- react\n  1. 688ms\n  2. 1167ms\n  3. 531ms\n  4. 625ms\n- vue\n  1. 750ms\n  2. 775ms\n  3. 256ms\n  4. 270ms\n\n## n===1600\n\n- riot\n  1. 917ms\n  2. 776ms\n  3. 546ms\n  4. 641ms\n- react\n  1. 2780ms\n  2. 3109ms\n  3. 1612ms\n  4. 1067ms\n- vue\n  1. 1348ms\n  2. 1533ms\n  3. 1167ms\n  4. 712ms\n\n## n===3200\n\n- riot\n  1. 2268ms\n  2. 1816ms\n  3. 2444ms\n  4. 1474ms\n- react\n  1. 5374ms\n  2. 7411ms\n  3. 4107ms\n  4. 2316ms\n- vue\n  1. 2657ms\n  2. 2868ms\n  3. 3113ms\n  4. 1744ms\n\n# 学习曲线（在组件化方面，自己体会）\n\n## riot\n\n```html\n<parent-component class=\"parent\">\n  <child-component class=\"child\" onclick=\"{click}\"></child-component>\n  <h1>{title}</h1>\n  <script>\n    this.on('mount',()=>{\n        ...\n    });\n    this.click = e=>{\n        this.update({ title: \"clicked\" });\n    };\n  </script>\n  <style scoped>\n    :scope {\n    }\n  </style>\n</parent-component>\n```\n\n## react\n\n```javascript\nReact.createClass({\n    getInitialState(){\n        return { title: \"\" };\n    },\n    click(){\n        this.setState({title: \"clicked\"});\n    },\n    componentDidMount(){\n        ...\n    },\n    render(){\n        return (\n        <div className=\"parent\">\n            <div className=\"child\" onClick={this.click}></div>\n            <h1>{title}</h1>\n        </div>\n        );\n    }\n})\n```\n\n## vue\n\n```html\n<template>\n  <div class=\"parent\">\n    <child class=\"child\" @click=\"click\"></child>\n    <h1>{{title}}</h1>\n  </div>\n</template>\n<script>\n  export default {\n      components: { child },\n      data() { return { title: \"\" } },\n      ready() {\n          ...\n      },\n      methods: {\n          click() {\n              this.title = \"clicked\";\n          }\n      }\n  }\n</script>\n```\n\n# 三个库静态页面动态渲染行为的方式\n\n## 模板渲染(Vue,riot)\n\n两者都是模板渲染，所以你的 html 如果按照它们模板语法来写，渲染起来很简单\n\n## 数据元渲染(react，咦？html 不算数据元)\n\nreact 相当于把渲染的内容转成类似于 json 的数据元，到客户端渲染的时候还需要解析一遍数据元。。。\n说白了，你得用 redux 或者 flux 或者 relay\n\n# rollup、postcss 还是 webpack\n\n> 实际上都是些工具上的事，汗啊，还是哪天说吧\n\n# es2015 该用啥\n\nes2015 编译主要体现在\n\n- 语法糖编译\n- pollyfill\n- modules\n\n### 语法糖编译\n\n- class\n- 解构\n- 箭头符号\n- decorator（争议）\n\n### pollyfill\n\n- Promise\n- generator\n- async/await(7)\n\n### modules\n\n- import\n- export\n\n---\n\n## 个人感觉\n\n- pollyfill 实在太大了，如果能不用就别用\n- 语法糖最好用一下，代码可读性一下提高好多\n- modules 我靠你连这个都不用你还好意思说你用的是 es6，这玩意儿不仅要用还不要转译成 AMD 或者 CMD，就按照 es6 的规范做才对，给 rollup 点个赞。\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2016/08/11/MochiUI.md","slug":"2016/08/11/mochiui","body":"\nhttps://mp.weixin.qq.com/s?__biz=MzI4MzM5ODM1Nw==&mid=2247483658&idx=1&sn=33c68d3f615fab291c57213d1ee9712f&scene=1&srcid=08114XgM7exmkysfZ3vzfcvE&pass_ticket=YH0FqjfQPOhb325pmlOXJmvmdpwmYignZi4BGS8fvn4VZ0TwllTJ6QHqKJsJMAnY#rd\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2016/08/12/MochiUI-Button.md","slug":"2016/08/12/mochiui-button","body":"\n# FRAMEWORK WIDGET-Mochi\n\n## BUTTONS\n\n### DATE:2012/09/26\n\n---\n\n#### 按钮\n\n**_文字内容_**\n\n- 字号 14pt\n- 字体 PreludeWGL\n- 粗体 斜体\n- 颜色 #4b4b4b\n\n**_圆括号_**\n\n- 字号 30pt\n- 字体 PreludeWGL Bold\n- 颜色 #4b4b4b\n\n**_垂直间隔_**\n\n文字在圆括号中间居中。\n圆括号的行高要比文字低 5 点。\n文字的上下间距是 8 像素。\n\n**_水平间隔_**\n\n文字在圆括号中间。\n第一个括号后没有字符间隔，文字后有一个字符间隔。\n两边的间隔为 8 像素。\n\n![](https://mmbiz.qlogo.cn/mmbiz/aEj0pBet08t8XWyBXodZAYbVyVuyq5OktnQEwveBUqRV9ia4MGzZPoTbWNJGOmLick5G0PGBiaOeO16XZwYiavphqQ/0?wx_fmt=png)\n\n---\n\n#### 下拉按钮\n\nlist-arrow.png 8x8 像素。\n相对于按钮垂直居中。\n\n**_点击时_**\n\n圆括号要对应伸缩\n\n![](https://mmbiz.qlogo.cn/mmbiz/aEj0pBet08t8XWyBXodZAYbVyVuyq5OkJ4zUVPUoP6Ill5YBszmkQdv7tNibS4icXf5TS0oMPOZyhjxgWQ20Em5w/0?wx_fmt=png)\n\n---\n\n#### 禁用按钮&警告按钮\n\n![](https://mmbiz.qlogo.cn/mmbiz/aEj0pBet08t8XWyBXodZAYbVyVuyq5OkZRuJblZg1jKe2yRyicn2RxrP26NHQPLNBYyX9udVuMEAzG4O8Qeo8cQ/0?wx_fmt=png)\n\n---\n\n#### 按钮间隔\n\n最小水平间距 2 单元（16 像素）\n\n![](https://mmbiz.qlogo.cn/mmbiz/aEj0pBet08t8XWyBXodZAYbVyVuyq5OkufrzdI7bqOaKIT7tIGNFQ3VibXL6hjIyQxVqTSAmcb527KHDwfV0wyA/0?wx_fmt=png)\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2016/08/17/KarmaTest.md","slug":"2016/08/17/karmatest","body":"\n# 跑一下前端的单元测试\n\n## 什么是单元测试\n\n指对软件中的最小可测试单元进行检查和验证。\n\n<center><img alt=\"举个栗子\" src=\"http://i0.hdslb.com/video/05/050dcbac6717c4e1c99c6f0c0a61c4b9.jpg\"/></center>\n\n**_老代码_**\n\n```javascript\n// getProtocol.js\ngetProtocol: function() {\n    // 这里列举出了所有的scheme，导致缺失了扩展性。\n     var e = [\"scheme1\",\"scheme2\",\"scheme3\"];\n     // 获取userAgent\n     var t = navigator.userAgent;\n     for (var n = 0; n < e.length; n++) {\n         if (t.indexOf(e[n]) !== -1)\n             return e[n].toLowerCase()\n     }\n     return \"http\";\n }\n```\n\n**_新代码_**\n\n```javascript\n// getProtocol.js\ngetProtocol: function() {\n     var e = (function() {\n         var res = navigator.userAgent.toLowerCase().match(/(^|\\s)(scheme[^\\/]+)\\/([\\d\\.]+)/),\n    scheme = res && res[2],\n    version = res && res[3];\n        return [scheme];\n     })();\n     // 获取userAgent\n     var t = navigator.userAgent;\n     for (var n = 0; n < e.length; n++) {\n         if (t.indexOf(e[n]) !== -1)\n             return e[n].toLowerCase()\n     }\n     return \"http\";\n }\n```\n\n这里需要对**_输入(navigator.userAgent)_**\n进行处理来查看函数的\n**_输出(scheme1,scheme2,scheme3,schemeXX,http)_**\n是否发生改变\n\n## 什么工程要单元测试\n\n1. 存在大量调用的工程\n   **_(√)_**\n2. 代码量少的工程（每次修改后自测都能完全覆盖用例）\n   **_(X)_**\n\n> 代码可以加 jshint\n\n```javascript\n// .jshintrc\n{\n  \"undef\": true, \"unused\": true, \"curly\": true, \"freeze\": true, \"funcscope\": true, \"nocomma\": true, \"notypeof\": true, \"shadow\": true, \"debug\": true, \"indent\": true,\n  \"predef\": [\n      \"require\", \"document\", \"window\", \"QApp\", \"module\", \"setTimeout\", \"setInterval\", \"encodeURI\", \"encodeURIComponent\", \"clearTimeout\", \"clearInterval\", \"navigator\", \"describe\", \"beforeEach\", \"it\", \"jasmine\", \"____MODULES\", \"spyOn\", \"expect\"\n   ]\n}\n\n```\n\n## 什么代码可以测试\n\n不是所有代码都可以单元测试，需要测试的代码需要给 runner 留有接口。\n\n但是，因为 js 没有真的对象（多年从事找对象工作的笔者哭晕在厕所），所以大家实现私有函数的方法真是天花乱坠。\n\n可是宝宝要单测的代码都是私有方法啊！！！！！！\n\n<center><img alt=\"哭\" src=\"http://img2.imgtn.bdimg.com/it/u=2304895309,1301584123&fm=21&gp=0.jpg\" /></center>\n\n### case A\n\n```javascript\nvar _utils = function() {\n  /*do something*/\n};\n_utils.prototype.add = function(a, b) {\n  return a + b;\n};\nmodule.exports = _utils;\n```\n\n```javascript\ndescribe(\"utils\", () => {\n  it(\"add\", () => {\n    var a = new (require(\"utils.js\"))();\n    expect(a.add(1, 1)).toBe(2);\n  });\n});\n```\n\n### case B\n\n```javascript\nvar _add = function(a, b) {\n  return a + b;\n};\nmodule.exports = { add: _add };\n```\n\n```javascript\ndescribe(\"utils\", () => {\n  it(\"add\", () => {\n    var a = require(\"utils.js\").add;\n    expect(a.add(1, 1)).toBe(2);\n  });\n});\n```\n\n### case D\n\n```javascript\nvar _add = function(a, b) {\n  return a + b;\n};\nmodule.exports = function() {\n  return _add(1, 1);\n};\n```\n\n只能把用例写到代码里面了。。。\n\n所以当我们写代码的时候要留好单元测试的接口，不管你写的代码多牛逼，\n如果你的代码不可测试，那宝宝就认为你的代码是不可读的。\n\n<center><img alt=\"白眼\" src=\"http://www.people.com.cn/mediafile/pic/20150203/21/15475877261822907269.jpg\" /></center>\n\n## 拿什么测试\n\nfekit 自带测试功能，在 test 文件夹下面执行`fekit test`就可以运行，用例语法遵循 mocha.js，可惜运行时是当前的 node 环境。\n\nangular 的测试 runner 时 karma，可以拿来跑用例，并且可以指定环境，所以使用 karma 跑用例还不错。\n\n那么，用例拿什么写呢？\n\n- QUnit\n- mocha.js\n- jasmine\n- ava\n- tape\n\n实际上 ava 和 tape 是我强推的，可惜这俩 node 环境还不错，到了 browser 还是用老牌的好一点。\n\n## 怎么配置 karma\n\n需要安装的 npm modules 在下面的 devDependencies 里面\n\n```javascript\n{\n \"scripts\": {\n    \"test\": \"karma start\"\n  },\n  \"devDependencies\": {\n    \"bower\": \"^1.7.9\",\n    \"jasmine-core\": \"^2.4.1\",\n    \"karma\": \"^1.1.2\",\n    \"karma-chrome-launcher\": \"^1.0.1\",\n    \"karma-jasmine\": \"^1.0.2\"\n  }\n}\n```\n\n执行\n\n```shell\nnpm i\n```\n\n下面的代码会自动生成 karma 的配置文件\n\n```shell\nkarma init\n```\n\n工程根目录里面会多一个 karma.conf.js 文件\n\n```javascript\n// Karma configuration\n// Generated on Mon Aug 08 2016 17:25:40 GMT+0800 (CST)\n\nmodule.exports = function(config) {\n  config.set({\n    // base path that will be used to resolve all patterns (eg. files, exclude)\n    basePath: \"\",\n\n    // frameworks to use\n    // available frameworks: https://npmjs.org/browse/keyword/karma-adapter\n    frameworks: [\"jasmine\"],\n\n    hostname: \"localhost\",\n\n    // list of files / patterns to load in the browser\n    files: [\n      \"bower_components/jquery/dist/jquery.js\",\n      \"bower_components/jasmine-jquery/lib/jasmine-jquery.js\",\n      \"bower_components/jasmine-ajax/lib/mock-ajax.js\",\n    ],\n\n    // list of files to exclude\n    exclude: [],\n\n    // preprocess matching files before serving them to the browser\n    // available preprocessors: https://npmjs.org/browse/keyword/karma-preprocessor\n    preprocessors: {},\n\n    // test results reporter to use\n    // possible values: 'dots', 'progress'\n    // available reporters: https://npmjs.org/browse/keyword/karma-reporter\n    reporters: [\"progress\"],\n\n    // web server port\n    port: 9876,\n\n    // enable / disable colors in the output (reporters and logs)\n    colors: true,\n\n    // level of logging\n    // possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG\n    logLevel: config.LOG_INFO,\n\n    // enable / disable watching file and executing tests whenever any file changes\n    autoWatch: true,\n\n    // start these browsers\n    // available browser launchers: https://npmjs.org/browse/keyword/karma-launcher\n    browsers: [\"Chrome\", \"Chrome_without_security\"],\n    customLaunchers: {\n      Chrome_without_security: {\n        base: \"Chrome\",\n        flags: [\"--disable-web-security\", \"--args\"],\n      },\n    },\n\n    // Continuous Integration mode\n    // if true, Karma captures browsers, runs the tests and exits\n    singleRun: false,\n\n    // Concurrency level\n    // how many browser should be started simultaneous\n    concurrency: Infinity,\n  });\n};\n```\n\n可以看到 files 里面我又加上了一些文件，那些还不是测试用例，因为要测试一些 dom 以及 ajax 的情况，加了一些代码。\n\n```javascript\n// bower.json\n{\n  \"dependencies\": {\n    \"jquery\": \"^3.1.0\",\n    \"jasmine-ajax\": \"^3.2.0\",\n    \"jasmine-jquery\": \"^2.1.1\"\n  }\n}\n```\n\n## 说说这些 karma 的原理吧\n\n用过 QUnit 和 mocha 的人都知道，如果写测试用例要把 js 和用例放在一个 html 环境下，再引进来 QUnit.js 和 mocha.js 就行了，\n其实 Karma 差不多，只不过把手工的部分换成机器了，这样你不用新建一个 html 文件，发布之前也不需要先删除测试代码了。\n\n## jasmine 的语法\n\n懒得写了，可以看一下下面的文章\n\n> [JavaScript 单元测试框架——Jasmine 入门](http://ued.fanxing.com/javascriptdan-yuan-ce-shi-kuang-jia-jasmine/)<br/> >[jasmine-ajax - Faking Ajax responses in your Jasmine suite.](https://github.com/jasmine/jasmine-ajax/blob/master/README.markdown)<br/> >[jasmine-jquery](https://github.com/velesin/jasmine-jquery/blob/master/README.md)\n\n<center>![举个栗子](http://i0.hdslb.com/video/05/050dcbac6717c4e1c99c6f0c0a61c4b9.jpg)</center>\n\n如果你有一个 Dialog 对象，你想看看它的 show 函数执行后页面是否有类名`.dialog`的 dom 节点。\n\n```JavaScript\ndescribe('Dialog', ()=>{\n    var _d = new Dialog();\n    it('show', ()=>{\n        _d.show();\n        expect($('.dialog')[0]).toBeInDOM();\n    });\n})\n```\n\n再如，Dialog 有一个 sendVcode 函数，执行的时候会发起 Ajax 请求，你要 Mock 一个 Ajax 请求\n\n```JavaScript\ndescribe('Mock AJAX', ()=>{\n    var mock = JSON.stringify({\n        status: 200,\n        data: {\n            message: \"blahblah\"\n        }\n    }),_d = new Dialog(),request;\n\n    beforeEach(()=>{\n        jasmine.Ajax.install();\n        _d.sendVcode();\n        request = jasmine.Ajax.requests.mostRecent();\n        request.respondWith({ status: 200, responseText: mock});\n    });\n\n    it('sendVcode', ()=>{\n        expect(request.url).toBe(\"xxx.htm\");\n        expect(request.method).toBe(\"POST\");\n        expect(request.data()).toEqual({\"source\":\"xxxx\"});\n    });\n});\n```\n\n另外，Dialog 执行 sendVcode 的时候，会执行`Dialog.timer`的 start 函数\n\n```javascript\ndescribe(\"Timer\", () => {\n  var _d = new Dialog();\n\n  beforeEach(() => {\n    spyOn(_d.timer, \"start\");\n    _d.sendVcode();\n  });\n\n  it(\"timer.start\", () => {\n    expect(_d.timer).toHaveBeenCalled();\n  });\n});\n```\n\n如果说要做接口测试\n\n```javascript\ndescribe(\"interface\", () => {\n  var _d = new Dialog(),\n    onSuccess,\n    onFailure;\n\n  beforeEach(() => {\n    jasmine.Ajax.install();\n    (onSuccess = jasmine.createSpy(\"onSuccess\")),\n      (onFailure = jasmine.createSpy(\"onFailure\"));\n    _d.init({\n      success: res => {\n        onSuccess(res);\n      },\n      error: () => {\n        onFailure(res);\n      },\n    });\n    request = jasmine.Ajax.requests.mostRecent();\n  });\n\n  it(\"init\", () => {\n    expect(onSuccess).toHaveBeenCalledWith(\"{xxxx}\");\n  });\n});\n```\n\n说下 Cookie 和 UA 的 hack，用[karma-phantomjs-launcher](https://github.com/karma-runner/karma-phantomjs-launcher/blob/master/README.md)可以改配置\n\n```javascript\ndocument.__defineGetter__(\"cookie\", function() {\n  return \"BlahBlah\";\n});\n\nnavigator.__defineGetter__(\"userAgent\", function() {\n  return \"Schema1\";\n});\n```\n\nCSS 的测试\n\n```javascript\ndescribe(\"addStyle:\", function() {\n  it(\"body{background:red;}\", function() {\n    main.addStyle(\"body{background:red;}\");\n    expect(window.getComputedStyle(document.body).backgroundColor).toEqual(\n      \"rgb(255, 0, 0)\"\n    );\n  });\n});\n```\n\n最后说一下，如果 karma 要支持 commonJS 需要加入 preCompiler，如 webpack 或者 browserfy，否则不支持 require。\n好在 fekit 是在 window 下注入\\_\\_\\_\\_MODULES 解决模块化，所以只需要知道模块的 md5 值就好。\n如刚才的 Dialog 的引入\n\n```javascript\nvar Dialog = ____MODULES[\"babf80335465996414cd682baf25de10\"];\n```\n\n## 关于自动生成测试用例\n\n写安卓的时候，AS 会自动生成用例，所以想让 Atom 也支持这一功能，找了一下 plugin，基本上没有。。。<br/>\n如果我写一个的话。。。我得估一下它的必要性。。。\n\n<center><img alt=\"来打我呀\" src=\"http://img2.imgtn.bdimg.com/it/u=3823151670,1751373648&fm=21&gp=0.jpg\" /></center>\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2016/09/06/sonic.js-loading.md","slug":"2016/09/06/sonicjs-loading","body":"\n# sonic.js制作盾牌形状loading\n\n## 如图\n\n<img src=\"http://ww1.sinaimg.cn/thumb300/89d0a2e1jw1f7k2y2x1h7j20qo0qowha.jpg\" style=\"background:#000;\">\n\n---\n\n```javascript\nvar circle = new Sonic({\n\n    width: 50,\n    height: 50,\n    padding: 50,\n    strokeColor: 'white',\n\n    pointDistance: .01,\n    stepsPerFrame: 7,\n    trailLength: .95,\n    fps: 30,\n\n    step: 'fader',\n    fillColor: 'white',\n\n    setup: function() {\n        this._.lineWidth = 3;\n        this._.lineCap = 'round';\n        this._.lineJoin = 'round';\n    },\n\n    path: [\n        ['bezier', 0, 0, 30, -10, 0, 5, 30, -5],\n        ['bezier', 30, -10, 60, 0, 30, -5, 45, 0],\n        ['line', 60, 0, 60, 45],\n        ['bezier', 60, 45, 0, 45, 30, 70, 30, 70],\n        ['line', 0, 45, 0, 0]\n    ]\n\n});\n\ncircle.play();\n```\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2016/10/24/Efficient-your-component-development.md","slug":"2016/10/24/efficient-your-component-development","body":"\n# 高效你的组件化开发\n\n组件化开发算是老生常谈了，最早听说这个理论，我还在大学，写着那些被后端称为模板的东西。所以当时的开发就是写成一堆\\*p（php、jsp 等）片段然后 include 到一起。\n\n## 为什么要做组件化\n\n为什么要做组件化呢？因为它是什么神奇的算法，能提高代码的运行效率？不会，因为组件化会对代码进行封装，封装就会稍稍拖累运行效率。\n那为什么还要组件化呢？\n\n![理想的更新迭代](http://ww4.sinaimg.cn/mw690/89d0a2e1gw1f93dxsw0zyj215n0qvtcf.jpg)\n\n首先，在做软件的时候，我们更希望能最开始制作一套原型，并在后期的迭代中不断地对这一套原型填充。\n但是现实中，我们更有可能遇到某一工程的部分可以在以后的项目中使用，这时就可以把共有的部分封装成组建公用。\n\n![现实中的迭代](http://ww3.sinaimg.cn/mw690/89d0a2e1gw1f93ea4gcqtj219s0js0vz.jpg)\n然后，在设计一个较大的前端项目的时候，我们要对项目进行分拆，定义接口，实现多人协同开发，自然也需要组件化。\n\n最后，如果项目产生了 bug，或者要对项目进行更新，我们可以对其进行局部的更改和回归。就像制造业，如果一辆车爆胎了，\n只需要更换轮胎就好，不必更换整辆车。\n\n## WEB 组件化的昨天今天和明天\n\n那么既然组件化有这么多好处，聪明的程序员们自然早就在使用了\n\n### Web 1.0 时代\n\n![Web1.0时代的组件化](http://ww3.sinaimg.cn/mw690/89d0a2e1gw1f93ea4vx7sj21480nn44a.jpg)\n\n在 Web1.0 的时代，前端的确还只是所谓的模板，CSS 基本上还是 inline，js 也除了基础框架也基本上写在页面里面。那会儿的组件化依靠 web server\n把页面内多个碎片拼装在一起，然后一并传到客户端，当时组件化的特点是：\n\n- 客户端必须通过刷新页面实现和服务端的交互，而页面一旦刷新，页面内的所有组件刷新。\n- 每次刷新，服务端几乎每个组件都要重新计算一下，会拖累性能。\n- HTML 担任组件化的主体，页面基本上由 HTML 碎片组合而成。\n\n### Web 2.0 时代\n\n![Web2.0时代的组件化](http://ww3.sinaimg.cn/mw690/89d0a2e1gw1f93ea5eq1oj21d90rudmu.jpg)\n\nWeb 2.0 因为 AJAX 的出现，用户可以实现不刷新页面与服务端交互。为了不拖累服务端，CSS 和 JS 都各自写在一起，作为静态资源存放在 CDN 上加速。\n这时的 CSS，因为 LESS、SASS 等预编译工具的出现实现了工程文件的组件化。\n而 HTML 因为其结构依然保持着 1.0 时代的组件化，只不过这回是在前端拼接了。\njs 依靠选择器更新页面实现不刷新更新，这时组件化的特点是：\n\n- JS 逐渐替代 HTML，担负起页面组件的拼接工作。\n- HTML、JS 和 CSS 都各自逐渐实现组件化，但三者耦合不多。\n- 有完全放弃 CSS 和 HTML，只用 JS 完成页面的方案，然而可定制性不高。\n\n### SPA 时代\n\n![厉害了我大JS](http://ww2.sinaimg.cn/mw690/89d0a2e1gw1f93ea62d3bj21770jbq65.jpg)\n\n后来，为了应付更复杂的交互，前端出现了很多如 Angular、React 之类的框架，这些框架基本上就是以服务端返回的数据作为 Model，\n用 Cotroller 的处理产生 View 并渲染到页面上。\n\n![SPA时代开始](http://ww1.sinaimg.cn/mw690/89d0a2e1gw1f93ea6msqgj21670oetdw.jpg)\n\n有了这种框架，页面就可以处理更多逻辑，以前后端的路由功能也复制到了前端。\n这时 JS 已经完全接管了组件化的工作，可惜问题是，\n随着页面逻辑的复杂程度，单一 Controller 下要处理的绑定也变多了，\n工程也逐渐复杂难懂。\n\n### Web Components\n\n![Web Components](http://ww4.sinaimg.cn/mw690/89d0a2e1gw1f93ea7hxopj21d80ld11e.jpg)\n\n> 天下大事，分久必合，合久必分。\n\nWeb Components 的出现，一定程度把 HTML、CSS 和 JS 又耦合在一起，\n只不过都有了一个作用域的概念，完整的组件化已经形成，然而这一方案\n还在试验中，变数还有很多。好在现在很多框架都已经相对模仿并实现了这一方案。\n\n## 设计组件的思想\n\n用了能实现组件化思维的框架并不代表已经用组件化开发了，\n还需要一套思想，那么如何设计组件呢？\n\n> 任何一个组件都是一个有限状态机。 ——沃·滋基硕德\n\n![有限状态机](http://ww1.sinaimg.cn/mw690/89d0a2e1gw1f93ea7muo1j20u6054q38.jpg)\n\n组件的状态是有限的，状态转变是因为受到了某一个事件。\n\n![举个例子](http://ww2.sinaimg.cn/mw690/89d0a2e1gw1f93ewntvqsj20ci0a13yp.jpg)\n\n比如一个输入框，初始状态为无光标、值为空。\n\n![输入框](http://ww3.sinaimg.cn/mw690/89d0a2e1gw1f93ea82j7kj20ca02ra9y.jpg)\n\n```javascript\nM.state = {\n  curser: false,\n  value: \"\",\n};\n```\n\n输入框被聚焦之后，显示光标，值为之前的值。\n\n![输入框被聚焦](http://ww1.sinaimg.cn/mw690/89d0a2e1gw1f93ea8dlpbj20ca02r3yf.jpg)\n\n```javascript\nM.state = M.on('focus', ()=>{\n    curser: true,\n    value: M.state.value\n})\n```\n\n输入值之后，每一个字符都触发一次 input 事件。\n\n![输入框被输入值](http://ww2.sinaimg.cn/mw690/89d0a2e1gw1f93ea8qr4pj20ca02rdft.jpg)\n\n```javascript\nM.state = M.on('input', (c)=>{\n    curser: true,\n    value: M.state.value + c\n})\n```\n\n![输入框状态变化图](http://ww1.sinaimg.cn/mw690/89d0a2e1gw1f93ea929zzj20x50d3dh7.jpg)\n\n由此可以得出，组件的新状态都要由旧状态和受到的事件产生，\n再经过渲染成 View 层展示\n\n![公式](http://ww4.sinaimg.cn/mw690/89d0a2e1gw1f93eaa6y5hj20rb06gjs5.jpg)\n\n## 构造和使用组件\n\n### 原子化你的组件\n\n![一个组件要是什么样的](http://ww4.sinaimg.cn/mw690/89d0a2e1gw1f93ea9et4cj21220ebjsl.jpg)\n\n一个组件应该做成什么样的？是一个页面还是一个弹窗还是什么样子？\n比如下面这个页面，就说输入框吧，每个输入框有三个状态，\n那么整个页面就有了 12 种状态，维护起来真是复杂；\n如果这些输入框用一个迭代器处理，的确就只有三个状态了，\n可是这些迭代的输入框对事件的处理又不同\n（比如手机号要加掩码），又会把每个事件弄复杂了。\n\n![示例页面](http://ww3.sinaimg.cn/mw690/89d0a2e1gw1f93ea9uu5qj20ol0w3dil.jpg)\n\n其实，如果一个组件的状态很多，管理起来也很麻烦，\n莫不如把这个组件拆开，比如一个输入框可以由\n普通输入框混淆掩码实现，则上图输入框的处理可以变成如下\n\n![组件化后](http://ww1.sinaimg.cn/mw690/89d0a2e1gw1f93eaavbbkj21gi0vyn28.jpg)\n\n### 组件怎样交互\n\n通过原子化组件能够很好解决复杂的状态管理，\n但是需要组件间进行交互。\n\n其实很简单，页面和用户交互是监控人的事件，\n和后端交互是监控 XMLHttpRequest 的事件，\n那么组件间的交互自然是监控组件的事件，\n而组件内部交互是监控自己的事件。\n\n![组件交互](http://ww1.sinaimg.cn/mw690/89d0a2e1gw1f93eix7uspj20rb0gsjtg.jpg)\n\n比如下图的输入框，输入框可以找到清除按钮并监控其点击事件来\n判断自己是否需要清空，按钮监控输入框的输入事件来判断自己是否可点。\n\nhttp://ww1.sinaimg.cn/mw690/89d0a2e1gw1f93eix7uspj20rb0gsjtg.jpg\n![又是输入框](http://ww3.sinaimg.cn/mw690/89d0a2e1gw1f93eabffgxj219x0he0yg.jpg)\n这样组件化的又一难题就解决了。\n\n## 写在最后\n\nweb 前端的组件化还在一个发展中的状态，\n本文对组件化的想法可以刚好适应移动端页面的需求。\n技术在日新月异地发展中，\n也许今天看似高效的做法明天就不是了，\n写本文为的是能够分享一下我的想法，希望能够给人一定启发。\n\n## 参考\n\n[Web 应用的组件化开发（一）——基本思路](http://www.ituring.com.cn/article/63549)\n\n[The Sam Pattern](http://sam.js.org)\n\n[Shadow DOM 201](https://www.html5rocks.com/en/tutorials/webcomponents/shadowdom-201/)\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/05/02/Qxf-Qconfig.md","slug":"2017/05/02/qxf-qconfig","body":"# 结合Qxf和Qconfig解决前端热发布\n\n或许篇文章写得有些晚了，如果这篇文章是写koa的话，估计受欢迎程度会很高。\n\n最近正巧有一个前后同构的项目，其实是利用node作渲染层。至于为什么用node作渲染层就不做详述了，节约后端资源，释放前端约束，可能方案并不是通用的，正好我的项目需要。\n\n## Qxf 介绍\n\nQxf是基于express的node服务方案，也就是说很多express的API可以直接使用。确切说并不完全是这样，response.write就被改写了，但并不影响使用。\n\n其实Qxf的出现是给node做了一层兼容于原有去哪儿前后端分离模式的node后端。同时为开发者做了一层脚手架封装，集成包括cluster、logger、handlebars等开源的中间件以及去哪儿私有的异常处理、日志处理、埋点统计以及静态资源版本号的管理中间件。\n\n## QConfig\n\nQConfig是去哪儿内部解决后端热发的方案，简单地说它会依照版本存储```*.properties```或者```*.json```文件，并按需将这些配置文件推送到各个机器，推送之后也可以回滚。\n\n## 解决的问题\n\n前端有很多需求是文案修改、图标修改，相对来说算是比较安全，但每次修改的时候还要测试回归上线，这样流程拖得太长，如果前端也可以利用QConfig实现热发，那自然是很受欢迎的。\n\n## Qxf怎么用\n\n针对Qxf怎么去创建一个工程在此就不多余介绍了，讲一下工作原理吧。\n\n    qxf dev\n\n这个命令会启动Qxf的测试环境，其实就是执行了以下代码\n\n    NODE_ENV=development node ./bin/start.js --l .logs\n\n也就是说，包括server的启动配置都写在这里面了。整个服务都会在```multiprocess.listen(app, opts)```之后执行（注意一个坑点，multiprocess没有暴露server对象，所以用不了reload.js，开发的时候只能手动刷新页面了）。\n\n## QConfig怎么用\n\n讲完Qxf说说QConfig，按照qConfig的文档在Qxf的config.js里面配置好要取的配置，QConfig要在Qxf启动之前执行，也就是还要修改start.js里面的\n\n    multiprocess.listen(app, opts);\n\n为\n\n    qConfigClient.init().then(()=> multiprocess.listen(app, opts));\n\n之后如果需要获取某一个属性文件，则需要执行\n\n    const configs = qConfigClient.getConfig('*.json');\n    const value = configs.get('key');\n\n如果你的配置是json的，获取到的值会直接parse成对象。\n\n***需要注意一点,Qconfig是异步的，也就是说getConfig的执行必须放到某个可抵达的回调里面***\n\n## 结束\n\n执行一下```qxf dev```，服务器访问```localhost:3000```到对应的router下面就可以看到效果了。\n\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/05/03/QxfComponents.md","slug":"2017/05/03/qxfcomponents","body":"# 写啥题目呢\n\n## 回顾一下\n\n去年三月，我分享了一个用riotjs开发前端的方案，既然已经有一年的时间了，就先回顾一下。\n\n这套方案出自2015年，之前一直使用的是公司的QApp解决方案，后来发现使用上存在问题，\n并在试图寻找一套可行的替代方案。\n\n### 组件化方案\n\nQApp的最小单位是View(大概可以理解为页面)，\nView里面大到一个轮播图小到一个按钮的操作逻辑都和view耦合，\n假设我想使用某一个View里面的某一个组件，想直接拆出来是不太可能的。\n\n* 以前的写法\n\n        QApp.defineView({\n            html: `\n            <div node-type=\"vcode\">\n                <input action-type=\"input\">\n                <button action-type=\"vcode\">发送短信</button>\n            </div>\n            <button action-type=\"submit\">提交</button>\n           `\n            actions: {\n                // 这里的this指向整个view\n                \"input:input\": () => this.doInput(),\n                \"submit\": () => this.doSubmit(),\n                \"vcode\": () => this.doVcode(),\n            },\n            init: {\n                doInput() {},\n                doSubmit() {},\n                doVcode() {},\n            }\n        });\n        QApp.config({...});\n\n* 新的写法\n\n        riot.tag('pay-input',`\n            <input oninput=\"oninput\">\n        `, ()=> {\n            // 这里的this指向整个pay-input\n        });\n        riot.tag('pay-submit', `\n            <submit ontap=\"onsubmit\">\n                <yield/>\n            </submit>\n        `, ()=> {\n            // 这里的this指向整个pay-submit\n        });\n        riot.tag('pay-vcode', `\n            <pay-input></pay-input>\n            <pay-submit>发送短信</pay-submit>\n        `, ()=> {\n            // 这里的this指向整个pay-vcode\n        });\n        riot.tag('pay-view',`\n            <pay-vcode></pay-vcode>\n            <pay-submit>提交</pay-submit>\n        `, ()=>{\n            // 这里的this指向整个pay-view\n        });\n        riot.mount('pay-view');\n\n### 基于发布订阅的统一事件管理模式\n\n有很多时候，我们要处以理一些“这些东西，我们不要了”之类的需求，\n当我们回头去翻代码的时候，惊奇的发现它被封装了，\n那么后面的故事就是要和“xxx function is undefined”做长期斗争了。\n\n* 之前的调用方式\n\n        QApp.defineView({\n            init: {\n                doSomething: ()=> {}// 删我貌似很困难\n                doSomethingElse: ()=>this.doSomething()\n            },\n            ready() {\n                this.doSomething();\n            }\n        });\n\n* 之后的调用方式\n\n        riot.tag('pay-view',`...`, ()=>{\n            this.on('doSomething', ()=> doSomething()); // 不要就删掉吧\n\n            this.doSomethingElse = () => this.trigger('doSomething');\n            this.on('mount', () => {\n                this.trigger('doSomething')\n            });\n        });\n\n### 基于状态基的异步流程处理\n\n其实2015年，是异步流程处理比较混乱的一年，Promise刚出来，没多少人敢用，\n更别提generator还有async之类的东西了，\n这套方案正好利用了发布订阅的优点，\n只要在异步事件触发之前订阅上就没问题了\n\n* 之前\n\n        QApp.defineView({\n            ...,\n            ready() {\n                this.ajax({\n                    ...,\n                    success() {\n                        foo(..., () => {\n                            bar( ..., () => {\n                                ...\n                            });\n                        })\n                    }\n                });\n            }\n        });\n\n* 之后\n\n        riot.tag('pay-view', '...', () => {\n            this.on('ajaxDone', () => {\n                ...\n                this.trigger('foo');\n            });\n\n            this.on('fooDone', () => {\n               ...\n               this.trigger('bar');\n            });\n\n            this.on('barDone', () => {\n               ...\n            });\n\n            this.on('mount', () => this.trigger('ajax'));\n        });\n\n### 利用组件树检索组件\n\n项目组件化（Component）+ 事件化（Reactive）之后，\n一个页面的运行方式就成为某一个组件监控某一个组件的某一事件并对其造成的处理。\n那么需要利用祖组件树解决一下检索问题。\n\n    require(\"pay-input\");\n    require(\"pay-submit\");\n\n    riot.tag('pay-vcode', `\n        <pay-input></pay-input>\n        <pay-submit>发送短信</pay-submit>\n    `, ()=> this.tags[\"pay-submit\"].on('subimit', () => {\n        this.trigger('vcodeSent');\n    }) );\n\n    riot.tag('pay-view', `\n        <pay-vcode></pay-vcode>\n        <pay-submit></pay-submit>\n    `, () => this.tags['pay-vcode'].on('vcodeSent', ()=> {\n        this.tags['pay-submit'].trigger('enabled');\n    }));\n\n\n* pay-view\n  * parent: null\n  * tags\n    * pay-vcode\n      * parent: pay-view\n      * tags\n        * pay-input\n        * pay-submit\n        * parent: pay-vcode\n      * pay-submit\n        * parent: pay-view\n\n\n### 利用mixin实现继承\n\necmascript2015之前，js一直都没有一个像样的类的表达方式，\n所以我们其实也没有一个像样的继承方式，\n混淆是目前用的最多的一种继承，大概是源自$.extend吧。\n\n* ajaxApi1\n\n        module.exports = {\n            init: {\n                this.on('ajaxApi1', () => ajax(...) );\n                this.on('ajaxApi1Done', ()　=> ... );\n            }\n        };\n\n* ajaxApi2\n\n        module.exports = {\n            init: {\n                this.on('ajaxApi2', () => ajax(...) );\n                this.on('ajaxApi2Done', () => ... );\n            }\n        };\n\n* pay-view\n\n        riot.tag('pay-view', '...', () => {\n            this.mixin(require('ajaxApi1.js'));\n            this.mixin(require('ajaxApi2.js'));\n\n            this.on('mount', () => this.trigger('ajaxApi1 ajaxApi2') );\n        });\n\n### 结合velocity和yield实现首屏渲染\n\n首屏渲染，SPA一直有这个问题。\n因为在html加载到js加载完成（甚至是一些ajax返回）之前，\n页面都是白屏，其实vm可以完成一部分后端的渲染，并替代第一个ajax。\n\n* vm之中\n\n        #set($description = \"这里会代替<yield/>\")\n        <pay-view>\n            <span if=\"$!description\">$description</span>\n        </pay-view>\n        <script>\n            window.vmData = \"$!vmData\";\n        </script>\n\n* js里面\n\n        riot.tag('pay-view', `\n            <pay-vcode></pay-vcode>\n            <pay-submit></pay-submit>\n            <yield/>\n        `, () => {\n            const vmData = window.vmData;\n        });\n\n### SPA的路由（这部分本文不涉及，忽略）\n\n## 希望优化的点\n\n### 发布订阅解决函数调用问题是存在缺陷的\n\n这套方案会产生冗余代码，其实最好使用typescript编写代码，\n这样在编译环境下就能查出哪个函数调用了删除的方法。\n\n* util.ts\n\n            export const a = {\n                    // foo() { 假设我删除了foo }\n                    ...\n            };\n\n* xxx.ts\n\n            import { a } from \"util\"\n\n            class xxx {\n                constructor() {\n                    a.foo(); // 编译时会报错foo这个方法不存在，终止编译\n                }\n            }\n\n### 使用面向对象的语法\n\n* html\n\n        <body>\n            <pay-view></pay-view>\n        </body>\n\n* ES5\n\n        require(\"pay-input\");\n        require(\"pay-submit\");\n        require(\"pay-vcode);\n\n        riot.tag(\"pay-view\", '<span>{ title }</span><pay-vcode></pay-vcode><pay-submit>提交</pay-submit>', function(opts) {\n            this.title = opts.title;\n        });\n\n        riot.mount(\"pay-view\", {});\n\n* TypeScript\n\n        import {PaySubmit} from \"pay-submit\";\n        import {PayVcode} from \"pay-vcode\";\n\n        @tag({\n            name: \"pay-view\",\n            tmpl: `\n            <span>{ title }</span>\n            <pay-vcode></pay-vcode>\n            <pay-submit>提交</pay-submit>\n            `\n        })\n        class PayView extends TagCore {\n            onCreate(tag) {\n                tag.title = opts.title;\n            }\n            constructor() {\n                this.submit = new PaySubmit();\n                this.vcode = new PayVcode();\n            }\n            submit: PaySubmit;\n            vcode: PayVcode;\n        }\n\n        PayView.mount({});\n\n### 利用发布订阅模式控制流程并不是最好的流程控制\n\n目前来说原生的Promise支持已经很不错了，\nasync虽然是个实验特性，\n但发明C#的微软明显推荐用这个特性。\n\n* 发布订阅\n\n        riot.tag('pay-view', '...', () => {\n            this.on('fooDone', ()=> this.bar());\n            this.on('barDone', ()=> this.blah());\n            this.bar = () => {\n                ...\n                this.trigger('barDone');\n            };\n            this.blah = () => xxx;\n            this.on('mount', () => this.trigger('fooDone'));\n        });\n\n* Promise\n\n        @tag({\n            name: \"pay-view\",\n            tmpl: \"...\",\n        });\n        class PayView extends TagCore {\n            onCreate(tag, opts) {\n                tag.on('mount', () => this.foo.then(()=> {\n                    return this.bar()\n                }).then(()=> {\n                    this.blah();\n                }));\n            }\n            foo = ()=> new Promise(resolve => resolve());\n            bar = ()=> new Promise (resolve => resolve())\n            blah = () => {...}\n            ...\n        }\n\n* async & await\n\n        @tag({\n            name: \"pay-view\",\n            tmpl: \"...\",\n        });\n        class PayView extends TagCore {\n            onCreate(tag, opts) {\n                tag.on('mount', async () => {\n                    await this.foo();\n                    await this.bar();\n                    this.blah();\n                });\n            }\n            foo = ()=> new Promise(resolve => resolve());\n            bar = ()=> new Promise (resolve => resolve())\n            blah = () => {...}\n            ...\n        }\n\n### 没有完善的广播机制\n\n其实之前的方案是可以广播的，但需要选中需要的组件，如\n\n    [tagA,tagB,tagC].forEach(tag => tag.trigger('foobar'));\n\n但是我希望的广播是每一个页面里面的tag无需选中就可以接收到。\n其实在每个tag加载之后都会传进一个opts对象，\n这个对象或者是执行mount函数传入的值，或者是模板标签上的变量\n\n    XXX.mount({ aaa: 1 });\n    // opts == {aaa: 1}\n\n    <xxx aaa=1 ></xxx>\n    // opts == {aaa：１}\n\n所以只要把一个obersable的对象传到opts里面就行了.\n\n### 需要一个更好的mixin\n\ntypescript对mixin支持很好，\n配合vscode的输入提醒代码体验十分完美，\n所以几乎可以放弃riot的mixin了\n\n* riot.mixin\n\n        // ajaxApi.js\n        {\n            init() {\n                this.on('ajaxApi', ()=> ...);\n            }\n        }\n        // xxxtag\n        riot.tag('xxx', '...', ()=> {\n            this.mixin(require('ajaxApi.js'));\n            this.trigger(\"ajaxApi\");\n        });\n\n* @mixin(any[])\n\n        class AjaxApi {\n            ajaxApi() {\n                ...\n            }\n        }\n\n        @tag({ name: \"xxx\", tmpl: \"...\" });\n        @mixin([AjaxApi])\n        class XxxTag extends TagCore implement AjaxApi {\n            onCreate( tag, opts ) {\n                this.ajaxApi();\n            }\n            ajaxApi: () => void;\n        }\n\n### velocity模板语法太次了\n\n改用node渲染，Qxf使用的是handlebars，riot自身也支持后端渲染。\n\n## 介绍点儿常识\n\n### typescript的语法\n\n#### 类型化声明\n\n        const a:string = \"这是一个不可变的字符串\";\n        let b:string; // b只能赋字符串\n        let c:any; // c可以赋任一值\n        let d: () => void; // d只能赋空参数且返回为空的函数\n\n#### class语法糖\n\n        class a extends b {\n            constructor() {\n                super();//执行b的构造函数\n            }\n            public foo() {\n                super.foo();//执行b的原型上的foo函数\n                console.log(`\n                    我在ａ的prototype上\n                    this指向context\n                `);\n            }\n            public bar =　() => {\n                cosnole.log(`\n                    我在a的实例里,\n                    this指向a的实例\n                `)\n            }\n            public blaha = function() {\n                cosnole.log(`\n                    tslint默认禁止使用\n                    我在a的实例里,\n                    this指向context\n                `)\n            }\n        }\n\n#### async await 上面提过了\n\n#### Object解构\n\n        const obj = { a: 1 };\n        const name = \"name\";\n        const data = { ...obj, b: 2, name }; // { a: 1, b : 2, name: \"name\" }\n        const { a:xxx } = obj; // xxx===1\n        const data1 = {[xxx]: 'data1'}; // {1: 'data1'}\n\n#### 接口\n\n        interface Ia { foo: () => void; }\n        interface Ib { bar: () => string; }\n        interface Ic { name: string; }\n        class D { doSomeThing() { .... } }\n        class E implements Ia,Ib,D {\n            doSomeThing: () => any;// 如果实现的是类内元素，可以只声明，不实现\n            foo = () => {...} // 如果实现的是接口内元素，必须按照类型定义\n            bar = () => {...} // 必须把要实现的所有接口内的元素声明\n            constructor(param: Ic) {\n                const { name } = param;// param 必须是只含有name的对象\n            }\n        }\n\n### 装饰器\n\n就是前面类似于@tag,@mixin的东西，\n这个有点复杂，只说在class前面的装饰器吧,\n是用来处理对象原型的函数，\n会在构造函数执行结束后执行\n\n### Qxf router的使用(其实是express4 router的使用)\n\n#### 三种获取请求参数的方式\n\n假设一个接口是 'api/default/index?a=1'\n\n        router.param('solution', (req, res, next, value) => {\n            console.log(value); => 'default'\n            next();\n        })\n\n        router.get('api/:solution/:page', (req, res, next) => {\n            console.log(req.params) => { solution: 'default', page: 'index' }\n            console.log(req.query.a) => 1\n\n            res.write('111');// 返回111但是请求并不结束\n            res.end();　// 返回结束\n        });\n\n        router.post('api/:solution/:page', (req, res, next) => {\n            console.log(req.params) => { solution: 'default', page: 'index' }\n            console.log(req.body.a) => 1\n            res.json({aaa: 1}); //　返回　{aaa: 1}\n        });\n\n#### 中间件\n\n        router.use(`api`, (req, res, next) => {\n            req.xxx = 'xxx';\n            next();\n        });\n\n### 核心的几个类和接口\n\n#### 状态机存储器：　Store\n\n```new Store()```可以订阅```on```或者触发```trigger```几种事件，\n没错```riot.tag```函数里面的```this```就继承自```Store```;\n\n    const a = new Store();\n    a.on('sayHi', () => console.log('hello'));\n    a.trigger('sayHi'); // hello\n\n#### 广播控制器：　Control\n\n是一个状态机的集合，方法```addStore```可以添加状态机存储器，\n```trigger```可以广播触发存储器的事件。\n\n    const store1 = new Store();\n    store1.on('sayHi', () => console.log('hello,I'm store1'));\n    const store2 = new Store();\n    store2.on('sayHi', () => console.log('hello,I'm store2'));\n    const ctrl = new Control();\n    ctrl.addStore(store1);\n    ctrl.addStore(store2);\n    ctrl.trigger('sayHi');//hello,I'm store1hello,I'm store2\n\n#### 标签生成器：TagCore虚基类\n\n必须搭配@tag装饰器，```new```一个TagCore的子类（构造函数必须传一个Control），\n跟执行了一下```riot.tag```是一样的。\n执行```mount```方法就能在页面空标签里挂在上标签的实现，相当于执行了```riot.mount```。\n\n    @tag({\n        name: 'x-tag',\n        tmpl: `<span>{content}</span>`\n    })\n    class XTag extends TagCore {\n        onCreate(tag: IriotTag, opts: IriotOpts) {\n            this.on('mount', () => opts.ctrl.trigger('xTag_Mounted') );\n            tag.content = opts.content;\n        }\n        mount: (opt: { content: string }) => void;\n    }\n\n    const store = new Store();\n    store.on('xTag_Mounted', () => console.log('prodCasted') );\n\n    const ctrl = new Control();\n    ctrl.addStore(store);\n\n    const xTag = new XTag(ctrl);\n    xTag.mount({ content: '我就是content' });\n\n    // 页面里面的<x-tag></x-tag> 变成　<x-tag><span>我就是content</span></x-tag>\n    // 控制台打印出 prodCasted\n\n### node-fetch\n\n一个开源的项目，可以让node端使用fetch，使用方法和whatwg里面的API是一样的，在此就不多嘴了。\n\n### 前后端同构初阶\n\n如果看网上的一些前后端同构的资料，他们会给你如下的方案。\n\n    if (isServer) {\n        doNodeThings();\n    } else {\n        doClientThings();\n    }\n\n我可以告诉你，他们都抄自同一个骗纸。。。\n\n原因是很多前端的modules会操作window对象，\nnode端的module更牛，有一些都是二进制的，\n如果用webpack1的话，如何bundle到一个js里面?\n\n#### TreeShaking\n\n树摇（字面翻译）是个es6对module的定义，\n简单地说js代码编译的时候会解析成AST语法树，\n通过分析这个语法树可以知道某一个js里面的某一个函数是多余的，\n打包的时候就可以把它剔除。","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/05/04/0-riotjs.md","slug":"2017/05/04/0-riotjs","body":"# 回顾一下以前的Riot.js方案\n\n2015年我开始从事前端工作，开始公司正在用QApp作为前端SPA框架，\n可是在我看来QApp比较笨重(130+KB)，另外还需要引入kami做组件(100+KB)，一直想找一个轻一点的框架代替，最后选择了riot.js(76KB)来代替这两个，主要基于以下几个需求。\n\n## 大量组件化的需求\n\nQApp的最小单位是View，也就是单一页面，而我接到的需求，要么是对某个按钮做改动，要么是连做几个页面，里面的某个输入框逻辑相同。QApp中的this指向View使得这些部分既不能从View里解构出来，对部分的修改也会造成挣个View的影响。\n\n* 以前的写法\n\n        QApp.defineView({\n            html: `\n            <div node-type=\"vcode\">\n                <input action-type=\"input\">\n                <button action-type=\"vcode\">发送短信</button>\n            </div>\n            <button action-type=\"submit\">提交</button>\n           `\n            actions: {\n                // 这里的this指向整个view\n                \"input:input\": () => this.doInput(),\n                \"submit\": () => this.doSubmit(),\n                \"vcode\": () => this.doVcode(),\n            },\n            init: {\n                doInput() {},\n                doSubmit() {},\n                doVcode() {},\n            }\n        });\n        QApp.config({...});\n\n* 新的写法\n\n        riot.tag('pay-input',`\n            <input oninput=\"oninput\">\n        `, ()=> {\n            // 这里的this指向整个pay-input\n        });\n        riot.tag('pay-submit', `\n            <submit ontap=\"onsubmit\">\n                <yield/>\n            </submit>\n        `, ()=> {\n            // 这里的this指向整个pay-submit\n        });\n        riot.tag('pay-vcode', `\n            <pay-input></pay-input>\n            <pay-submit>发送短信</pay-submit>\n        `, ()=> {\n            // 这里的this指向整个pay-vcode\n        });\n        riot.tag('pay-view',`\n            <pay-vcode></pay-vcode>\n            <pay-submit>提交</pay-submit>\n        `, ()=>{\n            // 这里的this指向整个pay-view\n        });\n        riot.mount('pay-view');\n\n## XX function is undefined\n\n报错邮件以前经常会有这样的报错，究其原因，很多是由“xxx功能”我不要了这种需求造成。\n\n* 之前的调用方式\n\n        QApp.defineView({\n            init: {\n                doSomething: ()=> {}// 删我貌似很困难\n                doSomethingElse: ()=>this.doSomething()\n            },\n            ready() {\n                this.doSomething();\n            }\n        });\n\n* 之后的调用方式\n\n        riot.tag('pay-view',`...`, ()=>{\n            this.on('doSomething', ()=> doSomething()); // 不要就删掉吧\n\n            this.doSomethingElse = () => this.trigger('doSomething');\n            this.on('mount', () => {\n                this.trigger('doSomething')\n            });\n        });\n\n## 基于状态基的异步流程处理\n\n其实2015年，是异步流程处理比较混乱的一年，Promise刚出来，没多少人敢用，\n更别提generator还有async之类的东西了，\n这套方案正好利用了发布订阅的优点，\n只要在异步事件触发之前订阅上就没问题了\n\n* 之前\n\n        QApp.defineView({\n            ...,\n            ready() {\n                this.ajax({\n                    ...,\n                    success() {\n                        foo(..., () => {\n                            bar( ..., () => {\n                                ...\n                            });\n                        })\n                    }\n                });\n            }\n        });\n\n* 之后\n\n        riot.tag('pay-view', '...', () => {\n            this.on('ajaxDone', () => {\n                ...\n                this.trigger('foo');\n            });\n\n            this.on('fooDone', () => {\n               ...\n               this.trigger('bar');\n            });\n\n            this.on('barDone', () => {\n               ...\n            });\n\n            this.on('mount', () => this.trigger('ajax'));\n        });\n\n## 利用组件树检索组件\n\n项目组件化（Component）+ 事件化（Reactive）之后，\n一个页面的运行方式就成为某一个组件监控某一个组件的某一事件并对其造成的处理。\n那么需要利用祖组件树解决一下检索问题。\n\n    require(\"pay-input\");\n    require(\"pay-submit\");\n\n    riot.tag('pay-vcode', `\n        <pay-input></pay-input>\n        <pay-submit>发送短信</pay-submit>\n    `, ()=> this.tags[\"pay-submit\"].on('subimit', () => {\n        this.trigger('vcodeSent');\n    }) );\n\n    riot.tag('pay-view', `\n        <pay-vcode></pay-vcode>\n        <pay-submit></pay-submit>\n    `, () => this.tags['pay-vcode'].on('vcodeSent', ()=> {\n        this.tags['pay-submit'].trigger('enabled');\n    }));\n\n\n* pay-view\n  * parent: null\n  * tags\n    * pay-vcode\n      * parent: pay-view\n      * tags\n        * pay-input\n        * pay-submit\n        * parent: pay-vcode\n      * pay-submit\n        * parent: pay-view\n\n## 利用mixin实现继承\n\necmascript2015之前，js一直都没有一个像样的类的表达方式，\n所以我们其实也没有一个像样的继承方式，\n混淆是目前用的最多的一种继承，大概是源自$.extend吧。\n\n* ajaxApi1\n\n        module.exports = {\n            init: {\n                this.on('ajaxApi1', () => ajax(...) );\n                this.on('ajaxApi1Done', ()　=> ... );\n            }\n        };\n\n* ajaxApi2\n\n        module.exports = {\n            init: {\n                this.on('ajaxApi2', () => ajax(...) );\n                this.on('ajaxApi2Done', () => ... );\n            }\n        };\n\n* pay-view\n\n        riot.tag('pay-view', '...', () => {\n            this.mixin(require('ajaxApi1.js'));\n            this.mixin(require('ajaxApi2.js'));\n\n            this.on('mount', () => this.trigger('ajaxApi1 ajaxApi2') );\n        });\n\n## 结合velocity和yield实现首屏渲染\n\n首屏渲染，SPA一直有这个问题。\n因为在html加载到js加载完成（甚至是一些ajax返回）之前，\n页面都是白屏，其实vm可以完成一部分后端的渲染，并替代第一个ajax。\n\n* vm之中\n\n        #set($description = \"这里会代替<yield/>\")\n        <pay-view>\n            <span if=\"$!description\">$description</span>\n        </pay-view>\n        <script>\n            window.vmData = \"$!vmData\";\n        </script>\n\n* js里面\n\n        riot.tag('pay-view', `\n            <pay-vcode></pay-vcode>\n            <pay-submit></pay-submit>\n            <yield/>\n        `, () => {\n            const vmData = window.vmData;\n        });\n\n## SPA的路由（忽略）\n\n## 视频地址\n\nhttp://v.youku.com/v_show/id_XMTUxMjMyMzM0OA==.html?from=s1.8-1-1.2&spm=a2h0k.8191407.0.0","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/05/04/1TypeScript.md","slug":"2017/05/04/1typescript","body":"# TypeScript干货\n\n## 类型化声明\n\n        const a:string = \"这是一个不可变的字符串\";\n        let b:string; // b只能赋字符串\n        let c:any; // c可以赋任一值\n        let d: () => void; // d只能赋空参数且返回为空的函数\n\n## 接口\n\n        interface Ia { foo: () => void; }\n        interface Ib { bar: () => string; }\n        interface Ic { name: string; }\n        class D { doSomeThing() { .... } }\n        class E implements Ia,Ib,D {\n            doSomeThing: () => any;// 如果实现的是类内元素，可以只声明，不实现\n            foo = () => {...} // 如果实现的是接口内元素，必须按照类型定义\n            bar = () => {...} // 必须把要实现的所有接口内的元素声明\n            constructor(param: Ic) {\n                const { name } = param;// param 必须是只含有name的对象\n            }\n        }\n\n## class语法糖\n\n        class a extends b {\n            constructor() {\n                super();//执行b的构造函数\n            }\n            public foo() {\n                super.foo();//执行b的原型上的foo函数\n                console.log(`\n                    我在ａ的prototype上\n                    this指向context\n                `);\n            }\n            public bar =　() => {\n                cosnole.log(`\n                    我在a的实例里,\n                    this指向a的实例\n                `)\n            }\n            public blaha = function() {\n                cosnole.log(`\n                    tslint默认禁止使用\n                    我在a的实例里,\n                    this指向context\n                `)\n            }\n        }\n\n## 装饰器\n\n类似于@tag,@mixin的东西，\n这个有点复杂，只说在class前面的装饰器吧,\n是用来处理对象原型的函数，\n会在构造函数执行结束后执行\n\n## Object解构\n\n        const obj = { a: 1 };\n        const name = \"name\";\n        const data = { ...obj, b: 2, name }; // { a: 1, b : 2, name: \"name\" }\n        const { a:xxx } = obj; // xxx===1\n        const data1 = {[xxx]: 'data1'}; // {1: 'data1'}\n\n## 一个更好的mixin\n\ntypescript对mixin支持很好，\n配合vscode的输入提醒代码体验十分完美，\n所以几乎可以放弃riot的mixin了\n\n* riot.mixin\n\n        // ajaxApi.js\n        {\n            init() {\n                this.on('ajaxApi', ()=> ...);\n            }\n        }\n        // xxxtag\n        riot.tag('xxx', '...', ()=> {\n            this.mixin(require('ajaxApi.js'));\n            this.trigger(\"ajaxApi\");\n        });\n\n* @mixin(any[])\n\n        class AjaxApi {\n            ajaxApi() {\n                ...\n            }\n        }\n\n        @tag({ name: \"xxx\", tmpl: \"...\" });\n        @mixin([AjaxApi])\n        class XxxTag extends TagCore implement AjaxApi {\n            onCreate( tag, opts ) {\n                this.ajaxApi();\n            }\n            ajaxApi: () => void;\n        }\n\n\n## async await 处理异步流程\n\n目前来说原生的Promise支持已经很不错了，\nasync虽然是个实验特性，\n但发明C#的微软明显推荐用这个特性。\n\n* 发布订阅\n\n        riot.tag('pay-view', '...', () => {\n            this.on('fooDone', ()=> this.bar());\n            this.on('barDone', ()=> this.blah());\n            this.bar = () => {\n                ...\n                this.trigger('barDone');\n            };\n            this.blah = () => xxx;\n            this.on('mount', () => this.trigger('fooDone'));\n        });\n\n* Promise\n\n        @tag({\n            name: \"pay-view\",\n            tmpl: \"...\",\n        });\n        class PayView extends TagCore {\n            onCreate(tag, opts) {\n                tag.on('mount', () => this.foo.then(()=> {\n                    return this.bar()\n                }).then(()=> {\n                    this.blah();\n                }));\n            }\n            foo = ()=> new Promise(resolve => resolve());\n            bar = ()=> new Promise (resolve => resolve())\n            blah = () => {...}\n            ...\n        }\n\n* async & await\n\n        @tag({\n            name: \"pay-view\",\n            tmpl: \"...\",\n        });\n        class PayView extends TagCore {\n            onCreate(tag, opts) {\n                tag.on('mount', async () => {\n                    await this.foo();\n                    await this.bar();\n                    this.blah();\n                });\n            }\n            foo = ()=> new Promise(resolve => resolve());\n            bar = ()=> new Promise (resolve => resolve())\n            blah = () => {...}\n            ...\n        }\n\n## 用TypeScript写一个Riot组件\n\n* html\n\n        <body>\n            <pay-view></pay-view>\n        </body>\n\n* ES5\n\n        require(\"pay-input\");\n        require(\"pay-submit\");\n        require(\"pay-vcode);\n\n        riot.tag(\"pay-view\", '<span>{ title }</span><pay-vcode></pay-vcode><pay-submit>提交</pay-submit>', function(opts) {\n            this.title = opts.title;\n            this.mixn(require('ajax1.js'));\n\n            this.trigger('ajax1');\n        });\n\n        riot.mount(\"pay-view\", {});\n\n* TypeScript\n\n        import {PaySubmit} from \"pay-submit\";\n        import {PayVcode} from \"pay-vcode\";\n\n        @tag({\n            name: \"pay-view\",\n            tmpl: `\n            <span>{ title }</span>\n            <pay-vcode></pay-vcode>\n            <pay-submit>提交</pay-submit>\n            `\n        })\n        @mixin([Ajax1])\n        class PayView extends TagCore implement Ajax1 {\n            onCreate(tag) {\n                tag.title = opts.title;\n                this.ajax1();\n            }\n            constructor() {\n                this.submit = new PaySubmit();\n                this.vcode = new PayVcode();\n            }\n            submit: PaySubmit;\n            vcode: PayVcode;\n            ajax1: () => void;\n        }\n\n        PayView.mount({});","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/05/04/2WebPack2-treeShaking-extTextPlugin.md","slug":"2017/05/04/2webpack2-treeshaking-exttextplugin","body":"# webpack2\n\n## tree-shaking（树摇）\n\nes6 module里面详述了树摇的的实现，但是webpack1始终没能实现，后来rollup实现了，于是大量框架转用rollup，去年webpack2发布，带来的就是这个tree-shaking功能。\n\n### AST树\n\n所有的代码，编译或者执行之前都会被转义成AST树，\n那么AST树是啥\n\n    let a;\n    let b = 1 + 1;\n\n* 代码\n    + 声明表达式\n        - let 声明\n        - 变量名 a\n    + 赋值表达式\n        - 加法运算\n            * 常量1\n            * 常量1\n        - 声明表达式\n            - let 声明\n            - 变量名 b\n\n### module的解析\n\n    // module a\n\n    export function foo() {...}\n    export function bar() {...}\n\n    // js\n\n    import { foo, bar } from a;\n\n    foo();\n\nwebpack会将代码解析成AST树，并发现bar并没有用过，就不会被打包进去。\n\n## extTextPlugin\n\n这是webpack的一个插件，可以解析出代码里面的css单独打包。这样css可以和组件放在一起了。\n\n    declare const require;\n    require(\"./style.scss\");\n\n    @tag({\n        name: \"pay-toast\",\n        tmpl: `\n        <div class=\"pay-toast\">{content}</div>\n        `,\n    })\n    export class PayToast extends TagCore {\n        public name: string = payToastConsts.name;\n        public onCreate(tag: ItoastTag, opts: ItoastRiotOpts) {\n            tag.update(opts);\n        }\n       public appendTag() {\n           const document = window.document;\n           const elem = document.createElement(this.name);\n           document.body.appendChild(elem);\n       }\n    }\n\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/05/04/3postcss-cssnext-cssnano.md","slug":"2017/05/04/3postcss-cssnext-cssnano","body":"# postcss干货\n\n上文说过，借助extTextPlugin可以把多个组件的css抽取成一个css，但webpack做的只是简单的文件拼接。处理css的地方要交给postcss。\n\n## cssnext\n\ncssnext使用caniuse.com的数据判断css需要支持到哪些浏览器，并自动做出可行的css解决方案（当然让ie6支持flex还是不行的）。\n\n    browsers: [\"> 0.1% in CN\", \"last 2 versions\"]\n\n登入 http://browserl.ist/ 可以查看上面的语句能支持的浏览器\n\n## cssnano\n\npostcss也是把css代码解析成ast树，解析之后可以看到冗余代码并对它进行压缩。\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/05/04/4Qxf-bigPipe.md","slug":"2017/05/04/4qxf-bigpipe","body":"# Qxf上的BigPipe的实现和优化原理\n\n![](http://i2.muimg.com/588926/2400354de719507f.jpg)\n\nQxf其实是express下的一堆中间件的集合，所以其实我在介绍express的BigPipe实现。\n\n简单的来说，当一个html开始下载的同时浏览器就开始渲染html了（而不是等html下载完成再渲染）。\n所以，返回给用户的页面可以一上一行地写出来（用我们学生时代老师的话来说就是挤牙膏）。\n\n## server => client (以前)\n\n1. 接到用户请求 => 白屏\n2. 请求接口，或者查数据库，处理数据，不拉不拉不拉 => 白屏\n3. 渲染出数据为state => 白屏\n4. 渲染模板为html => 白屏\n5. 返回html并结束请求 => 收到html并渲染，可能会下载css\n6. 空闲 => 下载js\n7. 空闲 => 渲染js，如果有ajax请求就请求\n\n## server => client (BigPipe)\n\n1. 接到用户请求 => 白屏\n2. 返回html的head => 收到head，下载css，核心js\n3. 请求接口，或者查数据库，处理数据 => 等待返回，如果有与UI无关的逻辑可以在下载完js后先执行\n4. 页面首部分的数据返回，生成state（组合成script标签） => 等待返回，如果有与UI无关的逻辑可以在下载完js后先执行\n5. 按照state生成模板一并返回，如果后面的接口也返回了数据重复3-5 => 渲染收到的html碎片\n6. 全部页面加载完成，结束请求 => 页面加载完成\n\n但是实际上按照BigPipe的做法，屏幕上面依赖的请求会阻塞，所以我对这一方案做了修改\n\n## server => client (BigPipe+)\n\n1. 接到用户请求 => 白屏\n2. 返回html的head + 按照默认state渲染的页面 + 默认state拼成的script标签 => 渲染出页面，下载css、js，js下载完成后可以操作了\n3. 请求接口，或者查数据库，处理数据 => 等待返回，或者直接操作页面\n4. 如果有接口返回，渲染出state并以script标签返回 => 根据收到的state二次渲染已经在dom树的组件\n5. 全部接口返回，结束请求 => 页面加载完成\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/05/04/5IsomophicApp.md","slug":"2017/05/04/5isomophicapp","body":"# Isomophic App\n\n如果你已经了解过前后端同构的话，你一定知道如下的方案\n\n    if (isServer) {\n        doServer();\n    } else {\n        doClient();\n    }\n\n那你看的文档应该都转发自同一个人。\n\n这种做法很有局限性\n\n* 你引用的module必须是umd打包的\n* 你引用的module必须不存在二进制包\n\n这回你知道为啥react要用全家桶了吧？\n\n## 换一种想法\n\n首先看一下node层和client层的不同点\n\n* node\n\n    接到用户Get请求 =>\n    node-fetch异步获取后端数据 =>\n    初始化Riot标签 =>\n    渲染页面为html =>\n    返回给用户 =>\n    收到接口元数据 =>\n    将元数据处理成state =>\n    以script标签形式返回用户 =>\n    res.end\n\n* client\n\n    收到渲染好的html并进行渲染 =>\n    加载js代码 =>\n    初始化Riot标签 =>\n    收到并运行script标签 =>\n    更新state =>\n    页面渲染完成\n\n可见，涉及到node像后端取数据并处理成state这部分逻辑是没必要加到client里面的，\n那么可以做两个文件实现node和client不同状态的处理。\n\n## 之前先介绍几个名词\n\n* 状态机存储器：　Store\n\n    ```new Store()```可以订阅```on```或者触发```trigger```几种事件，\n    没错```riot.tag```函数里面的```this```就继承自```Store```;\n\n* 广播控制器：　Control\n\n    是一个状态机的集合，方法```addStore```可以添加状态机存储器，\n    ```trigger```可以广播触发存储器的事件。\n\n* 标签生成器：TagCore虚基类\n\n* server.js\n\n        class RouteStore extends Store {\n            constructor(control) {\n                super()\n                this.on('apiFetched', () => ...)\n                this.on('serverStarted', () => ...)\n                ...\n            }\n        }\n\n        const control = new Control();\n        const routeStore = new RouteStroe(control);// 前后端不同的状态机\n        const someStore = new SomeStore(control);// 前后端一样的状态机\n\n        control.addStore(routeStore);\n        control.addStore(someStore);\n\n        const app = new App(control);\n\n* client.js\n\n        class ClientStore extends Store {\n            constructor(control) {\n                super()\n                this.on('DOMonLoad', () => ...)\n                ...\n            }\n        }\n\n        const control = new Control();\n        const clientStore = new ClientStore(control);// 前后端不同的状态机\n        const someStore = new SomeStore(control);// 前后端一样的状态机\n\n        control.addStore(clientStore);\n        control.addStore(someStore);\n\n        const app = new App(control);\n\n这样App、someStore这部分可以同构，clientStore和routeStore分别针对运行环境处理就可以了","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/05/04/6.md","slug":"2017/05/04/6","body":"# 项目完成情况\n\n## 封装完成但还没有上传npm\n\n1. QunarSniff中间件\n2. QunarLogin中间件\n3. TagCore，Control，Store\n4. fetch（用于合并请求，基于node-fetch）\n5. hysdk、QConfig-client-node， Qxf, PayGa 等的TypeScript封装\n6. 完成公用组件： yo-header, yo-logo, pay-toast\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/05/15/Riot-Preact.md","slug":"2017/05/15/riot-preact","body":"# 弃坑Riot转投Preact\n\n![换个坑继续趟](http://i4.buimg.com/588926/431151959544ded0.jpg)\n\n## 回顾一下为什么用Riot\n\n### 1. 对ES5最友好的组件化MVP框架\n\n> 吐槽一下现在的前端，gulp + webpack + rollup +　babel + ... 用gcc的同学都看哭了好么\n\nriot.js虽然官网上给出的语法是ES6的，但是可以直接使用ES5的语法，虽然react也可以，但是没人会想用ES5写JSX吧。\n\n相比于其它框架，使用ES5的riot.js不用写gulpfile，不用谢webpack.config.js，不用写babelrc，想想，直接上去就开始写逻辑还是件挺爽的事情哈。\n\n当时公司大量使用Fekit作为发布工具，因为Fekit只是简单地commonjs实现，所以使用Riot.js就是件理所当然的事情了。\n\n### 2. 十分轻量的框架\n\nriot.js的源码70+KB，混淆之后是10+KB，大概一个handlebars或者是大一点的arctemplate的大小，里面包括组件化、observable的事件机制、路由器、SSR这些功能。\n\n用riot.js开发之后的逻辑代码（移动端）大小也没有比vue的核心代码库大。\n\n所以如果有一个项目想要快速开发，代码量又不想太大，riot.js会是我推荐的，而且不必担心性能问题（可以参考我之前vue、react和riot的对比，分明react是性能最差的）。\n\n之前写过riot.js的最佳实践，没在公众号里面推，后面补上哈～\n\n----\n<center>\n    <h3>蛋是</h3>\n    <h2>你还是一个好<s>人</s>框架</h2>\n    <h3>而我已经不是那个骚年了</h3>\n</center>\n\n---\n\n## Preact的出现\n\n去年我录制了一个Riot.js的分享视频（在youku可以搜到哦），Preact大概在那时出现在了hackernews的首页，我记得当时hackernews下面的回复都是很轻蔑的“呵呵，又一个“。\n\n等了大概一年，这个项目居然没死，要知道这一年很多类react的项目过得可不是那么好啊。这个项目的Twitter帐号都发会议邀请函了。\n\n## 那么引入Preact是为什么\n\n### 1. Typescript对JSX的支持好过template\n\ntypescript能够做静态类型检查，简单地说，如果我的代码里面有什么拼写错误或者什么包没引入，编译器都能查出来。\n\n蛋是，如果我写的代码在模板里面，编译器就无能为力了，毕竟模板就只是字符串啊。而jsx不同，它是一种DSL，编译器自然会检查里面的代码。\n\n### 2. Preact真的太TM小了\n\n当时使用riotjs的原因很大的比重在减负，在我的哲学里面，一个框架只需要完成我需要它完成的东西，其他的不要多。preact相比riot减负了大概50k（源代码），当然功能上也少了（observable，router）。\n\n### 3. 真的能堵住很多人的嘴\n\nPreact和React用的是同一套API，JSX语法又一样，用这套框架估计没有人吐槽难用了吧？（这一条真的很无力，好多人连react都没用过，就说我用一冷门框架不好维护，就像我用了react你就能来维护一样）\n\n## 所以我会用Preact吗？\n\n我会在最近的一次优化把我的项目进行优化改造，最后我在根据它的性能（ssr+browser）、最终的业务代码大小、是否可以多人合作开发等多方面分析考虑是否切换。\n\n当然，也有别的可能，毕竟当初说好用vim的我现在竟用着vscode。\n\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/06/04/riotjs-typed.md","slug":"2017/06/04/riotjs-typed","body":"# 我把riotjs-typed开源了\n\n都来看啊，都来看啊\n\n关键字：\n\nriotjs, riotcontrol, SSR, 组件化开发, 前后端同构","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/06/15/nock-node-mock.md","slug":"2017/06/15/nock-node-mock","body":"# nock做node的mock数据\n\n懒得写了，mark一下","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/08/01/archifactory.md","slug":"2017/08/01/archifactory","body":"# Achifactory私有源的坑\n\n公司的私有源从CNPM改成AchiFactory了，为的是更好的管理docker、maven、PyPI和npm，结果我在迁移的时候出现了问题。\n\nnpm install的时候一直报 module achifactory not found\n\n结果是公司的私有库没有完全同步，我的一个私有包404了，但是报achifactory not found还真是。。。","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/08/15/Er-pt.md","slug":"2017/08/15/er-pt","body":"# 【Erʌpt】一个前后端同构的设计思想\n\n<img src=\"http://ww1.sinaimg.cn/large/89d0a2e1ly1fikrpw68t9j208c08cdfx.jpg\" alt=\"logo\" width=\"150px\">\n\n> 最近一直没有更新博客，其实脑子里面已经装了很多东西了，略微分享一下。\n\n[精美PPT~（花了十多分钟呢](http://gongbushang.com/ng/ERUPT/)\n\n## 前提\n\n2017年前端看起来是风平浪静的，其实不然，今年WASM终于定稿了，那意味着用任何语言编译web应用得到了官方支持。由于采纳的是Mozilla的asm.js方案，兼容性上面要好得多。很多人关注的是性能上的提升，而我觉得最先活起来的应该是前后端同构。因为大批的后端程序员可以避开javascript的各种坑去使用自己的开发语言开发前端应用了。\n\n### 最近出现了很多诸如RustWeb和Golymer的框架\n\n<table>\n<tr>\n<td>\n<img src=\"http://ww1.sinaimg.cn/mw690/89d0a2e1ly1fir7gp7j3ej20r40k6abz.jpg\"/>\n</td>\n<td>\n<img src=\"http://ww1.sinaimg.cn/mw690/89d0a2e1ly1fir7nz5t8qj21040qcabg.jpg\"/>\n</td>\n</tr>\n</table>\n\n### CS架构解决的问题\n\n![现有的CS架构](http://ww1.sinaimg.cn/thumbnail/89d0a2e1ly1fir7ta8jaij20a90a9437.jpg)\n\n* 我是谁\n* 我从哪里来\n* 要到哪里去\n\n### 照以前前后端分离的方案\n\n| server | client |\n|--------|--------|\n| 返回html | 发出请求 |\n| 空闲  | 获取css、js等资源 |\n| 空闲  | 发出ajax请求 |\n| 返回数据 | 空闲 |\n| 空闲 | 渲染数据 |\n\n### 前后端同构的做法\n\n| server | client |\n|--------|--------|\n| 返回html头部 | 发出请求 |\n| 返回html碎片 | 获取css、js |\n| 返回html碎片 | 渲染碎片 |\n| 返回end | 结束页面渲染 |\n\n### 小结一\n\n前后端同构是在“我是谁？”这一部分做了优化。\n\n### 前后端同构的优势\n\n1. SEO，不多说了；\n2. 减少http请求数；\n3. 减少用户初次访问页面的白页时间；\n4. 减少因前后端分离造成的技术障碍。\n\n### 前后端同构的策略\n\n1. 精确渲染\n2. 结构渲染\n3. 模板渲染\n\n#### 精确渲染\n\n把页面首屏的内容都渲染出来。\n\n![精确渲染](http://ww1.sinaimg.cn/mw690/89d0a2e1ly1fiylzsf71jj20hs0b4mxf.jpg)\n\n#### 精确渲染的评价\n\n优点\n\n* 渲染出来的页面就是用户看到的\n\n缺点\n\n* 部分后端请求会阻塞页面的渲染\n\n#### 结构渲染\n\n把初始状态的首屏渲染出来然后在同一请求中把应该展示的状态展示出来。\n\n![结构渲染](http://ww1.sinaimg.cn/mw690/89d0a2e1ly1fiym4385dfj20hs0b4jro.jpg)\n\n#### 框架渲染的评价\n\n优点\n\n* 解决了精确渲染会阻塞的问题\n\n缺点\n\n* 对于新闻类型的页面，框架渲染不利于SEO\n\n#### 模板渲染\n\n把模板直接作为html传到客户端。\n\n![模板渲染](http://ww1.sinaimg.cn/mw690/89d0a2e1ly1fiynhe7jenj20hs0b43ys.jpg)\n\n#### 模板渲染的评价\n\n优点\n\n* 字符串渲染，计算开销最小\n\n缺点\n\n* 用户会看到未渲染的模板变量\n\n### 小结二\n\n应该结合精确渲染和框架渲染\n\n## 介绍Erʌpt\n\n| | Erʌpt |  |\n|--|---|---|\n| E | Express | 这都不知道？退下吧  |\n| R | React | 这也不知道？别看了 |\n| ʌ | Values | 基于Redux的异步数据管理 |\n| P | Pipe | HTML渲染器 |\n| T | Tunnel | 同步数据管理 |\n\n## Values异步数据管理\n\n### 单向数据流\n\nreact的render函数是会不断轮询页面上绑定的数据来进行页面更新的。\n\n| value===\"bud\" | value===\"bloom\" |\n|--|--|\n|![](http://ww1.sinaimg.cn/mw690/89d0a2e1ly1fiyoot1ss4j20m80gojsi.jpg)|![](http://ww1.sinaimg.cn/mw690/89d0a2e1ly1fiyotbnajvj20m80godgz.jpg)|\n\n### Values的写法\n\n```typescript\nclass TestValues extends Values {\n    public getReducer() {\n        return combineReducers({\n            flower: TestValues.FlowerValue(),\n        });\n    }\n    public static FlowerValue = () => {\n        return ( value = \"bud\", action ) => {\n            if ( action.type === \"开花\" ) return \"bloom\";\n            if ( action.type === \"被狗踩了\" ) return \"baiduLogo\";\n            return value;\n        }\n    }\n}\n```\n\n### 怎么使用Values\n\n```typescript\nconst v = new TestValues();\nconst store = createStore(v.getReducer());\nstore.getState(); // { flower: \"bud\" }\n```\n\n### Pipe HTML渲染器\n\n用于利用React renderToString 生成HTML。\n\n### Pipe的写法\n\n```typescript\nclass TestPipe extends Pipe<Request, Response> {\n    constructor(request, response) {\n        super( request, response, minifyParams);\n    }\n    public renderPage(tunnel) {\n        this.html(`\n        <!doctype html>\n        <html>\n            <body>\n            ${this.JSX2HTML(\n                <Provider store={store}>\n                    <Page></Page>\n                </Provider>\n            )}\n            </body>\n        </html>\n        `);\n        this.response.end();\n    }\n}\n```\n\n### Tunnel同步数据管理\n\n#### Tunnel的设计\n\n前后端同构的意思是要在后端完成一部分工作，当前端getState的时候，获取的是后端生成并注入到前端作用域的state，也就是说这个对象在后端完成set工作，而在前端完成get工作。\n\n![Tunnel设计](http://ww1.sinaimg.cn/mw690/89d0a2e1ly1fiypthxr4jj20m80goq4f.jpg)\n\n#### Tunnel的使用\n\nServer\n\n```typescript\nconst t = new Tunnel(\"QNR_GLOBAL\", {}, value);\nPipe.renderPage(t)\n```\n\nClient\n\n```typescript\nconst t = new Tunnel();\nt.$state // { flower: \"bud\" }\nwindow.QNR_GLOBAL // { $state: { flower: \"bud\" } }\n```\n\n## 结论\n\nErvpt是VPT在react+express上面的实现，能够很好地实现前后端同构中的精确渲染和结构渲染，基于这套思想我相信它能带来一场新的前后端分离的革命，也就是前端能够主导全部的页面逻辑，后端专注于接口的优化。","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/09/18/Typescript sucks but long live the types.md","slug":"2017/09/18/typescript-sucks-but-long-live-the-types","body":"# TypeScript Sucks but Long Live the Types\n\n[查看PPT](http://gongbushang.com/ng/types-slide/)\n\n## Part I : Type System\n\n### JavaScript 是一种很爽的语言\n\n作为一款动态语言，比如你可以执行以下代码而不用担心报错。\n\n```javascript\nvar num = \"3\" - \"2\";　// num = 1\n```\n\n---\n\n但是，如果遇到了下面这种情况，就算是灾难了。\n\n```javascript\nisGreater(\"1000\", \"233\"); // false\n\nfunction isGreater(ａ, b) {\n    return a > b;\n}\n```\n\n---\n\n所以我们写代码的时候，都会加注释\n\n```javascript\n/**\n* 是否为最大\n* 参数传数字啊\n* 谁不传谁是小狗\n* @constructor\n* @param {number} ａ\n* @param {number} b\n* @returns {boolean}\n**/\nfunction isGreater(ａ, b) {\n    return a > b;\n}\n```\n\n---\n\n可是总有人不看注释，所以这个函数变成了\n\n```javascript\nfunction isGreater(a, b) {\n    const T_NUM = \"number\";\n    if (\n        T_NUM === typeof a &&\n        T_NUM === typeof b\n    ) {\n        return a > b;\n    } else {\n        throw(\"参数传数字啊，扎心了，老铁！\");\n    }\n}\n```\n\n---\n\n这还没完呢，假设这次改动出现在某次重构中，此前这个isGreater方法已经遍布你的项目了。\n\n```javascript\nbtn.onclick = () =>\n    isGreater(\"x\", \"y\") ? ... : ...;\n```\n\n而正好，这个 onClick 在自测的时候被忽略了。上线之后就是灾难了。\n\n---\n\n### 动态一时爽，重构火葬场\n\n### 举个 TS 的栗子\n\n```javascript\nfunction isGreater(ａ: number, b: number): boolean {\n    return a > b;\n}\n```\n\n### 类型系统的优势\n\n* 代码可读性高\n* 更有利于重构\n* IDE能更好地支持\n* 预防某些类型相关的错误\n\n### 比较流行的JS类型系统\n\n![](http://ww1.sinaimg.cn/mw690/89d0a2e1ly1fjow3fyxzbj20fy0baq4k.jpg)\n\n## Part II : TS vs Flow\n\n众多类型系统里面，typescript 和 flowtyped 的比较类似，目标都是为了 JS 的工程化，而且语法上除了细节几处根本没区别。\n\n### 对照\n\n| | TypeScript    | Flow-typed    |\n|--|---------------|---------------|\n| by   | Microsoft  | Facebook   |\n| in   | TypeScript | OCamel     |\n| is A | Compiler   | Checker    |\n| VSCode | 原生支持  | 安装插件 |\n| webpack | ts-loader | babel |\n| config | json | config |\n| version | 2.3.2 | 0.54.1 |\n\n### 简单比对\n\n#### TypeScript\n\n```javascript\nfunction isGreater(a: number, b: number): boolean {\n    return a > b;\n}\n\nisGreater(\"1\", \"2\");\n      // ^^^^\n      // Argument of type \"1\" is not assignable to parameter of type 'number'.\n```\n\n### Flow-typed\n\n```javascript\n//@flow\nfunction isGreater(a: number, b: number): boolean {\n    return a > b;\n}\n\nisGreater(\"1\", \"2\");\n        // ^^^  ^^^\n        // string (This type is incompatible with the expected param type of number)\n```\n\n### 空值检查\n\nTypeScript(strict) 和 Flow 都能指出 nullCheck 函数应该指明返回值为 string | void 类型。\n\n```javascript\nfunction nullCheck(num: number): string {\n                                // ^^^\n                                // [ts] Function lacks ending return statement and return type does not include 'undefined'.\n                                // [flow] This type is incompatible with an implicitly-returned undefined.\n    if (num > 10) {\n        return \"it's ok\"\n    }\n}\n```\n\n### 泛型\n\nTypeScript 和 Flow 都指出狗的数组不能加入猫的实例。\n\n```javascript\nclass Animal { }\nclass Dog extends Animal { woff = true }\nclass Cat extends Animal { meow = true }\n\nlet animals: Animal[] = [];\nlet dogs: Dog[] = [];\nlet cat: Cat[] = [];\n\nanimals.push(new Animal);\nanimals.push(new Dog);\nanimals.push(new Cat);\n\ndogs.push(new Cat);\n      // ^^^^^^^^\n      // 'Argument of type 'Cat' is not assignable to parameter of type 'Dog'.\n      // ^^^^^^^ Cat. This type is incompatible with\n```\n\n---\n\n此处 TS 和 Flow 都能查出错误，但是报错位置不同。\n\n```javascript\n//@flow\nclass Animal {}\nclass Dog extends Animal { woff = true }\nclass Cat extends Animal { meow = true }\n\nlet animals: Animal[] = [];\n            // ^^^^^^\n            // [flow] Animal (This type is incompatible with Cat)'\nlet cats: Cat[] = animals;\n// ^^^\n// [ts] Type 'Animal[]' is not assignable to type 'Cat[]'.\n```\n\n#### Wait for IT\n\n震惊，TypeScript 在这种情况下不报错！！！\n\n```javascript\n//@flow\nclass Animal {}\nclass Dog extends Animal { woff = true }\nclass Cat extends Animal { meow = true }\n\nlet cats: Cat[] = [];\nlet animals: Animal[] = cat;\n        // ^^^^^^^^^\n        // [flow] Animal (This type is incompatible with Cat)\n\nanimals.push(new Dog);\nanimals.push(new Cat);\nanimals.push(new Animal);\n\nJSON.stringify(cats); // [{\"woff\":true},{\"meow\":true},{}]\n```\n\n***TS 只做了类型检查，而 JS 数组是引用赋值的，因此引起了错误***\n\n#### Nominal & Structural (property-based) Typing\n\nFlow 是标称类型而 TS 是结构类型。\n\n```javascript\nclass Animal { }\nclass Dog extends Animal { name = \"dog\" }\nclass Cat extends Animal { name = \"cat\" }\n\nlet dog: Dog = new Dog;\ndog = new Cat;\n      // ^^^^^^^ [Flow] Cat. This type is incompatible with Dog\ndog = { name: \"dog\" };\n      // ^^^^^^^^^^^^^^^ [Flow] object literal. This type is incompatible with\n```\n\n#### 对比总结\n\n|    |　TypeScript | Flow-typed |\n|----|-------------|------------|\n| 工具支持　| 有亲爸做编辑器　| 目前体验存在迟钝，但可以做 linting 前的最后工序 |\n| 第三方库定义支持　| npm @types 私有库　| flow-typed 可以安装定义，但明显少于 TS |\n| 质量检查　| tslint　| eslint　(jshint 不行) |\n| 编译　|　可以直接编译为各版本的 JS | 借助babel |\n| 迁移成本　| 可以把原来的 JS 作为类库使用，但整体依然要用 TS 写 | 可以指定要检查的文件 |\n| 其他　| 支持很多es7/8的功能　| 只是检查器，但是类型检查强于 TS |\n\n## Part III Types in use (TypeScript)\n\n### Library\n\nJavaScript 的类库一直是良莠不齐，所以当你有两个以上的类库可选的话，究竟选哪个可能是个问题。\n\n好在如果一个 JS 类库存在类型声明的话，可以说明这两个问题。\n\n* 官方声明：作者写这一类库的时候不是玩票地试一下\n* 第三方声明：已经有人在使用这一类库了\n\n![](http://ww1.sinaimg.cn/mw690/89d0a2e1ly1fjq8ttqtxhj20w20i4abt.jpg)\n\n那么在使用这些类库的时候起码不会有太多的坑。\n\n#### NPM declarations\n\n假如你是一个类库的作者，你已经用 typescript 写完了一个库，正准备把它发布到 npm 上面，如果你想给这个类库加上类型声明，只需在 typescript 的编译配置　(tsconfig.json)　上添加如下字段。\n\n```javascript\n\"declaration\": true\n```\n\n再次编译，你会看到很多```*.d.ts```文件，这就是类库的声明文件。\n\n```javascript\nfunction isGreater(ａ: number, b: number): boolean;\n```\n\n接下来，在```package.json```添加 type 字段，再发布的 npm 包就已经带有声明了。\n\n```javascript\n\"types\": \"./lib/main.d.ts\",\n```\n\n另外，通过在　@types 下搜索也能找到第三方的类库声明。\n\n#### 3rd party declaration\n\n有的时候，你的类库并没有声明文件，同时 @types 也没有其他人上传，你需要自己写声明文件。\n\n比如 HySDK, 只需要在项目目录里添加　.d.ts　文件\n\n```javascript\ndeclare module \"@qnpm/hysdk\" {\n    export = {\n        openWebView: (param: {\n            url: string;\n            name?: string;\n            data?: any;\n        }) => void,\n    }\n}\n\nimport { openWebView } from \"@qnpm/hysdk\";\nopenWebView({ url: \"\" });\n```\n\n### Types in Redux\n\n前端交互逻辑用得最多的就是发布订阅模式了，\n在发布订阅模式里面需要一个约定值来确定订阅的是哪一个事件。\n那么类型系统就派上用场了，这里拿 Redux 举例。\n\n---\n\nRedux 的问题在于，订阅和发布的约定值可以随便写。\n\n```javascript\nconst store = createStore((state,{type, data}) => {\n    if (type === \"action1\") return ...\n    if (type === \"action2\") return ...\n    return state;\n})\nfunction doAction(action) {store.dispatch(action);}\ndoAction({ type: \"action1\", data }); // OK\ndoAction({ type: \"actionX\", data }); // OK\n```\n\n---\n\n我们给 action 写一个约束 IAction，这样，\n在 reducer 里面不能多写一个 actionY 事件，\ndispatch 的时候也不能指定 actionX 事件。\n\n```javascript\ninterface IAction { type: \"action1\" | \"action2\", data: any }\nconst store = createStore((state,{type, data}: IAction) => {\n    if (type === \"action1\") return ...\n    if (type === \"action2\") return ...\n    if (type === \"actionY\") return ... // Err\n    return state;\n})\nfunction doAction(action: IAction) {store.dispatch(action);}\ndoAction({ type: \"action1\", data }); // OK\ndoAction({ type: \"actionX\", data }); // Err\n```\n\n## Part IV Epilogue\n\n### 应该使用类型系统吗？\n\n|   |   |\n|---|---|\n| 页面只用于接下来的十一活动营销　| No |\n| 页面很简单就是展示文案 | No |\n| 新项目,并以后很有可能会频繁重构　| TypeScript |\n| 老项目,老文件不再改,只增加文件 | Flow |\n\n其实，前端的类型系统到目前为止依然还有很多瑕疵，因此我说 TypeScript sucks，但是就目前的版本来说，可比它刚发布那会儿要好用的多了，起码已经到了能用的地步。\n\n随着 TS 和 Flow 的发展和互相影响，前端类型系统将会逐步完善，但那都是以后的事了。就目前来说，如果你手上有一个大工程，还没有用上类型系统，那为何不尝试一下呢？","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/11/22/Building.Isomorphic.JavaScript.Apps.md","slug":"2017/11/22/buildingisomorphicjavascriptapps","body":"# Building Isomorphic JavaScript Applications\n\n## 读<构建同构的JavaScript应用>有感\n\n![](https://covers.oreillystatic.com/images/0636920042846/cat.gif)\n\n这本书简单介绍了并实现了前后端js应用方案(Hapj.js)\n\n我更喜欢书后半部分各个公司对前后端同构的优化.\n\n### React\n\nReact的后端渲染存在性能瓶颈(这个我在现实使用时也考虑过,虽然我用的是Preact), 书中通过修改 mountComponent 方法缓存最近渲染的模板, 这种 LRU 算法很大的加快了后端渲染效率. 貌似 Vue 也用的这种方案.\n\n我的做法可能更粗暴点,我直接在服务启动的时候把不会变化的组件渲染出来在内存里使用了,囧. 但这是最快的做法呀(原谅~).\n\n### Angular\n\n其实是 Angular1, 由于过于依赖浏览器, 开发者抽象了很多的浏览器 API. 作者介绍了 Angular2 Universal. 我比较喜欢的是 Preboot 功能, 这个功能能够缓存用户在未渲染完成的页面的操作,并在客户端渲染完成进行操作, 这样能够解决用户过早提交表单的问题.\n\n我的确碰到表单问题了, 但我是直接把表单删了, 依赖 JS 处理 submit 按钮, 这样用户在未渲染之前是不能提交的, 遗憾的是这样就失去了表单的功能了.\n\n### Backbone\n\n没有过多了解, 书里提到后悔使用jQuery, jQuery的确是一个前后同构的 js 库, 刚有 node 的时候我也在用, 然而现在我也不用了.\n\n### C#.Net\n\n有趣的是, 前后端同构并不是 node 独享的, 书里的最后一个例子是 C# 的, 作者找到了 js 和 C# 共有的模板引擎解决了跨语言前后端同构的问题.\n\n## 注意\n\n需要注意的是，做单页面应用的时候，或许不需要考虑太多内存泄漏，毕竟页面关了资源就释放了。而做 server 端并不会。\n\n\n## 总结\n\n这本书很薄, 英文版209页而已, 后面的例子的确有很多可采纳的地方.\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/12/20/plantUML.md","slug":"2017/12/20/plantuml","body":"# plantUML的使用\n\n参考自 [轻松从Js文件生成UML类图](https://github.com/imfly/bitcoin-on-nodejs/blob/master/4-%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/7-%E6%96%B9%E6%B3%95%E8%AE%BA/6-%E8%BD%BB%E6%9D%BE%E4%BB%8EJs%E6%96%87%E4%BB%B6%E7%94%9F%E6%88%90UML%E7%B1%BB%E5%9B%BE.md)\n\n## 使用说明\n\nvscode 安装 plantUML 插件, 编写 *.puml 文件的时候执行 Alt + D 可以预览绘制的流程图.\n\n## *.puml 文件格式说明\n\nplantUML的解析以 @startuml 开始 以 @enduml 结束\n\n## 时序图\n\n```plantuml\n@startuml\nactor Foo1\nboundary Foo2\ncontrol Foo3\nentity Foo4\ndatabase Foo5\ncollections Foo6\nFoo1 -> Foo2 : To boundary\nFoo1 -> Foo3 : To control\nFoo1 -> Foo4 : To entity\nFoo1 -> Foo5 : To database\nFoo1 -> Foo6 : To collections\n@enduml\n```\n\n![](http://ww1.sinaimg.cn/large/89d0a2e1ly1fn3ikg2r9fj20pe0m6433.jpg)\n\n\n```plantuml\n@startuml\nactor Bob\nactor Alice\nactor AVertyVeryLongName as L\nAlice->Bob: Authentication Request\nBob->Alice: Authentication Response\nBob->L: Log transaction\n@enduml\n```\n\n![](http://ww1.sinaimg.cn/large/89d0a2e1ly1fn3ikg1c86j20q60ietc5.jpg)\n\n## 活动图\n\n```plantuml\n@startuml\nstart\nif (condition A) then (yes)\n  :Text 1;\nelseif (condition B) then (yes)\n  :Text 2;\n  stop\nelseif (condition C) then (yes)\n  :Text 3;\nelseif (condition D) then (yes)\n  :Text 4;\nelse (nothing)\n  :Text else;\nendif\nstop\n@enduml\n```\n\n![](http://ww1.sinaimg.cn/large/89d0a2e1ly1fn3ikfxoemj20ug0f4juf.jpg)\n\n```plantuml\n@startuml\n\nstart\n\nrepeat\n  :read data;\n  :generate diagrams;\nrepeat while (more data?)\n\nstop\n\n@enduml\n```\n\n![](http://ww1.sinaimg.cn/large/89d0a2e1ly1fn3ikfyu6cj20c80ikjt1.jpg)\n\n## 类图\n\n```plantuml\n@startuml\nclass Dummy {\n  String data\n  void methods()\n}\n\nclass Flight {\n   flightNumber : Integer\n   departureTime : Date\n}\n@enduml\n```\n\n![](http://ww1.sinaimg.cn/large/89d0a2e1ly1fn3ikftv49j20iw060jsm.jpg)","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/12/25/WebAR.md","slug":"2017/12/25/webar","body":"\r\nhttps://github.com/jeromeetienne/AR.js/\r\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2018/01/03/typescript-AST.md","slug":"2018/01/03/typescript-ast","body":"# TypeScript编译抽象语法树\n\n[代码地址](http://gongbushang.com:3000/gongbushang/typescript_compiler)\n\n两年前我曾写了一个篇\n[Esprima静态分析js代码](http://gongbaodd.github.io/fe/2015/12/25/esprima%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90js%E4%BB%A3%E7%A0%81.html),\n当时的目的是为了检查一个js文件对某些函数的调用数计数来确定这个函数是不是可删的.\n\n自从用了typescript,\n这种方法自然就不需要使用了,\n但是如果我想获取 typescript 的 AST 怎么办?\n\n很简单, 因为 Ts 本身就是开源项目, 官方已经有解决方案.\n\n假设我想看一下 \"const a:number = 11;\" 的 AST 树, 代码如下.\n\n```typescript\nimport ts = require(\"typescript\");\nconst source = \"const a:number = 11;\";\n\nfunction printChildren(node: ts.Node, depth = 0) {\n    console.log(new Array(depth + 1).join(\"---\"), ts.SyntaxKind[node.kind], node.pos, node.end);\n    depth++;\n    node.getChildren().forEach(c => printChildren(c, depth));\n}\n\nconst sourceFile = ts.createSourceFile(\"a.ts\", source, ts.ScriptTarget.ES2016, true);\nprintChildren(sourceFile);\n```\n\n结果\n\n```shell\n SourceFile 0 20\n--- SyntaxList 0 20\n------ VariableStatement 0 20\n--------- VariableDeclarationList 0 19\n------------ ConstKeyword 0 5\n------------ SyntaxList 5 19\n--------------- VariableDeclaration 5 19\n------------------ Identifier 5 7\n------------------ ColonToken 7 8\n------------------ NumberKeyword 8 14\n------------------ FirstAssignment 14 16\n------------------ FirstLiteralToken 16 19\n--------- SemicolonToken 19 20\n--- EndOfFileToken 20 20\n```\n\n一个空对象的抽象语法树.\n\n```typescript\nclass a {}\n```\n\n```shell\n SourceFile 0 10\n--- SyntaxList 0 10\n------ ClassDeclaration 0 10\n--------- ClassKeyword 0 5\n--------- Identifier 5 7\n--------- FirstPunctuation 7 9\n--------- SyntaxList 9 9\n--------- CloseBraceToken 9 10\n--- EndOfFileToken 10 10\n```\n\n那么复杂点的对象\n\n```typescript\nclass a {\n    public num: number = 11;\n    public getNumber() {\n        return this.num;\n    }\n}\n```\n\n```shell\n SourceFile 0 96\n--- SyntaxList 0 96\n------ ClassDeclaration 0 96\n--------- ClassKeyword 0 5\n--------- Identifier 5 7\n--------- FirstPunctuation 7 9\n--------- SyntaxList 9 94\n------------ PropertyDeclaration 9 38\n--------------- SyntaxList 9 20\n------------------ PublicKeyword 9 20\n--------------- Identifier 20 24\n--------------- ColonToken 24 25\n--------------- NumberKeyword 25 32\n--------------- FirstAssignment 32 34\n--------------- FirstLiteralToken 34 37\n--------------- SemicolonToken 37 38\n------------ MethodDeclaration 38 94\n--------------- SyntaxList 38 49\n------------------ PublicKeyword 38 49\n--------------- Identifier 49 59\n--------------- OpenParenToken 59 60\n--------------- SyntaxList 60 60\n--------------- CloseParenToken 60 61\n--------------- Block 61 94\n------------------ FirstPunctuation 61 63\n------------------ SyntaxList 63 88\n--------------------- ReturnStatement 63 88\n------------------------ ReturnKeyword 63 78\n------------------------ PropertyAccessExpression 78 87\n--------------------------- ThisKeyword 78 83\n--------------------------- DotToken 83 84\n--------------------------- Identifier 84 87\n------------------------ SemicolonToken 87 88\n------------------ CloseBraceToken 88 94\n--------- CloseBraceToken 94 96\n--- EndOfFileToken 96 96\n```\n\n那么看看应用, 之前我写过 [plantUML的使用](http://gongbaodd.github.io/fe/2017/12/20/plantUML.html),\n正好可以试一下看看能不能自动生成类图.\n\n```typescript\nimport { readFileSync } from \"fs\";\nimport * as ts from \"typescript\";\n\nexport function uml(src: ts.SourceFile) {\n    const classMap = {};\n    analyseNode(src);\n    console.log(draw());\n\n    function analyseNode(node: ts.Node) {\n        if (node.kind === ts.SyntaxKind.ClassDeclaration) {\n            const cls = {};\n            node.forEachChild(n => {\n                if (n.kind === ts.SyntaxKind.Identifier) {\n                    classMap[n.getText()] = cls;\n                }\n                if (n.kind === ts.SyntaxKind.PropertyDeclaration) {\n                    n.forEachChild(i => {\n                        if (i.kind === ts.SyntaxKind.Identifier) {\n                            cls[i.getText()] = \"var\";\n                        }\n                    });\n                }\n                if (n.kind === ts.SyntaxKind.MethodDeclaration) {\n                    n.forEachChild(i => {\n                        if (i.kind === ts.SyntaxKind.Identifier) {\n                            cls[i.getText()] = \"function\";\n                        }\n                    })\n                }\n            });\n        }\n        node.forEachChild(analyseNode);\n    }\n\n    function draw() {\n        const tpl = `\n@startuml\n#\n@enduml\n        `.trim();\n        let str = \"\";\n\n        Object.keys(classMap).forEach(className => {\n            const classItems = classMap[className];\n            str += `class ${className} {\\n`;\n            Object.keys(classItems).forEach(i => {\n                str += `${classItems[i]} ${i}\\n`;\n            });\n            str += \"}\\n\";\n        });\n\n        return tpl.replace(\"#\", str);\n    }\n}\n\n\nconst file = process.argv.slice(2);\nfile.forEach(f => {\n    const src = ts.createSourceFile(f, readFileSync(f).toString(), ts.ScriptTarget.ES2016, true);\n    uml(src);\n})\n\n```\n\n\n```plantuml\n@startuml\nclass A {\nvar num\nfunction getNumber\n}\n\n@enduml\n```","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2018/01/24/30-kotlin.md","slug":"2018/01/24/30-kotlin","body":"# 完成了30个kotlin安卓挑战\n\n去年逛IT邦看到了关于Kotlin的铁人赛，30个安卓demo．毕竟不是我的原创，这里贴上原地址\n\nhttps://ithelp.ithome.com.tw/users/20107329/ironman/1286\n\n再贴上我的代码地址\n\nhttp://gongbushang.com:3000/gongbushang/kotlinPlayground\n\n## 我的测试机\n\n说来我的测试机，可是我当年拿实习工资买的魅蓝，后来跑步摔碎了，现在打开更新下居然还能用，也是奇迹了．\n\n![](https://wx2.sinaimg.cn/mw690/89d0a2e1ly1fnt8xpefslj20qo0zkwin.jpg)\n\n## 01TapCounter\n\n最简单的计数器\n\nKotlin 的 lamda 表达式的使用,\n使用 kotlin 的一个好处，\n获取 button 或者 textEdit 之类的组件不需要使用 findViewById 了\n\n```kotlin\nthis.tapButton.setOnClickListener {\n    currentNumber += 1\n    numberTextView.text = currentNumber.toString()\n}\n```\n\n## 02seekBarPercentage\n\nprogressBar 的使用\n\n## 03ImgePicker\n\n获取相机\n\n```kotlin\nval intent = Intent(MediaStore.ACTION_IMAGE_CAPTURE)\n\nstartActivityForResult(intent, ACTION_CAMERA_REQUEST_CODE)\n```\n\n获取相册\n\n```kotlin\nval intent = Intent(Intent.ACTION_PICK)\nintent.type = \"image/*\"\nstartActivityForResult(intent, ACTION_ALBUM_REQUEST_CODE)\n```\n\n## 04ScalableImageView\n\n自定义一个 ImageView\n\n## 05WebSearch\n\nwebView\n\n```kotlin\nwebview.webViewClient = webViewClient\nwebview.loadUrl(\"https://www.bing.com\")\n```\n\n## 06ImageList\n\nfragment 的高度要固定\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<android.support.constraint.ConstraintLayout\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"260dp\">\n</android.support.constraint.ConstraintLayout>\n```\n\n## 07MyLocation\n\n没法用谷歌地图, 改用高德地图, 主要还是要很多权限\n\n```xml\n\n    <!--允许程序打开网络套接字-->\n    <uses-permission android:name=\"android.permission.INTERNET\" />\n    <!--允许程序设置内置sd卡的写权限-->\n    <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />\n    <!--允许程序获取网络状态-->\n    <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />\n    <!--允许程序访问WiFi网络信息-->\n    <uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" />\n    <!--允许程序读写手机状态和身份-->\n    <uses-permission android:name=\"android.permission.READ_PHONE_STATE\" />\n    <!--允许程序访问CellID或WiFi热点来获取粗略的位置-->\n    <uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" />\n    <uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\"/>\n```\n\n## 08BottomNavigation\n\n没啥意思就是底部导航栏\n\n## 09ImageSlider\n\nImageSlider的使用\n\n## 10ProgressControl\n\n控制 progressBar\n\n## 11ActivitySchedule\n\n日期弹框\n\n```kotlin\n  DatePickerDialog(\n                    this,\n                    DatePickerDialog.OnDateSetListener { _, year, month, date ->\n                        cal.set(Calendar.YEAR, year)\n                        cal.set(Calendar.MONTH, month)\n                        cal.set(Calendar.DATE, date)\n\n                        val time = SimpleDateFormat(\"yyyy-MM-dd\", Locale.CHINA)\n                        dateTextView.text = time.format(cal.time)\n                    },\n                    cal.get(Calendar.YEAR),\n                    cal.get(Calendar.MONTH),\n                    cal.get(Calendar.DATE)\n            ).show()\n```\n\n时间弹框\n\n```kotlin\nTimePickerDialog(\n                    this,\n                    TimePickerDialog.OnTimeSetListener { _, hour, minute ->\n                        cal.set(Calendar.HOUR_OF_DAY, hour)\n                        cal.set(Calendar.MINUTE, minute)\n\n                        val time = SimpleDateFormat(\"HH:mm\", Locale.CHINA)\n                        timeTextView.text = time.format(cal.time)\n                    },\n                    cal.get(Calendar.HOUR_OF_DAY),\n                    cal.get(Calendar.MINUTE),\n                    true\n            ).show()\n```\n\n## 12GitHubStars\n\nOkHttpClient\n\n```kotlin\nval client = OkHttpClient()\n            val request = Request.Builder()\n                    .url(\"https://api.github.com/users/$username/starred\")\n                    .build()\n\n            client.newCall(request).enqueue(object: Callback {\n                override fun onFailure(call: Call?, e: IOException?) {\n                    Toast.makeText(this@MainActivity, \"get data failed\", Toast.LENGTH_SHORT).show()\n                }\n\n                override fun onResponse(call: Call?, response: Response?) {}\n            })\n```\n\n## 13LocalStorage\n\n存\n\n```kotlin\nval preference = PreferenceManager.getDefaultSharedPreferences(this)\n            val editor = preference.edit()\n            editor.putString(\"login_name\", name)\n            editor.apply()\n\n```\n\n取\n\n```kotlin\nval preference = PreferenceManager.getDefaultSharedPreferences(this)\n            val name = preference.getString(\"login_name\", \"\")\n            if (name.isEmpty()) {\n                Toast.makeText(this, \"name is empty\", Toast.LENGTH_SHORT).show()\n            }\n            nameTextView.text = name\n```\n\n## 14Ball\n\n```kotlin\nanimator = ObjectAnimator.ofFloat(imageView4, \"translationX\", 0f, 600f, 0f)\nanimator.duration = 1500\nanimator.interpolator = AccelerateInterpolator()\nanimator.start()\n```\n\n## 15Notification\n\n其实大部分API魅族都给砍了,所以加title啥的就没有必要了\n\n```kotlin\nval notify = NotificationCompat.Builder(this, \"channel id test\")\n                    .setSmallIcon(R.drawable.img)\n                    .setLargeIcon(BitmapFactory.decodeResource(resources, R.drawable.img))\n                    .setContentTitle(\"Notification\")\n                    .setContentText(\"It's time\")\n                    .setVibrate(longArrayOf(300, 600, 300, 600))\n                    .setLights(Color.RED, 1000, 1000)\n                    .build()\n            val noticeManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager\n            noticeManager.notify(1, notify)\n```\n\n## 16PushMessaging\n\n```kotlin\nval intent = Intent(\"gongMsg\")\nintent.putExtra(\"message\", text)\nbroadcast.sendBroadcast(intent)\n```\n\n## 17PullToRequest\n\nfragment记得加高度\n\n## 18SideMenu\n\n安卓常见的左滑目录\n\n## 19Sound\n\n音乐播放器,还是用默认的style吧,换一个卡得不行\n\n## 20ActivityTransition\n\nActivity转场动画\n\n## 21LayoutSwitcher\n\nGrid布局变化\n\n## 22LocalDatabase\n\n本地的SQL\n\n## 23speech\n\nTTS, 魅族居然不支持\n\n## 24Painter\n\nCanvas\n\n## 25Face\n\n人脸检测, 但是并没检测出来我\n\n## 26ActionRecieve - ActionSend\n\n```kotlin\nval intent = Intent()\nintent.action = Intent.ACTION_SEND\nintent.putExtra(Intent.EXTRA_TEXT, textEdit.text.toString())\nintent.type = \"text/plain\"\nstartActivity(intent)\n```\n\n接受的时候 intentfilter 需要加入\n\n```kotlin\n<action android:name=\"android.intent.action.SEND\" />\n<category android:name=\"android.intent.category.DEFAULT\" />\n<data android:mimeType=\"text/plain\" />\n```\n\n## 27ShakeIt\n\n摇一摇\n\n## 28Tabs\n\n顶部 tab\n\n## 29Floats\n\n自定义悬浮框 和 右下角悬浮按键\n\n## 30Video\n\n和播放器其实类似\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2018/02/03/webpack-nestjs.md","slug":"2018/02/03/webpack-nestjs","body":"# Webpack + NestJS 全栈自动刷新\n\n> 本来想写热启动, 算了, 其实就是刷新了, 实事求是点好.\n\n去年我单位所有项目进入前后端同构的状态, 主要的工具是 NestJS 和 React,\n但还没有做过热启动, 反正开始重写主页了, 顺带着做一下.\n\n## NestJS 自动刷新\n\nNestJS 本身就利用 Nodemon 实现了文件修改后自动重启.\n\n```javascript\n{\n    \"watch\": [\n        \"src\"\n    ],\n    \"ext\": \"ts\",\n    \"ignore\": [\n        \"src/**/*.spec.ts\"\n    ],\n    \"exec\": \"node ./dev/index\"\n}\n```\n\n利用 ts-node 开发速度也比编译后再开发快很多\n\n## NestJS 无缝使用 Express\n\nNestJS 虽然基于 Express, 但是语法和 Express 区别很大, 好在可以直接把 Express 的实例作为子类使用\n\n```typescript\nasync function bootstrap() {\n    const instance = express();\n    instance.use(morgan(\"short\")); // 一个日志中间件\n    const app = await NestFactory.create(\n        ApplicationModule,\n        instance,\n    );\n    await app.listen(8080);\n}\n```\n\n## Webpack 自动刷新\n\nwebpack 自动更新, 简单地说就是用 webpackDevMiddleware 代替 express.static.\n\n先给js里面加上webpack-hot-middleware/client, 这里偷下懒, 每次 index.tsx 更新后页面都会重启.\n\n```javascript\n// webpack.config.js\nmodule.exports = {\n    entry: [\n        \"./src/public/index.tsx\",\n        \"./node_modules/webpack-hot-middleware/client.js?reload=true\"\n    ],\n    output: {\n        path: path.resolve(__dirname, \"./dist/public/\"),\n        filename: \"index.js\",\n        publicPath: \"/public\"\n    },\n}\n```\n\nserver 部分, 要把 express.static 注释掉\n\n```typescript\nconst webpackConfig: webpack.Configuration = webpackRawConfig as any;\nconst webpackCompiler = webpack(webpackConfig);\nconst webpackDevConfig: webpackDevMiddleware.Options = {\n    publicPath: webpackConfig.output.publicPath,\n};\n\ninstance.use(webpackDevMiddleware(webpackCompiler, webpackDevConfig));\ninstance.use(webpackHotMiddleware(webpackCompiler));\n```\n\n***nodemon 别加 tsx, 编译起来真的很慢***","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2018/02/06/TexturePacker.md","slug":"2018/02/06/texturepacker","body":"# 用 TexturePacker 做雪碧图\n\n在 setting 里面选择格式, 如 PixiJS, 然后点击 Publish Sprite Sheet 会生成对应的 png 和 json","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2018/02/07/Webpack.md","slug":"2018/02/07/webpack","body":"# webpack 前端热更新\n\nWebpack仅仅实现前端热更新要比前后端同构简单得多, sourceMap 是必须加的, 用来判断哪些文件更新.\n\n```typescript\n// webpack.config.ts\nimport * as webpack from \"webpack\";\nimport * as path from \"path\";\n\nconst config: webpack.Configuration = {\n    entry: [\n        \"./src/index.tsx\",\n    ],\n    output: {\n        path: path.resolve(__dirname, \"./public\"),\n        filename: \"index.js\",\n        publicPath: \"/public/\",\n    },\n    module: {\n        loaders: [\n            {\n                test: /\\.tsx?$/,\n                loader: \"ts-loader\",\n                exclude: /node_modules/\n            }\n        ]\n    },\n    devtool: \"source-map\",\n    devServer: {\n        hot: true,\n    },\n    plugins: [\n        new webpack.NamedModulesPlugin(),\n        new webpack.HotModuleReplacementPlugin(),\n    ]\n}\n\nexport default config;\n```","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2018/02/08/PreactCSSTransation.md","slug":"2018/02/08/preactcsstransation","body":"# PreactCSSTransation 的使用\n\n项目地址 http://gongbushang.com:3000/gongbushang/animateCSSplayground\n\n## 结合 animate.css\n\n## 结合 preact-router\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2018/02/10/FontAwesome-5.md","slug":"2018/02/10/fontawesome-5","body":"# FontAwesome出5啦\n\nQunar的很多图片都是用iconfont实现的,\n我们有一套类似于fontawesome网站的[yicon](https://yicon.ymfe.org),\n\n然而当初构建的时候,对于使用iconfont还是svg是很受争议的.\n其结果自然iconfont胜出,而那时我见识到了svg对于制作模块化图标,\n甚至是动画图标的潜力(SMIL,很遗憾后来为了CSS3,这一功能基本上无人问津了)\n,这些对于svg唯一的缺点就是兼容性了.\n\n看到FontAwesome的第5个版本推荐使用svg, 马上拿过来试试.\n\n[参考代码](http://gongbushang.com:3000/gongbushang/fontAweSome5Playground)\n\n## 官方的React组件\n\n当然也有Vue的, 安装 @fortawesome/fontawesome @fortawesome/fontawesome-free-solid @fortawesome/react-fontawesome \n(0.1.0-3以上有d.ts说明)\n\n利用 create-react-app 快速建立工程\n\n```shell\nnpx create-react-app awesome --scripts-version=react-scripts-ts\n```\n\n```JSX\n<FontAwesomeIcon icon={faCoffee}/>\n```\n\n直接使用,非常简单\n\n## 新功能:变形\n\n比如放大(grow)或者缩小(shrink),\n后面的数字的单位是 1/16em.\n\n```JSX\n<FontAwesomeIcon\n    {...{\n        icon: faCoffee,\n        border: true,\n        fixedWidth: true,\n        transform: \"shrink-8\",\n    }}\n/>\n```\n\n上(up) 下(down) 左(left) 右(right)\n垂直翻转(flip-v) 水平翻转(flip-h) \n旋转(rotate) \n\n## 新功能:遮罩\n\n```JSX\n<Font\n    {...{\n        icon: faCoffee,\n        border: true,\n        fixedWidth: true,\n        transform: \"shrink-8\",\n        mask: faSquare,\n    }}\n/>\n```\n\n## 新功能:图层\n\n两个图标层叠\n\n```JSX\n        <span className=\"fa-layers fa-fw fa-border\">\n          <Font\n            {...{\n              icon: faCircle,\n            }}\n          />\n          <Font\n            {...{\n              icon: faCoffee,\n              transform: \"shrink-7\",\n              style: {\n                color: \"#fff\"\n              }\n            }}\n          />\n        </span>\n```\n\n图标添加数字角标,默认右上(指定位置: fa-layers-${bottom|top}-${left|right}).\n\n```JSX\n        <span className=\"fa-layers fa-fw\">\n          <Font\n            {...{\n              icon: faAlignJustify,\n            }}\n          />\n          <span className=\"fa-layers-counter\">1111</span>\n        </span>\n```\n\n叠加文字\n\n```JSX\n        <span className=\"fa-layers fa-fw\">\n          <Font\n            {...{\n              icon: faSquare,\n            }}\n          />\n          <span\n            {...{\n              className: \"fa-layers-text\",\n              style: {\n                color: \"#fff\"\n              }\n            }}\n          >\n          e\n          </span>\n        </span>\n```\n\n## 总结\n\nFontAwesome 总的来看,不考虑兼容性的话的确可以使用,\n而且随着emoji的推广, Material Design等各种设计模式的诞生,\n彩色的可模块化的图标方案会逐渐替代现有的单色图标.\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2018/02/14/Valentine's-Day-for-you-some-color-to-see.md","slug":"2018/02/14/valentines-day-for-you-some-color-to-see","body":"# 情人节给你点颜色看看\n\n![示例代码](http://gongbushang.com:3000/gongbushang/pixijsPlayground/src/master/src/12-hsl_hsv.ts)\n\nCMYK用于打印, RGB用于显示屏, 然而二者都不能直观的展示颜色, 于是有了 HSL 和 HSV 坐标系.\n\n## 简介\n\n今天看看HSL和HSV转化RGB, [维基地址](https://zh.wikipedia.org/wiki/HSL%E5%92%8CHSV%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4).\n\n![HSL与HSV](https://upload.wikimedia.org/wikipedia/commons/thumb/b/b6/HSL_HSV_cylinder_color_solid_comparison.png/800px-HSL_HSV_cylinder_color_solid_comparison.png)\n\n* H 指的是 hue 色相 [0-360]\n* S 指的是 saturation 饱和度 [0-1]\n* V 指的是 value 明度 [0-1]\n* L 指的是 light 亮度 [0-1]\n\n## HSV转换RGB\n\nHSL转换RGB有点烦(我认为是这样的), 维基里面有详细的解释, HSV到比较简单\n\n```typescript\n/**\n * hsv2rgb\n * @param {number} h hue 色相 [0, 360]\n * @param {number} s saturation 饱和度 [0, 1]\n * @param {number} v value 明度 [0, 1]\n * @returns [r, g, b] 分别取值 [0, 255]\n */\nfunction hsv2rgb(\n    h: number,\n    s: number,\n    v: number,\n) {\n    // 色相\n    while(h < 0) {\n        h += 360;\n    }\n    h = h % 360;\n    // 饱和度\n    s = s < 0? 0: s > 1? 1: s;\n    // 明度\n    v = (v < 0? 0: v > 1? 1: v)*255;\n\n    let hi = (h/60|0)%6;\n    let f = h/60 - hi;\n    let p = v*(1-s) | 0;\n    let q = v*(1-f*s) | 0;\n    let t = v*(1-(1-f)*s) | 0;\n    v |= 0;\n    switch (hi) {\n        case 0: return [v, t, p];\n        case 1: return [q, v, p];\n        case 2: return [p, v, t];\n        case 3: return [p, q, v];\n        case 4: return [t, p, v];\n        case 5: return [v, p, q];\n    }\n}\n```\n\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2018/02/19/PixiJS.md","slug":"2018/02/19/pixijs","body":"# 春节的PixiJS试炼\n\n[代码地址](http://gongbushang.com:3000/gongbushang/pixijsPlayground)\n\n1. 展示雪碧图\n\n2. 容器 Container\n\n3. 图形 Graphics\n\n4. 遮罩 Mask\n\n5. 动画 Ticker\n\n6. 文字\n\n7. 动态图\n\n8. 交互\n\n9. 自适应\n\n10. datGUI\n\n11. 上色\n\n12. HSV、HSL色彩空间\n\n13. 混合模式 blend\n\n14. 材质 texture\n\n15. 滤镜 filter\n\n16. 骨骼 snake\n\n17. 骨骼 goblin\n\n18. 粒子 particles\n\n19. 实例一 滚动的圆\n\n20. 实例二 万花筒\n\n另外还想做两个 [万花尺](https://ithelp.ithome.com.tw/articles/10195023)、[印章](https://ithelp.ithome.com.tw/articles/10195375) ，\n感觉和试炼关系不大以后补充。","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2018/03/20/I-am-bored.md","slug":"2018/03/20/i-am-bored","body":"# 好无聊\n\n最近工作很忙、还要雅思考试、还感冒了，真是心力俱疲。\n\n![lena](http://ww1.sinaimg.cn/large/89d0a2e1ly1fpjg5b5wc7j20e80e812x.jpg)\n\n但是这些都是打不到我的！！！！\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2018/04/09/GraphQL.md","slug":"2018/04/09/graphql","body":"# GraphQL的使用\n\n> you can find the code in http://gongbushang.com:3000/gongbushang/graphql_starter","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2018/04/10/Archlinux-VScode.md","slug":"2018/04/10/archlinux-vscode","body":"# ArchLinux 修改 VScode 可监视文件大小\n\nhttps://github.com/guard/listen/wiki/Increasing-the-amount-of-inotify-watchers\n\n```shell\necho fs.inotify.max_user_watches=524288 | sudo tee /etc/sysctl.d/40-max-user-watches.conf && sudo sysctl --system\n```\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2018/04/16/lego.md","slug":"2018/04/16/lego","body":"# lego系统一岁啦\n\n![logo](http://ww1.sinaimg.cn/large/89d0a2e1ly1fqer3a0s0pj20sg0bk0wr.jpg)\n\n大概看了下去年的博客，我大概在五月初，对lego的第一次上线做了总结，那么现在大概就是lego的一周岁生日了。\n\n## lego 的定义\n\n![lego云图](http://ww1.sinaimg.cn/large/89d0a2e1ly1fqemomvxyqj20sg0lcdo4.jpg)\n\n支付lego平台是一个支持多维度线上配置的web组件化前后端同构渲染平台，覆盖从服务端到web前端再到数据监控的整体解决方案，目前服务于去哪儿网会员的【我的钱包】【我的银行卡】【绑卡服务】【实名认证】等服务。\n\n## lego 搭建背景\n\n![ykit](http://ww1.sinaimg.cn/large/89d0a2e1ly1fqem7mt787j20jc0fit9k.jpg)\n\n* 公司内部正在要求使用 ykit 代替 fekit 打包前端代码，对 fe/member-mobile 来说这种改动相当于全项目重构。\n\n```shell\nbusiTypeId=WLHotelHD&\ncouponAmount=300& bannerLink=http%3A%2F%2Fwww.qunar.com%2F& HMAC=362b0da8eb2f95cb33608cf4584c7700&\nagreement=&\ndid=865630020132708&\npid=10010&\nextraJson=&\ncardType=ALL& \nversion=20140808& title=%E7%BB%91%E5%8D%A1%E9%A2%86%E7%BA%A2%E5%8C%85&\nisObtainCoupon=1& \ncouponSource=pay_test& \nuserId=1444548113& \nsuccessURL=http%3A%2F%2Ftcbeta2.qunar.com%2Factivity%2Fspringgift%3Ftpl%3Dredirect%26couponId%3Dundefined& \ngid=8438932D-5548-D769-1AF7-22274CDE88E4&\nbindCardRule=%5B%22%E9%A6%96%E6%AC%A1%E7%BB%91%E5%8D%A1%E6%88%90%E5%8A%9F%EF%BC%8C%E4%B8%94%E8%AF%A5%E9%93%B6%E8%A1%8C%E5%8D%A1%E6%9C%AA%E5%9C%A8%E5%8E%BB%E5%93%AA%E5%84%BF%E7%BD%91%E7%BB%91%E5%AE%9A%E8%BF%87%E7%9A%84%E7%94%A8%E6%88%B7%EF%BC%8C%E5%8D%B3%E5%8F%AF%E8%8E%B7%E5%BE%97%E4%BC%9A%E5%91%98%E7%BA%A2%E5%8C%85%E3%80%82%22%2C%22%E6%AF%8F%E4%B8%AA%E7%94%A8%E6%88%B7%E5%8F%AA%E5%8F%AF%E7%BB%91%E5%8D%A1%E9%A2%86%E5%8F%96%E4%B8%80%E6%AC%A1%E4%BC%9A%E5%91%98%E7%BA%A2%E5%8C%85%E3%80%82%22%2C%22%E6%B4%BB%E5%8A%A8%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%87%BA%E7%8E%B0%E4%BD%9C%E5%BC%8A%E8%A1%8C%E4%B8%BA%EF%BC%88%E5%A6%82%E6%89%B9%E9%87%8F%E6%B3%A8%E5%86%8C%E3%80%81%E6%81%B6%E6%84%8F%E8%B4%AD%E4%B9%B0%E3%80%81%E8%99%9A%E5%81%87%E4%BA%A4%E6%98%93%E7%AD%89%EF%BC%89%EF%BC%8C%E5%8E%BB%E5%93%AA%E5%84%BF%E7%BD%91%E5%B0%86%E8%87%AA%E5%8A%A8%E5%8F%96%E6%B6%88%E6%82%A8%E6%9C%AC%E6%AC%A1%E6%B4%BB%E5%8A%A8%E8%AE%A2%E5%8D%95%EF%BC%8C%E5%B9%B6%E6%9C%89%E6%9D%83%E5%86%BB%E7%BB%93%E8%B4%A6%E5%8F%B7%E5%B9%B6%E5%8F%96%E6%B6%88%E6%82%A8%E5%90%8E%E7%BB%AD%E5%8F%82%E4%B8%8E%E5%8E%BB%E5%93%AA%E5%84%BF%E7%BD%91%E4%BB%BB%E6%84%8F%E6%B4%BB%E5%8A%A8%E7%9A%84%E6%9D%83%E5%88%A9%EF%BC%8C%E5%BF%85%E8%A6%81%E6%97%B6%E8%BF%BD%E7%A9%B6%E6%B3%95%E5%BE%8B%E8%B4%A3%E4%BB%BB%E3%80%82%22%5D& \nvid=60001092&\nmerchantCode=WLHotelHDJK001&\nreturnURL=https%3A%2F%2Fmembermobilebetak.qunar.com%2Fm%2Fmember%2Fasset%2Fcoupon%2Fdetail.html& bindCardSource=coupon_bind& banner=https%3A%2F%2Fsource.qunarzz.com%2Fsite%2Fimages%2Fzhuanti%2Fhuodong%2Fflight_free_banner.jpg\n```\n\n* member-mobile 内部已经有根据传递参数配置页面展示的方法，但是很多参数相对于来源是静态的，同时如果需要增加新参数或者新来源的时候需要前后端介入开发，大概会需要 2~3pd。\n\n![使用的工具](http://ww1.sinaimg.cn/large/89d0a2e1ly1fqeqvbrmjvj20sg0lc77v.jpg)\n\n* 前端以及node的一系列框架工具逐渐成熟，足以制作类似于lego的渲染系统。\n\n* 公司的 QConfig 支持 JSON 类型的配置文件，并且已经可以在 node 端使用。\n\n## 编程语言的选择\n\n![Typescript](http://ww1.sinaimg.cn/large/89d0a2e1ly1fqeowo5o6jj20gx0gxwf6.jpg)\n\nmember-mobile 为了保证浏览器兼容性用的是 ES5，然而更多的代码库使用的是 ES6 编写，使用的时候再编译成 ES5。但是，无论 ES5 还是 ES6 都是动态类型 JS，无法对代码进行类型检查。\n\n至于关于 typescript 的好处，我不在此多余阐述，可以参考我过去的记次分享 \n\n[typescript干货](http://gongbaodd.github.io/fe/2017/05/04/1TypeScript%E5%B9%B2%E8%B4%A7.html) \n\n[Typescript sucks but long live the types\n](http://gongbaodd.github.io/fe/2017/09/18/Typescript-sucks-but-long-live-the-types.html) 。\n\n[TypeScript编译抽象语法树](http://gongbaodd.github.io/fe/2018/01/03/typescript%E7%BC%96%E8%AF%91AST%E8%AE%AD%E7%BB%83.html)\n\n## 架构设计\n\n![架构设计](http://ww1.sinaimg.cn/large/89d0a2e1ly1fqeqvsivq4j20sg0lcaee.jpg)\n\nlego 参考了公司内普遍使用的增加一层 node 层作为渲染层的方案，然而工程上利用 webpack 可以分别打包以及 js 可以在双端运行的特性，实现了前后端同构方案，这样再开放上无需在 node 层增加开发人员，具体的实现请参考[【erʌpt】一个前后端同构的设计思想](http://gongbaodd.github.io/fe/2017/08/15/Er%CA%8Cpt-%E4%B8%80%E4%B8%AA%E5%89%8D%E5%90%8E%E7%AB%AF%E5%90%8C%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3.html)。\n\n### Qxf 作为 node 服务框架\n\nQxf 是 Qunar 的 node 服务框架，基于 Express，Express 也是目前被最广泛使用的框架。\n\n* q-version QZZ版本管理\n* q-logger 日志系统\n* q-exception 异常捕获\n* q-monitor 监控系统\n* q-healthcheck 响应Ngix请求\n\nQxf 包含的模块使得 lego 在搭建初期不需要重建轮子，节省了很多时间。同时因为其基于 Express,　更有利于搭建　restfull 接口。\n\n### Preact 作为同构渲染框架\n\n![Preact logo](https://opencollective-production.s3-us-west-1.amazonaws.com/3fd44c50-b42b-11e6-8e7e-5955bbcb143d.png)\n\nlego 使用 preact 作为前后端的渲染框架，preact 的包大小是 react 的 1/20，同时 preact 对 typescript 的支持是目前除 angular 外最好的框架。\n\n### 统一路由地址\n\nlego 在 node 端使用　preact-router 渲染路由路径，而在客户端结合　HashHistory 使得客户端无需刷新页面更新路由。\n\n```shell\n# node\n\n/bindCard/default/index\n\n# client\n\n/bindCard/defaut/index#/index/auth\n```\n\n### HTTP 连接\n\n起初 lego 使用的是 fetch 作为前后端接口交互框架，然而实际使用后我们全部改用了 Axios，主要原因有下。\n\n* Axios 双端完全兼容，只有部分参数不同。\n* Axios 支持超时，超时后可以 abort 不多于占用 socket。\n* Axios 可以配置中间件用来处理登录情况。\n\n## QConfig 配置\n\n在 QConfig 中，每一个项目都有自己的配置文件（JSON类型）\n\n![QConfig配置](http://ww1.sinaimg.cn/large/89d0a2e1ly1fqer9g1ivej20lg0y0gnu.jpg)\n\n每个 JSON 文件都有一个 solutions 字段，里面是按照来源存放的配置文件，每次使用的时候配置文件会和 default 混合一次确保配置的完整性。\n\n![JSON](http://ww1.sinaimg.cn/large/89d0a2e1ly1fqerbb3zwqj20ia0d6dgr.jpg)\n\n## Hybrid 桥\n\n用于 Qunar 端的 HYSDK 并没有完全适配公司的客户端，我们开发了 PayDevice 来补足短板\n\n```typescript\nclass PayDevice {\n    static readonly NAME_IOS_FIX: string;\n    static readonly NAME_IPX_FIX: string;\n    static readonly QUNAR_IPHONE: string;\n    static readonly QUNAR_APHONE: string;\n    static readonly GONGLUE: string;\n    static readonly FIX_NAV_IOS_HEIGHT: number;\n    static readonly FIX_NAV_IPX_HEIGHT: number;\n    static readonly FIX_STATUS_IOS_HEIGHT: number;\n    static readonly FIX_STATUS_IPX_HEIGHT: number;\n    static readonly FIX_BOTTOM_IPX_PAD: number;\n    private static readonly regularExp;\n    private static getLowerUA;\n    private static getMatchArray;\n    static getAppProtocol: typeof getAppProtocol;\n    static sniff: typeof sniff;\n    static isIPad: typeof isIPad;\n    static isIPod: typeof isIPod;\n    static isIPhone: typeof isIPhone;\n    static isCtripApp: typeof isCtripApp;\n    static isApp: typeof isApp;\n    static isAppIPhoneX: typeof isAppIPhoneX;\n    static isCtripAppIPhoneX: typeof isCtripAppIPhoneX;\n    static trim: typeof trim;\n    static getCookie: typeof getCookie;\n    static getQN270: typeof getQN270;\n    static getBodyFixClass: typeof getBodyFixClass;\n    static sniffmiddleware: typeof sniffmiddleware;\n}\n```\n\n## 监控系统\n\n我们修改了 Qxf 的 logger 和 monitor 以适配支付中心的鹰眼系统，更新　member-mobile 的 payGa 以接收前端埋点。\n\n## 支付组件库\n\n### PayUI\n\n我们经过和 UE 协调，利用 Yo 制作了一套 PayUI.css，可以直接作为支付中心样式使用。\n\n![PayUI](http://ww1.sinaimg.cn/large/89d0a2e1ly1fqesxkdjt7j20c80a074u.jpg)\n\n### TS PAY COMS\n\n利用 payUI 制作的组件库，使用 rollup commonJS 打包，提供工厂方法构建。\n\n![TS PAY COMS](http://ww1.sinaimg.cn/large/89d0a2e1ly1fqet3rrs2yj217c0uwwjt.jpg)\n\n```javascript\nexport const FormID = Factory.input(\n    Component, h, { CheckUtil, PayInput, PayList, MemICO },\n);\n\nexport const FormIDTlist = Factory.list(\n    Component, h, { FormID, CheckItem, PayPopup, PayList },\n);\n```\n\n## 打包系统优化\n\n![打包系统](http://ww1.sinaimg.cn/large/89d0a2e1ly1fqes6t5852j21k60uy1kx.jpg)\n\n### typescript编译优化\n\n使用 HappyPack 分别使用３个线程处理前后端编译，利用 ForkTsCheckerWebpackPlugin 使用一个线程做类型检查，使用 cache-loder 缓存已编译的内容，减少重复编译时间。\n\n经过优化，ts 的编译时间减少到原来的 1/2。\n\n### CSS的优化\n\n#### 使用 PostCSS 逐步代替 Yo\n\nYo 的缺点\n\n* 使用 SASS 逐文件单线程编译，效率慢\n\n* 使用的是 SASS 语法，不是原生 CSS 语法，并只会对使用 Yo 语法的地方做浏览器兼容处理,没有编辑器支持\n\n```CSS\n/*** Yo 源代码 ***/\n.foo {\n    @include yoflex();\n}\n\n.bar {\n    display: flex;\n}\n```\n\n```CSS\n/*** 生成代码 ***/\n.foo {\n    display: -moz-flex;\n    display: -webkit-flex;\n    display: flex;\n}\n\n.bar {\n    display: flex;\n}\n```\n\n#### 使用 CSS-modules 避免全局类名覆盖\n\nCSS 一直存在很严重的类名覆盖问题，由于 CSS 的类名都存在于一个全局域中，当两个组件中存在重名类名，其中一个会被覆盖。\n\n```CSS\n/**a-button.css**/\n.button {\n    background: red;\n    background: blue;\n}\n/**b-button.css**/\n.button {\n    background: blue;\n}\n```\n\n使用 CSS-modules 后，编译好的 CSS 文件会处理掉重名类名。\n\n```CSS\n.button-a {\n    background: red;\n}\n.button-b {\n    background: blue;\n}\n```\n\n### 发布使用 node_cache_share 缓存 node_modules\n\n### 异步处理生成文件\n\n使用了以上优化，我们最终将编译速度由初期的五分钟优化到现在的26秒。\n\n## 过去一年遇到的问题\n\n* 大部分开发人员的水平仍然停留在13年左右，知道的优化方案相对过时，对于“枚举”、“泛型”、“私有成员”等定义都比较模糊。\n* 公司内部前端解决方案不统一，平台部门的解决方案往往在重复造轮子，到我们这里必须要修改后才能使用。\n* 很多人抵触学习新技术，往往是需要用的时候再去学习，当然对应的前端发展速度也前所未有的快。\n* 因为lego放弃了最初微服务的方案，杂糅很多业务逻辑后，现在功能比较臃肿，新功能的推广只能循序渐进。\n* 每次修改需要等待编译，开发起来比较慢。\n* restful API只是一个思想，还没有所谓的最佳实践，推广至开发人员后，一个接口的定义会跟开发人员的能力而显得参差不齐。\n\n## 解决方案\n\n* 【开发能力】增加技术分享，补足技术瓶颈\n* 【重复造轮子】我们建立了qtalk群，互相分享各部门的使用经验\n* 【强制代码规范】修改编译配置项阻止不规范的代码上线\n* 【减少冗余业务】和产品讨论，把没必要的业务逻辑删除\n* 【加快编译速度】打开多线程、缓存，使用 webpack-server 和 nodemon 处理本地开发环境\n* 【考虑新的传输协议】考虑使用 object-validator 或者 apollo + graphQL 实现。\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2018/04/19/CSS-3D.md","slug":"2018/04/19/css-3d","body":"# 用CSS制作3D动画\n\n![](http://ww1.sinaimg.cn/large/89d0a2e1ly1fqi1sjijteg20np0dce82.gif)\n\n直到前几天，我需要做一个简单的3D动画时候，我才意识到其实我还没有用CSS做过3D动画。\n\n很多人其实认为只要写下\n\n```CSS\n.3d-Object {\n    transform: rotateY(180deg);\n}\n```\n\n但最终效果并不是三维的旋转，原因是它的父元素必须是一个有深度的盒子。\n\n```CSS\n.box {\n    perspective: 800px;\n}\n\n.box .3d-Object {\n    transform: rotateY(180deg);\n}\n```\n\n如果是希望旋转180度后不展示背面可以添加 backface-visibility。\n\n```CSS\n.box .3d-Object {\n    transform: rotateY(180deg);\n    backface-visibility: hidden;\n}\n```\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2018/05/28/inkscape.md","slug":"2018/05/28/inkscape","body":"# Inkscape 简单使用\n\n## 改变画布为横版\n\nFile - Document Properties - LandScape\n\n## 旋转对象\n\n慢速度点击两次\n\n## 多选\n\n使用 shift 和 鼠标左键\n\n## 小试牛刀\n\n![](http://ww1.sinaimg.cn/mw690/89d0a2e1ly1frr2us5d6kj21uw1dyaft.jpg)","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2018/06/22/Meteor-ToDoAPP.md","slug":"2018/06/22/meteor-todoapp","body":"# 使用 Meteor 快速搭建TODO APP\n\n代码在 https://github.com/gongbaodd/MeteorTodoAPP 这里做一下简单记录。\n\n## 把冰箱门打开\n\n```shell\nmeteor create app\n```\n\n打开 app 文件夹，可以看到 meteor 项目了，官网有各个文件夹的说明， 在此不赘述。\n\n```shell\nmeteor\n```\n\n可以在 localhost:3000 看到初始项目了。\n\n到```.meteor/package```下删除autopublish 和 insecure，添加 apollo 和 accounts-passwd\n\n## 把大象放进去\n\n下面记录一下踩到的坑。\n\n### CSS\n\ncss很尴尬，我想用postcss，但貌似meteor的postcss包并不是很给力。自带的css的打包功能貌似不能用（起码我没整出来）。好在 ecmascript 包可以引用 css。\n\n项目直接使用了bulmaCSS， 很方便。\n\n### Apollo增加用户token\n\n要用到Apollolink，在请求头里面添加meteor-login-token，在后面的 resolver 里面的 context 对象里面就有 userId 这个值了。\n\n```JavaScript\nconst apolloLink = new ApolloLink(\n    (operation, forward) => {\n        const token = Accounts._storedLoginToken();\n        operation.setContext(\n            _ => ({\n                headers: {\n                    'meteor-login-token': token,\n                }\n            })\n        );\n        return forward(operation);\n    }\n);\n```\n\n### Graphql\n\ngraphql文件修改了并不能触发重启，而且有的时候甚至一直读缓存而不在乎文件有修改，要把 makeExecutableSchema 参数做修改之后才能正常运行。\n\n## 总结\n\n用 Meteor 做项目的确是目前我知道的最快速了，主要是不用考虑数据库的种种，要知道，即使是黑盒，对于前端工程师来说，数据库还是很少触碰的。\n\nGraphql，最大的优势就是给接口做了个强制定义，以后不必去维护什么v1、v2的接口了。\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2018/07/07/GulpV4-Task.md","slug":"2018/07/07/gulpv4-task","body":"\n# Gulp v4 之后 task 必须传函数\n\nhttps://fettblog.eu/gulp-4-parallel-and-series/\n\n如链接所说，为实现并行操作，原来的\n\n```javascript\ngulp.task(\"default\", [\"css\", \"html\", \"js\"]);\n```\n\n已经改为\n\n```javascript\ngulp.task(\"default\", gulp.parallel([\"css\", \"html\", \"js\"]));\n```\n\n而如果想串行执行的话可以用`gulp.series`\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2018/07/10/Apollo-Meteor.md","slug":"2018/07/10/apollo-meteor","body":"\n# 没有手动配置过 Apollo 都不知道 Meteor 帮你做了多少事\n\n## Server 端\n\n```ts\nexport class AppModule implements NestModule {\n  graphiql(customer: MiddlewareConsumer) {\n    if (!isDev) return;\n    customer\n      .apply(graphiqlExpress({ endpointURL: graphql }))\n      .forRoutes(graphiql);\n  }\n  graphql(customer: MiddlewareConsumer) {\n    customer\n      .apply(graphqlExpress(req => ({ schema, rootValue: req })))\n      .forRoutes(graphql);\n  }\n  configure(customer: MiddlewareConsumer) {\n    this.graphiql(customer);\n    this.graphql(customer);\n  }\n}\n```\n\n## client\n\n```typescript\n@Component({\n  components: {\n    MeCard,\n    Links\n  },\n  apollo: {\n    hello: {\n      query: gql`\n        {\n          hi\n        }\n      `,\n      update(data) {\n        return data.hi;\n      }\n    }\n  }\n})\nexport default class IndexPage extends Vue {\n  data() {\n    return {\n      hello: \"\"\n    };\n  }\n}\n```\n\n同时要在 nuxt 配置中增加 apollo 的配置项\n\n```typescript\n[\n  \"@nuxtjs/apollo\",\n  {\n    clientConfigs: {\n      default: {\n        httpEndpoint:\n          process.env.HTTP_ENDPOINT || \"http://localhost:3000/graphql\"\n      }\n    }\n  }\n];\n```\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2018/07/27/pixiJS-L.md","slug":"2018/07/27/pixijs-l","body":"# pixiJS 的 l-system 实现\n\n![](https://i0.hdslb.com/bfs/archive/a0a9d5e73809d1a5b41a45cb848575b9af54c865.jpg@320w_200h_100Q_1c.webp)\n\n[pixiJS 的 l-system 实现](https://www.bilibili.com/video/av28166320)","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2018/08/05/CSS Grid Layout.md","slug":"2018/08/05/css-grid-layout","body":"# CSS Grid Layout 使用总结\n\n最近被猎头催的实在不行了（真的，感觉他们更担心我找不到工作），于是我写了份简历给他们。当然了，既然最后要的是PDF，这种机会不试试新的CSS布局还真说不过去。\n\n##　实现圣杯布局\n\n提到CSS布局，自然想到了圣杯，一行header，中间是sidebar和content，底下是footer。\n\n```css\n.grid {\n    display: grid;\n    grid-template-area: \"header header  header\"\n                        \"left   content right\"\n                        \"footer footer  footer\";\n}\n\n.item1 {\n    grid-area: header;\n}\n\n.item2 {\n    grid-area: left;\n}\n\n.item3 {\n    grid-area: content;\n}\n\n.item4 {\n    grid-area: right;\n}\n\n.item5 {\n    grid-area: footer;\n}\n```\n\n很简单，使用 Grid Layout 的最大好处是页面布局由CSS全部接管，意味着想把```.item5```改成header只需要修改```grid-area```即可，```grid-template-area```结合 media query　可以实现适配不同设备，如打印机布局相比于屏幕来说界面比较窄。\n\n```CSS\n@media print {\n    .grid {\n        grid-template-area: \"header\"\n                            \"left\"\n                            \"content\"\n                            \"right\"\n                            \"footer\";\n    }\n}\n```\n\n## 实现无大小限制瀑布流\n\n前端瀑布流在网格布局之下，结合``` grid-auto-flow: row dense;```可以实现大小不一的网格元素按照最合理的形式行填充。\n\n```css\n.grid {\n    display: grid;\n    grid-template-columns: repeat(auto-fill, 100px);\n    grid-template-rows: 100px;\n}\n\n.size-1 {\n    grid-column: span 1;\n    grid-row: span 1;\n}\n\n.size-2 {\n    grid-column: span 2;\n    grid-row: span 2;\n}\n\n.size-3 {\n    grid-column: span 3;\n    grid-row: span 3;\n}\n\n```\n\n## 兼容性\n\n并没有测试IE11，从caniuse可以看到，主流浏览器除了IE11都是不需要家前缀的，IE11需要加-ms前缀（道听途说autoprefixer不会补grid，所以最好手改）。\n\n国产浏览器兼容性就不理想了，除了UC，百度、QQ浏览器都不支持，汗啊，看来浏览器这行业真的是不挣钱了，所以如果要支持这些浏览器还需要再等等。\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2018/08/07/React16.md","slug":"2018/08/07/react16","body":"# React16 模拟输入框输入事件\n\n照往常，我会新建一个input事件然后dispatch一下，今天在instagram上面试验失败了。原因是React16 内部定义了descriptor拦截了value.\n\n```javascript\nlet input = $0;\nlet value = 'new value';\n\nlet event = new Event('input', { bubble: true });\nevent.simulated = true;\n\nlet tracker = input._valueTracker;\ntracker && tracker.setValue(value);\n\ninput.value = value;\ninput.dispatchEvent(event);\n```\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2018/08/14/AframeJS.md","slug":"2018/08/14/aframejs","body":"# AframeJS 学习笔记\n\n## 创建项目\n\n使用 [npm/angle](https://www.npmjs.com/package/angle)\n\n## ECS(Entity-Component-System)\n\n不懂百度。\n\n## 组件库\n\nhttps://aframe.io/aframe-registry/\n\n## 博客\n\nhttps://aframe.io/blog/\n\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2018/08/22/mock-fs-io.md","slug":"2018/08/22/mock-fs-io","body":"# 单元测试时使用mock-fs模拟IO返回值\n\n最近换工作到了一家对测试要求比较高的公司，相比以前仅仅完成Appnium完全匹配不同，这里要求使用jest自动化测试覆盖率达到80%+，[此处应有jest cheat sheet](https://devhints.io/jest)。\n\n工作过程中有很多需要读配置文件的地方，做法是在本地对应位置放上文件，然后配置ignore掉这个文件进行测试，然而这并不是个很优雅的方式（尤其是当代码中有判断此配置是否存在时，需要手动移动文件），此时即可利用mock-fs。\n\n## 简单使用\n\n```javascript\nconst mock = require('mock-fs');\n\nmock({\n  'path/to/fake/dir': {\n    'some-file.txt': 'file content here',\n    'empty-dir': {/** empty directory */}\n  },\n  'path/to/some.png': Buffer.from([8, 6, 7, 5, 3, 0, 9]),\n  'some/other/path': {/** another empty directory */}\n});\n```\n\n指定的文件夹地址是默认相对于process.cwd()的，当然也可以配置其它地址。执行mock之后，所有有关IO的部分就都被修改了。\n\n## 需要注意的地方\n\n* 因为强制修改了IO，你会发现require也不好用了所以一般放在require之后\n* 记得要在每个用例执行之后回收mock状态\n\n```javascript\ndecribe('# test', () => {\n    const mockfs = require('mock-fs');\n    beforeEach(() => jest.resetModule());\n    afterEach(() => mockfs.restore());\n    it('should do ...', () => {\n        const foo = require('foo.js');\n        mockfs({...});\n        expect(foo)...\n    });\n})\n```","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2018/08/23/prettier-eslint.md","slug":"2018/08/23/prettier-eslint","body":"# 如果prettier和eslint冲突了怎么办\n\n最近工作发现小伙伴都不喜欢用prettier，原因是格式化后的代码其实和之前约定的eslint有出入。\n\n其实安装prettier-eslint之后，你的prettier就不会将代码改成违反eslint规则的样子，在vscode配置中，打开prettier.eslintIntegration。这样自动保存也会避开eslint。\n\n另外prettier文档中也有如何解决二者冲突的方法 https://prettier.io/docs/en/integrating-with-linters.html。","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2018/08/24/eslint-plugin-typelint-jsdoc-linting.md","slug":"2018/08/24/eslint-plugin-typelint-jsdoc-linting","body":"# eslint-plugin-typelint借助jsdoc实现无编译linting级别的类型检查工具","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2018/08/28/Functional Reactive Programming-baconjs.md","slug":"2018/08/28/functional-reactive-programming-baconjs","body":"# Functional Reactive Programming 框架 baconjs","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2018/08/29/OpenAPI-swagger.md","slug":"2018/08/29/openapi-swagger","body":"","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2018/09/23/ibus.md","slug":"2018/09/23/ibus","body":"# 记一个关于 iBus 的教训\n\n大概今年开始，chrome在linux里面就没办法正常看输入框，到了8月更惨，vscode和atom都完蛋了，完全看不到输入法的面板（也许我得考虑英文输入了）。\n\n其实是个hidpi的问题，chromium对输入光标的位置处理和linux处理不同，导致输入法都跪了，没错，不只是fcitx。这次我就以为这是fcitx的bug，换了ibus，结果ibus其实也很多坑。\n\n## 安装和配置ibus\n\nlinux 的profile其实比较混乱， 有.bashrc/.bash_profile/.profile/.xprofile/.environments等等，而且这些点文件在/etc中都有全局备份，所以要检查GTK_IM_CONFIG就要挨个文件找。\n\n记得安装ibus-table，现在gnome和ibus的整合比fcitx好，装好之后可以在setting里面切换输入法。\n\n但是！注意，装了ibus就没有搜狗拼音了，而且并不能解决hidpi问题。无奈我又把fcitx装回来了。\n\n## 不过并不是没有好消息\n\n在KDE环境下面跑的vscode还是能显示的，开心\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2018/10/13/node.md","slug":"2018/10/13/node","body":"# 阿里深圳node地下铁\n\n## 渲染服务化，egg.js北斗\n\n最早同机部署，利用热更新，减少node发布频率。\n\n使用node做页面渲染，渲染好的html给java层，最终分发还是给java。\n\n资源争抢，linux [cgroup](https://wiki.archlinux.org/index.php/Cgroups)，但是没实现。\n\n静态资源分发系统，使用推送的方式（其实我没听懂那面拉取说的是啥。。。），基于阿里的[DragonFly](https://alibaba.github.io/Dragonfly)。\n\n## node devops\n\n[sandbox](https://github.com/midwayjs/sandbox)\n\n代码治理，哎呀就是linting啊typechecking啊。\n\n包治理，到底是大厂，包有问题还能查出来。居然还知道那些应用用过哪些包。\n\n数据治理，错误日志分析。\n\n链路分析\n\n远程调试，可以在办公区调试服务机器。\n\n故障演练，内部平台不给人看啊。[QCon](http://www.infoq.com/cn/presentations/ali-electricity-supplier-fault-management-and-fault-drills-practice) 找到了视频，有机会看下。\n\n另外可以看下[pandora.js](https://github.com/midwayjs/pandora)\n\n## Node-FFI\n\n牛逼你深圳，上哪儿听js的分享能谈到IoT啊。\n\n应用背景是想要用JS去调用C的动态链接库。毕竟JS写起来容易些。\n\n原来多语言交互，通过共享内存、RPC调用或者外部函数调用（FFI）。\n\n[mJS](https://github.com/cesanta/mjs)比较感兴趣，是[mongoose os](https://mongoose-os.com/)的js运行语言。\n\n## Tarsjs\n\n[tars](http://tars.tencent.com/base/tars_index/en/index.html)听起来巨牛逼，没听懂。。。\n\n话说阿里的投屏系统是什么，还带录屏功能，貌似我在mac上没用过投屏系统啊。\n\ntarjs提供了一套高性能的RPC协议，可以用 @tar/stream 获取。\n\n太多了，听不懂啊。\n\n进程管理，进程重启，无损重启，数据监控。\n\n### node监控指标：\n\nmemUsage、 cpuUsage、 eventLoopLag：队列延迟， libuv\n\n### LongStackTrace组件的实现\n\n[问题背景](https://www.ctolib.com/topics-134009.html)\n\n[具体代码](https://github.com/medns/longstack)\n\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2018/10/16/Get.md","slug":"2018/10/16/get","body":"# 世纪话题Get参数传数组\n\n哎呀，这个话题，其实挺简单的，但是仔细想起来，URL的请求参数如下，如果要写数组怎么办？\n\n```\na=1&b=2&c=3\n```\n\n其实无非是解析这个字符串，但是由于没有标准方案，所以大家的处理方法五花八门。我遇到过的方式如下\n\n## 数组标识\n\n```\na[1]=1&a[2]=2\n```\n\n或者\n\n```\na[]=1&a[]=2\n```\n\n这种做法，jquery时代很多，可以很简单分辨出数组，但是取到数据的时候要单独处理key，因为直接取到的值是`a[]`\n\n## 序列化\n\n```\na=%5B1%2C2%5D\n```\n\n少说废话，直接stringify，然后发现URL里面要转义的东西太多了，然后后端取到值还要parse下，因为传来个字符串\n\n## 分隔符分割\n\n```\na=1%2C2\n```\n\n莫不如加个`,`处理下？缺点，找错分隔符的话还是要处理转义，后端还是要单独split下\n\n## 其实有标准的\n\n根据[URLSearchParam](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams)\n\n```\na=1&a=2\n```\n\n如此生成的URLSearchParam对象（类似于Map对象），直接调用```get('a')```方法只会取到一个值，但是执行```getAll('a')```可以获取到数组\n\n既然是标准，koa的koa-qs也是这么处理数组的。\n\n另外URLSearchParam还有一定容错能力，所以即使url被浏览器截断（其实不太会，因为此时报错414）也不会有太大问题。\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2018/10/22/moment.md","slug":"2018/10/22/moment","body":"\n# moment 获取跨越一段时间的月和周\n\n这个实现是同步实现，其实最好改成异步实现。\n\n另外关于```time.startOf('month')```竟然传递的是引用，简单说```time```改变之后这个值还会变，所以要```clone```一下。\n\n```javascript\n/**\n * @param {moment.Moment} _startTime\n * @param {moment.Moment} _endTime\n * @returns {moment.Moment[]}\n */\nfunction getMonths(_startTime, _endTime) {\n\tconst startTime = _startTime.clone();\n\tconst endTime = _endTime.clone();\n\tconst times = [];\n\twhile (\n\t\tendTime > startTime ||\n\t\tstartTime.format('YYYYMM') === endTime.format('YYYYMM')\n\t) {\n\t\tconst month = startTime.startOf('month').clone();\n\t\ttimes.push(month);\n\t\tstartTime.add(1, 'month');\n\t}\n\treturn times;\n}\n\n/**\n * @param {moment.Moment} _startTime\n * @param {moment.Moment} _endTime\n * @returns {moment.Moment[]}\n */\nfunction getDays(_startTime, _endTime) {\n\tconst startTime = _startTime.clone();\n\tconst endTime = _endTime.clone();\n\tconst times = [];\n\twhile (\n\t\tendTime > startTime ||\n\t\tstartTime.format('YYYYMMDD') === endTime.format('YYYYMMDD')\n\t) {\n\t\tconst day = startTime.startOf('day').clone();\n\t\ttimes.push(day);\n\t\tstartTime.add(1, 'day');\n\t}\n\treturn times;\n}\n\n/**\n * @param {moment.Moment} startTime\n * @param {moment.Moment} endTime\n * @returns {moment.Moment[]}\n */\nfunction getWeeks(_startTime, _endTime) {\n\tconst startTime = _startTime.clone();\n\tconst endTime = _endTime.clone();\n\tconst times = [];\n\twhile (\n\t\tendTime > startTime ||\n\t\tstartTime.endOf('week').format('YYYYMMDD') ===\n\t\t\tendTime.endOf('week').format('YYYYMMDD')\n\t) {\n\t\tconst week = startTime.startOf('week').clone();\n\t\ttimes.push(week);\n\t\tstartTime.add(1, 'week');\n\t}\n\n\treturn times;\n}\n```\n\n另外， 用```moment```获取到的```unix```时间戳是秒级别的，而默认js处理```Date.now()```取到的是毫秒级别的，需要单独处理。\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2018/11/16/A-magical-printing-character.md","slug":"2018/11/16/a-magical-printing-character","body":"# 神奇的打印字符\n\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2018/12/16/postman-prescript.md","slug":"2018/12/16/postman-prescript","body":"# postman的prescript对异步代码支持不足\n\n用过postman做集成测试的话，有个prescript功能很不错，就是在执行发送请求之前要执行的脚本。\n\n我曾经以为这个prescript是直接运行的一个js脚本，执行完之后发送请求。但是貌似postman里面处理异步逻辑与v8有所不同。如果你想先发送一个POST请求，然后执行postman的PATCH请求，中间在加一个大概1s的delay，如下代码竟然能实现！\n\n```javascript\n// prescript\npm.sendRequest({...});\nsetTimeout(() => {}, 1000);\n```\n\n这个prescript其实是会对异步代码进行超时处理。无论是多层callback还是promise还是async，但唯独对setTimeout无效。\n\n```javascript\n// callbacks\npm.sendRequest({}, () => {\n    pm.sendRequest({}, () => { ... }); // 这一步回调可能会超时中断\n})；\n```\n\n```javascript\n// promise\nconst req = () => new Promise(res => {\n    pm.sendRequest({}, () => res());\n});\n\nPromise.resolve()\n    .then(req({ ... }))\n    .then(req({ ... }));// 这一步可能会超时中断\n```\n\n```javascript\n// async - await\nconst req = () => new Promise(res => {\n    pm.sendRequest({}, () => res());\n});\n~ async function() {\n    await req({ ... });\n    await req({ ... });// 这一步可能会超时中断\n} ();\n```\n\n因为只要setTimeout的timer不释放prescript就不会被超时中断，可以借助这一点防止prescript超时。\n\n```javascript\nconst TIME_OUT = 200;\nfunction stop() {\n    if (stop.done) {\n        return clearTimeout(stop.timer);\n    }\n    stop.timer = setTimeout(arguments.callee, TIME_OUT);\n}\nstop.done = false;\nstop.timer = setTimeout(stop, TIME_OUT);\n```\n\n想要停止代码的话，只需把stop.done设置为true就可以了。\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2018/12/25/CSS.md","slug":"2018/12/25/css","body":"# 两个学习CSS布局的小游戏\n\n## Grid Layout\n\n[CSS Grid Garden](http://cssgridgarden.com)\n\n![CSS Grid Garden](http://ww1.sinaimg.cn/mw690/89d0a2e1gy1fyirzvparkj21mw0vkn3d.jpg)\n\n## Flexbox Layout\n\n[CSS Flexbox Froggy](https://flexboxfroggy.com/)\n\n![CSS Flexbox Froggy](http://ww1.sinaimg.cn/mw690/89d0a2e1gy1fyis1ajl89j21n20qcafs.jpg)","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2019/01/08/Webpack-V3-V4-globalObject-window.md","slug":"2019/01/08/webpack-v3-v4-globalobject-window","body":"# Webpack从v3升级到v4后默认globalObject会变成window\n\n今天小伙伴出于安全考虑把Webpack从v3升级到v4（太可怕了直接一个大版本更新），结果导致我们node上面引用的umd包竟然就挂了，报错内容是 window is undefined.\n\n搜了下Stack Overflow，果然很多人也有这样的问题。从v4开始，webpack默认globalObject为window。\n\n```\nmodule.exports = {\n    ...\n\toutput: {\n\t\t...\n\t\tglobalObject: 'this'\n\t}\n}\n```\n\n如上改动即可\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2019/02/19/jest-exceedsMaxOf500kb.md","slug":"2019/02/19/jest-exceedsmaxof500kb","body":"# jest 报警 exceedsMaxOf500KB\n\n已经工作快半年了，做个小记录，jest测试的时候偶尔会报lodash exceeds the max of 500KB错误。\n\n查了很多配置，应该是coverage哪里的问题，在coveragePathIgnorePatterns里面忽略```<rootDir>/node_modules/```即可。 ","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2019/03/30/CSS.md","slug":"2019/03/30/css","body":"# 第五届中国CSS大会\r\n\r\n感谢宇神赠票了~大会很多内容收获很多，待我稍加整理发出来。","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2019/04/01/XSS.md","slug":"2019/04/01/xss","body":"# Google 的 XSS 漏洞\r\n\r\n视频地址： [An actual XSS on google.com by Masato Kinugawa. ](https://youtu.be/lG7U3fuNw3A)\r\n\r\n## 简单的背景\r\n\r\n首先正常浏览器在控制台执行以下代码是会弹窗的，也就是说如果一个输入框输入了`<img src=\"\" onerror=\"alert(1)\"/>`，同时前端在回显的时候并没有处理它，页面就会弹窗。\r\n\r\n```javascript\r\nconst a = document.createElement('div');\r\na.innerHTML = '<img src=\"\" onerror=\"alert(1)\"/>';\r\n```\r\n\r\n很简单，只要把里面的标签都给替换成纯文字不就行了？问题又来了，如果我们需要的就是富文本呢？\r\n好在，现在已经有很多`sanitize`的包用来把可能注入代码的地方做转义处理了。\r\n\r\n## 在深入一点\r\n\r\n但是，假设用户输入的不是标准HTML呢？\r\n\r\n如果用户输入的是下面的代码\r\n\r\n```html\r\n<script><p title=\"</script>\">\r\n```\r\n\r\n浏览器会解析成两个节点\r\n\r\n```html\r\n<script><p title=\"</script>\r\n\"&gt;\r\n```\r\n\r\n如果换成DIV标签\r\n\r\n```html\r\n<div><p title=\"</div>\">\r\n```\r\n\r\n则会解析成一个节点\r\n\r\n```html\r\n<div><p title=\"</div>\"></p></div>\r\n```\r\n\r\nscript标签在执行innerHTML的时候并不解析，可见，浏览器对不同标签的处理是不同的，那么，干脆让浏览器来做标签标准化如何？借助template标签就可以。\r\n\r\n```javascript\r\nconst a = document.createElement('template');\r\na.innerHTML = '<div><p title=\"</div>\">';\r\nconsole.log(a.innerHTML); // 输出 <div><p title=\"</div>\"></p></div>\r\n```\r\n\r\n## 问题出现\r\n\r\n问题出现了，假设用户输入的是如下代码呢？\r\n\r\n```html\r\n<noscript><p title=\"</noscript><img src='' onerror='alert(1)'/>\">\r\n```\r\n\r\n在`template`的输出如下\r\n\r\n```html\r\n<noscript>\r\n    <p title=\"</noscript><img src='' onerror='alert(1)'/>\"></p>\r\n</noscript>\r\n```\r\n\r\n可浏览器的解析却如下\r\n\r\n```html\r\n<noscript>\r\n    <p title=\"\r\n</noscript>\r\n    <img src=\"\" onerror=\"alert(1)\">\r\n\"&gt;\r\n```\r\n\r\n怎么会这样？？？原因在于noscript是在不支持script的环境下作为script标签的兼容标签，在template环境下是不支持script的，此时noscript被解析了，而在开了script功能的浏览器却不解析noscript。\r\n\r\n## 修复\r\n\r\n这个问题很快就被Google回滚修复了，bug源于2月的一个功能性提交。","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2019/09/04/webpack.md","slug":"2019/09/04/webpack","body":"# 为webpack工程的本地开发提供代理\n\n首先，我绝对反对线上和本地环境有这种不同配置，但是如果代理是必选项的时候，选择工程化的配置要比每个人维护一套更有效。\n\n需要在webpack.dev.server.config中增加setProxy文件\n\n```\nconst proxy = require('http-proxy-middleware');\n\nmodule.exports = function(app) {\n    app.use(\n        proxy('/api', {\n            target: 'https://xxx.api.com',\n            changeOrigin: true,\n            secure: false,\n            pathRewrite: {\n                '^/api': '/',\n            },\n        })\n    );\n};\n\n```\n\n这样，每个请求`localhost/api`的请求就被代理到`https://xxx.api.com`下了。","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2019/09/06/CSP.md","slug":"2019/09/06/csp","body":"Web UI Security matters\nRead 51 penetration test and Front-End-Checklist first.\n\n1. Reverse tab nabbing\nCRITICALITY:\n\nAn attacker might use this technique to silently load other pages on the parent tab which can be used for malicious operations such as phishing attacks.\n\nSUGGESTED FIX:\n\nPlease ensure that user-controlled (anchor tag with target=\"_blank\") links have the following attribute set: \n\nCopy\nrel=\"noopener noreferrer\"\nMore about the fix: https://cheatsheetseries.owasp.org/cheatsheets/HTML5_Security_Cheat_Sheet.html#tabnabbing﻿\n\n\n2. Content security policy\nCRITICALITY:\nAn attacker may inject scripts into the HTML files to steal user's information, such as Cookie, JWT token. If the CSP header is not offered, the browser will use same-origin policy standard, attackers can do XSS attack by injecting <img/> tags or <script/> tags.\n\nSUGGESTED FIX:\nCurrently we have two kinds of projects:\n\nS3 bucket project: The CI uploads webpack compiled static files to AWS S3 bucket,  the server is served by AWS cloud front.\nNode project: The project has one node server to serve itself.\nFor S3 bucket project\nMost of the CSP directives can be added using <meta/> tags.\n\ninstall csp-html-webpack-plugin into the projectyarn add -D csp-html-webpack-plugin\n\nyou can use the configuration in admin.aftership.com, including reCAPTCHA, Newrelic Browser & google-analytics.\n\nSome directives such as frame-ancestors can not be added by <meta/> tag. A response header is needed to add to the website.\n\nYou cannot add frame-ancestors directive using <meta/>\n\nadd  frame-ancestor _and _X-Frame-Options _in AWS cloudfront _to avoid click jacking attack.\n\nValidations\n\nYou can check your CSP content in [CSP Evaluator](https://csp-evaluator.withgoogle.com/).\n\n3. Subresource Integrity\n#\nCRITICALITY\nAttackers can inject arbitrary malicious content info files on the CDN.\n\nSUGGESTED FIX\nFor files from CDN add integrity & crossorigin field in script and link  tags, you can calculate the hash by using SRI Hash Generator.\n\nCopy\n<script src=\"https://example.com/example-framework.js\"\n        integrity=\"sha384-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/uxy9rx7HNQlGYl1kPzQho1wx4JwY8wC\"\n        crossorigin=\"anonymous\"></script>\n<link href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css\" \n        rel=\"stylesheet\" \n        integrity=\"sha256-MfvZlkHCEqatNoGiOXveE8FIwMzZg4W85qfrfIFBfYc= sha512-dTfge/zgoMYpP7QbHy4gWMEGsbsdZeCXz7irItjcC3sPUFtf0kuFbDz/ixG7ArTxmDjLXDmezHubeNikyKGVyQ==\" \n        crossorigin=\"anonymous\"/>\n﻿\n\nIf the project is a S3 bucket project, the following webpack plugin can add integrity for the compiled statics.\n\n﻿\n\nwebpack-subresource-integrity\n﻿\n\nYou need to set output.crossOriginLoading to anonymous in webpack.config.js.\n\n不推荐用SRI，因为integrity会加上用户的UA","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2019/09/10/cloudflare worker-CSP.md","slug":"2019/09/10/cloudflare-worker-csp","body":"# cloudflare worker 增加 CSP\n\n```javascript\naddEventListener('fetch', event => {\n\n  event.respondWith(fetch(event.request)\n      .then(function(response){\n            response = new Response(response.body, response);\n            // Set content-security-policy header to self and also include \n            // cloudflare workers dashboard to make it easy to preview\n            response.headers.set(\"content-security-policy\",\n               \"frame-ancestors 'self' https://dash.cloudflare.com;\");\n\n            return response;\n        }\n\n      ));\n    \n\n});\n```","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2019/09/27/jest.md","slug":"2019/09/27/jest","body":"# 总结一下最近 jest 上面的经验\n\n## mock localStorage\n\njsdom里面的localStorage是不能通过赋值覆盖的，但是有一个hack就是利用Object.defineProperty。\n\n```javascript\nObject.defineProperty(window, 'localStorage', {\n    writable: true,\n    value:{\n        getItem: jest.fn(),\n        setItem: jest.fn()\n    }\n});\n```\n\n## setTimeout\n\n有的时候需要让测试代码以为自己已经跑了一会儿。\n\n```javascript\njest.useFakeTimers();\n\njest.advanceTimersByTime();\n\njest.clearAllTimers();\n```\n\n## matchMedia\n\njsdom 还没提供，需要自己mock。\n\n```javascript\nwindow.matchMedia = jest.fn(query => ({\n    matches: false,\n    media: query,\n    onchange: null,\n    addListener: jest.fn(),\n    removeListener: jest.fn(),\n}));\n```","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2020/01/03/2019-Node.md","slug":"2020/01/03/2019-node","body":"\n# 2019 年的 Node 测试最佳实践\n\n这其实不是一篇总结文档，而是一个笔记，基于[NodeJs && JS testing best practise](https://medium.com/@me_37286/yoni-goldberg-javascript-nodejs-testing-best-practices-2b98924c9347)。\n\n比较有趣的是，[Stryker Mutator](https://stryker-mutator.io/)这个工具，可以用来做 mutation testing，简单说，一般测试工具只能保证代码经过了分支，这个工具可以通过修改部分代码逻辑（比如把 true 改成 false）来判断代码是否还会经过这个逻辑。\n\n再一个就是[License Checker](https://www.npmjs.com/package/license-checker)和[plagiarism check](https://www.npmjs.com/package/plagiarism-checker)，就是避免自己养肥了被别人割韭菜。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["test"]}},{"id":"2020/02/10/actix-web-rust-web.md","slug":"2020/02/10/actix-web-rust-web","body":"\n# 利用 actix_web 使用 rust 编写 web 应用\n\n最近我一直在实践 rust 相关的内容，本来想写一篇类似于[scrapy 的文章](http://gongbaodd.github.io/tech/2020/02/04/Windows%E4%B8%8A%E4%BD%BF%E7%94%A8scrapy%E7%88%AC%E7%BD%91%E9%A1%B5.html)，后来发现内容有点多，仅仅一篇文章兜不住，干脆写一个系列好了。\n\n## 使用 Rust 的工具\n\n### rustup\n\n使用 chocolatey 安装，安装好以后只是处理好了 rustup，后面的工具链还要用再次处理。\n\n```shell\nchoco install rust\n```\n\n关于 rustup 的使用，可以查看[文档](https://github.com/rust-lang/rustup/blob/master/README.md)，包括如何做交叉编译都可以使用这个工具完成。\n\n```shell\nrustup toolchain install stable-msvc\n```\n\n### crates.io\n\n[crates.io](https://crates.io/) 是 rust 的模块库，没啥可说的。\n\n### cargo\n\ncargo 是 rust 的包管理工具。以下是几个 cargo 经常使用的命令。\n\n- `cargo new [project name]`，新建一个项目。\n- `cargo init`，初始化一个项目。\n- `cargo clean`，清理编译文件（相信我，这个会经常用）。\n- `cargo run`，编译并运行 main 文件。\n- `cargo run --bin [helper file name]`，直接执行 bin 文件夹下的文件。\n- `cargo build`，编译文件。\n- `cargo install [tools name]`，安装工具。\n\n### cargo-edit\n\n执行`cargo init`之后，项目根目录会生成一个`Cargo.toml`文件本项目的依赖模块都会放到这里，然而手动编写这个文件对于像我这样的懒人显然是无法接受的。因此可以借助`cargo-edit`完成。\n\n```shell\ncargo install cargo-edit\n```\n\n记住`cargo-edit`如下命令即可。\n\n- `cargo add [module name]` 安装一个模块。\n- `cargo rm [module name]` 删除一个模块。\n\n## rust 项目结构\n\n```shell\n- Cargo.toml\n- Cargo.lock\n- src\n-- main.rs # 项目入口文件\n-- lib.rs # 如果作为封装成一个crate，这里配置可以暴露的模块\n-- bin/ # 项目工具文件\n--- helper.rs\n```\n\n## 语法速记\n\n### 函数\n\nrust 的函数还比较有趣，它的`return`关键字是默认省略的，如果这个函数没有中断，这个函数的最后一行就是返回值，且这一行不带分号。\n\n```rust\npub async fn index() -> impl Responder {\n    format!(\"hello\")\n}\n```\n\n如果这个函数没写返回值，其实编译器还会让这个函数返回一个`()`。\n\n```rust\nfn main() {\n    println!(\"hello world\");\n    () // 此处不加()编译器还是会默认理解为返回()。\n}\n```\n\n这么做确实比较符合函数编程的概念，但是一般 rust 库里面的函数都会返回 Result 或者 Option 类型，就用 Result 类型做例子，一般会有四种处理方式。\n\n```rust\nlet bar = foo().expect(\"Panic!\"); // 直接中断程序\nlet bar = match foo() {\n    Ok(value) => Some(value),\n    Err(_) => Some(someError)\n}; // 通过match判断处理错误， 类似于其他语言的switch-case\nlet bar = foo()?; // 把错误处理交给bar\nlet bar = foo().unwrap_or(); // 成功返回成功值，失败返回unwrap_or的值\n```\n\n### 模块\n\n通常想要使用一个模块，只需要使用`use`关键字。\n\n```rust\nuse std::env;\n\nfn main() {\n    let db_url = match env::var(\"DB_URL\") {\n        Ok(_) => { \"OK\".to_owned() }\n        Err(_) => { \"Err\".to_owned() }\n    };\n\n    println!(\"{}\", db_url);\n}\n```\n\n如果引用的这个包是个非 rust 标准包（一个 crate，这里说的是我的理解，如果有个官方中文说法，以它为准），需要在添加`extern crate`关键字，如果还引用了宏，还要加上`#[macro_use]`（这就比较坑了，我哪知道到底用没用上宏，所以一般我都靠编辑器帮我编译一下...）。\n\n```rust\n#[macro_use]\nextern crate log;\n\nfn main() {\n    info!(\"debug\")\n}\n```\n\n如果只是引用本项目相对地址的文件，使用`mod`关键字就好，可以看我的[actix_log](https://github.com/gongbaodd/rust_webAssembly_study/tree/master/actix_log)。\n\n#### 为啥 rust 的模块这么复杂\n\n我猜测毕竟 rust 是对标 C 语言的，相比于很多高级语言的链接工作是在虚拟机里面做的，rust 则全部下放到语言里面，所以一起用起来就会比较复杂。\n\n## trait\n\ntrait 是 rust 上面的一个新概念，类似于 JS 的 mixin 和 Java 的接口，后面我会按例子来讲。\n\n很多库的 trait 需要单独引用，否则会编译失败，这些库往往会封装成一个 prelude 使用。\n\n```rust\nuse gtk::prelude::*;\n```\n\n## rust command\n\nrust 是个系统级语言，可以互相访问其他程序语言分享的堆内存空间，FFI 依靠的是 Box，但是本篇暂时不提及，这个[代码](https://github.com/gongbaodd/rust_webAssembly_study/tree/master/command)实现的是读取并处理其它语言的 std 输出。\n\n## Actix_web\n\n[actix-web](https://actix.rs/)是 Rust 的 web 框架之一，试用了一下，很好上手，有一点 Express 的味道。\n\n```shell\ncargo add actix-web\ncargo add actix_rt\n```\n\n官网首页的例子即是一个简单的应用。\n\n```rust\nuse actix::{\n    web,\n    App,\n    HttpServer,\n    Responder,\n    HttpRequest,\n};\n\nasync fn greet(req: HttpRequest) -> impl Responder {\n    let name = req.match_info()\n        .get(\"name\")\n        .unwrap_or(\"World\");\n\n    format!(\"Hello {}!\", name)\n}\n\n#[actix_rt]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new(\n        || {\n            App::new()\n                .route(\"/\", web::get().to(greet))\n                .route(\"/{name}\", web::get().to(greet))\n        }\n    )\n    .bind(\"127.0.0.1:8080\")?\n    .run()\n    .await\n}\n\n```\n\n当然，如果觉得路由的部分比较难写，还可以使用宏来修改。\n\n```rust\n#[get(\"/\")]\nasync fn greet(req: HttpRequest) -> impl Responder {\n    let name = req.match_info()\n        .get(\"name\")\n        .unwrap_or(\"World\");\n\n    format!(\"Hello {}!\", name)\n}\n\nApp::new().route(greet);\n```\n\n### 利用中间件处理日志和错误\n\nlog 和 env_logger 是 rust 的日志工具，基本上都是宏。\n\n```\ncargo add log\ncargo add env_logger\n```\n\nactix-web 使用 wrap 方法添加中间件，如添加 Logger 打出标准访问日志。\n\n```rust\nuse actix_web::middleware::Logger;\nasync fn main() -> std::io::Result<()> {\n    std::env::set_var(\"RUST_LOG\", \"actix_web=info,info\");\n    env_logger::init();\n\n    let url = \"127.0.0.1:8080\";\n    let app = || {\n        App::new()\n            .wrap(Logger::default())\n            .wrap(Logger::new(\"%a %{User-Agent}i\"))\n            .wrap(middleware::DefaultHeaders::new().header(\"X-Version\", \"0.2\"))\n            .wrap(ErrorHandlers::new().handler(http::StatusCode::INTERNAL_SERVER_ERROR, render_500))\n            .service(routes::index::index)\n    };\n\n    let server = HttpServer::new(app).bind(url);\n    let wait_server = server?.run();\n\n    info!(\"Running Server on {}\", url);\n    wait_server.await\n}\n```\n\n错误处理，详细代码可以查看[actix-log](https://github.com/gongbaodd/rust_webAssembly_study/tree/master/actix_log)。\n\n```rust\nfn render_500<B>(mut res: dev::ServiceResponse<B>) -> Result<ErrorHandlerResponse<B>> {\n    res.response_mut().headers_mut().insert(\n        http::header::CONTENT_TYPE,\n        http::HeaderValue::from_static(\"Error\"),\n    );\n    Ok(ErrorHandlerResponse::Response(res))\n}\n```\n\n### 使用 serde 返回 JSON\n\n想要制作 Restful API，JSON 支持是少不了的。\n\n```shell\ncargo add serde\n```\n\n由于 actix-web 对路由回应格式的支持，一个 json 文件可以这么写。\n\n```rust\nuse acrix_web:{\n    HttpResponse,\n    Responder,\n    get,\n};\nuse serde::{\n    Serialize,\n    Deserialize,\n};\n\n#[derive(Serialize, Deserialize)]\nstruct MyObj {\n    message: String,\n}\n\n#[get(\"/hello\")]\nasync fn hello() -> impl Responder {\n    HttpResponse::Ok().json(MyObj {\n        message: \"SUCCESS\"\n    })\n}\n\n```\n\n更多详细的代码可以查看我的[github](https://github.com/gongbaodd/rust_webAssembly_study/tree/master/actixweb)。\n\n## diesel 处理 ORM(sqlite)\n\n强烈安利大家去看一下 diesel 的[Get Start](http://diesel.rs/guides/getting-started/)，确实是一种下一代 ORM 的感觉。\n\n```shell\ncargo add diesel\n```\n\n### diesel_cli\n\ndiesel_cli 是 diesel 的命令行工具，提供数据部署和 schema 生成的功能，如果不指定 feature 的话，安装时会同时编译 sqlite、postgreSQL 以及 MySQL。\n\n```shell\ncargo install diesel_cli --no-default-features --features sqlite\n```\n\n第一次编译的时候，在 Windows 下面失败了，翻了一下[issue](https://github.com/diesel-rs/diesel/issues/487)找到了解决方案。\n\n首先安装 Visual Studio（反正现在免费安），使用 VS 的终端打开 sqlite 文件夹。\n\n```batch\ncd C:\\ProgramData\\chocolatey\\lib\\SQLite\\tools\nlib /def:sqlite3.def /out:sqlite3.lib\n```\n\n然后记得把`C:\\ProgramData\\chocolatey\\lib\\SQLite\\tools`放到环境变量 PATH 里面。\n\n再次编译即可，具体如何使用 diesel 的 get start 已经足够了，在此不做赘述，可以查看[源码](https://github.com/gongbaodd/rust_webAssembly_study/tree/master/diesel_demo)。\n\n这里列举一下经常用的命令\n\n- `diesel setup` 初始化。\n- `diesel migration generate [step name]` 生成 down.sql 和 up.sql。\n- `diesel migration run` 按照 SQL 文件部署数据库和 schema 文件（目前发现一个 bug，生成的 schema 不完全，没能完全复现）。\n- `diesel migration revert` 撤回数据库操作。\n\n### 补充一下 rust 语法里面的生命周期\n\ndemo 里面的 lib 文件 create_post 语法很奇怪。\n\n```rust\npub fn create_post<'a>(conn: &SqliteConnection, title: &'a str, body: &'a str) -> usize {\n    use schema::posts;\n\n    let new_post = NewPost {\n        title: title,\n        body: body,\n    };\n\n    diesel::insert_into(posts::table)\n        .values(&new_post)\n        .execute(conn)\n        .expect(\"Error saving new post\")\n}\n```\n\n`<'a>`的写法是指明函数的生命周期标注，因为 rust 没有垃圾回收机制，所有申请的堆内存在一个函数执行结束后就会回收。所以当一个函数的输入值是堆内存的变量，就发生「借用」，如这个函数里面的三个参数，借用都用`&`来标注。\n\n假设一个变量借出给另一个函数，而在借用变量的函数执行阶段借出函数就结束并销毁变量，程序就会出错，因此生命周期就是用来确定一个借出的变量必须还回后才能被销毁。默认 rust 都会给一个生命周期，然而当出现两个以上生命周期时，如`create_post`则需要程序员指定参数必须在一个生命周期内。\n\n## juniper 实现 graphql\n\n写一个 Query 的方法\n\n```rust\n#[derive(juniper::GraphQLObject)]\nstruct MyObj {\n    name: String,\n}\n\nstruct QueryRoot;\n#[derive(juniper::object)]\nimpl QueryRoot {\n    fn myObj() -> juniper::FieldResult {\n        Ok(MyObj {\n            name: \"World\"\n        })\n    }\n}\n```\n\nMutation 也类似，基本很简单，可以查看[代码](https://github.com/gongbaodd/rust_webAssembly_study/blob/master/graphql_only)了解。\n\n### rust 语法里面闭包里面 move 的使用\n\n前面说过，如果一个函数想调用另一个函数的堆内存，可以借用。但是还有另一种函数，闭包，理论上闭包可以处理闭包所在词法作用域下的所有变量。在动态执行时如果闭包中依赖的一个变量已经销毁也是很危险的事儿，所以这里可以用 move 关键字将变量所有权交给闭包，在闭包外则无权再次处理已经 move 的变量。\n\n```rust\nasync fn main() -> io::Result<()> {\n    let schema = std::sync::Arc::new(create_schema());\n\n    let app = move || {\n        App::new()\n            .data(schema.clone())\n            .wrap(middleware::Logger::default())\n            .service(graphql)\n            .service(graphiql)\n    };\n\n    HttpServer::new(app)\n        .bind(\"127.0.0.1:8080\")?\n        .run()\n        .await\n}\n```\n\n当然 graphql 的代码里面还有 RC 和 ARC 的概念，现在暂时了解他们时 Rust 下面的引用计数的一种实现，RC 用于单线程，ARC 用于多线程。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["rust","actix_web"]}},{"id":"2020/02/21/Windows-flutter.md","slug":"2020/02/21/windows-flutter","body":"\n# Windows 安装 flutter 开发环境\n\n从 chocolatey 可以直接安装 flutter。\n\n```shell\nsudo choco install flutter\n```\n\n运行成功后可以运行`flutter doctor`检查环境是否完备，比如我会有`X Android license status unknown.`报错，可以运行以下命令检查详情。\n\n```shell\nflutter doctor --android-licenses\n```\n\n发现 SDK 管理的问题，进而发现要把 JDK 降级到 8.0，好在有 chocolatey，很快就解决了。\n\n```shell\nsudo choco install ojdkbuild8\n```\n\n然后修改.bashrc 设置代理\n\n```shell\nexport HTTP_PROXY=127.0.0.1:1080\nexport HTTPS_PROXY=127.0.0.1:1080\nexport NO_PROXY=127.0.0.1,localhost\n```\n\n打开 VScode，安装 flutter，打开命令面板输入`flutter new`，就可以创建工程了（然后下载了巨多文件，感觉如果写个 hello world 都要加载这么多文件真是比较坑）。\n\n打开模拟器，在 VSCode 里面按 F5 就能实时 debug 了。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["flutter","dart"]}},{"id":"2020/02/22/hoisting.md","slug":"2020/02/22/hoisting","body":"\n# 我也谈谈 hoisting\n\n最近在看 getify 的[You-Dont-Know-JS](https://github.com/getify/You-Dont-Know-JS)，第二版里面相对于第一版增加了很多个人认为比较硬核的东西。第二版貌似对 var 关键字进行了洗白，就目前来看还是比较争议的，毕竟这几年来我基本上已经用 let 完全替代 var 了。\n\n最近我正好是在学习 Rust，首先说明一下 Rust 的确是一个不太好学习的语言，但是学会了之后就会对编译原理有更高更深一层次的认识（同样学会了 typescript，也会有类似的感觉）。\n\n那也许是时代的问题。人们发现面向对象并不是万能的，面向函数逐渐的从原来不受人注意，变的受人理解。尤其是最近我还跟一些人在讨论到一些面向对象的继承属性。以后的以后的继承，将逐渐被组合所替代。甚至是 rust，里面已经没有了继承关系。而最受欢迎的前端框架 react 框架也逐渐的使用函数来替代对象。\n\n那么我们现在回顾一下，2015 年，那年 TC39 发布了 ECMA2015，包括块级作用域，let，class 等关键字。当时 JavaScript 的作者，Brendan Eich 就说他不赞成这个对象的设计，但是显然很多人没有理解，当然后来还发生了关于 class 成员是否跟分号的 bug。\n\n那么现在我们把当年的事情再拿出来看一看。Hoisting 这个 JavaScript 独有的特性，是不是一个鸡肋的 bug。\n\n参考 BrendanEich 老爷子自己的[话](https://twitter.com/brendaneich/status/562313394431078400)\n\n> function declaration hoisting is for mutual recursion & generally to avoid painful bottom-up ML-like order\n\n> `var` hoisting was an implementation artifact. `function` hoisting was better motivated.\n\n首先是 ML 这个语言呢也是一个基于函数的语言。但是跟 js 不太一样的是，这个语言就没有 hoisting，所以呢，看代码就只能是一行一行的看下去，比较麻烦。\n\n至于 var 的提升，则是实现 function 带来的人工产物。\n\n想一想 2015 年之前我们写前端 js 代码的时候，往往会把依赖的 function 放到最底下。\n\n```javascript\nfunction foo() {\n  bar1();\n  bar2();\n  bar3();\n\n  return;\n\n  function bar1() {}\n\n  function bar2() {}\n\n  function bar3() {}\n}\n```\n\n其实就像你现在这个角度来观察这个代码，也会觉得。这个语言的确有它的独到之处。这样的写法，直接通过 return 关键字，把一个函数分成了构造函数部分和他的私有成员。如果想要了解这个函数的功能的话，大可不必把所有的函数都看一遍。\n\n自从有了块级作用域，JavaScript 就必须要考虑，同时存在块级作用域和函数作用域的情况，就出现了 TDZ 的情况。简单讲就是说，就是块级作用域，变量不能被重复声明，即使是使用函数声明，而以前的 var 关键字是可以重新定义的（当然重新定义的时候没有重新赋值，因为提升的关系重新定义，并不存在）。\n\n```javascript\n{\n  let foo = \"foo\";\n  var foo; // wrong\n}\n```\n\n```javascript\n{\n  var foo = \"foo\";\n  let foo; // wrong\n}\n```\n\n那么块级作用域有没有提升呢？那肯定是有的，因为如果你想判断这个作用域下面的变量是不是被重新定义了，还是要预先申请内存的。只不过在他声明之前被使用的话，相比于函数变量返回未定义的值，块级作用域会报错。\n\n所以我们一般会把块级作用域变量定义放在这个块儿的最上面，来消除 TDZ。\n\n但是把定义放在最上面的话，就如之前所说的失去了 JavaScript 初衷的优雅。所以 function 和 var 关键字并不一定被宣判死刑，而是在特定的情况下还能被拿出来使用。\n\n不过，话说回来，优雅的东西不一定就是所有人喜欢的。块级作用域对 C 语言使用者来说没有学习障碍，工程上还是少数服从多数，选择最简单的而不是选择最对也存在合理性，所以即使现在面向对象逐渐失宠也不一定将来也会被摒弃。\n\n另外，Eich 和 Crockford 还有一篇访谈，可以看一下。\n\n[Eich and Crockford on the Future of JavaScript: Insight from the Creators of JavaScript and JSON](https://www.infoq.com/news/2018/07/eich-crockford-js-future/)\n","collection":"blog","data":{"type":"post","category":"fe","tag":["JavaScript"]}},{"id":"2020/02/25/stryker-mutation test.md","slug":"2020/02/25/stryker-mutation-test","body":"\n# 使用 stryker 做 mutation test\n\n今年年初的时候，我整理了一下前端测试现状，有一项就是 mutation test。本文将会讲一下如何给 typescript 项目添加 mutation test。\n\n## Stryker-mutator\n\n首先，为项目安装 stryker 全家桶。\n\n```shell\nyarn add -D stryker-typescript stryker-jest-runner stryker-html-reporter stryker-api stryker\n```\n\n你可能会接到升级的警告，我发现最新版本（以@stryker-mutator 做域）会有 bug，而且 github 上面显示 CI 编译失败，保守起见，还是使用老版本比较好。\n\n执行`yarn stryker init`初始化项目，修改 stryker.conf.js，详细的参数说明可以参考[这里](https://github.com/stryker-mutator/stryker/tree/master/packages/core)。\n\n```javascript\nmodule.exports = function stryker(config) {\n  config.set({\n    mutator: \"typescript\",\n    mutate: [\"src/linked_node/**/*.ts\", \"!src/**/*.spec.ts\"],\n    packageManager: \"yarn\",\n    reporters: [\"clear-text\", \"dashboard\", \"progress\", \"html\"],\n    testRunner: \"jest\",\n    coverageAnalysis: \"off\",\n    tsconfigFile: \"tsconfig.json\",\n    dashboard: {\n      reportType: \"full\",\n    },\n  });\n};\n```\n\n注意，官网的 tutorial 会要求添加 transpilor 为 typescript，这里因为我们的测试 runner 是已经配置好的 jest，所以不能再添加一次编译。\n\n执行`yarn stryker run`就能执行测试，这个测试很占用性能，我这 10 代 i7 的本都要跑 8 分钟左右，执行成功会生成报告存储在 reports 文件夹下。\n\n## 配置 travis\n\nstryker 官方提供[dashboard](https://dashboard.stryker-mutator.io)，登入配置好环境变量即可生成 stryker 的徽章，可以把它贴到 github 的 readme 中。这样，每次 travis 执行好 mutation test 后都能更新徽章分数。\n\n关于 dashboard 如何配置可以参考[handbook](https://github.com/stryker-mutator/stryker-handbook/blob/master/dashboard.md)。\n\n但是我没能成功上传 report，只能显示出分数，并不确定哪里出了问题，还是看官方如何更新吧。\n\n## 原理\n\n如果我有以下函数，并配合 100%测试覆盖的单元测试。\n\n```typescript\nfunction isGe18(num: number) {\n  return num >= 18;\n}\n\ndescribe(\"the input is 1\", () => {\n  it(\"should return false\", () => {\n    expect(isGe18(1)).toBe(false);\n  });\n});\n```\n\n显然以上的测试是不完备的，那么 stryker 如何找到它不完备的地方？首先修改函数的返回值，如生成如下四个函数。\n\n```typescript\nfunction isGe18_1(num: number) {\n  return num > 18;\n}\nfunction isGe18_2(num: number) {\n  return num < 18;\n}\nfunction isGe18_3(num: number) {\n  return true;\n}\nfunction isGe18_3(num: number) {\n  return false;\n}\n```\n\n分别用他们重新跑测试，只要有一个测试失败，就称这个 mutate 被 killed，如果测试全部通过，则称 mutate 被 survived。\n则对应上面例子：\n\n- isGe18_1 => survived\n- isGe18_2 => killed\n- isGe18_3 => killed\n- isGe18_3 => survived\n\n则此时需要增加测试\n\n```typescript\ndescribe(\"the input is 19\", () => {\n  it(\"should return true\", () => {\n    expect(isGe18(19)).toBe(true);\n  });\n});\n\ndescribe(\"the input is 18\", () => {\n  it(\"should return true\", () => {\n    expect(isGe18(18)).toBe(true);\n  });\n});\n```\n\n重新跑测试\n\n- isGe18_1 => killed（最后一个测试未通过）\n- isGe18_2 => killed\n- isGe18_3 => killed\n- isGe18_3 => killed（新增加的 2 个测试未通过）\n\n此时测试才是完备的。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["test","stryker","javascript"]}},{"id":"2020/02/27/rust-webassembly-game-of-life.md","slug":"2020/02/27/rust-webassembly-game-of-life","body":"\n# 使用 rust 和 webassembly 开发 game of life\n\n这是一篇翻译，[原文](https://github.com/rustwasm/book.git)，这可能是第一篇系统讲解 rustwasm 的文章了。\n\n## 这本书适合谁？\n\n这本书适合任何对快速编译 Rust 和 Webassembly 感兴趣的人，相关的代码已经发布在网上。你应该已经了解一些 Rust 的知识，对 JavaScript HTML 和 css 很熟悉，但你不需要是在这些方面的专家。\n\n还不了解 rust？请先参阅[开始使用 rust 语言](https://doc.rust-lang.org/book/)。\n不了解 JavaScript 的 html 或者是 css？请参阅[MDN](https://developer.mozilla.org/en-US/docs/Learn)\n\n## 为什么用 rust 和 webAssembly\n\n### 底层支持和高效(Low-Level Control with Hign-Level Ergonomics)\n\nJavascript 的应用，纠结于如何保持高效运作。但是 JavaScript 的动态类型系统和垃圾回收机制，使他们不能高效。看起来很小的修改，如果不小心走出了 JIT 的舒适区，看起来很小的修改都会导致很严重的错误。\n\n### .wasm 文件大小\n\n因为要通过网络下载，代码的大小就变得异常重要。Rust 不需要运行环境，使得编译文件不需要包括垃圾回收器。这些文件包括的只有真正需要的函数。\n\n### 不要重写所有的东西\n\n现有的代码不需要被扔走，你可以把性能最严重的 JavaScript 函数，交给 rust 去执行。\n\n### 和其他工具交互融洽\n\nRust 和 WebAssembly 支持现有的工具链，它支持 ecmascript 模块，并且你依然可以使用现有的工具链如 NPM，webpack 和 greenkeeper。\n\n## 背景和相关概念\n\n### 什么是 WebAssembly\n\nWebAssembly（wasm）是一个简单的机器模块拥有大量的[定义](https://webassembly.github.io/spec/)。它被设计得以相近于原生的速度便携紧密地执行。\n\n作为一个开发语言，尽管是以两种方式展示的格式，wasm 依然表示于同样的结构。\n\n- `.wat`文本格式（叫做 WebAssembly Text），使用[S-expression](https://en.wikipedia.org/wiki/S-expression)，有点类似于 Lisp 家族，像是 Scheme 和 Clojure。\n- `.wasm`二机制格式，是一个底层的目标是让 wasm 虚拟机使用的格式，有些类似于 ELF 和 Mach-O。\n\n以`.wat`书写的斐波那契数列如下：\n\n```wasm\n(module\n  (func $fac (param f64) (result f64)\n    get_local 0\n    f64.const 1\n    f64.lt\n    if (result f64)\n      f64.const 1\n    else\n      get_local 0\n      get_local 0\n      f64.const 1\n      f64.sub\n      call $fac\n      f64.mul\n    end)\n  (export \"fac\" (func $fac)))\n```\n\n如果感兴趣的话，可以使用[此工具](https://webassembly.github.io/wabt/demo/wat2wasm/)执行上面的代码。\n\n#### 线性内存\n\nWasm 使用的[内存模式](https://webassembly.github.io/spec/core/syntax/modules.html#syntax-mem)很简单。一个 wasm 模块，可以访问的一系列内存，被限制于一个字节数组中。这些内存会[增长](https://webassembly.github.io/spec/core/syntax/instructions.html#syntax-instr-memory)为多个页（64K）不会收缩。\n\n#### Wasm 是仅仅为 web 开发的吗？\n\n尽管在 JavaScript 和 web 社区中有很多讨论。WASM 并没有考虑过它的运用环境。所以目前只能定义它为将来可以使用的便携运行格式。但就目前而言，wasm 仍然在很多方面与 JavaScript 有关。不仅仅是浏览器，还有 Node.js。\n\n## 关于本书\n\n这一部分开始使用 Rust 和 WebAssembly 开发[Conway 的 Game of Life](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life)。\n\n本章会讲到以下内容。\n\n- 如何搭建编译 WebAssembly 的 Rust 工具链。\n- 一个支持开发多语言程序（Rust、wasm、JavaScript、HTML 和 CSS）的工作流。\n- 设计最大利用 rust 和 wasm 的优势配合 JavaScript 的优点的 API。\n- 如何调试 wasm 模块。\n- 如何查看 wasm 的时间日志（time profile）。\n- 如何减少生成的二进制文件包大小。\n\n## 安装工具\n\n本节将会介绍编译 Rust 编译 WASM 并和 JavaScript 集成的工具链。\n\n### Rust 工具链\n\n你需要安装 rust 的标准工具链，[rustup，rustc 和 cargo](https://www.rust-lang.org/tools/install)（强烈建议你们在 WSl 的环境下面工作）。\n\nWASM 已经推动 Rust 新特性进入稳定版，所以我们需要有 1.30 或更新版本。\n\n### wasm-pack\n\n`wasm-pack`是一站式的建造测试以及发布 rust 相关的 wasm 应用工具。\n\n```shell\ncargo install wasm-pack\n```\n\n### cargo-generate\n\n`cargo-generate`帮助你使用现存的 Git 仓库作为模板新建 Rust 项目。\n\n```shell\ncargo install cargo-generate\n```\n\n### NPM\n\n`npm`是 JavaScript 的包装管理器。我们将利用它，去安装和运行 JavaScript 的打包和测试部署。我们将把我们编译好的`.wasm`文件放到 npm 的包中。\n\n如果你已经安装了 NPM 可以执行以下命令，安装最新版。\n\n```shell\nnpm install npm@latest -g\n```\n\n## 你好，世界\n\n通过本部分可以创建一个 Rust+WASM 页面，并能在页面弹窗展示`\"Hello, World!\"`。\n\n### 复制项目模板\n\n这个项目的模板已经提前编译好，可以借此快速绑定、集成和打包成 Web 项目。\n\n利用模板创建项目的命令：\n\n```shell\ncargo generate --git https://github.com/rustwasm/wasm-pack-template\n```\n\n它会提醒你新建一个项目名称，这里我们先使用\"wasm-game-of-life\"。\n\n### 文件结构\n\n进入项目文件夹。\n\n```shell\ncd wasm-game-of-life\n```\n\n以下是项目文件夹：\n\n```\nwasm-game-of-life/\n├── Cargo.toml\n├── LICENSE_APACHE\n├── LICENSE_MIT\n├── README.md\n└── src\n    ├── lib.rs\n    └── utils.rs\n```\n\n接下来详细看一下：\n\n#### wasm-game-of-life/Cargo.toml\n\n`Cargo.toml`文件描述`cargo`的依赖和源文件，Rust 的包管理工具和编译工具。这个包括`wasm-bindgen`依赖，我们会稍后了解其他的依赖，还有一些用来初始化`.wasm`的`crate-type`库。\n\n#### wasm-game-of-life/src/lib.rs\n\n`src/lib`文件放在 Rust 项目的更目录下面。它使用`wasm-bindgen`去和 JavaScript 链接。它能引入`window.alert`这个 JavaScript 函数，并暴露`greet`函数，并弹出弹框。\n\n```Rust\nmod utils;\nuse wasm_bindgen::prelude::*;\n\n// 当wee_alloc特性被打开，将会使用wee_alloc作为全局分匹配器\n#[cfg(feature = \"wee_alloc\")]\n#[global_allocator]\nstatic ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;\n\n#[wasm_bindgen]\nextern {\n    fn alert(s: &str);\n}\n\n#[wasm_bindgen]\npub fn greet() {\n    alert(\"Hello, wasm-game-of-life!\");\n}\n```\n\n#### wasm-game-of-life/src/utils.rs\n\n`src/utils`模块为编译 Rust 到 WASM 提供工具函数，我们后面会在调试时提到它，现在先忽略。\n\n### 编译项目\n\n使用`wasm-pack`依赖以下工具：\n\n- 保证 Rust 版本在 1.30 以上，且已经通过`rustup`安装`wasm32-unknown-unknown`工具链。\n- 使用`cargo`编译 Rust 到 WASM。\n- 使用`wasm-bindgen`去生成 JavaScript 的 API。\n\n为了完成以上内容，需要在根目录执行以下命令：\n\n```shell\nwasm-pack build\n```\n\n编译完成后，我们可以看到`pkg`里面的结构，里面应该有如下文件。\n\n```\npkg/\n├── package.json\n├── README.md\n├── wasm_game_of_life_bg.wasm\n├── wasm_game_of_life.d.ts\n└── wasm_game_of_life.js\n```\n\n`README.md`文件是直接从根目录复制的，但是其他文件完全是新生成的。\n\n#### wasm-game-of-life/pkg/wasm_game_of_life_bg.wasm\n\n`.wasm`文件是 Rust 工具链使用 Rust 源代码生成的 WASM 的二进制文件，它包括全部的函数和数据，比方说，爆露出来的`greet`函数。\n\n#### wasm-game-of-life/pkg/wasm_game_of_life.js\n\n这个`.js`文件是`wasm-bindgen`引入 DOM 和 JavaScript 方法到 Rust 中，并油耗地暴露 WASM 的 API 到 JavaScript 中。举个例子，这里个`greet`函数包裹了 WASM 中的`greet`函数，目前，这个粘合还没做任何功能，当我们逐渐从 WASM 和 JavaScript 中传输数据，他会提供帮助。\n\n```javascript\nimport * as wasm from \"./wasm_game_of_life_bg\";\n\nexport function greet() {\n  return wasm.greet();\n}\n```\n\n#### wasm-game-of-life/pkg/wasm_game_of_life.d.ts\n\n这个`.d.ts`是 TypeScript 链接 JavaScript 的文件。如果你的项目中使用了 TypeScript，你可以让你的 WebAssembly 项目被类型检查，并且你的 IDE 会提供代码提醒和自动完成功能。\n\n```TypeScript\nexport function greet(): void;\n```\n\n#### wasm-game-of-life/pkg/package.json\n\n这个文件包括了所有生成的文件描述，并使得这个项目能够作为一个使用 WebAssembly 的 NPM 包，能够集成到 JavaScript 工具链并发布至 NPM。\n\n```json\n{\n  \"name\": \"wasm-game-of-life\",\n  \"collaborators\": [\"Your Name <your.email@example.com>\"],\n  \"description\": null,\n  \"version\": \"0.1.0\",\n  \"license\": null,\n  \"repository\": null,\n  \"files\": [\"wasm_game_of_life_bg.wasm\", \"wasm_game_of_life.d.ts\"],\n  \"main\": \"wasm_game_of_life.js\",\n  \"types\": \"wasm_game_of_life.d.ts\"\n}\n```\n\n### 开始加入页面\n\n想要`wasm-game-of-life`能够展示到页面中，需要使用[`create-wasm-app` JavaScript 模板](https://github.com/rustwasm/create-wasm-app)。\n\n在项目根目录执行以下命令：\n\n```shell\nnpm init wasm-app www\n```\n\n这是`wasm-game-of-life/www`文件夹包括的文件。\n\n```\nwasm-game-of-life/www/\n├── bootstrap.js\n├── index.html\n├── index.js\n├── LICENSE-APACHE\n├── LICENSE-MIT\n├── package.json\n├── README.md\n└── webpack.config.js\n```\n\n#### wasm-game-of-life/www/package.json\n\n这个文件包括已经配置好的`webpack`和`webpack-dev-server`依赖，和`hello-wasm-pack`，版本号为已经发布到 NPM 上面的版本号。\n\n#### wasm-game-of-life/www/webpack.conf.js\n\n这个是用来配置 webpack 和开发服务器的文件。该文件已经提前布置好，如果只是开发则无需过多关心这个文件。\n\n#### wasm-game-of-life/www/index.html\n\n这是页面的 HTML 文件，它是来调用`bootstrap.js`的。\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\" />\n    <title>Hello wasm-pack!</title>\n  </head>\n  <body>\n    <script src=\"./bootstrap.js\"></script>\n  </body>\n</html>\n```\n\n#### wasm-game-of-life/www/index.js\n\n这是 JavaScript 的入口文件，他引入了`hello-wasm-pack`，并带哦用了 greet 函数。\n\n```JavaScript\nimport * as wasm from \"hello-wasm-pack\";\n\nwasm.greet();\n```\n\n#### 安装 NPM 依赖\n\n首先保证已经在`www`文件夹下面执行过`npm i`，这个命令会安装好现有依赖包括 webpack 和开发服务器。\n\n> 注意 webpack 并不是必须的，他只是个打包器并提供了开发服务器，这是我们选择它的原因。Parcel 和 Rollup 一样支持 WebAssembly 模块。你也可以选择[不使用打包器](https://rustwasm.github.io/docs/wasm-bindgen/examples/without-a-bundler.html)。\n\n#### 在 www 文件夹中使用本地 wasm-game-of-life 包\n\n相比于使用 NPM 线上的`hello-wasm-pack`，使用本地文件会提高我们的开发舒适度。\n\n打开`www/package.json`，找到`devDependencies`，在兄弟节点增加`dependencies`字段，并在里面增加`\"wasm-game-of-life\": \"file:../pkg\"`。\n\n```JSON\n{\n  // ...\n  \"dependencies\": {                     // Add this three lines block!\n    \"wasm-game-of-life\": \"file:../pkg\"\n  },\n  \"devDependencies\": {\n    //...\n  }\n}\n```\n\n接下来修改`www/index.js`引入 greet 函数。\n\n```JavaScript\nimport * as wasm from \"wasm-game-of-life\";\n\nwasm.greet();\n```\n\n既然修改了 package.json，则需要重新安装他。\n\n```shell\nnpm install\n```\n\n好了，现在服务器可以成功运行了。\n\n#### 启动本地服务\n\n接下来，打开一个新终端来在后台运行服务器，请在`www`文件夹下执行如下命令。\n\n```shell\nnpm run start\n```\n\n打开http://localhost:8080，应当会弹出如下弹窗。\n\n![弹窗](https://rustwasm.github.io/book/images/game-of-life/hello-world.png)\n\n### 练习\n\n修改 greet 函数，引入参数`name: &str`，重新执行`wasm-pack build`，并刷新页面使得弹窗中能够显示\"Hello, {name}\"。\n\n**_答案，不许看！_**\n\n修改`src/lib.rs`\n\n```Rust\n#[wasm_bindgen]\npub fn greet(name: &str) {\n    alert(&format!(\"Hello, {}!\", name));\n}\n```\n\n再修改 JavaScript 绑定`www/index.js`\n\n```JavaScript\nwasm.greet(\"Your name\");\n```\n\n## Conway 的生命游戏的游戏规则\n\n如果你已经了解[Conway 的生命游戏](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life)，可以跳过这部分。\n\n整个 Conway 的生命游戏是在一个无限的二维的正交格子宇宙中，每一个细胞拥有两种生命状态，生或者死。或者说可增殖或者不可增殖。每一个细胞都和它的 8 个邻居交互，它们分别是纵向的，斜向的，横向的相邻。并且每一步都会发生如下的变化。\n\n1. 任何一个活着的细胞，如果有少于两个邻居就会死亡。\n2. 任何一个活细胞拥有两个或三个活着的邻居，则会继续增殖。\n3. 任何一个活着的细胞拥有三个以上活着的的邻居，则会死亡。\n4. 任何一个死掉的细胞，如果有三个活着的邻居，则会重生。\n\n最初的图案组成了最初的世界。第 1 代是按照以上的规则生成的，每一个细胞的生成和死亡都是同时的。他们的生存和死亡这一个时间我们称之为一刻。用程序的语言来说，这一刻是上一次生成的纯函数。这个规则一直有效。\n\n考虑设置如下的初始宇宙：\n\n![初始宇宙](https://rustwasm.github.io/book/images/game-of-life/initial-universe.png)\n\n我们可以通过考虑每一个细胞来确定下一代。最左上角的细胞已经死亡，第 4 条规则是唯一一个能够处理死亡细胞的规则。所以第 1 排的所有细胞都有相同的规则。他们都没有三个活着的邻居。只能保持死亡。\n\n当我们看到最上面的活着的细胞时，这个游戏开始变得有趣了。在第 2 排第 3 列。对于活着细胞前三个规则都可以应用。对于这一个细胞，他只有一个活着的邻居，所以规则一可用。这个细胞会在下一次争执死亡。下面那几个活着的细胞也是有一样的命运。\n\n中间的活着的细胞，还有两个邻居，上面的和下面的，这就意味着它符合规则二，他可以活到下一次增值。\n\n最后一个比较有趣的例子，就是当我们看到死掉的细胞。嗯。在中间这活着的细胞的左边和右边。这三个活着的细胞都是他们的邻居。这使得他们按照规则是可以在下一轮重生。\n\n将这些规则放在一起，我们可以获得下一刻的世界。\n\n![下一刻的世界](https://rustwasm.github.io/book/images/game-of-life/next-universe.png)\n\n根据这个例子，和确定的规则。不去并精彩的事情将会发生。\n\n![Gosper's glider gun](https://upload.wikimedia.org/wikipedia/commons/e/e5/Gospers_glider_gun.gif)\n\n![Pulsar](https://upload.wikimedia.org/wikipedia/commons/0/07/Game_of_life_pulsar.gif)\n\n![Space ship](https://upload.wikimedia.org/wikipedia/commons/3/37/Game_of_life_animated_LWSS.gif)\n\n### 练习\n\n手动计算出下一刻，宇宙应该是什么样\n\n**_答案，不许看！_**\n\n![下一刻宇宙](https://rustwasm.github.io/book/images/game-of-life/initial-universe.png)\n\n你能找到一个稳定的没有变化的宇宙吗？\n\n**_答案，不许看！_**\n\n这个答案，不许看！其实有无数个，最平凡的答案，不许看！就是它是一个空宇宙。如果是一个 2×2 的方格，也可以形成一个稳定的宇宙。\n\n## 实现 Conway 的生命游戏\n\n### 设计\n\n在开始之前呢，我们要先考虑以下几种设计模式。\n\n#### 无限宇宙\n\n生命游戏是在一个无限宇宙中玩的。但是我们没有无限的内存和计算能力。在这种情况下，我们往往会有三个选项。\n\n1. 始终追踪这个宇宙的发展，并适当的扩展宇宙。这个扩张是无限的，所以这个实现实现了就会逐渐逐渐的变得越来越慢，直到把内存全部用完。\n2. 创建一个固定的宇宙，当细胞碰到宇宙的边缘的时候，将会有更少的邻居。更简单的策略就是当他们已经达到边缘的时候，直接被宇宙剪掉。\n3. 创建一个固定的宇宙，当细胞达到边缘的时候，将会从另外一边滑入这样，我的我们的应用就可以一直跑下去。\n\n我们会按照第 3 个选项来实现。\n\n#### 连接 Rust 和 JavaScript\n\n> 此部分是本人最重要的一节。\n\nJavaScript 的垃圾回收堆内存，是用来调用 Object 和 Array 还有 DOM 结点的。而 Rust 存在的 WebAssembly 线性内存和它是截然不同的。WebAssembly 目前还不能直接操作垃圾回收堆内存（在 2018 年 4 月，一个关于[接口类型（Interface Type）](https://github.com/WebAssembly/interface-types/blob/master/proposals/interface-types/Explainer.md)的提案将会改变这一局面）。JavaScript 却可以读写 WebAssembly 的线性内存，但仅限于 ArrayBuffe 支持的标量（u8, i32, f64 等等）。WebAssembly 行数一样能处理和返回这些标量。以下讲解 WebAssembly 和 JavaScript 如何链接。\n\nwasm_bindgen 定义了如何穿过这段链接计算数据结构的方法。它包括装箱 Rust 结构，并包装指针成为一个 JavaScript 类以供使用，或者提供 JavaScript 对象给 Rust 使用。wasm_bindgen 非常便利，但并不是无需考虑怎样在这个链接上传输数据结构。你应该把它当作一个实现接口的工具。\n\n当设计 WebAssembly 和 JavaScript 的接口时，我们需要考虑到以下内容。\n\n1. **减少复制到和移出 WebAssembly 线性内存中的值**，无效的复制会造成无用的性能损耗。\n2. **最小的序列化和解序列化**，和复制类似，序列化和解序列化一样造成性能损耗，如果想要把数据无副作用地从一端传到另一端，与其说在一端序列化，到另一端解序列化，不如使用 wasm_bindgen 帮助我们将 JavaScript 的 Object 装箱成 Rust 的 structure。\n\n一个结论，处理 JavaScript 和 WebAssembly 接口设计时，经常将大的、生命周期长的数据结构作为 Rust 类型，存储在 WebAssembly 线性内存中，并给 JavaScript 暴露一个处理方法，JavaScript 调用 WebAssembly 转换文件，处理运算，并最终得到一个小的，可复制的结果。通过只返回计算结果，我们可以躲过复制和序列化数据的过程。\n\n#### 在生命游戏中链接 Rust 和 JavaScript\n\n接下来结局几个要规避的问题。我们不想每刻都复制整个宇宙到 WebAssembly 的内存中，我们不想处理宇宙中所有的细胞，也不想在每次读写细胞的时候都穿过 WebAssembly 和 JavaScript 的分界。\n\n这是我们的 4x4 宇宙在内存中的结构。\n\n![4x4宇宙在内存中的结构](https://rustwasm.github.io/docs/book/images/game-of-life/universe.png)\n\n为了寻找细胞在内存中的位置，我们可以使用下面的公式。\n\n```\nindex(row, column, universe) = row * width(universe) + column\n```\n\n我们有很多方法来给 JavaScript 暴露宇宙中的细胞。开始我们要为宇宙实现一个`std::fmt::Display`。我们可以使用一个 Rust 的 String，每个字符代表一个细胞。这个 Rust 的 string 将会从 WebAssembly 的内存中复制到 JavaScript 的内存里，并接下来作为 textContent 展示到 HTML 里面。本节的后面，将会讲到如何把细胞展示到 canvas 中。\n\n> 另一种设计是让 Rust 返回每个细胞的生存状态列表，这样 JavaScript 就不需要在渲染时解析整个宇宙，这不过这个是先更加复杂些。\n\n#### Rust 的实现\n\n上一章，我们复制了初始化模板，我们现在要修改这个模板。\n\n从删除 greet 函数，并定义宇宙中的细胞开始。\n\n```Rust\n#[wasm_bindgen]\n#[repr(u8)]\n#[derive(Clone, Copy, Debug, PartialEq, Eq)]\npub enum Cell {\n    Dead = 0,\n    Alive = 1,\n}\n```\n\n`#[repr(u8)]`很重要，这样每个细胞都会以一个字节存储，另外 Alive 为 1，Dead 为 0 也很重要，这样我们就可以使用加法计算邻居数目。\n\n接下来定义宇宙，一个宇宙包括宽度，高度和一个向量的细胞。\n\n```Rust\n#[wasm_bindgen]\npub struct Universe {\n    width: u32,\n    height: u32,\n    cells: Vec<Cell>,\n}\n```\n\n访问并转换细胞的实现如下。\n\n```Rust\nimpl Univers {\n    fn get_index(&self, row: u32, column: u32) -> usize {\n        (row*self.width + column) as usize\n    }\n}\n```\n\n为了计算细胞接下来的状态，我们要统计某个细胞有多少个邻居存活。\n\n```Rust\nimpl Univers {\n    fn live_neighbor_count(&self, row: u32, column: u32) -> u8 {\n        let mut count = 0;\n        for delta_row in [self.height - 1, 0, 1].iter().cloned() {\n            for delta_col in [self.width - 1, 0, 1].iter().cloned() {\n                if delta_row == 0 && delta_col ==0 {\n                    continue;\n                }\n\n                let neighbor_row = (row + delta_row) % self.height;\n                let neighbor_col = (column + delta_col) % self.width;\n                let idx = self.get_index(neighbor_row, neighbor_col);\n                count += self.cells[idx] as u8\n            }\n        }\n        count\n    }\n}\n```\n\n这个函数使用取余处理边界问题。现在我们已经有所有的必须函数了，最后只需要生成下一刻的状态即可（记住，每个函数必须在`#[wasm_bindgen]`属性之下，这样 JavaScript 才能接到暴露的函数）。\n\n```Rust\n#[wasm_bindgen]\nimpl Universe {\n    pub fn tick(&mut self) {\n        let mut next = self.cells.clone();\n\n        for row in 0..self.height {\n            for col in 0..self.width {\n                let idx = self.get_index(row, col);\n                let cell = self.cells[idx];\n                let live_neighbors = self.live_neighbor_count(row, col);\n\n                let next_cell = match (cell, live_neighbors) {\n                    (Cell::Alive, x) if x < 2 => Cell::Dead,\n                    (Cell::Alive, 2) | (Cell::Alive, 3) => Cell::Alive,\n                    (Cell::Alive, x) if x > 3 => Cell::Dead,\n                    (Cell::Dead, 3) => Cell::Alive,\n                    (otherwise, _) => oterwise,\n                };\n\n                next[idx] = next_cell;\n            }\n        }\n        self.cells = next;\n    }\n}\n```\n\n目前为止，一个宇宙的状态就都被存储在 cell 这个向量里面了。为了提高它的可读性，让我们实现一个文本渲染器，目的是将整个宇宙按行输出为文字，每一个活着的细胞标注为 Unicode 符号“■”，死掉的细胞则为“□”。\n\n通过实现 Rust 标准库中的`Display`trait，我们可以将数据结构以一种用户交互方式输出，它也提供了一个`to_string`方法。\n\n```Rust\nuse std::fmt;\n\nimpl fmt::Display for Universe {\n  fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n    for line in self.cells.as_slice().chunks(self.width as usize) {\n      for &cell in line {\n        let symbol = if cell == Cell::Dead {\"□\"} else {\"■\"};\n        write!(f, \"\\n\")?;\n      }\n    }\n\n    Ok(())\n  }\n}\n```\n\n最后，我们定义一个构造器去初始化一个有趣的图案和一个渲染函数。\n\n```Rust\n#[wasm_bindgen]\nimpl Universe {\n  pub fn new() -> {\n    let width = 64;\n    let height = 64;\n\n    let cells = (0..width * height)\n      .map(|i| {\n        if i%2 == 0 || i%7 == 0 {\n          Cell::Alive\n        } else {\n          Cell::Dead\n        }\n      }).collect();\n\n    Universe {\n      width,\n      height,\n      cells,\n    }\n  }\n\n  pub fn render(&self) -> String {\n    self.to_string()\n  }\n}\n```\n\n以上，Rust 部分已经完工。\n\n#### 使用 JavaScript 渲染\n\n首先在 HTML 中插入<pre>标签用来展示整个宇宙。\n\n```html\n<body>\n  <pre id=\"game-of-life-canvas\"></pre>\n  <script src=\"./bootstrap.js\"></script>\n</body>\n```\n\n另外我们希望<pre>标签能处于页面中央。我们可以通过 CSS flex box 实现这个任务，在 html 中增加<style>标签。\n\n```css\nbody {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n}\n```\n\n修改 JavaScript 入口文件，将原来引入的 greet 函数改为 Universe。\n\n```JavaScript\nimport { Universe } from \"wasm-game-of-life\";\n```\n\n让我们在那个<pre>标签中增加新的宇宙实例吧。\n\n```JavaScript\nconst pre = document.getElementById(\"game-of-life-canvas\");\nconst universe = Universe.new();\n```\n\n使用 JavaScript 创建一个 requestAnimationFrame 循环，每一次循环，就在<pre>标签中绘制一遍宇宙，并执行一次`Universe::tick`。\n\n```JavaScript\nfunction renderLoop() {\n  pre.textContent = universe.render();\n  universe.tick();\n\n  requestAnimationFrame(renderLoop);\n}\n```\n\n想要实现渲染，只需执行`requestAnimationFrame(renderLoop)`。\n\n确保你的本地服务任然在运行，此时你的页面应该如下所示。\n\n![浏览器页面](https://rustwasm.github.io/book/images/game-of-life/initial-game-of-life-pre.png)\n\n#### 渲染到 Canvas 上\n\n在 Rust 中生成字符串并通过 wasm-bindgen 拷贝到 JavaScript 中做了很多无关的复制。既然 JavaScript 已经知道宇宙的长度和宽度，而且 JavaScript 本来可以直接读 WebAssembly 的内存，我们将要修改 render 方法，直接返回细胞向量的指针。\n\n同时，与其渲染 Unicode 字符，不如开始用 Canvas API。接下来我们会开始设计这些。\n\n在 html 中，修改<pre>为<canvas>。\n\n```html\n<body>\n  <canvas id=\"game-of-life-canvas\"></canvas>\n  <script src=\"./bootstrap.js\"></script>\n</body>\n```\n\n为了能拿到 Rust 中的相关数据结构，我们需要为宇宙增加 getter 函数，暴露宇宙的宽度、高度和细胞的向量。增加如下函数。\n\n```Rust\n#[wasm_bindgen]\nimpl Universe {\n  pub fn width(&self) -> u32 {\n    self.width\n  }\n\n  pub fn height(&self) -> u32 {\n    self.height\n  }\n\n  pub fn cells(&self) -> *const Cell {\n    self.cells.as_ptr()\n  }\n}\n```\n\n接下来，在 JavaScript 中，引入 Cell，并设置几个渲染画布的常量。\n\n```JavaScript\nimport { Universe, Cell } from \"wasm-game-of-life\";\n\nconst CELL_SIZE = 5;\nconst GRID_COLOR = \"#CCCCCC\";\nconst DEAD_COLOR = \"#FFFFFF\";\nconst LIVE_COLOR = \"#000000\";\n```\n\n接下来修改实现 canvas 的部分。\n\n```JavaScript\nconst universe = Universe.new();\nconst width = universe.width();\nconst height = universe.height();\n\nconst canvas = documnet.getElementById(\"game-of-life-canvas\");\ncanvas.height = (CELL_SIZE+1)*height + 1;\ncanvas.width = (CELL_SIZE+1)*width + 1;\n\nconst ctx = canvas.getContext(\"2d\");\n\nfunction renderLoop() {\n  universe.tick();\n\n  drawGrid();\n  drawCells();\n\n  requestAnimationFrame(renderLoop);\n}\n```\n\n世界的网格，是一系列等宽的竖线和横线。\n\n```JavaScript\nfunction drawGrid() {\n  ctx.beginPath();\n  ctx.strokeStyle = GRID_COLOR;\n\n  for(let i =0; i <= width; i+=1) {\n    ctx.moveTo(i*(CELL_SIZE+1) + 1, 0);\n    ctx.lineTo(i*(CELL_SIZE+1) + 1, (CELL_SIZE+1)*height+1);\n  }\n\n  for(let i=0; i<=height; j++) {\n    ctx.moveTo(0, i*(CELL_SIZE+1)+1);\n    ctx.lineTo((CELL_SIZE+1)*width+1, i*(CELL_SIZE+1)+1);\n  }\n\n  ctx.stroke();\n}\n```\n\n我们可以直接访问 WebAssembly 的内存，他是直接定义在`wasm_game_of_life_bg`。为了画细胞，我们先找到一个细胞的指针，并将它们转换成 Unit8Array，迭代这些细胞，并按照他们的生命状态绘制白色和黑色方块。计量避免复制所有细胞。\n\n```JavaScript\nimport { memory } from \"wasm-game-of-life/wasm_game_of_life_bg\";\n\nfunction getIndex(row, column) {\n  return row*width+column;\n}\n\nfunction drawCells() {\n  const cellsPtr = universe.cells();\n  const cells = new Unit8Array(\n    memory.buffer,\n    cellPtr,\n    width*height,\n  );\n\n  ctx.beginPath();\n\n  for(let row=0; row<height; row+=1) {\n    for (let col=0; col<width; col+=1) {\n      const idx = getIndex(row, col);\n\n      ctx.fillStyle = cells[idx] === CellDead\n        ? DEAD_COLOR\n        : LIVE_COLOR;\n\n      ctx.fillRect(\n        cell*(CELL_SIZE+1) + 1,\n        row*(CELL_SIZE+1) + 1,\n        CELL_SIZE,\n        CELL_SIZE,\n      );\n    }\n  }\n\n  ctx.stroke();\n}\n```\n\n开始渲染，需要添加以下表达式。\n\n```JavaScript\ndrawGrid();\ndrawCells();\nrequestAnimationFrame(renderLoop);\n```\n\n注意 drawGrid 和 drawCell 必须要在 requestAnimationFrame 之前执行。\n\n#### 成功了！\n\n重建 WebAssembly 绑定。\n\n```shell\nwasm-pack build\n```\n\n确定开发服务器还在运行，如果不是，需要执行以下命令。\n\n```shell\nnpm run start\n```\n\n刷新`http://localhost:8080/`，你应该能看到如下结果。\n\n![页面](https://rustwasm.github.io/docs/book/images/game-of-life/initial-game-of-life.png)\n\n结束之前，这里还有一个不错的实现生命游戏的算法，[hashlife](https://en.wikipedia.org/wiki/Hashlife)。它使用缓存，使得程序有指数级性能提升！但是为什么我们不实现它呢？它已经超出本文涉及的范围了，本文只是专注于 Rust 和 WebAssembly 集成，但是我们强烈期望你能实现这一算法。\n\n### 练习\n\n#### 实现一台宇宙飞船\n\n#### 生成一个随机的初始环境，每个细胞有 50%的生存可能\n\n**_答案，不许看！_**\n\n先增加 js-sys 依赖\n\n```toml\n[dependencies]\njs-sys=\"0.3\"\n```\n\n接下来使用 js 的随机函数\n\n```Rust\nextern crate js_sys;\n\nif js_sys::Math::random() < 0.5 {\n\n} else {\n\n}\n```\n\n#### 以 bit 形式存储每个 cell\n\n**_答案，不许看！_**\n\n在 Rust 中，使用 fixedbitset 代替`Vec<Cell>`;\n\n```Rust\nextern crate fixedbitset;\nuse fixedbitset::FixedBitSet;\n\n#[wasm_bindgen]\npub struct Universe {\n  width: u32,\n  height: u32,\n  cells: FixedBitSet,\n}\n```\n\n宇宙的构造器应该这么修改。\n\n```Rust\npub fn new() -> Universe {\n  let width = 64;\n  let height = 64;\n\n  let size = (width*height) as usize;\n  let mut cells = FixedBitSet::with_capacity(size);\n\n  for i in 0..size {\n    cells.set(i, i%2==0 || i%7==0);\n  }\n\n  Universe {\n    width,\n    height,\n    cells,\n  }\n}\n```\n\n使用 FixedBitSet 的 set 方法更新宇宙的下一刻。\n\n```Rust\nnext.set(idx, match (cell, live_neighbors) {\n  (true, x) if x<2 => false,\n  (true, 2) | (true, 3) => true,\n  (true, x) if x>3 => false,\n  (false, 3) => true,\n  (otherwise, _) => otherwise\n});\n```\n\n传输指针的时候，需要返回 slice。\n\n```Rust\n#[wasm_bindgen]\nimpl Universe {\n  pub fn cells(&self) -> *const u32 {\n    self.cells.as_slice().as_ptr()\n  }\n}\n```\n\n在 JavaScript 中，构造 Unit8Array 的时候需要除以 8，以为我们是以 bit 存储细胞的。\n\n```JavaScript\nconst cells = new Unit8Array(\n  memory.buffer,\n  cellsPtr,\n  width*height/8\n);\n```\n\n通过判断 Unit8Array 是否被赋值而判断细胞是否是活着的。\n\n```JavaScript\nfunction bitIsSet(n, arr) {\n  const byte = Math.floor(n/8);\n  const mask = 1<<(n%8);\n  return (arr[byte] & mask) == mask;\n}\n```\n\n根据以上变化，新版本的 drawCells 如下。\n\n```JavaScript\nfunction drawCells() {\n  const cellsPtr = universe.cells();\n  const cells = new Unit8Array(\n    memory.buffer,\n    cellsPtr,\n    width*height/8\n  );\n\n  ctx.beginPath();\n\n  for (let row=0; row<height; row+=1) {\n    for(let col=0; col<width; col+=1) {\n      const idx = getIndex(row, col);\n\n      ctx.fillStyle = bitIsSet(idex, cells)\n        ? LIVE_COLOR\n        : DEAD_COLOR;\n\n      ctx.fillRect(\n        col*(CELL_SIZE+1)+1,\n        row*(CELL_SIZE+1)+1,\n        CELL_SIZE,\n        CELL_SIZE,\n      );\n    }\n  }\n\n  ctx.stroke();\n}\n```\n\n## 测试\n\n现在我们已经实现了 Rust 的实现，并成功渲染在浏览器中。现在来谈谈测试 WebAssembly 中的 Rust 函数。\n\n我们将要测试 tick 函数，确保它能返回正确的值。\n\n接下来，我们将处理 Universe 的 setter 函数，让我们能构造不同大小的 universe。\n\n```Rust\n#[wasm_bindgen]\nimpl Universe {\n  pub fn set_width(&mut self, width: u32) {\n    self.width = width;\n    self.cells = (0..width * self.height).map(|_| Cell::Dead).collect()\n  }\n\n  pub fn set_height(&mut self, height: u32) {\n    self.height = height;\n    self.cells = (0..self.width * height).map(|_| Cell::Dead).collect()\n  }\n}\n```\n\n我们将会创建另一个不需要`#[wasm_bindgen]`的`impl Universe`实现，因为我们不能把所有的 WebAssembly 函数暴露给 JavaScript，Rust 生成的 WebAssembly 函数是不能返回引用的。可以尝试让 Rust 返回一个引用，查看一下编译结果中是什么错误。\n\n接下来我们要写一个 get_cells 来获得细胞，和一个 set_cells 来设置哪些细胞是活的，哪些是死的。\n\n```Rust\nimpl Universe {\n  pub fn get_cells(&self) -> &[Cell] {\n    &self.cells\n  }\n\n  pub fn set_cells(&mut self, cells: &[(u32, u32)]) {\n    for (row, col) in cells.iter().cloned() {\n      let idx = self.get_index(row, col);\n      self.cells[idx] = Cell::Alive;\n    }\n  }\n}\n```\n\n现在我们将创建测试文件`tests/web.rs`。\n\n在这之前，测试环境已经配置好，请确定`wasm-pack test --chrome --headless`能够在根目录下运行。你也可以使用`--firefox`，`--safari`和`--node`选项来在其他浏览器测试你的代码。\n\n在`test/web.rs`中，我们需要到处 Universe 类型。\n\n```Rust\nextern crate wasm_game_of_life;\nuse wasm_game_of_life:Universe;\n```\n\n在测试文件中，我们要创建一个飞船构造函数。\n\n我们要构造一个 tick 函数执行之前的飞船，和一个 tick 函数执行后的期望值。\n\n```Rust\n#[cfg(test)]\npub fn input_spaceship() -> Universe {\n  let mut universe = Universe::new();\n\n  universe.set_width(6);\n  universe_set_height(6);\n  universe_set_cells(\n    &[\n      (1,2),\n      (2,3),\n      (3,1), (3,2),(3,3)\n    ]\n  );\n\n  universe\n}\n\n#[cfg(test)]\npub fn expected_spaceship() -> Universe {\n  let mut universe = Universe::new();\n\n  universe.set_width(6);\n  universe_set_height(6);\n  universe_set_cells(\n    &[\n      (2,1), (2,3),\n      (3,2), (3,3),(4,2)\n    ]\n  );\n\n  universe\n}\n```\n\n现在我们写一个 test_tick 函数，创建以上的两个飞船。最后使用`assert_eq!`宏比较 expected_ship 来确保 tick 函数运行正确。我们添加`#[wasm_bindgen_test]`属性保证这个函数可以在 WebAssembly 环境下测试。\n\n```Rust\n#[wasm_bindgen_test]\npub fn test_tick() {\n  let mut input_universe = input_spaceship();\n  let expected_universe = expected_spaceship();\n\n  input_universe.tick();\n  assert_eq!(\n    &input_universe.get_cells(),\n    &expected_universe.get_cells(),\n  )\n}\n```\n\n测试这个测试函数使用`wasm-pack test --firefox --headless`。\n\n## 调试\n\n写这么多代码之前（虽然上面都写完了，我也不知道原作者抽什么风），先看一看 Rust 的调试工具。\n\n### 调试工具\n\n此部分将会介绍 WebAssembly 的调试工具。\n\n#### 使用 debug 标记编译\n\n如果没有打开 debug 标记，\"name\"这个部分就不会被编译到二进制程序中，错误栈也不会显示函数名，你会收到`wasm-functions[42]`而不是`wasm_game_of_file::Universe::live_neighbor_count`。\n\n调试编译，`wasm-pack build --debug`或者`cargo build`总是会默认打开 debug 标记。\n\n版本编译（release build），debug 标记是默认关闭的，要打开 debug 标记，需要声明`debug=true`。\n\n```toml\n[profile.release]\ndebug = true\n```\n\n#### 使用 console API 打印日志\n\n打印日志是最好的判断程序是否是有错的方式。在浏览器中，`console.log`函数可以将日志打印到浏览器的 dev 工具里。\n\n我们可以使用 web-sys 包去调用 console API。\n\n```Rust\nextern crate web_sys;\n\nweb_sys::console::log_1(&\"Hello, world!\".into());\n```\n\n相应的`console.error`函数用法一致，但是浏览器的调用栈还是按照`console.error`来打印。\n\n使用`console.log`：\n\n- [`web_sys::console::log`，接受一个向量的数据做参数](https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.log.html)。\n- [`web_sys::console::log_1`，接受一个数据做参数](https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.log_1.html)。\n- [`web_sys::console::log_2`，接受两个数据做参数](https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.log_2.html)。\n- ...\n\n使用`console.error`：\n\n- [`web_sys::console::error`，接受一个向量的数据做参数](https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.error.html)。\n- [`web_sys::console::error_1`，接受一个数据做参数](https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.error_1.html)。\n- [`web_sys::console::error_2`，接受两个数据做参数](https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.error_2.html)。\n- ...\n\n#### 打印崩溃日志\n\n[`console_error_panic_hook`包能通过`console.error`打印崩溃日志](https://github.com/rustwasm/console_error_panic_hook)。他能打印出格式化的崩溃信息而不是难以理解的`RuntimeError: unreachable executed`。\n\n你只需要增加调用这个钩子函数。\n\n```Rust\n#[wasm_bindgen]\npub fn init_panic_hook() {\n  console_error_panic_hook::set_once();\n}\n```\n\n#### 使用调试器\n\n不幸的，WebAssembly 的调试器依然不成熟，在很多 unix 系统中，DWARF 是用来解析调试程序需要的数据的工具。虽然，Windows 上面也有一个类似的工具。但还没有相当的工具提供给 WebAssembly。所以，调试器目前能给予的功能有限，我们只能收到 WebAssembly 的错误而不是 Rust 源代码的错误。\n\n> 这里有一个故事是[跟踪 WebAssembly 的调试](https://github.com/WebAssembly/debugging)的，我们希望它将来会有所改善！\n\n尽管如此，调试器还是能够给调试 JavaScript 方面提供效力。\n\n#### 一开始就规避在 WebAssembly 上面使用调试\n\n如果错误和交互 JavaScript 和 Web API 有关，则使用`wasm-bindgen-test`写测试。\n\n如果和 JavaScript 和 Web API 无关，这是用默认的`#[test]`属性。使用[`quickcheck`包](https://crates.io/crates/quickcheck)可以减少写测试上面的时间。\n\n为了避免`#[test]`编译器出现连接错误，你需要一个 rlib 依赖，在`Cargo.toml`文件按照如下修改。\n\n```toml\n[lib]\ncrate-type [\"cdylib\", \"rlib\"]\n```\n\n### 在生命游戏中打开崩溃日志\n\n如果程序崩溃，最好是能够在审查工具中看到日志。\n\n在``src/utils.rs`里面有一个可选的 console_error_panic_hook 包，可以在 Universe 初始化的时候调用它。\n\n```Rust\npub fn new() -> Universe {\n  utils::set_panic_hook();\n}\n```\n\n### 为生命游戏增加日志\n\n让我们在 Rust 中利用 web-sys 调用 console，打印出每一刻的细胞状态。\n\n首先在以来中增加 web-sys，修改 Cargo.toml。\n\n```toml\n[dependencies.web-sys]\nversion = \"0.3\"\nfeatures = [\n  \"console\",\n]\n```\n\n为了高效，我们把`console.log`函数封装到`println!`一样的宏中。\n\n```Rust\nextern crate web_sys;\n\nmacro_rules! log {\n  ($( $t:tt )*) => {\n    web_sys::console::log_1(&format!( $( $t )* ).into());\n  }\n}\n```\n\n现在可以通过调用 log 发送日志了。\n\n```Rust\nlog!(\n  \"cell[{}, {}] is initially {:?} and has {} live neighbors\",\n  row,\n  col,\n  cell,\n  live_neighbors,\n)\n```\n\n### 使用调试器\n\n浏览器的调试器在调试 JavaScript 和 Rust 生成的 WebAssembly 很有效。\n\n举个例子，在 renderLoop 函数中增加`debugger;`可以暂停页面执行的某一刻。\n\n者给予我们查看每一刻细胞状态的能力。\n\n![调试画面](https://rustwasm.github.io/docs/book/images/game-of-life/debugging.png)\n\n### 练习\n\n1. 给 tick 方法增加 log，查看细胞状态。\n2. 加入`panic!()`查看打印出来的崩溃日志。\n\n## 增加交互\n\n接下来我们要给这个游戏增加一些交互，我们会允许用户选择细胞的生死，并且允许暂停游戏，并使绘制初始图案更加简单。\n\n### 暂停和继续游戏\n\n首先修改 html，在画布上面增加一个<button>标签。\n\n```html\n<button id=\"play-pause\"></button>\n```\n\n在 JavaScript 中，我们要做以下几点改动。\n\n- 追踪调用 requestAnimationFrame 的标识符，这样我们就能通过调用 cancelAnimationFrame 来终止动画。\n- 当点击播放或者暂停键的时候，先检查标识符是否存在，一旦存在，则表示动画正在运行，我们需要取消动画以保证 renderLoop 不再被调用。如果标识符不存在，我们需要调用 requestAnimationFrame 以保证动画继续运行。\n\n因为是 JavaScript 控制着 Rust 和 WebAssembly，我们不需要修改 Rust 部分。\n\n我们引入 animationId 变量，保存 requestAnimationFrame 的结果。当没有排队的动画时，这个变量值为 null。\n\n```JavaScript\nlet animationId = null;\n\nfunction renderLoop() {\n  drawGrid();\n  drawCells();\n\n  universe.tick();\n\n  animationId = requestAnimationFrame(renderLoop);\n}\n```\n\n任何一个时间，我们可以通过判断 animationId 来判断这个动画是否被暂停。\n\n```JavaScript\nfunction isPaused() {\n  return animationId === null;\n}\n```\n\n现在，当播放暂停键被点击，当正在播放时，暂停动画。并把按钮的状态改为播放。\n\n```JavaScript\nconst playPauseButton = document.getElementById(\"play-pause\");\n\nfunction play() {\n  playPauseButton.textContent = \"⏸\";\n  renderLoop();\n};\n\nfunction pause() {\n  playPauseButton.textContent = \"▶\";\n  cancelAnimationFrame(animationId);\n  animationId = null;\n};\n\nplayPauseButton.addEventListener(\"click\", function playBtnListener(event) {\n  if (isPaused()) {\n    play();\n  } else {\n    pause();\n  }\n});\n```\n\n最后我们把之前的 requestAnimationFrame 函数封装成`play()`。刷新本地服务器，可以看到网页上已经有暂停按钮了。尝试点击一下它吧。\n\n### 修改一个细胞的状态\n\n现在我们能暂停这个游戏了，是时候增加一个修改细胞的功能了。\n\n想控制细胞的生死，需要给`src/lib.rs`下的 Cell 增加一个 toggle 函数。\n\n```Rust\nimpl Cell {\n    fn toggle(&mut self) {\n        *self = match *self {\n            Cell::Dead => Cell::Alive,\n            Cell::Alive => Cell::Dead,\n        };\n    }\n}\n```\n\n想要修改在宇宙中的细胞需要获得细胞的行纵值，并转换为细胞的序号。\n\n```Rust\n#[wasm_bindgen]\nimpl Universe {\n    pub fn toggle_cell(&mut self, row: u32, column: u32) {\n        let idx = self.get_index(row, column);\n        self.cells[idx].toggle();\n    }\n}\n```\n\n这个方法增加第 1 行的属性声明是为了能够在 JavaScript 环境里面直接调用。在 JavaScript 文件中，监听<canvas>标签，将页面上的点击事件转换成画布上的点击事件，并调用 toggle_cell 方法重绘场景。\n\n```Rust\ncanvas.addEventListener(\"click\", function canvasClickListener(event) {\n  const boundingRect = canvas.getBoundingClientRect();\n\n  const scaleX = canvas.width / boundingRect.width;\n  const scaleY = canvas.height / boundingRect.height;\n\n  const canvasLeft = (event.clientX - boundingRect.left) * scaleX;\n  const canvasTop = (event.clientY - boundingRect.top) * scaleY;\n\n  const row = Math.min(Math.floor(canvasTop/(CELL_SIZE + 1)), height - 1);\n  const col = Math.min(Math.floor(canvasLeft/(CELL_SIZE + 1)), width - 1);\n\n  universe.toggle_cell(row, col);\n\n  drawGrid();\n  drawCells();\n});\n```\n\n使用`wasm-pack build`重新编译，刷新网页，并更新细胞状态。\n\n### 练习\n\n- 新建一个<input>标签来处理每帧更新多少个刻。\n- 增加一个重置按钮，把宇宙恢复到初始状态；再增加一个消灭按钮，毁灭所有细胞。\n- 当使用`Ctrl+Click`的时候，增加一个[glider](<https://en.wikipedia.org/wiki/Glider_(Conway%27s_Life)>)，使用`Shift+Click`增加一个 pulsar。\n\n## 性能日志(Time Profiling)\n\n本节我们将会提高这个游戏的性能，我们将会用 time profiling 来完成。\n\n### Time Profiling\n\n此部分将会讲解如何获得页面的性能分析，目标是提高 JavaScript 和 WebAssembly 之间的吞吐。\n\n> 永远使用`wasm-pack build`编译最新的代码，以确定你的优化正确。\n\n#### windows.performance.now()\n\n这个函数会返回以毫秒为单位的时间戳来计算页面加载速度。\n\n调用`performance.now()`的性能损耗低，所以我们可以利用它创造一个简单的测算工具而不是产生很大误差值。\n\n我们可以通过`web-sys`调用时间函数。\n\n```Rust\nextern crate web_sys;\n\nfn now() -> f64 {\n  web_sys::window()\n    .expect(\"should have window\")\n    .performance()\n    .expect(\"should have a Performance\")\n    .now()\n}\n```\n\n#### 开发者工具的性能查看器\n\n所有的浏览器的开发者工具都有性能查看器。这个查看器通过火焰图展示函数调用栈来表示哪一个函数耗时更长。\n\n如果你编译的时候打开了调试，则函数名将会显示在这里（如果没打开则显示一个不透明的名字，比如`wasm-function[123]`）。\n\n注意，因为性能查看器不会显示内联函数，又因为 Rust 和 LVVM 很重地依赖于内联函数，其结果就会让人感到头疼。\n\n![性能查看器无法处理内联函数](https://rustwasm.github.io/docs/book/images/game-of-life/profiler-with-rust-names.png)\n\n#### console.time 和 console.timeEnd\n\n这两个函数是浏览器的内置函数。以调用`console.time(\"foo\")`作为开始，以`console.time(\"foo\")`作为结束，参数是可选的。\n\n你可以通过 web-sys 调用`web_sys::console::time_with_label(\"foo\")`和`web_sys::console::time_end_with_label(\"foo\")`。\n\n如下是浏览器的截图。\n\n![使用console.time的截图](https://rustwasm.github.io/docs/book/images/game-of-life/console-time.png)\n\n另外，`console.time`和`console.timeEnd`会调用性能检查器统计出瀑布图。\n\n#### 使用#[bench]调用原生代码\n\n就像我们能使用原生的测试方法`#[test]`来测试代码，我们可以使用`#[bench]`通过操作系统的工具来查看函数性能。\n\n写好标准函数并放到`benches`文件夹下。确保`crate-type`已经引入 rlib，能使测试代码能够链接。\n\n无论如何，先搞明白你知道 WebAssembly 里面的瓶颈之后再花费精力去调查原生的性能调查器！用你的浏览器的性能调查器，或者使用这些时间去优化你的代码不是更好？\n\n### 利用 window.performance.now 创建一个计时器\n\n创建一个 FPS 的计时器用来调查游戏的渲染速度不失为一个好办法。\n\n我们在 JavaScript 增加 fps 对象。\n\n```JavaScript\nconst fps = new class {\n  constructor() {\n    this.fps = document.getElementById(\"fps\");\n    this.frames = [];\n    this.lastFrameTimeStamp = performance.now();\n  }\n\n  render() {\n    // Convert the delta time since the last frame render into a measure\n    // of frames per second.\n    const now = performance.now();\n    const delta = now - this.lastFrameTimeStamp;\n    this.lastFrameTimeStamp = now;\n    const fps = 1 / delta * 1000;\n\n    // Save only the latest 100 timings.\n    this.frames.push(fps);\n    if (this.frames.length > 100) {\n      this.frames.shift();\n    }\n\n    // Find the max, min, and mean of our 100 latest timings.\n    let min = Infinity;\n    let max = -Infinity;\n    let sum = 0;\n    for (let i = 0; i < this.frames.length; i++) {\n      sum += this.frames[i];\n      min = Math.min(this.frames[i], min);\n      max = Math.max(this.frames[i], max);\n    }\n    let mean = sum / this.frames.length;\n\n    // Render the statistics.\n    this.fps.textContent = `\nFrames per Second:\n         latest = ${Math.round(fps)}\navg of last 100 = ${Math.round(mean)}\nmin of last 100 = ${Math.round(min)}\nmax of last 100 = ${Math.round(max)}\n`.trim();\n  }\n};\n```\n\n接下来再每次迭代中调用 fps render 函数。\n\n```JavaScript\nconst renderLoop = () => {\n    fps.render(); //new\n\n    universe.tick();\n    drawGrid();\n    drawCells();\n\n    animationId = requestAnimationFrame(renderLoop);\n};\n```\n\n最后在 HTML 中增加 fps 的展示。\n\n```JavaScript\n<div id=\"fps\"></div>\n```\n\n增加 CSS，让它展示得更好。\n\n```CSS\n#fps {\n  white-space: pre;\n  font-family: monospace;\n}\n```\n\n好了，现在可以在页面上看到 FPS 计数器了。\n\n### 给每一刻计算时间\n\n每一刻开始调用`console.time`，结束的时候调用`console.timeEnd`。\n\n首先，要在`Cargo.toml`里面增加 web-sys。\n\n```toml\n[dependencies.web-sys]\nversion = \"0.3\"\nfeatures = [\n  \"console\",\n]\n```\n\n因为每次执行`console.time`后总要执行`console.timeEnd`，把他们包再[RAII](https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization)类型下就会更加便利。\n\n```Rust\nextern crate web_sys;\nuse web_sys::console;\n\npub struct Timer<'a> {\n    name: &'a str,\n}\n\nimpl<'a> Timer<'a> {\n    pub fn new(name: &'a str) -> Timer<'a> {\n        console::time_with_label(name);\n        Timer { name }\n    }\n}\n\nimpl<'a> Drop for Timer<'a> {\n    fn drop(&mut self) {\n        console::time_end_with_label(self.name);\n    }\n}\n```\n\n接下来，统计每一刻用的时间是多久，只需把初始化 Timer 放到 Universe 的构造函数里。\n\n```Rust\nlet _timer = Timer::new(\"Universe::tick\");\n```\n\n如下是每一刻执行的时间。\n\n![每一刻的执行时间](https://rustwasm.github.io/book/images/game-of-life/console-time.png)\n\n另外，通过使用`console.time`和`console.timeEnd`也能获得执行性能数据。\n\n![性能数据](https://rustwasm.github.io/book/images/game-of-life/console-time-in-profiler.png)\n\n### 增加宇宙大小\n\n> 本部分是拿火狐浏览器做例子，当然还有很多浏览器有类似的功能，只是有细微的差别。这个数据是一致的，但是部分命名和标量可能不一样。\n\n如果我们把宇宙修改的大一些，会发生什么？把 64x64 改成 128x128，结果会把 fps 从 60 降到 40。\n\n如果我们打开性能监控器，并看到它的瀑布图，我们可以看到动画帧用了 20 毫秒，回顾 60fps 时渲染一页则需要 16 毫秒，这不仅仅是 JavaScript 和 WebAssembly，还包括重绘的部分。\n\n![性能监视](https://rustwasm.github.io/book/images/game-of-life/drawCells-before-waterfall.png)\n\n如果仔细查看，可以看到`CanvasRenderingContext2D.fillStyle`的 setter 是很耗费时间的。\n\n> 再火狐，你可能看到的是\"DOM\"而不是\"CanvasRenderingContext2D.fillStyle\"，你需要打开\"展示 Gecko 平台数据\"。\n\n![火狐的性能监视器](https://rustwasm.github.io/book/images/game-of-life/profiler-firefox-show-gecko-platform.png)\n\n当然，这并不稀奇，40%的的时间都浪费在这个 setter 上面。\n\n> 我们可能期望性能瓶颈再 tik 函数上，但并不是。永远选择性能监视器观察，因为你可能浪费很多时间在无关的地方上面。\n\n在 drawCell 上面，fillStyle 在每次动画和每个细胞上面使用。\n\n```JavaScript\nfor (let row = 0; row < height; row++) {\n  for (let col = 0; col < width; col++) {\n    const idx = getIndex(row, col);\n\n    ctx.fillStyle = cells[idx] === DEAD\n      ? DEAD_COLOR\n      : ALIVE_COLOR;\n\n    ctx.fillRect(\n      col * (CELL_SIZE + 1) + 1,\n      row * (CELL_SIZE + 1) + 1,\n      CELL_SIZE,\n      CELL_SIZE\n    );\n  }\n}\n```\n\n现在我们知道 fillStyle 资源耗费比较多，那么我们该怎么避免他呢？我们需要判断细胞的生命状态来自决定 fillStyle 的值，设想，如果先设定`fillStyle = ALIVE_COLOR`，再绘制所有的活着的细胞，然后设置`fillStyle = DEAD_COLOR`，再设置所有的死细胞，最后我们只设置 fillStyle 两次。\n\n```JavaScript\n// Alive cells.\nctx.fillStyle = ALIVE_COLOR;\nfor (let row = 0; row < height; row++) {\n  for (let col = 0; col < width; col++) {\n    const idx = getIndex(row, col);\n    if (cells[idx] !== Cell.Alive) {\n      continue;\n    }\n\n    ctx.fillRect(\n      col * (CELL_SIZE + 1) + 1,\n      row * (CELL_SIZE + 1) + 1,\n      CELL_SIZE,\n      CELL_SIZE\n    );\n  }\n}\n\n// Dead cells.\nctx.fillStyle = DEAD_COLOR;\nfor (let row = 0; row < height; row++) {\n  for (let col = 0; col < width; col++) {\n    const idx = getIndex(row, col);\n    if (cells[idx] !== Cell.Dead) {\n      continue;\n    }\n\n    ctx.fillRect(\n      col * (CELL_SIZE + 1) + 1,\n      row * (CELL_SIZE + 1) + 1,\n      CELL_SIZE,\n      CELL_SIZE\n    );\n  }\n}\n```\n\n修改之后，刷新页面，此时的 fps 已经上升到 60。\n\n如果重新看原来的数据，现在每一刻只使用 10 毫秒。\n\n![更新后的性能检查](https://rustwasm.github.io/book/images/game-of-life/drawCells-after-waterfall.png)\n\n消除了 fillStyle 的性能瓶颈，发现比较消耗资源的是 fillRect，用来绘制每一个细胞的。\n\n![目前的性能损耗都在fillRect上面](https://rustwasm.github.io/book/images/game-of-life/drawCells-after-flamegraph.png)\n\n### 让时间变快\n\n有些人可能不喜欢等待，更希望一帧跑完九刻而不是一刻。我们可以通过修改 renderLoop 函数实现。\n\n```JavaScript\nfor (let i = 0; i < 9; i++) {\n  universe.tick();\n}\n```\n\n在机器上，fps 降到了 35，但是我们一定要到 60fps！\n\n现在我们知道性能瓶颈在 tick 函数上面，所以我们给函数的每一步都加上 Timer 监视，我猜测是创建向量和释放向量占用了很多资源造成的。\n\n```Rust\npub fn tick(&mut self) {\n    let _timer = Timer::new(\"Universe::tick\");\n\n    let mut next = {\n        let _timer = Timer::new(\"allocate next cells\");\n        self.cells.clone()\n    };\n\n    {\n        let _timer = Timer::new(\"new generation\");\n        for row in 0..self.height {\n            for col in 0..self.width {\n                let idx = self.get_index(row, col);\n                let cell = self.cells[idx];\n                let live_neighbors = self.live_neighbor_count(row, col);\n\n                let next_cell = match (cell, live_neighbors) {\n                    // Rule 1: Any live cell with fewer than two live neighbours\n                    // dies, as if caused by underpopulation.\n                    (Cell::Alive, x) if x < 2 => Cell::Dead,\n                    // Rule 2: Any live cell with two or three live neighbours\n                    // lives on to the next generation.\n                    (Cell::Alive, 2) | (Cell::Alive, 3) => Cell::Alive,\n                    // Rule 3: Any live cell with more than three live\n                    // neighbours dies, as if by overpopulation.\n                    (Cell::Alive, x) if x > 3 => Cell::Dead,\n                    // Rule 4: Any dead cell with exactly three live neighbours\n                    // becomes a live cell, as if by reproduction.\n                    (Cell::Dead, 3) => Cell::Alive,\n                    // All other cells remain in the same state.\n                    (otherwise, _) => otherwise,\n                };\n\n                next[idx] = next_cell;\n            }\n        }\n    }\n\n    let _timer = Timer::new(\"free old cells\");\n    self.cells = next;\n}\n```\n\n看这些时间戳，很明显我的猜测是错误的：大部分时间确实用在计算下一代细胞上面，每一刻都调用和释放向量竟然无足轻重。所以一定要使用性能监视器！\n\n![性能监视](https://rustwasm.github.io/book/images/game-of-life/console-time-in-universe-tick.png)\n\n下一部分需要`nightly`编译，因为我们将会使用[test-feature-gate](https://doc.rust-lang.org/unstable-book/library-features/test.html)来跑 benchmark（性能测试）。我们将会安装另一个工具[cargo-benchcmp](https://github.com/BurntSushi/cargo-benchcmp)。一个迷你的有`cargo bench`支持的性能测试工具。\n\n让我们写一个函数使用`#[bench]`属性，我们可以使用更成熟的测试工具测试它。\n\n```Rust\n#![feature(test)]\n\nextern crate test;\nextern crate wasm_game_of_life;\n\n#[bench]\nfn universe_ticks(b: &mut test::Bencher) {\n    let mut universe = wasm_game_of_life::Universe::new();\n\n    b.iter(|| {\n        universe.tick();\n    });\n}\n```\n\n我们也要注释掉所有`#[wasm_bindgen]`，否则\"cdylib\"或则其他编译流程会失败，\n\n此时，我们可以跑`cargo bench | tee before.txt`来编译项目查看性能日志了！\n\n```shell\n$ cargo bench | tee before.txt\n    Finished release [optimized + debuginfo] target(s) in 0.0 secs\n     Running target/release/deps/wasm_game_of_life-91574dfbe2b5a124\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n     Running target/release/deps/bench-8474091a05cfa2d9\n\nrunning 1 test\ntest universe_ticks ... bench:     664,421 ns/iter (+/- 51,926)\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out\n```\n\n他也告诉我们二进制文件的位置，我们可以跑第二次性能测试。但这次可以使用系统的性能测试工具。因为我用的是 Linux，所以 perf 就是我的测试工具。\n\n```shell\n$ perf record -g target/release/deps/bench-8474091a05cfa2d9 --bench\nrunning 1 test\ntest universe_ticks ... bench:     635,061 ns/iter (+/- 38,764)\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out\n\n[ perf record: Woken up 1 times to write data ]\n[ perf record: Captured and wrote 0.178 MB perf.data (2349 samples) ]\n```\n\n查看性能测试报告，得知所有的时间都如期使用在`Universe::tick`。\n\n![perf的结果](https://rustwasm.github.io/book/images/game-of-life/bench-perf-report.png)\n\nperf 会指明函数中到底是什么操作引起的性能损耗（译者：虽然我也没看出来）。\n\n![perf的结果](https://rustwasm.github.io/book/images/game-of-life/bench-perf-annotate.png)\n\n它告诉我们 26.67%的时间花在总和细胞数目，23.41%的时间花在获取列序号，另外 15.42%花在取得行序号。这三个性能瓶颈中，第二和第三都使用了比较耗费性能的 DIV 命令。这些 DIV 的实现是在`Universe::live_neighbor_count`。\n\n回想这个函数的定义：\n\n```Rust\nfn live_neighbor_count(&self, row: u32, column: u32) -> u8 {\n    let mut count = 0;\n    for delta_row in [self.height - 1, 0, 1].iter().cloned() {\n        for delta_col in [self.width - 1, 0, 1].iter().cloned() {\n            if delta_row == 0 && delta_col == 0 {\n                continue;\n            }\n\n            let neighbor_row = (row + delta_row) % self.height;\n            let neighbor_col = (column + delta_col) % self.width;\n            let idx = self.get_index(neighbor_row, neighbor_col);\n            count += self.cells[idx] as u8;\n        }\n    }\n    count\n}\n```\n\n使用取余运算是为了避免使用杂乱的 if 代码来处理边界，但导致我不得不用 DIV 这样比较耗费性能的指令。相反，如果用 if 处理边界，并展开循环，则分支条件将会比较适合 CPU 处理。\n\n```Rust\nfn live_neighbor_count(&self, row: u32, column: u32) -> u8 {\n    let mut count = 0;\n\n    let north = if row == 0 {\n        self.height - 1\n    } else {\n        row - 1\n    };\n\n    let south = if row == self.height - 1 {\n        0\n    } else {\n        row + 1\n    };\n\n    let west = if column == 0 {\n        self.width - 1\n    } else {\n        column - 1\n    };\n\n    let east = if column == self.width - 1 {\n        0\n    } else {\n        column + 1\n    };\n\n    let nw = self.get_index(north, west);\n    count += self.cells[nw] as u8;\n\n    let n = self.get_index(north, column);\n    count += self.cells[n] as u8;\n\n    let ne = self.get_index(north, east);\n    count += self.cells[ne] as u8;\n\n    let w = self.get_index(row, west);\n    count += self.cells[w] as u8;\n\n    let e = self.get_index(row, east);\n    count += self.cells[e] as u8;\n\n    let sw = self.get_index(south, west);\n    count += self.cells[sw] as u8;\n\n    let s = self.get_index(south, column);\n    count += self.cells[s] as u8;\n\n    let se = self.get_index(south, east);\n    count += self.cells[se] as u8;\n\n    count\n}\n```\n\n接下来再跑一次性能测试，将他输出到`after.txt`。\n\n```shell\n$ cargo bench | tee after.txt\n   Compiling wasm_game_of_life v0.1.0 (file:///home/fitzgen/wasm_game_of_life)\n    Finished release [optimized + debuginfo] target(s) in 0.82 secs\n     Running target/release/deps/wasm_game_of_life-91574dfbe2b5a124\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n     Running target/release/deps/bench-8474091a05cfa2d9\n\nrunning 1 test\ntest universe_ticks ... bench:      87,258 ns/iter (+/- 14,632)\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out\n```\n\n感觉性能提高了不少，现在对比一下前后的数据。\n\n```shell\n$ cargo benchcmp before.txt after.txt\n name            before.txt ns/iter  after.txt ns/iter  diff ns/iter   diff %  speedup\n universe_ticks  664,421             87,258                 -577,163  -86.87%   x 7.61\n```\n\n哇！提高了 7.61 倍！\n\nWebAssembly 意图和原生系统贴近，但是我们确实需要在 WebAssembly 环境下也作一次测试。\n\n从新编译程序，刷新浏览器页面，画面重新跑在 60fps，每一帧大概是 10 毫秒。\n\n成功！\n\n![测试结果](https://rustwasm.github.io/book/images/game-of-life/waterfall-after-branches-and-unrolling.png)\n\n### 练习\n\n- 现在，下一个性能瓶颈是`Universe::tick`调用和释放函数的部分，尝试缓存细胞状态，让 Universe 维护两个向量，永远不释放他们，也不掉用新的区间。\n- 换一种方式实现游戏，让 Rust 和 JavaScript 以细胞的列表交互，这样能让渲染画布更快吗？你能实现这个设计同时不在每个 tick 函数中调用新的列表吗？\n- 就性能显示来看 2D 画布渲染显然不够快，使用 WebGL 画布重新渲染，WebGL 能多快？使用 WebGL 能在遇到瓶颈前创建多大的宇宙空间？\n\n## 压缩.wasm 文件大小\n\nrustc 有很多配置项，可以让`.wasm`二进制文件更加小。在很多情况下更小的生成文件意味着更长的编译时间。另外更小的文件使得 WebAssembly 的运行时间更长。我们应该意识到这些方面上的牺牲。在这些情况下，当我们要减少编译文件大小时，我们应该考虑到使用性能监视器衡量一下这种改动是否值得。\n\n### 使用链接配置器编译\n\n在`Cargo.toml`，增加`lto=true`：\n\n```toml\n[profile.release]\nlto = true\n```\n\n者给予 LLVM 更多机会去内联和简化函数，不仅仅会使`.wasm`更小，还会让他在运行时运行得更快！但是会让他编译得更长。\n\n### 配置 LLVM 牺牲速度换文件大小\n\nLLVM 默认配置是为了运行速度，并不是大小。我们可以通过更改`Cargo.toml`去修改这一配置。\n\n```toml\n[profile.release]\nopt-level = 's'\n```\n\n或者，更激进的可以把它改成\"z\"。\n\n但是，配置为\"s\"的时候有的时候会比\"z\"更小，所以一定要做测量！\n\n### 使用 wasm-opt 工具\n\n[Binaryen](https://github.com/WebAssembly/binaryen)是一个关于 WebAssembly 编译工具的集合。他比 LLVM 更加后端，使用`wasm-opt`处理生成文件常常会节省 15%~20%的代码，同时又会提高运行速度。\n\n```\n# 输出为压缩的文件大小。\nwasm-opt -Os -o output.wasm input.wasm\n\n# 更激进的输出为压缩的文件大小。\nwasm-opt -Oz -o output.wasm input.wasm\n\n# 输出文件追求运行速度。\nwasm-opt -O -o output.wasm input.wasm\n\n# 输出文件更激进的追求运行速度。\nwasm-opt -O3 -o output.wasm input.wasm\n```\n\n#### 注意调试信息\n\n占用生成文件大小的主要成分是调试信息和函数名。`wasm-pack`能够默认移除调试信息。然而`wasm-opt`在使用`-g`参数时能删除函数名。\n\n这意味着，如果你按照以上操作，生成文件应该既没有调试信息也没有函数名。如果你想保留某些调试信息，请一定注意这一点。\n\n### 文件大小检查调查\n\n如果修改编译配置不能获得更小的文件大小，就应该调查一下是什么代码导致文件太大。\n\n> 就像做性能测试，我们应让工具来判断哪里出了问题，否则我们会浪费更多自己的时间。\n\n#### twiggy 代码检查器\n\n[twiggy](https://github.com/rustwasm/twiggy)是一个支持 WebAssembly 的代码大小检查器，他能分析二进制代码的调用图，并解决如下问题：\n\n- 为什么这个函数被编译到这段代码中。\n- 这个函数占用大小是多少？如果我删除这个函数以及其相关函数我能节省多大的空间？\n\n```\n$ twiggy top -n 20 pkg/wasm_game_of_life_bg.wasm\n Shallow Bytes │ Shallow % │ Item\n───────────────┼───────────┼────────────────────────────────────────────────────────────────────────────────────────\n          9158 ┊    19.65% ┊ \"function names\" subsection\n          3251 ┊     6.98% ┊ dlmalloc::dlmalloc::Dlmalloc::malloc::h632d10c184fef6e8\n          2510 ┊     5.39% ┊ <str as core::fmt::Debug>::fmt::he0d87479d1c208ea\n          1737 ┊     3.73% ┊ data[0]\n          1574 ┊     3.38% ┊ data[3]\n          1524 ┊     3.27% ┊ core::fmt::Formatter::pad::h6825605b326ea2c5\n          1413 ┊     3.03% ┊ std::panicking::rust_panic_with_hook::h1d3660f2e339513d\n          1200 ┊     2.57% ┊ core::fmt::Formatter::pad_integral::h06996c5859a57ced\n          1131 ┊     2.43% ┊ core::str::slice_error_fail::h6da90c14857ae01b\n          1051 ┊     2.26% ┊ core::fmt::write::h03ff8c7a2f3a9605\n           931 ┊     2.00% ┊ data[4]\n           864 ┊     1.85% ┊ dlmalloc::dlmalloc::Dlmalloc::free::h27b781e3b06bdb05\n           841 ┊     1.80% ┊ <char as core::fmt::Debug>::fmt::h07742d9f4a8c56f2\n           813 ┊     1.74% ┊ __rust_realloc\n           708 ┊     1.52% ┊ core::slice::memchr::memchr::h6243a1b2885fdb85\n           678 ┊     1.45% ┊ <core::fmt::builders::PadAdapter<'a> as core::fmt::Write>::write_str::h96b72fb7457d3062\n           631 ┊     1.35% ┊ universe_tick\n           631 ┊     1.35% ┊ dlmalloc::dlmalloc::Dlmalloc::dispose_chunk::hae6c5c8634e575b8\n           514 ┊     1.10% ┊ std::panicking::default_hook::{{closure}}::hfae0c204085471d5\n           503 ┊     1.08% ┊ <&'a T as core::fmt::Debug>::fmt::hba207e4f7abaece6\n```\n\n#### 手动修改 LLVM-IR\n\nLLVM-IR 是 LLVM 生成 WebAssembly 代码的最后一步。所以，他和最终生成的 WebAssembly 很像。更多的 LLVM-IR 代码意味着生成的文件越大，当一个函数占用了 LLVM-IR 中 25%的位置，则代表他占用了 25%的文件大小。当然这些数字只是个经验值，因为 LLVM-IR 还有一些 WebAssembly 没有的重要的信息（因为 WebAssembly 没有诸如 DWARF 调试信息）。\n\n你可以使用 cargo 生成 LLVM-IR 代码：\n\n```shell\ncargo rustc --release -- --emit llvm-ir\n```\n\n接下来你可以使用 find 命令去寻找存储在 cargo 生成目录(target)下的`.ll`文件。\n\n```shell\nfind target/release -type f -name '*.ll'\n```\n\n相关可以参考[LLVM 语言](https://llvm.org/docs/LangRef.html)\n\n#### 更激进的工具\n\n修改编译配置是比较好上手的。如果你想前进一个里程，你可以使用一些更激进的工具，像是重写代码以减少冗余。以下是一些不太优雅的代码，但是的确能减少生成文件大小。\n\n##### 避免字符串格式化\n\n`format!`,`to_string`等，能加入很多冗余代码。如果可能，在调试环境用格式化，而在发布环境使用静态字符串。\n\n##### 避免使用崩溃\n\n这很明显，使用 twiggy 之类的工具或者人工检查 LLVM-IR 能帮助你查出到底哪个函数崩溃。\n\n崩溃并不总是出现在`panic!()`宏，他们会在很多情况下出现。\n\n- 访问切片越界，如：`my_slice[i]`\n- 除 0，如：`dividend/divider`\n- 解 Option 类型或者 Result 类型，如：`opt.unwrap()`或者`res.unwrap()`\n\n前两个可以被改成第三个，访问切片可以使用`my_slice.get(i)`。除法可以使用`checked_div`，所以你只有一种需要处理的情况。\n\n解开`Option`或者`Result`有两种方法安全的和不安全的。\n\n安全的方式是使用 abort 方法而不是返回 None 和 Error 值。\n\n```Rust\n#[inline]\npub fn unwrap_abort<T>(o: Option<T>) -> T {\n  use std::process;\n  match o {\n    Some(t) => t,\n    None => process::abort(),\n  }\n}\n```\n\n最终，崩溃在`wasm32-unknown-unknown`被翻译成退出，因此不会造成代码冗余。\n\n相反的，[unreachable](https://crates.io/crates/unreachable)包为 Option 和 Result 类型提供不安全的[unchecked_unwrap](https://docs.rs/unreachable/1.0.0/unreachable/trait.UncheckedOptionExt.html#tymethod.unchecked_unwrap)方法。让 Rust 编译器假定 Option 类型是 Some 类型而 Result 类型是 Ok 类型。如果值是不正确的的情况是未被考虑的。你一定要在 110%确认的情况下使用这个包，因为编译器可没那么聪明能预估出错误。即使你这么做了，你一定要在调试环境下面做检查，而在发布环境下去掉检查。\n\n#### 避免调用内存或者使用 wee_alloc\n\nRust 的默认调用器是`dlmalloc`的一部分。它能达到 10KB。如果能够避免动态调用，你应该能省下 10KB。\n\n完全避免动态语言调用可能会非常困难。但是删除调用却在某些情况下很简单，在这些情况下，可以使用[`wee_alloc`](https://github.com/rustwasm/wee_alloc)代替全局的调用器可以从 10KB 中节省很多。`we_alloc`是当你想要一些调用器时的一个选择，并能同时减少代码大小。\n\n#### 使用 trait 来替代泛型\n\n当你创建一些泛型函数。\n\n```Rust\nfn whatever<T: MyTrait>(t: T) { ... }\n```\n\n`rustc`和 LLVM 会为不同类型生成新的函数拷贝。这为编译器提供了各种类型使用这个函数的机会。但会增加代码大小。\n\n如果你为对象提供 trait，如下：\n\n```Rust\nfn whatever(t: Box<MyTrait>) { ... }\n// or\nfn whatever(t: &MyTrait) { ... }\n// etc...\n```\n\n这样经过虚调用动态派遣（dynamic dispatch）的方法就被使用了，如此只会用一个函数会放在`.wasm`。这样的缺点是丢失了编译器自定义的机会，并且增加了不直接的，动态的语言调用。\n\n#### 使用 wasm-snip 工具\n\n[`wasm-snip`](https://github.com/fitzgen/wasm-snip)使用`unreachable`方法代替了 WebAssembly 的函数。这是一个又沉又钝的锤子，更像是徒手。\n\n也许你知道有些函数可能永远不会在运行时被调用，但是编译器不能保证？掐了他！执行`wasm-opt`加上`--dce`参数，所有无关函数就会被剪掉。\n\n这个工具对删除崩溃及其有用。\n\n### 我们能把生命游戏缩到多小？\n\n默认的配置下，WebAssembly 二进制大小为 29410 字节。\n\n```shell\n$ wc -c pkg/wasm_game_of_life_bg.wasm\n29410 pkg/wasm_game_of_life_bg.wasm\n```\n\n打开 LTO 之后设置`opt-level=\"z\"`执行`wasm-opt -Oz`，结果是 17317 字节。\n\n```shell\n$ wc -c pkg/wasm_game_of_life_bg.wasm\n17317 pkg/wasm_game_of_life_bg.wasm\n```\n\n如果使用 gzip 压缩，你能搞到 9045 字节！\n\n```shell\n$ gzip -9 < pkg/wasm_game_of_life_bg.wasm | wc -c\n9045\n```\n\n### 练习\n\n- 使用`wasm-snp`工具删掉会有崩溃的函数，它能减少多少字节？\n- 使用`wee_alloc`作为全局调用器，，修改`Cargo.toml`：\n\n```\n[features]\ndefault = [\"wee_alloc\"]\n```\n\n能够减少多少大小呢？\n\n- 我们只实现了一个 Universe，所以相比使用构造器，我们可以导出一个`static mut`实例，如果这个实例使用的是双向缓存，我们也可以让这些缓存也是全局`staic mut`。这样就移除了所有的动态调用，我们可以增加`#![no_std]`包取消掉调用器。这回能缩小多少大小？\n\n## 发布到 NPM\n\n首先，确保你登入了 npm。\n\n接着，使用`wasm-pack login`登入。\n\n### 发布\n\n确保已经执行`wasm-pack build`并且 pkg 文件已经编译好。\n\n已经准备好之后，跑`wasm-pack publish`上传包到 npm。\n\n这样就发布了！\n\n有哥们照着这个指导做完发布失败，是因为\"name\"字段存在重名\n\n```toml\n[package]\nname = \"wasm-game-of-life-my-username\"\n```\n\n接着，重新编译并发布\n\n```shell\nwasm-pack build\nwasm-pack publish\n```\n\n这会应该能行。\n\n## 与 JavaScript 相互交互\n\n### JavaScript 函数的输出和引用\n\n#### 在 Rust 一边\n\n在 JavaScript 为主的世界里使用 WebAssembly，引入和输出函数比较直接，有点类似于 C。\n\nWebAssembly 模块声明了一系列引入，每一个都有模块名。模块名可以使用`#[link(wasm_import_module)]`提供给`extern {...}`。\n\n导出的 WebAssembly 线性内存被导出作\"memory\"。\n\n```Rust\n// import a JS function called `foo` from the module `mod`\n#[link(wasm_import_module = \"mod\")]\nextern { fn foo(); }\n\n// export a Rust function called `bar`\n#[no_mangle]\npub extern fn bar() { /* ... */ }\n```\n\n因为 WebAssembly 的值类型有局限，这些函数只有基础的数字类型。\n\n#### 在 JavaScript 一边\n\n在 JavaScript 中，wasm 二进制文件转换成 ES6 模块。它必须被实例化为线性内存并由一系列函数能对应到这些引入。细节描述可在[MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiateStreaming)找到。\n\nES6 的模块包括从 Rust 暴露给 JavaScript 的函数，现在可以用 JavaScript 调用。\n\n[这里](https://www.hellorust.com/demos/add/index.html)有一个很简单的构建流程。\n\n### 除了数字\n\n当在 JavaScript 中使用 WebAssembly，WebAssembly 的内存和 JavaScript 的内存有很大的不同。\n\n- 每个 WebAssembly 模块的线性内存，JavaScript 可以自由访问。\n- 对应之下，WebAssembly 不能访问 JavaScript 的内存。\n\n所以，有两种复杂的交互。\n\n- 复制二进制数据到 WebAssembly 内存。\n- 建立一个在 JavaScript 上的堆内存，提供一堆地址。这样 WebAssembly 访问 JavaScript 对象，间接通过 JavaScript 访问。\n\n幸运的是，通过`bindgen`框架[`wasm-bindgen`](https://github.com/rustwasm/wasm-bindgen)可以帮助交互。这个框架可以将已习惯的 Rust 语言自动翻译到 JavaScript。\n\n### 自定义部分（译者：所以这个到底是干什么用的？）\n\n自定义部分允许随意继承人一的数据进入 WebAssembly 模块，这个数据是在编译时设置，不能在运行时修改。\n\n在 Rust 中，自定义部分是通过`#[link_section]`属性暴露的静态数组([T; size])。\n\n```Rust\n#[link_section = \"hello\"]\npub static SECTION: [u8; 24] = *b\"This is a custom section\";\n```\n\n这样给 wasm 增加一个 hello 部分，这个 SECTION 变量是随意的，但是无论怎么赋值，内容总是这些文字。\n\n这个自定义内容可以被 JavaScript 通过[`WebAssembly.Module.customSections`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Module/customSections)获得自定义部分，它返回一个`ArrayBuffer`，如果有同名的部分，他们会被放到一个数组中。\n\n```JavaScript\nWebAssembly.compileStreaming(fetch(\"sections.wasm\"))\n.then(mod => {\n  const sections = WebAssembly.Module.customSections(mod, \"hello\");\n\n  const decoder = new TextDecoder();\n  const text = decoder.decode(sections[0]);\n\n  console.log(text); // -> \"This is a custom section\"\n});\n```\n\n## 哪些包能在 WebAssembly 下面使用\n\n最简单的就是列出 WebAssembly 上能用的 Rust 包：如果避开了以下内容，则这些包可以在 WebAssembly 使用。如果一个包支持`#![no_std]`\n的包，这个包也可能支持 WebAssembly。\n\n### 以下包不能使用\n\n#### C 和系统级依赖\n\nWebAssembly 不提供系统一级别的库，所以任何链接系统库的地方都无法成功。\n\n使用 C 库可能不会成功，既然没有稳定的交叉编译 ABI，和提供给 WebAssembly 交叉链接的连接库。虽然 clang 已经发布 wasm32 的生成，但是还远远不足。\n\n#### 文件 I/O\n\nWebAssembly 没有访问文件系统的功能，所以访问文件系统的库都不能使用。\n\n#### 调用线程\n\n目前有计划[加入线程](https://rustwasm.github.io/2018/10/24/multithreading-rust-and-wasm.html)，但是还没被发布。尝试调用线程会导致崩溃。\n\n### 有哪些目的的包能在 WebAssembly 下面使用\n\n如果只是提供[算法](https://crates.io/categories/algorithms)和[数据结构](https://crates.io/categories/data-structures)的包。\n\n#### #![no-std]\n\n[不依赖于标准库的包](https://crates.io/categories/no-std)能够运行在 WebAssembly 下面。\n\n#### 解析器\n\n只要是接受输入且无需文件操作的[解析器](https://crates.io/categories/parser-implementations)就可能运行在 WebAssembly 下。\n\n#### 文字处理\n\n[复杂的语言处理](https://crates.io/categories/text-processing)可能会运行在 WebAssembly 下面。\n\n#### Rust 范式\n\n[适用于不同情况下的包](https://crates.io/categories/rust-patterns)可能运行在 WebAssembly 下。\n\n## 如何给常用库增加 WebAssembly 支持\n\n本部分讲解如何将常用库增加 WebAssembly 支持。后面的内容我就捡感兴趣的写了。\n\n### 在 CI 增加 wasm32-unknown-unknown\n\n保证 CI 中增加如下命令\n\n```shell\nrustup target add wasm32-unknown-unknown\ncargo check --target wasm32-unknown-unknown\n```\n\n举个例子，在 travis 的配置中增加如下配置：\n\n```yaml\nmatrix:\n  include:\n    - language: rust\n      rust: stable\n      name: \"check wasm32 support\"\n      install: rustup target add wasm32-unknown-unknown\n      script: cargo check --target wasm32-unknown-unknown\n```\n\n### 在 node.js 或者无头浏览器（译者：卧槽是这么翻译么）\n\n你可以使用`wasm-bindgen-test`和`wasm-pack test`去跑测试，详细内容上面已经提到。\n\n## 发布 WebAssembly 到线上\n\n> 发布过程几乎和任何 web 应用发布是一样的。\n\n为了发布 Web 应用，复制生成文件到线上环境，配置你的 HTTP 服务器让他们可访问。\n\n### 保证服务器支持 application/wasm\n\n为了让浏览器加载变快，[WebAssembly.instantiateStreaming](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiateStreaming)函数会使用管道传输文件（请确定你的打包器能够使用这个函数）。但是 instantiateStreaming 需要 HTTP 返回类型支持`application/wasm`，否则会丢出错误。\n\n- [如何配置 Apache 服务器](https://httpd.apache.org/docs/2.4/mod/mod_mime.html#addtype)\n- [如何配置 Nginx 服务器](https://nginx.org/en/docs/http/ngx_http_core_module.html#types)\n\n### 更多内容\n\n- [webpack 线上打包的最佳实践](https://webpack.js.org/guides/production/)\n","collection":"blog","data":{"type":"post","category":"fe","tag":["rust","wasm"]}},{"id":"2020/03/05/Jekyll-Gatsby.md","slug":"2020/03/05/jekyll-gatsby","body":"\n# 从 Jekyll 迁移博客到 Gatsby\n\n很久以前就想迁移了，但是一直没下手，原因很简单，就是 ruby 不太熟悉，而使用 node 工具链比较趁手。\n\n当然了，Gatsby 的主题对比 Jekyll 就少太多了，没关系，大不了自己设计（又是一个大坑）。\n\n[Gatsby 官网](https://www.gatsbyjs.org/)的 tutorial 已经很详细了，这里只提简单的几个注意。\n\n- 所谓的 TypeScript 项目仅仅指的是前端，后端部分（因为是静态服务，应该说成编译的钩子`gatsby-node.js`）还是用的是 JavaScript，但是可以通过引入`ts-node`实现引用 TypeScript 文件。\n\n- 不确定是不是 WSL 或者 Windows 的锅，执行`gatsby develop`或者`gatsby build`的时候会偶尔出现权限无法访问并在根目录创建`reduxcache*`文件，挺烦人的其实，回头还得执行`sudo rm -Rf reduxcahce*`删除。\n\n- 无论`components`还是`pages`，其实都做了一层隐式封装，所以只有`default`暴露的组件参能使用 Gatsby 里面诸如`useStaticQuery`的钩子函数。\n\n- Gatsby 默认的 URL 格式和 Jekyll 不一样，为了保持持续性，我修改了`server/onCreateNode`来修改文件的 URL。\n\n- 修改 Travis 上传到`gh-pages`分支后，服务竟然挂了，查看 setting 说我只能在`master`分支上面放编译后的文件（莫非政策有变化？）。无所谓了，把`gatsby`分支改成默认分支，设置`master`分支为部署分支即可。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["jekyll","gatsby"]}},{"id":"2020/03/06/Utterance-GitHub-issue.md","slug":"2020/03/06/utterance-github-issue","body":"\n# 使用 Utterance 为博客添加基于 Github-issue 的评论系统\n\n最近在重构我部署在 GitHub pages 的博客，本来不想添加评论系统的，但是手贱，非想要加一个。\n\n尝试了 disqus（一个在国内无法使用的评论系统），貌似`page.url`中不能使用中文字符...这就尴尬了，突然想起来以前看 hackernews 的时候有人提起过使用 GitHub issue 搭建博客的想法。如果你是直接使用静态页面做网站，只需要去[Utterance](https://utteranc.es/)授权 GitHub 账号，复制对应的代码粘贴到网站即可。\n\n因为我新重构的网站是基于 Gatsby 的，Utterance 也提供了[react 高阶组件](https://www.npmjs.com/package/with-utterances)可以使用。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["github"]}},{"id":"2020/03/10/docker-strapi.md","slug":"2020/03/10/docker-strapi","body":"\n# 腾讯云 docker 安装 strapi\n\n## Docker engine\n\n如下是[官网的安装过程](https://docs.docker.com/install/linux/docker-ce/ubuntu/)，首先移出 Ubuntu 原有的 docker（如果有的话）\n\n```shell\n sudo apt-get remove docker docker-engine docker.io containerd runc\n sudo apt-get update\n```\n\n安装相关依赖\n\n```\nsudo apt-get install \\\n    apt-transport-https \\\n    ca-certificates \\\n    curl \\\n    gnupg-agent \\\n    software-properties-common\n```\n\n增加 docker 的安装源\n\n```shell\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n```\n\n开始安装（我的架构是 x86_64）\n\n```shell\nsudo add-apt-repository \\\n   \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\\n   $(lsb_release -cs) \\\n   stable\"\n\nsudo apt-get update\nsudo apt-get install docker-ce docker-ce-cli containerd.io\n```\n\n## Docker compose\n\n安装新版本`docker-compose`，因为文件存储在 github 上面，这里直接从 DaoCloud 下载。\n\n```\nsudo curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.4/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose\nsudo chmod +x /usr/local/bin/docker-compose\n```\n\n## 解决 ERROR: Couldn't connect to Docker daemon at http+docker://localhost - is it running？\n\n需要增加自己用户到 docker 组，然后重新进入即可\n\n```shell\nsudo gpasswd -a ${USER} docker\n```\n\n## Strapi\n\n按照[strapi 官方文档](https://strapi.io/documentation/3.0.0-beta.x/installation/docker.html)执行如下操作。\n\n新建文件夹，并增加`docker-compose.yaml`\n\n```yaml\nversion: \"3\"\nservices:\n  strapi:\n    image: strapi/strapi\n    environment:\n      DATABASE_CLIENT: mongo\n      DATABASE_NAME: strapi\n      DATABASE_HOST: mongo\n      DATABASE_PORT: 27017\n      DATABASE_USERNAME: strapi\n      DATABASE_PASSWORD: strapi\n    links:\n      - mongo:mongo\n    volumes:\n      - ./app:/srv/app\n    ports:\n      - \"1337:1337\"\n\n  mongo:\n    image: mongo\n    environment:\n      MONGO_INITDB_ROOT_USERNAME: strapi\n      MONGO_INITDB_ROOT_PASSWORD: strapi\n    volumes:\n      - ./data/db:/data/db\n    ports:\n      - \"27017:27017\"\n```\n\n修改 docker 镜像选择[腾讯加速器](https://cloud.tencent.com/document/product/457/9113)。\n\n```json\n//  /etc/docker/daemon.json\n{\n  \"registry-mirrors\": [\"https://mirror.ccs.tencentyun.com\"]\n}\n```\n\n重启服务\n\n```shell\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n```\n\n下载镜像。\n\n```shell\ndocker-compose pull\n```\n\n启动镜像\n\n```shell\ndocker-compose up -d\n```\n\n现在你的 1337 端口已经交给 strapi 了。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["docker","tencent","strapi"]}},{"id":"2020/03/17/Windows-Cypress.md","slug":"2020/03/17/windows-cypress","body":"\n# Windows 下面搞 Cypress 真心不容易\n\n最近在忙活让网站使用 [Cypress](https://www.cypress.io/) 做测试，之前使用苹果电脑以及 Linux 下面用起来还不错，这次在 Windows 下面碰壁比较多（其实我国的网络也有一部分功劳），所以在这里记录一下。\n\n## 尝试使用 WSL（失败）\n\nWSL 可以使用 XServer，所以我打算在 WSL 下面搭建，需要安装 [VcXsrv](https://sourceforge.net/projects/vcxsrv/) ，启动之后一路下一步就可以了，最后将 WSL 显示映射上去（在 bashrc 里面添加下面代码）。\n\n```shell\n# Display\nexport DISPLAY=localhost:0\nsudo /etc/init.d/dbus start &> /dev/null\n```\n\n另外需要把用户加到 sudoers 里面，否则每次启动还要输一遍密码\n\n```shell\nsudo echo \"{user} ALL = (root) NOPASSWD: /etc/init.d/dbus\" >> /etc/sudoers.d/dbus\n```\n\n然而，失败了，启动程序会报 GPU 渲染错误，同样的操作在 WSL2 中依然不行，可是[网络中有人成功了](https://nickymeuleman.netlify.com/blog/gui-on-wsl2-cypress/)。\n\n我相信更多的原因在于编译的时候网络环境太差了。\n\n## 尝试使用 MSYS\n\n直接跑 Windows 原生应用除了运行起来会更快，还可测试如 Edge 等浏览器，[MSYS](https://www.msys2.org/) 安装起来很简单，软件仓库管理使用的是 pacman，安装源可以尝试华中科大和清华的。\n\n```ini\n# C:\\msys64\\etc\\pacman.d\\mirrorlist.mingw32\nServer = http://mirrors.ustc.edu.cn/msys2/mingw/i686/\nServer = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/i686/\n```\n\n```ini\n# C:\\msys64\\etc\\pacman.d\\mirrorlist.mingw64\nServer = http://mirrors.ustc.edu.cn/msys2/mingw/x86_64/\nServer = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/x86_64/\n```\n\n```ini\n# C:\\msys64\\etc\\pacman.d\\mirrorlist.msys\nServer = http://mirrors.ustc.edu.cn/msys2/msys/$arch/\nServer = https://mirrors.tuna.tsinghua.edu.cn/msys2/msys/$arch/\n```\n\n另外需要在「控制面板>系统安全>系统>高级系统设置>环境变量」中增加`MSYS2_PATH_TYPE`值为`inherit`，这样 MSYS 里面的 PATH 就是用的是系统的 PATH 了。\n\n如果习惯使用 WWindows Terminal，可以尝试这个[issue](https://github.com/msys2/MSYS2-packages/issues/1684)，在 Windows Terminal 里面运行 MSYS。\n\n```shell\n$ cat .ms-terminal/wt-msys2.cmd\n@echo off\nsetlocal\n\nrem To activate windows native symlinks uncomment next line\nset MSYS=winsymlinks:nativestrict\n\nrem Shell types\nif \"x%~1\" == \"x-msys2\" set MSYSTEM=MSYS\nif \"x%~1\" == \"x-mingw32\" set MSYSTEM=MINGW32\nif \"x%~1\" == \"x-mingw64\" set MSYSTEM=MINGW64\n\n\nrem Shell types\nrem set MSYSTEM=MSYS\n\nC:\\msys64\\usr\\bin\\bash.exe --login -i\n\nexit /b 0\n```\n\n```json\n{\n  \"guid\": \"{e129fe71-3c94-40b5-8d92-961a3248f175}\",\n  \"commandline\": \"C:\\\\\\\\msys64\\\\home\\\\gongb\\\\wt-msys2.cmd\",\n  \"name\": \"MSYS2\",\n  \"startingDirectory\": \"%USERPROFILE%\",\n  \"icon\": \"ms-appx:///ProfileIcons/{0caa0dad-35be-5f56-a8ff-afceeeaa6101}.png\",\n  \"useAcrylic\": true,\n  \"acrylicOpacity\": 0.75\n}\n```\n\nWindows 下面的开发环境配置比较困难的原因之一就是这些链接库，比如安装一个`libpng-dev`，可以使用 Visual Studio Toolchain，也可以使用 MSYS，还可以使用微软开源的 VCPKG，然而没有一个体验能够达到极致。这导致 Gatsby 在我国的网络下永远不能部署成功。\n\n但是，直接在官网下载下来二进制包再进行[安装](https://docs.cypress.io/guides/getting-started/installing-cypress.html#Install-binary)也是可以的。\n\n```shell\nCYPRESS_INSTALL_BINARY=/local/path/to/cypress.zip npm install cypress\n```\n\n这样就可以运行 Cypress 了。\n\n## 最佳实践\n\n由此可知，其实 Cypress 可以在 Windows 下面原生执行，那么可以单独使用一个代码仓库管理测试用例，如本博客的测试用例放在[这里](https://github.com/gongbaodd/cy-blog.gongbusang.com)，在持续集成的时候将代码下载下来测试即可。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["cypress","Windows","WSL2","MSYS","VcXsrv"]}},{"id":"2020/03/22/react-three-fiber-WebGL.md","slug":"2020/03/22/react-three-fiber-webgl","body":"\n# 使用 react-three-fiber 体验美好的 WebGL 开发\n\n使用 threejs 开发 webGL 应用应该是几乎每个前端工程师想要做的事儿，然而虽然对比于原生 WebGL 开发来说，threejs 已经做了很多，但是相对于现代的一些前端框架。threejs 还稍显不足。针对这些不足，微软开发了[Babylon.js](https://www.babylonjs.com/)，给 threejs 量身定制了一个节点编辑器，如果做过 blender 或者 unity 的同学，对于节点编辑器肯定不会陌生，但对我本人来说还是没有触碰到 G 点。\n\n## 描述组件关系的重要性\n\n本人觉得，对于前端开发来说，提供一个能够准确描述组件和组件结构关系的语言（DSL）是至关重要的，如 HTML 之于 web 开发，xml 之于安卓开发。这些 DSL 能够以最直观的方式表达页面将会展示什么，就从开发的角度上来说，或许入门不是很方便，毕竟要处理很多文件。但是维护起来却异常的轻松，就是前面提到的原因，直观。当然因为 JavaScript 跟 HTML 的交互有很大的性能缺陷。所以给很多模板语言提供了机会。比如 mustache 还有 react 的 JSX。在安卓也能看到 anko 在 kotlin 社区兴起，但是仅仅一年就没有更多人使用了，个人体验，在 Android studio 中使用 xml 和 anko 开发体验差距并不大，有时候 xml 甚至占优，也许这就是原因之一了吧。\n\n几年前我翻查了很多框架，老实说可能更多人并没有把结构描述放在如我想的位置上，哪怕连个 JSON 的方案都没有。但是的确有[aframejs](https://aframe.io/)这种直接用 HTML 管理 canvas 中元素关系的库，可惜它更关注于 VR 开发，而我更希望 WebGL 能够成为诸如图书注解一样的工具，当然这种专注于一个方面的做法或许是正确的，毕竟能够汇聚一个小圈的开发者，也不会有很多流失。\n\n## 用 JSX 开发 WebGL\n\n今年运气就好多了，react-reconciler 使得我们能够直接接管组件的 render 函数，而 react-hooks 在开发体验上完美超出现有框架，[react-babylonjs](https://github.com/brianzinn/react-babylonJS) 和 [react-three-fiber](https://github.com/react-spring/react-three-fiber) 应运而生。我同时试用了这两个框架，简单来说，react-three-fiber 更加成熟些，对 tTypeScript 的支持更好，而 react-babylonjs 开发的时候往往会因为处理类型而费心，最后又不得不使用 JavaScript 开发。\n\n## 怎么使用 react-three-fiber\n\nreact-three-fiber 的[官方文档链接](https://inspiring-wiles-b4ffe0.netlify.com/)描述很详细，建议详读。另外 threejs 官方来链接的[threejs fundamentals](https://threejsfundamentals.org/)有时间也可以拿来读读。\n\n如果想把原来的 threejs 模块迁移到 react 模块，只需要使用一层 primitive 包装即可。每个拥有 set 和 get 的参数都可以作为 props 的成员，构造器参数则是`props.args: any[]`类型。\n\n```JavaScript\nconst grid = new GridHelper(2000, 20, 0x000000, 0x0000000);\n(grid.material as Material).opacity = 0.2;\n(grid.material as Material).transparent = true;\n\nconst Grid = () => {\n  useFrame(({ scene }) => {\n    if (!scene.fog) {\n      const fog = new Fog(0xa0a0a0, 200, 800);\n      scene.fog = fog;\n    }\n  });\n\n  return <primitive object={grid}></primitive>;\n};\n\n```\n\n## 调试工具\n\n这点 babylonjs 要好得多，一个节点编辑器秒杀一切，但是 threejs 还有一个「够用」的[threejs inspector](https://chrome.google.com/webstore/detail/threejs-inspector/dnhjfclbfhcbcdfpjaeacomhbdfjbebi?hl=en)。\n\n使用时需要把你的 scene 和 THREE 模块暴露给 window 作用域。\n\n```JavaScript\nwindow.scene = scene;\nwindow.THREE = THREE;\n```\n\n然后刷新浏览器就可以在场景添加光源，查看节点等操作了。\n\n## 提示\n\n因为 threejs 及其模块本身不是编译好的 ES5，在 nextjs 中一定记得使用`next-transpile-modules`编译，当然即使已经完美适配 ES5，在 IE11 的展示也不是很乐观 😅。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["threejs","webGL","react"],"series":{"slug":"threejs-howto","name":"细品threejs"}}},{"id":"2020/03/26/Tailwind-CSS.md","slug":"2020/03/26/tailwind-css","body":"\n# [Tailwind](https://tailwindcss.com/) 一个像宏语言的 CSS 解决方案\n\n先把刀放下，我知道，现在已经有 n 种 CSS 的解决方案，而且基本上没有一个用着顺心的。\n\n我记得曾有一段时间，好像是使用 YUI 那会儿，CSS 的 class 往往会命名成布局规则，比如希望一个 div 有 10 像素的留白，就给他添加一个 class，`.margin-10px`，然后对这个 class 的描述为。\n\n```CSS\n.margin-10px {\n    margin: 10px;\n}\n```\n\n当然，这种方式在我入职一段时间后马上消失了，大家都更倾向于使用组件语义化的 class，如显示头像，则把 class 命名为`.avatar`而不是`.margin-10px.padding-5px.radius-50`这种怎么看都不知道是干什么的命名。\n\n于是 CSS 开始和组件越来越近，自从有了 scope CSS， React 和 Vue 的组件库逐渐成形，更多的方案逐渐青睐[CSS in JS](https://cssinjs.org/?v=v10.1.1)，单纯的 CSS 解决方案除了 [bulma](https://bulma.io/) 剩下的就不多了。设计的时候往往要先考虑使用的这个组件库的设计语言能给改造预留出多大的空间，然后再设计。\n\n## 回头想一想\n\n其实把几个 CSS 语句合起来作为一个集合使用并不是错的，现有的 SASS 框架也会用 utils 库专门存储封装好的`@mixins`。想到以前使用[Yo](https://github.com/doyoe/Yo)做前端样式时常会用`@yo-flex('.box'){}`这样的函数，这个函数其实就是将 flex 布局的以及它的降级 box 布局，甚至是优雅降级到不支持 box 布局的样式集合到一起。\n\n如果你认同上面这段话，那么 tailwind 一定是个适合你的工具，个人比较喜欢的是这个工具仅仅基于 postcss，这意味着你不需要使用 SASS（并不是 SASS 不好，只是国内用起来太悲剧，即使已经有 sass dart，但是因为普遍还没支持，每次使用的时候神经都要紧绷一下），它和 SASS 也不冲突。你还可以使用 config 文件来自定义样式（这很像很多 CSS in JS 的样式库，这应该是我喜欢那些库的唯一一点了）。\n\n## 操练起来\n\n[官网安装方式](https://tailwindcss.com/docs/installation)很详细，基本上能提到的工具都提过了。\n\n就拿前面的`.avatar`来举例，使用 tailwind 的代码应如下（注意 tailwind 单位不是 px 而是 rem，这里假定 html 的字体大小为 10px）。\n\n```CSS\n.avatar {\n    @apply m-4;\n    @apply p-2;\n    @apply rounded-full;\n}\n```\n\n这样既满足了，类名的语义化，还能使用 config 文件来统一自己的设计语言，最重要的，如果你拿 houdini 写个什么奇葩的 polyfill，就算预编译器读不懂，他也会容错，毕竟这就是原生 CSS。\n\n至于官网的示例，我个人很不支持，感觉是一种开倒车的方式，但萝卜白菜各有所爱，如果有公司会因为我写那样的代码而给我钱的话，我当然无所谓。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["css","tailwind","postcss"]}},{"id":"2020/03/27/svelte.md","slug":"2020/03/27/svelte","body":"\n# Svelte 让人眼前一亮的前端框架\n\n我觉得必须要介绍一下 [svelte](https://svelte.dev/) 这个框架，确切的说是 svelte v3，这应该是继 [riotjs](http://riot.js.org/)、[typescript](https://www.typescriptlang.org/) 和 [rust](https://www.rust-lang.org/) 之后又一个能给我眼前一亮的感觉的产品了。\n\n## 关于 Svelte\n\n不得不提到他的作者 [Rich Harris](https://github.com/Rich-Harris)，提到他的另一个作品就是大名鼎鼎的 [rollup](http://rollupjs.org/)，这可是第一个提出 tree-shaking 的前端打包器（说实话，这导致我有更多的担忧，svelte 可能会变成像 rollup 一样的小众狂欢）。\n\n回到 svelte，他从 v1 的时候目标就是简单，只不过 v1 版本看起来太像 zepto 了（那我为什么不用原生 JavaScript）。不过 v3 版本这个框架换了个方向，从框架变成了编译器，类似于 riotjs 和 vuejs，组件的 html、css 和 js 可以写在一起，其实我并不是特别推崇这种做法，往往有时候我更倾向于 angularJS 的做法，但是 svelte 的处理真的太完美。\n\n```html\n<script>\n  const hello = \"world\";\n</script>\n\n<h1>{hello}</h1>\n\n<style>\n  h1 {\n    color: black;\n  }\n</style>\n```\n\n看到了吗？没有多出来的 `Vue.extend()`，HTML 和 JavaScript 部分的交互竟然这儿么完美！要是 CSS 再加把力就更好了（不过如果是 CSS in JS 的话...那还是用某个 preprocessor 勉强一下好了）。HTML 模板类似比较简单的 handlebars 语法，甚至支持异步模板。\n\n另外 svelte 没有虚拟 DOM，这一点我有一些相见恨晚，我之前就写过[文章](/fe/2016/03/31/VUE&Riot&React实力比较.html)质疑虚拟 DOM 是不是真的能带来性能提高（结果是性能很差），但是最终被人喷了，导致一年后不得不[弃坑 riotjs 改用 preact](/fe/2017/05/15/弃坑Riot转向Preact.html)。但我始终认为虚拟 DOM 更是一个范式而不是能带来性能提升的神器。所以你代码差，换什么范式，性能都差，喷别人之前先称称自己几斤几两好么？\n\nsvelte 符合响应式模式，这一点和 riotjs 很类似，借助 svelte 这个编译器，写好的组件会被编译成响应式函数。也许拿 riotjs 做比方会比较难，这里拿 react 做比方，在 react 中实现响应式需要使用`setState()`。\n\n```JavaScript\nconst Com = () => {\n    const [state, setState] = useState(1);\n    useEffect(() => setState(state + 1), [])\n    const stateX2 = state*2;\n\n    return (\n    <>\n        <div>{state*2}</div>\n        <div>{stateX2}</div>\n    </>\n    );\n}\n/* 输出\n * <div>2</div>\n * <div>2</div>\n*/\n```\n\n而由于 svelte 是个编译器，svelte 里面不仅代码更少，而且正确的输出了`stateX2`的值。\n\n```HTML\n<script>\nimport { onMount } from \"svelte\";\n\nlet state = 1;\n\nonMount(() =>  state += 1);\n\n$: let stateX2 = state * 2;\n</script>\n\n<div>{state}</div>\n<div>{stateX2}</div>\n\n<!--\n    输出\n    <div>2</div>\n    <div>4</div>\n-->\n```\n\n没错，完全没有多余的代码（其实 svelte 编译器会默默地给`state`增加一个`observable`的配置，但是这都是编译器自己做的，开发者完全不需要考虑）。这里发现`stateX2`前面有一个`$`标识，表明后面的语句是响应式的。这一点真的很巧妙，因为这个语法是 JavaScript 标准里百年不遇的`goto`语句，svelte 高明的使用 JavaScript 原有的语法实现了新的功能，不像某框架愣是加了一个 JSX 语法（不是鄙视 JSX，JSX 也很牛逼的说）。\n\n在 n 多个框架都在模仿 react 的主流下，这个框架还能别出心裁，不得不赞，如果你感兴趣，我强烈推荐浏览他们的[例子](https://svelte.dev/examples#hello-world)。store 和 context 都非常有启发。\n\n最大的缺点就是目前还没有官方的 TypeScript 支持，这一点很有尴尬，因为 svelte 本身就是 TypeScript 写的。不过现在有第三方的[svelte-preprocess](https://github.com/kaisermann/svelte-preprocess)对 TypeScript 提供支持，不知道啥时候转正。\n\n## Sapper\n\nriotjs 同样没有虚拟 DOM，这使得它在 SSR 方面会[有一些问题](https://riot.js.org/documentation/#riot-dom-caveats)，但是 Svelte 提供了一套 SSR 解决方案，[sapper](https://sapper.svelte.dev/) 同时支持 node 渲染和静态发布。\n\nSapper 受 next.js 启发，使用`src/route`文件夹下的文件做路由。\n\n```\nsrc/routes\n    _layout.svelte -- 布局文件\n    _error.svelte  -- 404目录\n    index.svelte   -- /或者/index\n    posts.json.js  -- /post.json，可以使用类似express路由的方式写接口\n```\n\n想要在 index 里面实现 server 端的预加载，可以使用 sapper 的 preload API。\n\n```html\n<script context=\"module\">\n  export async function preload(page, session) {\n    const res = await this.fetch(\"posts.json\");\n    const { posts } = await res.json();\n\n    return { posts };\n  }\n</script>\n```\n\n这样会在`window`上面注入一个`__SAPPER__`变量把 server 端预加载的值赋上去。\n\n因为 sapper 还在 beta 阶段，我也不敢拿来开发什么大项目，但真心想写写 svelte，因为它在很多地方非常有新意，历史包袱也不大，暂时写个 [CSS playground](https://css.gongbushang.com/) 来做 [CSS Secrets](http://shop.oreilly.com/product/0636920031123.do) 的笔记好了。\n\n## 单元测试\n\n[testing-library](https://testing-library.com/docs/svelte-testing-library/intro) 提供单元测试支持，配置起来绝对比 react 和 vue 简单，只是因为比较新，所以没有类似的 create react app 这种官方脚手架，当然如果 sapper 出正式版了就算有了。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["svelte","sapper","JavaScript","rollup"]}},{"id":"2020/03/29/Rust-crate.io.md","slug":"2020/03/29/rust-crateio","body":"\n# Rust 开发更换 crate.io 源\n\n使用 VSCode 开发 Rust 的我，最难过的一刻就是打开编辑器时的 RLS 检查，可以看做它是一个用来检查代码语法的后台程序，在 RLS 的 issue 里面有很多人吐槽他初始化的速度实在是太慢了，然而大佬的回复都是说他们不需要使用这种辅助工具。作为使用 JavaScript 都一定要 TypeScript 编译，打字都是通过语音输入来打字的我来说（没错，这篇博文是语音转换过来的），臣妾做不到啊。\n\nRLS 检查有一个步骤是`cargo check`，这里会链接`crate.io`检查包的完整性。由于`crate.io`的包大多托管在 GitHub，所以外网的宝宝们吐槽的慢只是秒级别的，而中国的宝宝是小时级的 😭。\n\n但是尚有修补的余地，中科大爸爸给国内开发者提供国内的镜像了。修改`~/.cargo/config`增加中科大的源。\n\n```ini\n[source.crates-io]\nregistry = \"https://github.com/rust-lang/crates.io-index\"\nreplace-with = 'ustc'\n\n[source.ustc]\nregistry = \"git://mirrors.ustc.edu.cn/crates.io-index\"\n```\n\n中科大就是我的神啊！开发 Rust 终于可以和国外一样慢了 😂！\n","collection":"blog","data":{"type":"post","category":"fe","tag":["rust","crate.io","ustc","cargo"]}},{"id":"2020/03/30/CSS Secret.md","slug":"2020/03/30/css-secret","body":"\n# CSS Secret 有感\n\n虽然维多利亚的秘密没有了，但是 CSS 的秘密还是可以考虑考虑的，这本书是 2015 年出版的，相比于现在，显然里面的很多属性已经可以做到多平台兼容了，当然里面还没有涉及 grid 布局，强烈推荐 [wesbos 的 grid 课程](https://cssgrid.io/)，虽然看完也是忘 😅。\n\n要说编程算法难学，跟 CSS 比起来还是个弟弟，不仅仅要了解一些拓扑的知识，编出来的图形还得好看。\n\n书中的实现都放在[这里](http://play.csssecrets.io/)，同时我也挑了一些喜欢的[自己实现了一下](http://css.gongbushang.com/)。\n\n书里面涉及到的有\n\n- outline\n- box-shadow\n- background-image（里面提到了一个纯 CSS 实现北京图案的[网站](https://leaverou.github.io/css3patterns/)，值得拥有）\n- background-origin\n- border-image\n- path-clip\n- transform\n- filter\n- font-variable\n- keyframe\n\n目前个人比较感兴趣然而未被涉及的是\n\n- grid\n- css variables\n\n当然这些那会儿都还没有，所以闲着没事儿干的时候还要多逛逛[css-tricks](https://css-tricks.com/)。\n\n还有，在写[svelte](/fe/2020/03/27/svelte一个让人眼前一亮的的前端框架.html)曾经提过如果有一个比较好的 CSS 和 JavaScript 以及 HTML 交互的方法就好了，细想之下 css variables 或许可以。试想如下结构。\n\n```html\n// Back.svelte\n<div class=\"bg\">\n  <slot></slot>\n</div>\n\n<style>\n  .bg {\n    --color: red;\n  }\n</style>\n```\n\n```html\n// Menu.svelte\n<ul>\n  <li>Menu</li>\n</ul>\n\n<style>\n  ul > li {\n    color: var(--color, blue);\n  }\n</style>\n```\n\n```html\n// App.svelte\n<script>\n  import Back from \"Back.svelte\";\n  import Menu from \"Menu.svelte\";\n</script>\n\n<Back>\n  <menu></menu>\n</Back>\n```\n\n此时的 Menu 应该是 Back 里面设置好的红色（我自己没尝试，只是写这个博文的时候临时起意）。这最大的好处显而易见，类似于 react 里面的 theme，`<Back/>`组件给`<Menu/>`组件提供了配合的样式，而不仅仅局限于 JavaScript 传入的数据。\n\n只可惜 CSS variables 需要做向下兼容，而且就算是 postcss 的[postcss-css-variables](https://www.npmjs.com/package/postcss-css-variables)也只能兼容放到`:root`下的变量（那要你有何用囧），不过就[caniuse](https://caniuse.com/#feat=css-variables)的数据，不考虑中国用户的话，确实可以大胆使用 CSS variables，就算是降级估计也没那么难看吧。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["CSS"]}},{"id":"2020/04/04/ObservableHQ-JS-Jupyter.md","slug":"2020/04/04/observablehq-js-jupyter","body":"\n# ObservableHQ-JS 终于有自己的 Jupyter 笔记本了\n\n学习机器学习的时候用上 python 的 Jupyter notebook 是真好用，曾经就想，如果 JavaScript 也有一个就好了，没错[ObservableHQ](https://observablehq.com/)就是基于 D3.js 的数据可视化笔记本。\n\n官方的[入门](https://observablehq.com/@observablehq/a-taste-of-observable)讲的很详细，接下来一周我可能会专心于里面的[D3 教程](https://observablehq.com/@d3/learn-d3)，间或去学习 threejs fundamental。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["observablehq","JavaScript","d3","jupyter"]}},{"id":"2020/04/07/D3.md","slug":"2020/04/07/d3","body":"\n# 学习 D3 的新姿势\n\n今天用了半天的时间把 observable HQ 上面的 [Learn D3](https://observablehq.com/@d3/learn-d3) 学习了一遍，[这](https://observablehq.com/@gongbaodd/d3-js)是纯笔记版。\n\n不过今天真的是爽到了，没错，我终于找到了以前学习 D3 没动力的原因了，那么厚的一本书，基本上就是把 D3 gallery 抄了一遍。最开始基本上还要学一个 D3 版本的 jQuery 选择器，数据还要自己搞，基本读了两章就打算放弃。\n\n```JavaScript\nvalues = [...\"123456\"];\nimport {chart as chart1} with {values as data} from \"@d3/histogram\";\n```\n\n这就是一个柱状图了！！！爽到有没有？\n\n如果你想写一个控制界面\n\n```JavaScript\nviewof replay = html`<button>Replay</button>`\n```\n\n使用这个控制器\n\n```JavaScript\nreplay, html`\n<svg viewBox=\"0 0 ${width} ${height}\">\n  ${d3.select(svg`<g>`).call(shape_xAxis).node()}\n  ${d3.select(svg`<g>`).call(shape_yAxis).node()}\n  ${d3.select(svg`\n    <path\n      d=\"${line(shape_data)}\"\n      fill=\"none\"\n      stroke=\"steelblue\"\n      stroke-width=\"1.5\"\n      stroke-miterlimit=\"1\"\n      stroke-dasharray=\"0,1\"\n    >\n    </path>\n  `).call(reveal).node()}\n</svg>\n`\n```\n\n哈哈，有趣，这语法很有想象力，比 svelte 更加大胆，仿佛用 JavaScript 实现了一个类似于 python 的词法。如果你想创建一个复杂的变量，你可以：\n\n```JavaScript\nsum = {\n  let s = 0;\n  for (let i = 0; i < 10; ++i) {\n    s += i;\n  }\n  return s;\n}\n```\n\nObservable HQ 的每个语句类似于 react 的 render 函数，你甚至可以把它写成一个迭代器。当 replay 被点击，页面展示的数值会从 1 逐渐增加到 299。\n\n```JavaScript\n{\n  replay;\n  for (let i = 0, n = 300; i < n; ++i) {\n    yield i;\n  }\n}\n```\n\n另外可以参考[如何利用 Wikipedia 的数据](https://observablehq.com/@mbostock/working-with-wikipedia-data)进一步使用 observable HQ。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["observablehq","d3"]}},{"id":"2020/04/16/CSS.md","slug":"2020/04/16/css","body":"\n# CSS 渐变利器\n\n[CSS gradient generator](https://mybrandnewlogo.com/color-gradient-generator)\n","collection":"blog","data":{"type":"post","category":"fe","tag":["css","gradient"],"series":{"slug":"tools","name":"利器"}}},{"id":"2020/04/21/threejs-mesh.md","slug":"2020/04/21/threejs-mesh","body":"\n# threejs 细化-创建一个 mesh、使用加载器、多个场景\n\n记录下最近几天的事，终于 Dell 的维修把我电脑的风扇修好了，不过感觉 inspiron 的风扇设计有 bug，新风扇估计也撑不了多久，但愿只是我多疑了。另外通过神奇的某宝，我将我手上的小米平板二升级了内存和硬盘，考虑到 8GB 内存对于 Atom Z8500 这个 CPU 有点多余，于是升级到了 4GB + 128GB，到手之后果然比 2GB 流畅（当然肯定没法比酷睿了），所以这个配置还是比较推荐的。\n\n回到主题，最近一周我都在使用 react-three-fiber 来学习 threejs，这里会做一个系列来详细整理一下。\n\n## 创建一个 mesh\n\n可以使用 JSX 创建 mesh, 因为 mesh 有 material 和 geometry 两个访问器，在 JSX 中可以作为属性使用。\n\n```JavaScript\nexport default () => (\n    <Canvas>\n        <mesh\n            name=\"mesh\"\n            material={new MeshBasicMaterial()}\n            geometry={new BoxBufferGeometry(1, 1, 1)}\n        />\n    </Canvas>\n);\n```\n\n当然作为参数也可以。\n\n```JavaScript\nexport default () => (\n    <Canvas>\n        <mesh arg={[new BoxBufferGeometry(1, 1, 1), new MeshBasicMaterial()]}/>\n    </Canvas>\n);\n```\n\n官网还提供了一个绝妙的方法。\n\n```JavaScript\n// 实现不了，不知道咋回事儿\nexport default () => (\n    <Canvas>\n        <mesh>\n            <boxBufferGeometry attach=\"geometry\" />\n            <meshBasicMaterial attach=\"material\" />\n        </mesh>\n    </Canvas>\n);\n```\n\n另外因为 Canvas 里面的元素和 JSX 的绑定使用的是 memo，所以如果使用 primitive 定义元素的时候会丢。\n\n```JavaScript\n// 这么做虽然会渲染出来，但是Box有的时候会丢\nconst Box = new Mesh(\n    new BoxBufferGeometry(1, 1, 1),\n    new MeshBasicMaterial(),\n);\n\nexport default () => (\n    <Canvas>\n        <primitive object={Box} />\n    </Canvas>\n);\n```\n\n## 加载器\n\n加载 texture 时，可以使用`useEffect`自己写，当然也有更优雅的方法，利用 react 自己的`useMemo`或者`useCallback`，再就是使用 react three fiber 的`useLoader`。\n\n```JavaScript\n// 使用 useMemo\nconst Plane = () => {\n    const texture = useMemo(() => new TextureLoader().load(\"xxx.jpg\"), [])\n    return <mesh\n        material={new MeshBasicMaterial({map: texture})}\n        geometry={new PlaneGeometry(1, 1)}\n    />\n}\n```\n\n```JavaScript\n// 使用 useLoader\nconst PlaneAsync = () => {\n    const [texture] = useLoader(TextureLoader, \"xxx.jpg\");\n\n    return <mesh\n        material={new MeshBasicMaterial({map: texture})}\n        geometry={new PlaneGeometry(1, 1)}\n    />\n}\n\nconst Plane = () => (\n        <Suspense fallback={<mesh />}>\n            <PlaneAsync />\n        </Suspense>\n    )\n```\n\n## 使用多个场景\n\nthree react fiber 会默认给一个场景(scene)、一个摄像头(camera)还有一个渲染器(render)。可是如果我需要多个场景，比如建模工具往往会给一个正交视图以及正视图，这种情况就需要多个场景。\n\n首先要使用`setDefaultCamera`将新建的摄像头代替默认摄像头。\n\n```TypeScript\nexport default () => {\n    const { setDefaultCamera } = useThree();\n    const camera = useRef<PerspectiveCamera>();\n\n    useLayoutEffect(() => camera.current && setDefaultCamera(camera.current), [])\n\n    return <perspectiveCamera\n      name=\"camera\"\n      ref={camera}\n    />\n}\n```\n\n接下来是创建场景，场景不需要代替原有场景，但是需要使用`useFrame`修改`render`方法。\n\n```TypeScript\n// 再原画面的左上角绘制场景\nexport default () => {\n    const scene = useRef<Scene>();\n    const {\n        size: {left, top, width, height},\n        camera,\n    } = useThree();\n\n    useFrame(({ gl }) => {\n        gl.autoClear = true;\n        gl.setScissor(left, top, width / 2, height / 2);\n        gl.setViewport(left, top, width / 2, height / 2);\n\n        scene.current && gl.render(scene, camera)\n    }, 10);\n\n    return (\n        <scene ref={scene}>\n            <mesh />\n        </scene>\n    );\n}\n```\n\n这里`useFrame`的第二个参数表示它的优先级，值越高，越先渲染，这意味着比它优先级低的场景渲染之前要把`gl.autoClear`设置为`false`，以避免被清除。\n\n## 其它\n\n另外可以看看京东的一篇博客[凹凸实验室](https://aotu.io/notes/2018/10/18/cannonjs/index.html)。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["threejs","JavaScript","webGL"],"series":{"slug":"threejs-howto","name":"细品threejs"}}},{"id":"2020/04/27/threejs.md","slug":"2020/04/27/threejs","body":"\n# threejs 细化-在网格上渲染，停止渲染，使用物理引擎\n\n这是细化了解 threejs 的第二篇，[第一篇](/fe/2020/04/21/threejs细化-创建一个mesh、使用加载器、多个场景.html)\n\n## 在网格上渲染\n\n这里有一点类似于使用多个场景，设想如果想要做一个类似于水晶球的设计，水晶球有一个 scene1，水晶球自己又在另一个 scene0 里面，这里就需要使用 renderTarget 渲染 scene1 到水晶球上面。\n\n先创建一个 target。\n\n```typescript\nconst target = new WebGLRenderTarget(width, height);\n```\n\n再创建一个球，并使用 target 作为材料。\n\n```tsx\nconst ball = () => {\n  return (\n    <mesh name=\"ball\">\n      <sphereBufferGeometry attach=\"geometry\" args={[1, 32, 16]} />\n      <meshPhongMaterial attach=\"material\" map={target.texture} />\n    </mesh>\n  );\n};\n```\n\n然后创建 scene1。\n\n```ts\nconst scene1 = new Scene();\nconst camera = new PerspectiveCamera(75, 1, 0.1, 5, position: [0, 1, 2]);\n\n{\n  const light = new HemisphereLight();\n  scene1.add(light);\n}\n\n{\n  const mesh = new Mesh(\n    new BoxBufferGeometry(1, 1, 1),\n    new MeshPhongMaterial({ color: 0x8844aa }),\n  );\n  scene1.add(mesh);\n}\n```\n\n貌似 react-three-fiber 的 render 函数也可以把 JSX 渲染成 scene。但是使用的时候告诉我需要创建 context，难道是要用 React.createContext? 感觉坑很多，所以暂时没有尝试，以后再补充这里。\n\n```tsx\nconst scene = new Scene();\nconst context = createContext();\n\nrender(\n  <>\n    <perspectiveCamera />\n    <hemishpereLight />\n    <mesh>\n      <boxBufferGeometry args={[1, 1, 1]} attach=\"geometry\" />\n      <meshPhongMaterial color={0x8844aa} attach=\"material\" />\n    </mesh>\n  </>,\n  scene,\n  context\n);\n```\n\n好了，回到正题，现在需要在 target 上面渲染 scene1.\n\n```ts\nuseFrame(({ gl }) => {\n  gl.setRenderTarget(target);\n  gl.render(scene1, camera); // 这里的camera是scene1里面的camera\n  gl.setRenderTarget(null);\n});\n```\n\n和渲染两个 scene 一样，不管打算渲染几个场景，实际的渲染器只有一个，所以渲染好 target 后还要把要渲染的目标换回来。\n\n## 停止渲染\n\nreact-three-fiber 默认会一直渲染每一帧，而在网页上，我们往往不需要它一直耗费 GPU 时间，比如渲染好的动画，只需要它在特殊时间才运动，react-three-fiber 有一个 invalidateFrameloop 选项可以暂停渲染。\n\n```tsx\n<Canvas invalidateFrameloop />\n```\n\n另外`useThree().invalidate`也可以暂停渲染，但这个不太稳定，不确定是不是我的问题。\n\n比如加载进来一个模型，想让它动画结束后就停止 GPU 渲染。\n\n```tsx\nconst animate = useMemo(() => new AnimationMixer(obj));\nconst action = useMemo(() => {\n  const act = animate.clipAction(obj.animations[0]);\n  act.setLoop(LoopOnce, 1);\n  act.enabled = true;\n  act.clampedWhenFinished = true;\n  act.play();\n  return act;\n}, []);\n\nconst { invalidate } = useThree();\n\nuseFrame((_, delta) => {\n  animate.update(delta);\n  if (!act.isRunning()) {\n    invalidate();\n  }\n});\n```\n\n## 使用物理引擎\n\n物理引擎是使用 webGL 最爽的部分，主要是不用考虑那些公式，这里用`Cannon.js`打个比方，（感动常在）。\n\n首先创建世界，比如创建一个 z 轴加速度为 9.82 的世界，还需要 NaiveBroadphase 做碰撞检测。\n\n```ts\nconst world = new World();\nworld.gravity.set(0, 0, -9.82);\nworld.broadphase = new NaiveBroadphase();\n```\n\n接下来创建一个物体，包括它的形状（shape）和在世界中的细节参数（body）。\n\n```ts\nconst shape = new Sphere(1);\nconst body = new Body({ mass: 5, shape });\nworld.add(body);\n```\n\n接下来设置渲染的时间间隔。\n\n```ts\nuseFrame(() => world.step(1 / 60)); // 单位秒\n```\n\n好了，那么怎么和 react-three-fiber 玩耍呢？其实可以写一个[useCannon](https://github.com/gongbaodd/webgl_demos/blob/dev/hooks/useCannon.tsx)。\n\n但是考虑到有现成的 hooks，自己就不用写轮子了，[react-spring/use-cannon](https://github.com/react-spring/use-cannon)，他是用 web worker 跑的，性能肯定更好，直接看例子好了，白嫖真爽。\n\n```jsx\nimport { Canvas } from \"react-three-fiber\";\nimport { Physics, usePlane, useBox } from \"use-cannon\";\n\nfunction Plane(props) {\n  const [ref] = usePlane(() => ({ rotation: [-Math.PI / 2, 0, 0], ...props }));\n  return (\n    <mesh ref={ref}>\n      <planeBufferGeometry attach=\"geometry\" args={[100, 100]} />\n    </mesh>\n  );\n}\n\nfunction Cube(props) {\n  const [ref] = useBox(() => ({ mass: 1, position: [0, 5, 0], ...props }));\n  return (\n    <mesh ref={ref}>\n      <boxBufferGeometry attach=\"geometry\" />\n    </mesh>\n  );\n}\n\nReactDOM.render(\n  <Canvas>\n    <Physics>\n      <Plane />\n      <Cube />\n    </Physics>\n  </Canvas>,\n  document.getElementById(\"root\")\n);\n```\n","collection":"blog","data":{"type":"post","category":"fe","tag":["threejs","webgl"],"series":{"slug":"threejs-howto","name":"细品threejs"}}},{"id":"2020/05/04/RN-Flutter-Dart.md","slug":"2020/05/04/rn-flutter-dart","body":"\n# 从 RN 到 Flutter-从 Dart 开始\n\n这是一篇翻译，原文来自于[官方文档](https://flutter.dev/docs/get-started/flutter-for/react-native-devs)，当然，里面夹带私货，哈哈。\n\n## 从 JavaScript 到 Dart\n\n就像 React Native，Flutter 也是用响应式界面。但是 React Native 是链接原生环境，而 flutter 则是直接编译到原生环境中。Flutter 可以控制屏幕上面的每一个像素，可以避免 JavaScript 和原生环境桥的性能问题。\n\nDart 是一个简单的语言，并提供以下功能。\n\n- 提供一个开源可伸缩的开发环境并提供给网页端、服务器端、移动端使用。\n- 提供单继承面向对象的 C 语法支持，并支持 AOT 编译至原生环境。\n- 可翻译到 JavaScript\n- 支持接口和虚基类的数据结构\n\n以下是几处 JavaScript 和 Dart 的不同之处。\n\n### 入口\n\nJavaScript 没有与设定的入口函数。\n\n```js\nfunction startHere() {\n  // 可以用来做入口函数\n}\n```\n\nDart 有一个顶级`main()`函数作为入口函数使用。\n\n```Dart\nmain() {}\n```\n\n在 [DartPad](https://dartpad.dev/0df636e00f348bdec2bc1c8ebc7daeb1) 上使用。\n\n### 打印日志\n\n在 Dart 中打印日志需要使用`print()`函数。\n\n```js\nconsole.log(\"Hello JavaScript!\");\n```\n\n```Dart\nprint(\"Hello Dart!\");\n```\n\n在 [DartPad](https://dartpad.dev/cf9e652f77636224d3e37d96dcf238e5) 试用。\n\n### 变量\n\nDart 是类型安全的——它结合静态类型检查和动态类型检查确保变量总是符合它的静态类型。即使类型是强制的，但类型标识并不是必须的，因为 Dart 会预判类型。\n\n#### 声明变量并赋值\n\n在 JavaScript 中，变量是无类型的（这是原文说的，不是我说的，我不是很同意）。\n\n```js\nvar name = \"JavaScript\";\n```\n\n在 Dart 中，变量必须声明类型，或者让系统能够预判类型。\n\n```Dart\nString name = \"Dart\";\nvar otherName = \"Dart\";\n```\n\n在 [DartPad](https://dartpad.dev/3f4625c16e05eec396d6046883739612) 中试用。\n\n点[这里](https://dart.dev/guides/language/sound-dart)了解 Dart 的类型系统。\n\n#### 默认值\n\n在 Javascript 中，未初始化的变量是`undefined`（他可能指的是函数作用域变量）。\n\n```js\nvar name; // undefined\n```\n\n在 Dart 中，未初始化的变量值为`null`。因为 Dart 中的类型都是对象，所以即使定义了类型但没有赋值它的默认值依然是 null。\n\n```dart\nvar name; // null\nint x; // null\n```\n\n在 [DartPad](https://dartpad.dev/57ec21faa8b6fe2326ffd74e9781a2c7) 使用。\n\n更多关于 [Dart 变量](https://dart.dev/guides/language/language-tour#variables) 的信息。\n\n#### 空值检查和零值检查\n\n在 JavaScript 中非空对象被认为是真值。\n\n```JavaScript\nvar myNull = null;\nif (!myNull) {\n  console.log(\"null是假值\");\n}\nvar zero = 0;\nif (!zero) {\n  console.log(\"0是假值\");\n}\n```\n\nDart 中，只有布尔真值是真值。\n\n```Dart\nvar myNull = null;\nif (myNull == null) {\n  print(\"使用 == null 做空值检查\");\n}\nvar zero = 0;\nif (zero == 0) {\n  print(\"使用 == 0 做零值检查\");\n}\n```\n\n在 [DartPad](https://dart.dev/guides/language/language-tour#variables) 上使用。\n\n#### 函数\n\n两个语言的函数基本上相同。\n\n```JavaScript\nfunction fn() {\n  return true;\n}\n```\n\n不同点是他们的声明。\n\n```dart\n{\n  fn() {\n    return true;\n  }\n}\n\n{// 也能这么写\n  bool fn() {\n    return true;\n  }\n}\n```\n\n在 [DartPad](https://dartpad.dev/5454e8bfadf3000179d19b9bc6be9918) 上使用，点[这里](https://dart.dev/guides/language/language-tour#functions)查看函数细节。\n\n#### 异步开发\n\n##### Futures\n\n和 Javascript 一样，Dart 支持单线程执行。JavaScript 使用 promise 对象处理异步的成功以及失败状态，并获取它的值。\n\n```js\nconst getIp = () =>\n  fetch(\"https://httpbin.org/ip\")\n    .then((res) => res.json())\n    .then(({ origin: { ip } }) => ip);\n\ngetIp()\n  .then((ip) => console.log(ip))\n  .catch((errpr) => console.error(error));\n```\n\n而在 Dart 中，使用 [Future](https://dart.dev/tutorials/language/futures) 对象处理异步。\n\n```Dart\nimport \"dart:convert\";\nimport \"package:http/http.dart\" as http;\n\nFuture<string> getIp() {\n  return http.get(\"https://httpbin.org/ip\")\n    .then((res) {\n      String ip = jsonDecode(res.body)[\"origin\"];\n      return ip;\n    });\n}\n\nmain() {\n  getIp()\n    .then(ip => print(ip))\n    .catchError((error) ==> print(error));\n}\n```\n\n点击[这里](https://dart.dev/tutorials/language/futures)了解 Future 对象。\n\n##### `async` 和 `await`\n\n使用 `async` 标识符声明异步函数。\n\n在 JavaScript 中，`async`函数返回一个`Promise`对象，并使用`await`处理它。\n\n```js\nasync function getIp() {\n  const res = await fetch(\"http://httpbin/ip\");\n  const { origin } = await res.json();\n  return origin;\n}\n\nasync function main() {\n  try {\n    const ip = await getIp();\n    console.log(ip);\n  } catch (e) {\n    console.log(e);\n  }\n}\n```\n\n在 Dart 中，`async`函数返回`Future`类型，函数体会被安排运行，`await`运算符被用来获取`Future`的返回值。\n\n```dart\nimport \"package:http/http.dart\" as http;\nimport \"dart:convert\"\n\nFuture<string> getIp() {\n  final res = await http.get(\"http://httpbin.org/ip\");\n  String ip = jsonDecode(res.body)['origin'];\n  return ip;\n}\n\nmain() async {\n  try {\n    final ip = await getIp();\n    print(ip);\n  } catch(e) {\n    print(e);\n  }\n}\n```\n\n了解更多[async 和 await](https://dart.dev/guides/language/language-tour#asynchrony-support)的信息。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["react-native","flutter","dart"],"series":{"slug":"Flutter-for-RN-devs","name":"从RN到Flutter","number":1}}},{"id":"2020/05/05/RN-Flutter.md","slug":"2020/05/05/rn-flutter","body":"\n# 从 RN 到 Flutter-简单说说\n\n## 如何创建一个 Flutter 应用\n\n创建一个 React Native，可以在终端中使用`create-react-native-typescript-app`，或者`expo-cli`。\n\n```shell\ncreate-react-native-typescript-app <projectname>\n```\n\n使用 Flutter 创建应用，可以采用以下两种方式。\n\n- 使用 IDE 中的 Flutter 和 Dart 插件。\n- 使用`flutter create`命令，请确保 Flutter SDK 已经在 PATH 中，[Windows 用户可以参考此文](/fe/2020/02/21/Windows安装flutter开发环境.html)。\n\n```shell\nflutter create <projectname>\n```\n\n更多内容，可以参考[快速入门](https://flutter.dev/docs/get-started)，入门是一个创建单按钮的计数项目，并能够部署在 Android 和 iOS 设备中的示例应用。\n\n## 如何运行应用\n\n在 React Native 中，你可以使用`npm run`或者`yarn run`。\n\n在 Flutter 中，可以参考如下方式：\n\n- 使用 IDE 中的\"run\"选项。\n- 在项目根目录执行 `flutter run`。\n\n你的应用会在连接好的设备上执行。\n\n更多信息，请参考 Flutter 的[快速入门](https://flutter.dev/docs/get-started)。\n\n## 如何引入部件\n\n在 React Native 中，你需要引入组件。\n\n```JavaScript\nimport React from \"react\";\nimport { StyleSheet, Text, View } from \"react-native\";\n```\n\n在 Flutter 中，需要引入`material.dart`包来使用 Material Design 库中的部件。要使用 iOS 样式的部件则需要引入 Cupertino 库。想使用更多基础部件，需要引入他们的库，或者你也可以自己写一个部件库，并引入。\n\n```Dart\nimport \"package:flutter/material.dart\";\nimport \"package:flutter/cupertino.dart\";\nimport \"package:flutter/widgets.dart\";\nimport \"package:flutter/my_widgets.dart\";\n```\n\n无论你引入了什么包，Dart 只会使用你在应用中使用的部件。\n\n## 写一个和 React Native 中一样的 Hello World 应用\n\n在 React Native 中，`HelloWorldApp`是`React.Component`的一个实现，并返回如下 view 组件实现。\n\n```tsx\nimport React, { FC } from \"react\";\nimport { StyleSheet, Text, View } from \"react-native\";\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: \"#fff\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n});\n\nconst App: FC = () => (\n  <View style={styles.container}>\n    <Text>Hello world!</Text>\n  </View>\n);\n\nexport default App;\n```\n\n在 Flutter 中，创建一个 Hello World 应用需要使用`Center`和`Text`核心部件，`Center`部件在部件树的根部件，并拥有唯一子部件`Text`。\n\n```Dart\nimport \"package:flutter/material.dart\";\n\nmain() {\n  runApp(\n    Center(\n      child: Text(\n        \"Hello World!\",\n        textDirection: TextDirection.ltr,\n      )\n    )\n  );\n}\n```\n\n（卧槽，写 Hello World 还挺简短的，怕不是错觉...）\n\n| Android                                                                                                                                                                | iOS                                                                                                                                                            |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| ![Android展示样式](https://flutter.dev/assets/get-started/android/react-native/hello-world-basic-ed1ed2698fc492892552a8d719b0e124b7a50e2f8e0327f1548e2834b0aa515a.png) | ![iOS展示样式](https://flutter.dev/assets/get-started/ios/react-native/hello-world-basic-1ba3dfcb9fcbee11f5307cde947ab29dd4f52683f311b049242a28fefb37412b.png) |\n\n这就是 Flutter 中最基础的应用，下一个部分将会利用 Flutter 丰富的组件库创建现代应用。\n\n## 如何使用在部件树中增加部件\n\n在 Flutter 中，几乎一切都是部件。\n\n部件是创建用户界面的基础块。部件组成的层级结构叫做部件树。每个部件接入它的父部件，并继承它们的属性。即使应用对象本身也是个部件。并没有分离的\"application\"对象，根部件就是它。\n\n一个部件可以定义如下内容：\n\n- 一个有结构的元素 —— 如一个按钮或菜单。\n- 一个样式元素 —— 如字体或者颜色方案。\n- 一个布局或视角 —— 如边距或者对齐。\n\n如下的例子使用 Material Design 创建部件，在此例子中，部件树链接在`MaterialApp`跟部件下。\n\n```Dart\nimport \"package:flutter/material.dart\";\n\nWidget MyApp() {\n  return MaterialApp(\n    title: \"Welcome to Flutter\",\n    home: Scaffold(\n      appBar: AppBar(\n        title: Text(\"Welcome to Flutter\"),\n      ),\n      body: Center(\n        child: Text(\"Hello world\"),\n      ),\n    ),\n  );\n}\n\nmain() => runApp(MyApp());\n```\n\n如下是使用 Material Design 部件创建的 “Hello world!” 应用。\n\n| Android                                                                                                                                                                             | iOS                                                                                                                                                                          |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| ![Adroid Material Design Hello World](https://flutter.dev/assets/get-started/android/react-native/hello-world-198f4b19ca6d3dd72f6a17dd858814cc42cf2bc696f61d7f273be95818110777.png) | ![iOS Material Design Hello World](https://flutter.dev/assets/get-started/ios/react-native/hello-world-ed7cf47213953bfca5eaa74fba63a78538d782f2c63a7c575068f3c2f7298bde.png) |\n\n写应用的时候，会使用到两种部件`StatelessWidget`和`StatefulWidget`（上面我写的就是`StatelessWidget`不过没有按照面向对象的写法去写）。一个`StatelessWidget`是一个没有状态的部件，它一旦被创建就不会改变。一个`StatefulWidget`会基于数据变化或者用户输入动态改变。\n\n`StatelessWidget`和`StatefulWidget`二者的最大不同点，就是`StatefulWidget`拥有一个`State`对象来存储数据，以避免在部件树渲染的时候丢失。\n\n在简单的项目中，写部件树是容易的，但是当代码变多之后，应用会越来越复杂，你应该将很深的部件封装成函数或者简单的类。创建封装好的函数和类有利于在复杂项目中实现复用。\n\n## 如何创建可复用的组件\n\n在 React Native 中，创建一个可复用的组件，并使用`props`向它传入属性和值。在如下的例子中，`CustomCard`就是个可复用组件。\n\n```tsx\nconst CustomCard: FC<{ index?: number; onPress?: () => void }> = ({\n  index,\n  onPress,\n}) => (\n  <View>\n    <Text>Card {index}</Text>\n    <Button title=\"Press\" onPress={() => onPress()} />\n  </View>\n);\n\n// Usage\n<CustomCard onPress={() => console.log(1)} index={1} />;\n```\n\n在 Flutter 中，可以通过创建一个后浪于（怎么样，这说法阳春不？）部件的类，并实现它的`build`函数，你也可以创建一个函数并复用它。\n\n```dart\nWidget CustomCard({int index, Function onPress}) {\n  return Card(\n    child: Column(\n      children: <Widget>[\n        Text('Card $index'),\n        FlatButton(\n          child: const Text('Press'),\n          onPress: onPress,\n        ),\n      ],\n    ),\n  );\n}\n\n// Usage\nCustomCard(index = 1, onPress = () { print('Card 1'); })\n```\n\n以上`CustomCard`参数的大括号是 Dart[可选参数](https://dart.dev/guides/language/language-tour#optional-parameters)。\n\n在类的构造函数中，可以使用`@required`实现必要参数。\n\n如下截图是`CustomCard`的展示效果。\n\n| Android                                                                                                                                                              | iOS                                                                                                                                                          |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| ![Android CustomCard](https://flutter.dev/assets/get-started/android/react-native/custom-cards-6bdba4664044a9e5328c0304a51c45fc2812bb37b3d0d57b0c93b98d5bab1f42.png) | ![iOS CustomCard](https://flutter.dev/assets/get-started/ios/react-native/custom-cards-47e3e1e3e73a0ce419eacbee11dc2f15b9acac9b5877c43cd1a783a792b519dc.png) |\n","collection":"blog","data":{"type":"post","category":"fe","tag":["react-native","flutter","dart"],"series":{"slug":"Flutter-for-RN-devs","name":"从RN到Flutter","number":2}}},{"id":"2020/05/06/RN-Flutter.md","slug":"2020/05/06/rn-flutter","body":"\n# 从 RN 到 Flutter-部件\n\n在 Flutter 中，你应该使用部件去描述针对于现有状态和配置的界面。\n\n部件是由许多很小或者单一目的的部件组成。比如`Container`部件就包括几个相关布局、绘制、定位和定型组件，像是`LimitedBox`、`ConstrainedBox`、`Align`、`Padding`、`DecoratedBox`以及`Transform`部件。除了使用`Container`来实现效果，你也可以用几个组件来实现它。\n\n`Center`部件是另一个控制布局的例子。想要剧中部件，就用`Center`包住它。这些部件没有自己的展示，他们的目标就是控制内部部件的布局。想要理解部件是如何渲染，可以去查看他们的相邻部件。\n\n了解更多信息，可以查看[Flutter 技术概览](https://flutter.dev/docs/resources/technical-overview)。\n\n想要了解更多部件信息，可以查看[Flutter 基础部件](https://flutter.dev/docs/development/ui/widgets/basics)，[Flutter 部件目录](https://flutter.dev/docs/development/ui/widgets) 或者 [Flutter 部件索引](https://flutter.dev/docs/reference/widgets)。\n\n## 界面\n\n### Flutter 中的 `View` 组件\n\n在 React Native 中，`View`是支持`Flexbox`布局、样式处理、触摸处理和无障碍化的组件。\n\n在 Flutter 中，你可以使用诸如`Container`、`Column Row`和`Center`的核心布局部件。更多信息可以参考[布局部件](https://flutter.dev/docs/development/ui/widgets/layout)目录。\n\n### Flutter 中的 `FlatList` 和 `SectionList` 组件\n\n一个`List`是垂直排布的可滚动列表。\n\n在 React Native 中，`FlatList`和`SectionList`可以用来渲染简单的或者复杂内容的列表。\n\n```tsx\n<FlatList data={[]} renderItem={({ item }) => <Text>{item.key}</Text>} />\n```\n\n`ListView`是 Flutter 中最常被使用的滚动部件。默认的构造器接受一列准确定义的数据。`ListView`适合少量个数部件渲染。对于无限滚动，需要使用`ListView.builder`，它会按需渲染，并之渲染能展示出来的数据。\n\n```dart\nvar data = [];\nListView.builder(\n    itemCount: data.length,\n    itemBuilder: (context, int index) {\n        return Text(data[index]);\n    },\n);\n```\n\n| Adroid ListVIew                                                                                                                                                | iOS ListView                                                                                                                                           |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| ![Android ListView](https://flutter.dev/assets/get-started/android/react-native/flatlist-91d7c8beaadff16f52d663e94aae7b4c9959d1d811dd7f12ea2005a10e166d34.gif) | ![iOS ListView](https://flutter.dev/assets/get-started/ios/react-native/flatlist-2a18c0173248dd8bf250b29fab7e4cdbc917c27d90ac33c1c791ecb73463f3a5.gif) |\n\n阅读[你的第一个 Flutter 应用，第一部分](https://codelabs.developers.google.com/codelabs/first-flutter-app-pt1)更多了解如何实现无限滚动。\n\n### 如何使用画布\n\n在 React Native 中是没有相关组件的，需要引入类似于`react-native-canvas`的第三方组件。\n\n```tsx\nconst App = () => {\n  return (\n    <View>\n      <Canvas\n        ref={(canvas) => {\n          const ctx = canvas.getContext(\"2d\");\n          ctx.fillStyle = \"skyblue\";\n          ctx.beginPath();\n          ctx.arc(75, 75, 50, 0, 2 * Math.PI);\n          ctx.fillRect(150, 100, 300, 300);\n          ctx.stroke();\n        }}\n      />\n    </View>\n  );\n};\n```\n\n在 Flutter 中，你可以使用`CustomPaint`和`CustomPainter`类去绘制画布。\n\n下面的例子展示的是如何使用`CustomPaint`部件绘制。它实现了虚类 `CustomPainter`，并传递了 `CustomPaint` 的属性。`CustomPaint` 的子类必须实现 `paint()` 和 `shouldRepaint()` 方法。\n\n```dart\nclass MyCanvasPainter extends CustomPainter {\n    paint(Canvas anvas, Size size) {\n        {\n            Paint paint = Paint();\n            paint.color = Colors.amber;\n            canvas.drawCircle(Offset(100.0, 200.0), 40.0, paint);\n        }\n        {\n            Paint paint = Paint();\n            paint.color = Colors.lightBlue;\n            Rect rect = Rect.fromPoints(Offset(150.0, 300.0), Offset(300.0, 400.0));\n            canvas.drawRect(rect, paintRect);\n        }\n    }\n    shouldRepaint() => false;\n}\n\nWidget getCanvas() {\n    return Scaffold(\n        body: CustomPaint(\n            paint: MyCanvasPainter(),\n        ),\n    );\n}\n```\n\n| Android CustomPaint                                                                                                                                             | iOS CustomPaint                                                                                                                                         |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| ![Android CustomPaint](https://flutter.dev/assets/get-started/android/react-native/canvas-cf039fc10bae17fb60b21adb4228eb928b2bf284f95fee71c5a20033c217e333.png) | ![iOS CustomPaint](https://flutter.dev/assets/get-started/ios/react-native/canvas-2cc207759f6ab912bf73e1c3298dc2183618ef207ed989f4d83f6c08fd3a3279.png) |\n\n## 布局\n\n### 如何使用布局部件\n\n在 React Native，许多布局可以通过 props 传入。比如，你可以使用`View`的`style`属性去指定 flexbox 布局。想要让组件成列排列，可以指定样式为`flexDirection: \"column\"`。\n\n```JavaScript\n<View\n    style={{\n        flex: 1,\n        flexDirection: \"column\",\n        justifyContent: \"space-between\",\n        alignItems: \"center\"\n    }}\n/>\n```\n\n在 Flutter 中，布局主要是由既定的布局部件和他们的参数实现。\n\n举个例子，`Column`和`Row`组件接受一个数组作为参数来以列或者以行排列。一个`Container`部件既能处理样式也能处理布局，一个`Center`部件可以将组件居中。\n\n```Dart\nCenter(\n    child: Column(\n        children: <Widget> [\n            Container(\n                color: Colors.red,\n                width: 100.0,\n                height: 100.0,\n            ),\n            Container(\n                color: Colors.blue,\n                width: 100.0,\n                height: 100.0\n            ),\n            Container(\n                color: Colors.green,\n                width: 100.0,\n                height: 100.0,\n            ),\n        ],\n    ),\n)\n```\n\nFlutter 提供一堆布局部件，比方说，`Padding`、`Align`和`Stack`。\n\n了解全部的布局部件，可以查看[布局部件](https://flutter.dev/docs/development/ui/widgets/layout)。\n\n| Adroid Layout                                                                                                                                                    | iOS Layout                                                                                                                                               |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| ![Adroid Layout ](https://flutter.dev/assets/get-started/android/react-native/basic-layout-2490ba3bed87bbf579b422977dcaa34f51a5b77dab53abbd460028acda33a000.gif) | ![iOS Layout](https://flutter.dev/assets/get-started/ios/react-native/basic-layout-bb720a0054daf418b7bafb40619c490933b730f9e45bd9003254ea9d80d6c163.gif) |\n\n### 如何堆叠部件\n\n在 React Native，可以使用绝对定位`absolute`来堆叠组件。\n\nFlutter 使用`Stack`部件让部件按照图层分布。部件会部分覆盖于下面的部件。\n\n```dart\nStack(\n    alignment: cont Alignment(0.6, 0.6),\n    children: <Widget>[\n        CircleAvatar(\n            backgroundImage: NetworkImage(\n                'https://avatars3.githubusercontent.com/u/14101776?v=4'\n            )\n        ),\n        Container(\n            decoration: BoxDecoration(\n                color: Colors.black45,\n            ),\n            child: Text(\"Flutter\"),\n        ),\n    ],\n)\n```\n\n上面的例子使用`Stack`来布局一个`Container`并展示一个拥有黑色半透明背景的`Text`部件覆盖于`CircleAvatar`部件。这个部件通过对齐参数来规定文字位置。\n\n| Android Stack                                                                                                                                            | iOS Stack                                                                                                                                        |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------ |\n| ![Android Stack](https://flutter.dev/assets/get-started/android/react-native/stack-65e0c9e7fc3db73d80d3943f6e88fc788819b1ab4c1354c11e4711298e26ecd0.png) | ![iOS Stack](https://flutter.dev/assets/get-started/ios/react-native/stack-04b7bf2727e1eb71f5dfea8430ee833f24be1ced1893ae86270795b2ab76c5b9.png) |\n\n更多信息可以查看`Stack`对象[文档](https://api.flutter.dev/flutter/widgets/Stack-class.html)。\n\n## 样式\n\n### 如何处理组件样式\n\n在 React Native 中，内联样式和`stylesheets.create`是用来处理组件样式的。\n\n```tsx\nconst style = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: \"#fff\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n});\n\n<View style={styles.container}>\n  <Text style={{ fontSize: 32, color: \"cyan\", fontWeight: \"600\" }}>\n    This is a simple text\n  </Text>\n</View>;\n```\n\n在 Flutter 中，`Text`部件可以使用`TextStyle`类，这个类的对象也可以给多个部件复用。\n\n```dart\nvar textStyle = TextStyle(\n    fontSize: 32.0,\n    color: Colors.cyan,\n    fontWeight: FontWeight.w600,\n);\n\nCenter(\n    child: Column(\n        children: <Widget>[\n            Text(\n                'sample text',\n                style: textStyle,\n            ),\n            Padding(\n                padding: EdgeInsets.all(20.0),\n                child: Icon(\n                    Icons.lightbulb_outline,\n                    size: 48.0,\n                    color: Colors.redAccent,\n                ),\n            ),\n        ],\n    ),\n)\n```\n\n| Android Style                                                                                                                                                     | iOS Style                                                                                                                                                 |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| ![Android Style](https://flutter.dev/assets/get-started/android/react-native/flutterstyling-10cfb607a02859b2a1e9767237029b3cc47891fd017bd70d84536de26383b39c.gif) | ![iOS Style](https://flutter.dev/assets/get-started/ios/react-native/flutterstyling-8b812e5226435b0db6f72b4f2f03a7c72b45bf0794965a0bee882fea909fc7b8.gif) |\n\n### 如何使用图标和颜色\n\nReact Native 没有支持图标的库（这点我不是很同意）。\n\n在 Flutter 中，引入 Material 库包含一堆[Material 图标](https://api.flutter.dev/flutter/material/Icons-class.html)和[颜色](https://api.flutter.dev/flutter/material/Colors-class.html)。\n\n```dart\nIcon(Icons.lightbulb_outline, color: COlors.redAccent)\n```\n\n使用`Icons`类时，记住要把`uses-material-design: true`设置在`pubspec.yaml`中。这保证`MaterialIcons`字体会被包括在应用中。\n\n```yaml\nname: my_awesome_application\nflutter:\n  uses-material-design: true\n```\n\nFlutter 的[Cupertino](https://flutter.dev/docs/development/ui/widgets/cupertino)包，完全遵守 iOS 设计语言。要使用`CupertinoIcons`字体，在项目中增加`cupertino_icons`依赖。\n\n```yaml\nname: my_awesome_application\ndependencies:\n  cupertino_icons: ^0.1.0\n```\n\n要完全的自定义组件的色彩和样式，使用`ThemeData`来定义主题。设置`MaterialApp`的`ThemeData`对象。`Colors`类提供遵守 Material 设计语言的调色盘。\n\n```dart\nWidget build() {\n    return MaterialApp(\n        title: \"Sample App\",\n        theme: ThemeData(\n            primarySwatch: Colors.blue,\n            textSelectionColor: Colors.red,\n        ),\n        home: SampleAppPage()\n    );\n}\n```\n\n### 如何增加主题样式\n\n在 Ract Native，主题是组件定义好的。\n\n在 Flutter 中，使用`ThemeData`类为整个`MaterialApp`部件提供主题。\n\n```dart\nWidget build() {\n    return MaterialApp(\n        title: \"Sample App\",\n        theme: ThemeData(\n            primarySwatch: Colors.blue,\n            textSelectionColor: Colors.red,\n        ),\n        home: SampleAppPage()\n    );\n}\n```\n\n一个`Theme`甚至可以不依赖于`MaterialApp`部件。[Theme](https://api.flutter.dev/flutter/material/Theme-class.html)部件需要一个`ThemeData`传入它的`data`参数中，以适配它的所有子部件。\n\n```dart\nclass SampleTheme extends StatelessWidget {\n    Widget build(BuildContext context) {\n      return Theme(\n           data: ThemeData(\n               primaryColor: Colors.cyan,\n               brightness: brightness,\n           ),\n           child: Scaffold(\n               backgroundColor: Theme.of(context).primaryColor,\n           )\n       )\n    }\n}\n```\n","collection":"blog","data":{"type":"post","category":"fe","tag":["react-native","flutter","dart"],"series":{"slug":"Flutter-for-RN-devs","name":"从RN到Flutter","number":4}}},{"id":"2020/05/07/RN-Flutter.md","slug":"2020/05/07/rn-flutter","body":"\n# 从 RN 到 Flutter-路由器\n\n> 我要死了，这个系列怎么这么长。\n\n许多应用都有多个页面来展示不同信息。比方说，你可能在页面展示一个产品的图片，当用户点击时打开这个产品的详情。\n\n在 Android，新的页面叫做 Activities。在 iOS 新的页面叫 ViewControllers，在 Flutter，新的页面也是部件！包括导航至这些页面的导航器也是导航器部件。\n\n## 如何在页面中导航\n\n在 React Native 里面，有三个导航器`StackNavigator`，`TabNavigator`和`DrawerNavigator`。都提供了配置的接口。\n\n```js\n// React Native\nconst MyApp = TabNavigator(\n  { Home: { screen: HomeScreen }, Notifications: { screen: tabNavScreen } },\n  { tabBarOptions: { activeTintColor: \"#e91e63\" } }\n);\nconst SimpleApp = StackNavigator({\n  Home: { screen: MyApp },\n  stackScreen: { screen: StackScreen },\n});\nexport default MyApp1 = DrawerNavigator({\n  Home: {\n    screen: SimpleApp,\n  },\n  Screen2: {\n    screen: drawerScreen,\n  },\n});\n```\n\n在 Flutter 中，有两个部件用于处理页面路由。\n\n- `Route` 是页面的抽象。\n- `Navigator` 是管理路由的部件。\n\n`Navigator`通过将一列页面以堆的方式覆盖，并提供方法管理这个堆，像是[Navigator.push](https://api.flutter.dev/flutter/widgets/Navigator/push.html)和[Navigator.pop](https://api.flutter.dev/flutter/widgets/Navigator/pop.html)。[MaterialApp](https://api.flutter.dev/flutter/material/MaterialApp-class.html) 部件提供 routes 参数接受这些路由，这些路由可能会明确指出或者动态生成，比如标题动画。下面是一个指明路由的例子。\n\n```dart\nclass App extends StatelessWidget{\n    Widget build(BuildContext: context) {\n        return MaterialApp(\n           routes: <String, WidgetBuilder> {\n                '/a': (BuildContext: context) => usualNavscreen(),\n                '/b': (BuildContext: context) => drawerNavscreen(),\n          },\n       ),\n    }\n}\n```\n\n使用`Navigator.of()`并指定一个`BuildContext`来处理导航，比如前往某个特定页面，可以使用`pushNamed`。\n\n```dart\nNavigator.of(context).pushNamed('/a');\n```\n\n你可以使用`push`方法调用已存在的[Route](https://api.flutter.dev/flutter/widgets/Route-class.html)，这样会动画打开 Route。下面的例子中[MaterialPageRoute](https://api.flutter.dev/flutter/material/MaterialPageRoute-class.html)提供一个模态的页面，并适配系统动画。\n\n```dart\nNavigator.push(context, MaterialPageRoute(builder: (BuildContext context)\n => UsualNavscreen()));\n```\n\n## 如何使用选项卡和抽屉导航\n\n在 Material 设计语言中，为 Flutter 提供了两种导航选项，tab 和 drawer。如果空间使用 tab 很紧张，则 drawer 是个不错的替代。\n\n### 选项卡导航\n\n在 React Native 中，`createBottomTabNavigator`和`TabNavigation`被用来处理选项卡和导航。\n\n```js\nimport { createBottomTabNavigator } from \"react-navigation\";\n\nconst MyApp = TabNavigator(\n  { Home: { screen: HomeScreen }, Notifications: { screen: tabNavScreen } },\n  { tabBarOptions: { activeTintColor: \"#e91e63\" } }\n);\n```\n\nFlutter 提供特别的部件处理抽屉和选项卡导航。\n\n- [TabController](https://api.flutter.dev/flutter/material/TabController-class.html)\n\n  提供`TabBar`和`TabBarView`的控制器\n\n- [TabBar](https://api.flutter.dev/flutter/material/TabBar-class.html)\n\n  展示横向的选项卡\n\n- [Tab](https://api.flutter.dev/flutter/material/Tab-class.html)\n\n  展示 Material 设计语言的单一选项\n\n- [TabBarView](https://api.flutter.dev/flutter/material/TabBarView-class.html)\n\n  展示选中的选项卡\n\n```dart\nTabController controller = TabController(length: 2, vsync: this);\n\nTabBar(\n    tabs: <Tab>[\n        Tab(icon: Icon(Icons.person),),\n        Tab(icon: Icon(Icons.email),),\n    ],\n    controller: controller,\n),\n```\n\n一个`TabController`用于协调`TabBar`和`TabBarView`。构造参数中的`length`属性，提供选项卡的个数。一个`TickerProvider`被用来处理框架状态变化的消息的，通过`vsync`传入。`vsync:this`参数是创建`TabController`必要的。\n\n[TickerProvider](https://api.flutter.dev/flutter/scheduler/TickerProvider-class.html)是可以产生[Ticker](https://api.flutter.dev/flutter/scheduler/Ticker-class.html)对象的类的接口。Ticker 是可以用来接收框架消息的对象，但是他们基本上都是间接通过[AnimationController](https://api.flutter.dev/flutter/animation/AnimationController-class.html)。`AnimationController`需要`TickerProvider`来获取`Ticker`对象。如果你正在从 State 里面创建一个 AnimationController，你可以使用[TickerProviderStateMixin](https://api.flutter.dev/flutter/widgets/TickerProviderStateMixin-mixin.html)或者[SingleTickerProviderStateMixin](https://api.flutter.dev/flutter/widgets/SingleTickerProviderStateMixin-mixin.html)对象以得到`TrickerProvider`。如果你用的是`flutter-hooks`你可以使用`useSingleTickerProvider`获取`Ticker`对象。\n\n[Scaffold](https://api.flutter.dev/flutter/material/Scaffold-class.html)部件封装了一个新的`TabBar`部件并创建两个选项卡。`TabBarView`部件通过`body`参数传入。所有页面的`TabBar`都是`TabBarView`部件的子部件。\n\n```dart\nclass Home extends StatefulWidget {\n  Home() : super();\n  @override\n  State<StatefulWidget> createState() {\n    return _Home();\n  }\n}\n\nclass _Home extends State<Home> with SingleTickerProviderStateMixin {\n  @override\n  Widget build(BuildContext context) {\n    TabController controller = TabController(length: 2, vsync: this);\n    return Scaffold(\n        appBar: AppBar(\n          title: Text('home'),\n        ),\n        bottomNavigationBar: Material(\n          color: Colors.blue,\n          child: TabBar(\n            controller: controller,\n            tabs: <Tab>[\n              Tab(\n                icon: Icon(Icons.person),\n              ),\n              Tab(\n                icon: Icon(Icons.email),\n              )\n            ],\n          ),\n        ),\n        body: TabBarView(\n          children: <Widget>[\n            Center(\n              child: Text('person'),\n            ),\n            Center(\n              child: Text('email'),\n            )\n          ],\n          controller: controller,\n        ));\n  }\n}\n\n```\n\n当然也可以使用`flutter-hooks`，其实如果收拾一下的话都要写两个类，就看你爱怎么写了。\n\n```dart\nclass Home extends HookWidget {\n  @override\n  Widget build(BuildContext context) {\n    final vsync = useSingleTickerProvider();\n    final controller = useMemoized(() {\n      return TabController(length: 2, vsync: vsync);\n    });\n\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Home'),\n      ),\n      bottomNavigationBar: Material(\n        color: Colors.blue,\n        child: TabBar(\n          controller: controller,\n          tabs: <Widget>[\n            Tab(icon: Icon(Icons.person)),\n            Tab(icon: Icon(Icons.email))\n          ],\n        ),\n      ),\n      body: TabBarView(\n        controller: controller,\n        children: <Widget>[\n          Center(child: Text(\"person\")),\n          Center(\n            child: Text(\"email\"),\n          )\n        ],\n      ),\n    );\n  }\n}\n\n```\n\n## 抽屉导航\n\n在 React Native 中，需要引入`react-navigation`包，并使用`createDrawerNavigator`和`DrawerNavigation`。\n\n```js\nexport default MyApp = DrawerNavigator({\n  Home: {\n    screen: SimpleApp,\n  },\n  Screen2: {\n    screen: drawScreen,\n  },\n});\n```\n\n在 Flutter 中，我们可以使用`Drawer`部件结合`Scaffold`部件创建 Material 设计语言的抽屉。想要创建一个带有抽屉的应用，需要将`Drawer`封装至`Scaffold`中。`Scaffold`部件提供一套基于[Material 设计标准](https://material.io/design)的样式结构，并且还支持许多特殊的 Material 设计组件，比如`Drawer`、`AppBar`和`SnackBar`。\n\n`Drawer`部件是一个基于 Material 设计的控制台，它在`Scaffold`水平方向的边缘，展示应用的导航链接。你可以在这个部件中使用[RaisedButton](https://api.flutter.dev/flutter/material/RaisedButton-class.html)和[Text](https://api.flutter.dev/flutter/widgets/Text-class.html)组件，或者一个列表。在下面的例子中[ListTile](https://api.flutter.dev/flutter/material/ListTile-class.html)就提供了点击导航的功能。\n\n```dart\n// Flutter\nDrawer(\n  child:ListTile(\n    leading: Icon(Icons.change_history),\n    title: Text('Screen2'),\n    onTap: () {\n      Navigator.of(context).pushNamed('/b');\n    },\n  ),\n  elevation: 20.0,\n),\n```\n\n在`Scaffold`部件的`AppBar`会自动适配给`Drawer`一个图标，并且`Scaffold`能够自动处理`Drawer`的左滑手势。\n\n```dart\n// Flutter\n@override\nWidget build(BuildContext context) {\n  return Scaffold(\n    drawer: Drawer(\n      child: ListTile(\n        leading: Icon(Icons.change_history),\n        title: Text('Screen2'),\n        onTap: () {\n          Navigator.of(context).pushNamed('/b');\n        },\n      ),\n      elevation: 20.0,\n    ),\n    appBar: AppBar(\n      title: Text('Home'),\n    ),\n    body: Container(),\n  );\n}\n```\n\n另外，如果不爽页面转场动画单一，然后自己又懒得写动画，可以直接用[page_transition](https://pub.dev/packages/page_transition)包。\n\n| Android Drawer                                                                                                                                                 | iOS Drawer                                                                                                                                             |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| ![Android Drawer](https://flutter.dev/assets/get-started/android/react-native/navigation-98906732ed22d9aa8e0ce0eb846dbcc7d24c123ad026c359f9f7fcc44ba99230.gif) | ![iOS Drawer](https://flutter.dev/assets/get-started/ios/react-native/navigation-1939f60628bec820bad0fe88d58c562984c1c00d8cfd755a4135f4321a37417e.gif) |\n","collection":"blog","data":{"type":"post","category":"fe","tag":["React-Native","flutter"],"series":{"slug":"Flutter-for-RN-devs","name":"从RN到Flutter","number":6}}},{"id":"2020/05/08/RN-Flutter.md","slug":"2020/05/08/rn-flutter","body":"\n# 从 RN 到 Flutter-动画\n\n好的动画会使 UI 更加直观，是应用更加精致，并提高用户体验。Flutter 的动画使简单动画和复杂动画的实现变得容易。Flutter SDK 所遵守的 Material 设计语言包含了标准的动态效果，你可以简单地自定义它们并应用于你的应用。\n\n在 React Native 中，Animated API 被应用于创建动画。\n\n在 Flutter 中，使用[Animation](https://api.flutter.dev/flutter/animation/Animation-class.html)类和[AnimationController](https://api.flutter.dev/flutter/animation/AnimationController-class.html)类。`Animation`是包括一个动画初始状态到它终态（完成或者取消）状态的抽象类。`AnimationController`类控制动画的执行、反转或者停止动画，乃至于设置动画为某一个值以做到自定义的目的。\n\n## 实现一个淡入动画\n\n下面的 React Native 例子是利用 Animated API 创建的`FadeInView`组件。初始状态、终止状态已经过程都需要定义。该组件包裹需要动画的组件，透明值`fadeAnim`向下继承到`Text`组件中，使得执行`start()`后，动画就开始了。\n\n```js\n// React Native\nclass FadeInView extends React.Component {\n  state = {\n    fadeAnim: new Animated.Value(0) // Initial value for opacity: 0\n  };\n  componentDidMount() {\n    Animated.timing(this.state.fadeAnim, {\n      toValue: 1,\n      duration: 10000\n    }).start();\n  }\n  render() {\n    return (\n      <Animated.View style={{...this.props.style, opacity: this.state.fadeAnim }} >\n        {this.props.children}\n      </Animated.View>\n    );\n  }\n}\n    ...\n<FadeInView>\n  <Text> Fading in </Text>\n</FadeInView>\n    ...\n```\n\n想在 Flutter 中实现相应效果，需要创建一个 [AnimationController](https://api.flutter.dev/flutter/animation/AnimationController-class.html) 对象，命名为`controller`并指明持续时间。默认`AnimationController`会在持续时间内线性执行动画。这个动画控制器在每一帧都会返回一个新值，默认是每秒 60 个值。\n\n使用`AnimationController`时，必须传入`vsync`对象。引入`vsync`的目的是避免不在屏幕上的动画浪费资源。你可以使用你的状态机作为`vsync`，只要在类定义的时候混入`TickerProviderStateMixin`。一个`AnimationController`构造时需要一个 TickerProvider 作为`vsync`参数。\n\n[Tween](https://api.flutter.dev/flutter/animation/Tween-class.html)描述初始值和结束值之间的插值。动画中使用`Tween`对象，可以将`Tween`的`animate()`返回值传给要修改的`Animation`对象。\n\n使用`controller.forward()`开始动画。其他操作如`fling()`和`repeat()`也可以开始动画。比如下面的例子，将[FlutterLogo](https://api.flutter.dev/flutter/material/FlutterLogo-class.html)部件放在`FadeTransition`部件中。\n\n```dart\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(Center(child: LogoFade()));\n}\n\nclass LogoFade extends StatefulWidget {\n  _LogoFadeState createState() => _LogoFadeState();\n}\n\nclass _LogoFadeState extends State<LogoFade> with TickerProviderStateMixin {\n  Animation animation;\n  AnimationController controller;\n\n  initState() {\n    super.initState();\n    controller = AnimationController(\n        duration: const Duration(milliseconds: 3000), vsync: this);\n    final CurvedAnimation curve =\n    CurvedAnimation(parent: controller, curve: Curves.easeIn);\n    animation = Tween(begin: 0.0, end: 1.0).animate(curve);\n    controller.forward();\n  }\n\n  Widget build(BuildContext context) {\n    return FadeTransition(\n      opacity: animation,\n      child: Container(\n        height: 300.0,\n        width: 300.0,\n        child: FlutterLogo(),\n      ),\n    );\n  }\n\n  dispose() {\n    controller.dispose();\n    super.dispose();\n  }\n}\n```\n\n也可以把动画的实现封装成 hook。\n\n```dart\nAnimation useFadeIn() {\n  final ticker = useSingleTickerProvider();\n  final controller = useMemoized(() => AnimationController(\n      duration: const Duration(milliseconds: 3000), vsync: ticker));\n  final animation = useMemoized(() => Tween(begin: 0.0, end: 1.0)\n      .animate(CurvedAnimation(parent: controller, curve: Curves.easeIn)));\n\n  useEffect(() {\n    controller.forward();\n    return () => controller.dispose();\n  });\n\n  return animation;\n}\n```\n\n| Android fadeIn                                                                                                                                                   | iOS fadeIn                                                                                                                                               |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| ![Android fadeIn](https://flutter.dev/assets/get-started/android/react-native/flutter-fade-241787290a9da1d7406516a96845a65c42c97b5a8219f4ff29f0c3412ab281ba.gif) | ![iOS fadeIn](https://flutter.dev/assets/get-started/ios/react-native/flutter-fade-2596d382757ecf7c4a2db020871d715da585db9fabed9956cbff6ef011b2786b.gif) |\n\n## 为卡片增加滑动关闭动画\n\n在 React Native 里，可以使用如`PanResponder`或者第三方库实现华东关闭。\n\n在 Flutter 中，为部件增加滑动动画可以使用[Dismissible](https://api.flutter.dev/flutter/widgets/Dismissible-class.html)部件。\n\n```dart\nchild: Dismissible(\n  key: key,\n  onDismissed: (DismissDirection dir) {\n    cards.removeLast();\n  },\n  child: Container(\n    ...\n  ),\n),\n```\n\n| Android Dismissable                                                                                                                                                 | iOS dismissable                                                                                                                                             |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| ![Android Dissmisable](https://flutter.dev/assets/get-started/android/react-native/card-swipe-20a57fe25c2e274bfbe0e9f3d4d1aebd5443fc9d2ce81bd6e9d2588e94e28b16.gif) | ![iOS Dismissible](https://flutter.dev/assets/get-started/ios/react-native/card-swipe-ed0bd70d7698b81793f2a44bea69ddf51be44ac486e8410961aabff16176e3ce.gif) |\n\n啊啊啊啊，这个系列翻译完了！！！后面还有一个 Flutter 和 React Native 组件的[对照表格](https://flutter.dev/docs/get-started/flutter-for/react-native-devs#react-native-and-flutter-widget-equivalent-components)，我就不贴上来了。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["React-Native","flutter"],"series":{"slug":"Flutter-for-RN-devs","name":"从RN到Flutter","number":8}}},{"id":"2020/05/10/Flutter.md","slug":"2020/05/10/flutter","body":"\n# Flutter 的手表应用-从入门到放弃\n\n这是一个写得一头沮丧的文章，可能是期待值比较高吧，所以任何一个想用 Flutter 写 wearOS 的朋友都要注意一点，他能写，但可能没那么好。这篇文章本来想参考[Flutter: Building Wear OS app](https://medium.com/flutter-community/flutter-building-wearos-app-fedf0f06d1b4)，因为`wear`这个包已经年久失修不支持最新的 SDK（我天，这可是 2019 年 6 月的文章），于是后来参考[Experimenting with Flutter on Wear OS](https://medium.com/@mjohnsullivan/experimenting-with-flutter-on-wear-os-f789d843f2ef)。如果不想踩坑，只是想写个应用截图发朋友圈的话，直接 clone[这个 repo](https://github.com/sbis04/flutter_os_wear)就好，热爱生命，避免折腾，哈哈。\n\n## 可以用 Flutter 来写手表应用吗\n\n答案是可以的，而且还意料之外地能用。首先要在本机安装模拟器（注意不要安装中国版，中国版真的会卡住）。然后直接运行 flutter 的官方示例就可以了。\n\n![模拟器下的Flutter示例](./2020-05-10-flutter-watch.png)\n\n## 表盘形状\n\n在 Flutter 中可以使用 MediaQuery 获取到屏幕的大小：\n\n```dart\nfinal screenSize = MediaQuery.of(content).size;\nfinal screenHeight = screenSize.height;\nfinal screenWidth = screenSize.width;\n```\n\n但是不能获取到表盘的形状，但是可以通过 kotlin 从安卓 Wear OS 的库里面获取。Flutter 为 Dart 提供了一个支持双向传输的数据通道[MethodChannels](https://flutter.io/platform-channels/)，比起 QML，这更像 JS bridge 的实现，因为这些数据是异步传输的，这些数据也可以通过流传输[EventChannels](https://docs.flutter.io/flutter/services/EventChannel-class.html)。\n\n在安卓的 MainActivity 中可以调用如下方法向 Flutter 传递表盘状态，注意因为是 Wear OS，所以在`Android/app/build.gradle`修改`minSdkVersion`为 23，并在以下依赖中增加以下项目。\n\n```gradle\ndependencies {\n    ...\n    implementation 'com.android.support:wear:27.1.1'\n    implementation 'com.google.android.support:wearable:2.3.0'\n    compileOnly 'com.google.android.wearable:wearable:2.3.0'\n    ...\n}\n```\n\n`AndroidManifest.xml`中打开权限。\n\n```xml\n<!-- Required for ambient mode support -->\n<uses-permission android:name=\"android.permission.WAKE_LOCK\" />\n\n<!-- Flags the app as a Wear app -->\n<uses-feature android:name=\"android.hardware.type.watch\" />\n\n<!-- Flags that the app doesn't require a companion phone app -->\n<application>\n<meta-data\n    android:name=\"com.google.android.wearable.standalone\"\n    android:value=\"true\" />\n</application>\n```\n\n```kotlin\nprivate fun setShapeMethodChannel() {\n  MethodChannel(flutterView, shapeChannel).setMethodCallHandler { _, result ->\n    setOnApplyWindowInsetsListener(flutterView, {_, insets: WindowInsetsCompat? ->\n      if (insets?.isRound == true) {\n        result.success(0)\n      }\n      else {\n        result.success(1)\n      }\n      WindowInsetsCompat(insets)\n    })\n    requestApplyInsets(flutterView)\n  }\n}\n```\n\n在 Dart 部分通过监听 channel 获得形状\n\n```dart\nenum Shape { square, round };\nShape shape;\ntry {\n  final int result = await platform.invokeMethod('shape');\n  shape = result == 1 ? Shape.square : Shape.round;\n} on PlatformException catch (e) {\n  // Default to round\n  print('Error detecting shape: $e');\n  shape = Shape.round;\n}\n```\n\n## 省电模式(Ambient mode)\n\n手表耗电是很棘手的，所以安卓手表的应用都会选择支持长期显示时进入省电模式（我就惊了，你说用电子纸多好，偏偏所有人都用 LED，又不是拿手表看片，要那么好的显示搞什么？）。\n\n可以在 kotlin 部分获取省电模式的事件并通过 channel 传给 dart。\n\n```kotlin\nclass MainActivity: FlutterActivity(), AmbientMode.AmbientCallbackProvider {\n    private var mAmbientController: AmbientMode.AmbientController? = null\n    override fun onCreate(savedInstanceState: Bundle?) {\n        // Set the Flutter ambient callbacks\n        mAmbientController = AmbientMode.attachAmbientSupport(this)\n    }\n    override fun getAmbientCallback(): AmbientMode.AmbientCallback {\n        return FlutterAmbientCallback(flutterView)\n    }\n}\n\nprivate class FlutterAmbientCallback(val flutterView: FlutterView): AmbientMode.AmbientCallback() {\n    override fun onEnterAmbient(ambientDetails: Bundle) {\n        MethodChannel(flutterView, ambientChannel).invokeMethod(\"enter\", null)\n        super.onEnterAmbient(ambientDetails)\n    }\n    override fun onExitAmbient() {\n        MethodChannel(flutterView, ambientChannel).invokeMethod(\"exit\", null)\n        super.onExitAmbient()\n    }\n    override fun onUpdateAmbient() {\n        MethodChannel(flutterView, ambientChannel).invokeMethod(\"update\", null)\n        super.onUpdateAmbient()\n    }\n}\n```\n\n在 Dart 部分处理事件。\n\n```dart\n@override\ninitState() {\n    super.initState();\n    platformAmbient.setMethodCallHandler((call) {\n        switch (call.method) {\n            case 'enter':\n                setState(() => ambientMode = Mode.ambient);\n            break;\n        case 'update':\n            if (widget.update != null)\n                widget.update();\n            else\n                setState(() => ambientMode = Mode.ambient);\n        break;\n        case 'exit':\n            setState(() => ambientMode = Mode.active);\n        break;\n    }\n  });\n}\n```\n\n## 总结\n\nFlutter 能写安卓应用吗？能，而且比不好用要强得多。但是如果想写出 apple watch 的应用那种，还是道阻且长。不过考虑 wear OS 本身自己的应用都不咋地，感兴趣玩一下还是可以的。\n\n另外 Flutter 没有为 wearOS 设计 Material 设计语言的部件，所以都要自己设计（虽然屏幕也就 1~2 英寸）。也没有左滑后退的能力，只能在界面增加一个后退按钮，如果用户不小心左滑了，应用就关闭了（尴尬）。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["flutter","wearOS"]}},{"id":"2020/05/12/flutter-CICD.md","slug":"2020/05/12/flutter-cicd","body":"\n# 多平台上的 flutter 以及 CICD\n\nFlutter 是一个号称面向全平台的框架，既然立了 flag，早晚要去摘的。除了 iOS 和 Android，beta 版本的 flutter 还支持 web 网页以及 mac 桌面端，alpha（master 分支）版本还提供 Windows 和 Linux 桌面端的支持，本篇除了介绍 flutter 在各端如何开发发布还会提及如何通过 CICD 发布安卓 apk，以及这段时间使用 Flutter 的感想。\n\n## Web 支持\n\nWeb 应该是 dart 语言一直想抢的蛋糕，在早期 chrome 上面就有 dart VM，甚至提供了 dart2js 这样的工具，所以 Flutter 在一炮走红之后立刻提供 web 支持是不意外的。\n\n创建 Web 端的 Flutter 应用，以下几项是必须的：\n\n- 安装 Flutter SDK\n- Chrome 浏览器\n- 一个支持开发 Flutter 的编辑器\n\n确定以上几项后执行下面命令切换 Flutter 到 beta 版本，并打开 Web 端支持。\n\n```shell\n flutter channel beta\n flutter upgrade\n flutter config --enable-web\n```\n\n以上命令执行成功后执行`flutter devices`应该能看到 Chrome 浏览器和 Web 伺服器的支持。\n\n打开任何一个 Flutter 项目的根目录，执行`flutter run -d chrome`，稍等片刻 chrome 会被自动打开并渲染项目（这个体验很割裂，真的，这个片刻其实比较久，而且你的终端会不会显示任何东西）。\n\n执行`flutter build web`就会编译项目至`/build/web`文件夹下。\n\n### Web 支持总结\n\n编译 web 应用已经相对稳定，基本上你老姑（谷歌）想要的功能也都有（比如 service-worker 什么的），但因为是 js 渲染，SEO 什么的可能没 SSR 项目号，再一个，我在使用的时候没发现有 sourcemap，估计 debug 的方法也会和普遍 web 应用不太一致。\n\n## Windows 桌面支持\n\n到 Flutter 的目录下，将它 checkout 到 master 分支，此时执行`flutter doctor`，它会检查你是否安装`Visual Studio`、`MSVC`以及`Windows10 SDK`（当然了，这是在 Windows 下面执行才有），没错，alpha 版本的 flutter 已经可以编译 Windows 桌面应用了，只需安装社区版的`Visual Studio`，在安装项里面添加`Clang`、`MSVC`和`Windows10 SDK`即可。\n\n另外还需要在项目中增加[flutter desktop embedding](https://github.com/google/flutter-desktop-embedding)，尝试到这里我有点失望，看了这个项目的 issue，目前 Windows 的桌面支持还是用 Win32 的 API，项目正在计划使用 UWP 来替换。同样 Linux 桌面也在纠结于到底使用 QT 还是 GTK 做框架，因此这两个桌面端的支持相较于 Mac 延后。\n\n## flutter-rs\n\n这是我的另一个 Flag，几个月前我在尝试用 rust 写桌面应用，几个平台都不理想，于是尝试了这个包。然而[flutter-rs](https://github.com/flutter-rs/flutter-rs)依然不太理想，不过更多原因可能是因为这个项目还在 WIP 阶段。\n\n目前 rust 推荐在 WSL 上面开发，考虑到 WSL1 对图形的支持不太好，我更新了[WSL2](https://aka.ms/wsl2kernel)的内核，并使用 Ubuntu 20.04 开发。\n\n这里注意下，WSL2 是完整的 Linux 内核，所以代理什么的都不能使用 WSL1 里面的`localhost`。\n\n```shell\nexport WSL_VERSION=$(wsl.exe -l -v | grep -a '[*]' | sed 's/[^0-9]*//g')\nexport WSL_HOST=$(tail -1 /etc/resolv.conf | cut -d' ' -f2)\nexport DISPLAY=$WSL_HOST:0\n\nexport HTTP_PROXY=http://$WSL_HOST:1080\nexport HTTPS_PROXY=http://$WSL_HOST:1080\nexport NO_PROXY=127.0.0.1,localhost,$WSL_HOST\n```\n\n同样在运行`vcXsrv`时也要加上`-ac`参数已打开远端支持。\n\n安装编译`flutter-rs`需要很多依赖，\n\n```shell\nsudo apt install build-essential libssl-dev pkg-config libxcb-util-dev libxcb-render-util0-dev libxcb-shape0-dev libxcb-xfixes0-dev libclang-dev libglfw3\n\ncargo install flutter-rs\n```\n\n尴尬的来了，执行`cargo flutter run`，打开的 flutter 窗口闪了一下就崩溃了...查了下，好像是 Skia 在 rust 上面链接的问题，哎，不跟进了。\n\n## hover\n\n那么就没有一个能稳定点的桌面端方案了么？有！go 提供了一套 API 接口[hover](https://hover.build/)也叫[go-flutter](https://github.com/go-flutter-desktop/go-flutter)，框架是 GLFW。\n\n在 MSYS 里面就可以安装 golang（太好了，WSL 下面编译 GUI 不敢恭维啊）。\n\n```shell\npacman -S mingw-w64-x86_64-go\n```\n\n初次运行提示找不到 go 命令，貌似`mingw-w64`不在 PATH 上，查了好多都没找到原因，干脆直接添加上好了。\n\n```shell\nexport PATH=/c/tools/msys64/mingw64/bin:$PATH\n```\n\n下面安装 hover\n\n```shell\nGO111MODULE=on go get -u -a github.com/go-flutter-desktop/hover\n```\n\n随便找个已有的 flutter 项目，执行`hover run`，它会询问你是否增加一段 fushia 的代码`lib/main_desktop.dart`，没错，所有的 desktop 端都叫 fushia，它也是桌面端的入口文件，直接回复 Y 即可。\n\n和 flutter 的命令类似，执行`hover build windows`就会在`/build/output/windows`下生成编译好的可执行文件。\n\nhover 相对来说是目前唯一比较成熟的 Flutter 桌面运行时了，更多内容可以查看它的[文档](https://github.com/go-flutter-desktop/hover)。但是运行结果不能说如意，比如在处理改变窗口大小时，界面不会跟着鼠标变化，直到释放之后才会改变，这对于 2020 年的人类来说，体验真是不够好，但是运行起来确实是比 electron 好些，起码笔记本风扇没有疯狂打转。\n\n### Windows 桌面支持总结\n\n在官方支持遥遥无期的情况下，桌面支持真是百花齐放，不过另一方面微软爸爸直接提供亲生的[React Native Windows](https://github.com/Microsoft/react-native-windows)可是支持 UWP 下面的 Fluent Design 哦，所以在多段支持上，起码 Windows 这里，React Native 略胜一筹。\n\n## CICD\n\n本来想写一下测试的，结果发现没啥新东西。干脆提一下利用 Github action 做 CICD 好了。（其实基本上就复制[别人](https://github.com/nabilnalakath/flutter-githubaction)的`/.github/workflows`文件夹就好，白嫖很开心）。\n\n```yaml\non: push\nname: Test, Build and Release apk\njobs:\n  build:\n    name: Build APK\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v1\n      - uses: actions/setup-java@v1\n        with:\n          java-version: \"12.x\"\n      - uses: subosito/flutter-action@v1\n        with:\n          flutter-version: \"1.7.8+hotfix.4\"\n      - run: flutter pub get\n      - run: flutter test\n      - run: flutter build apk --debug --split-per-abi\n      - name: Push APK to Releases\n        uses: ncipollo/release-action@v1\n        with:\n          artifacts: \"build/app/outputs/apk/debug/*.apk\"\n          token: ${{ secrets.TOKEN }}\n```\n\n## 总结\n\nFlutter 相对于 React Native 的确有性能上的优势，毕竟跳过了 js 和原生环境交互的沟壑，但是对比开发环境还是没有 RN 全面。\n\n- 如果只是移动端应用，两者皆可，Flutter 有对 Material Design 更原生的支持，所以如果设计上是 Material Design，开发效率会更高；但是 RN 则在可定制上更高一筹。\n- 如果是 Wear OS，必然 Flutter。\n- 如果是桌面应用，目前我站 RN，除了工具链全面，它对比 Electron 已经很好了，而 Flutter 即使理论上性能更高，但其 alpha 的不稳定也要考虑在内。\n- 如果是 Web 端，感觉 Flutter 根本打不过现有的框架，不过仅仅对比 RN 的话，Flutter 可以不做配置就直接编译 Web，也就是说如果你有一个移动应用，又不想关心 Web 是怎么回事儿，用它还是可以的。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["flutter","CICD","rust","golang","wsl2","hover","github-action","vcXsrv","MSYS"]}},{"id":"2020/05/29/WebRTC.md","slug":"2020/05/29/webrtc","body":"\n# WebRTC，谈谈我这几天对它的研究\n\nWebRTC 是一个我在大学时期就关注的技术了，然而由于时间过早，很多技术细节都还在草案上就暂时罢休。今年年初，全世界都进入在家办公状态，视频会议工具被推到风口浪尖，webRTC 技术又一次被推到小高潮，于是便有了[这个实现](https://github.com/gongbaodd/ReactRTC)以及这篇文章。\n\n## WebRTC 是什么\n\nWebRTC 是实现网络端视频会议的技术，包括实现获取客户端的媒体 API，如获取摄像头以及麦克风的 `navigator.mediaDevices.getUserMedia()` 以及录制屏幕的 `navigator.mediaDevices.getDisplayMedia()`；还有实现双端数据传输的 `RTCPeerConnection` 类。\n\n目前主流的实现方式是将用户本地视频上传到后台服务器，由服务器转发视频数据到客户端。很恐怖是吧，没错，这就是为什么疫情刚刚开始大部分视频服务都因为访问过多而宕机，但是因为技术架构相对简单，容易实现并可以迁移到多个平台上面。\n\nWebRTC 依赖的是 P2P 技术，一旦两台机器实现连接，双方直接进行数据传输而不需要第三方转发，所以相对安全，但是实现细节比较困难，强烈推荐看一下 MDN 的[介绍](https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API)。\n\n## 两台机器如何连接\n\nP2P 说起来简单，实现起来并不容易，目前互联网主流使用 IPv4 协议，这意味着在网络环境中，真正暴漏的单一 IP 对应的是后台基于 NAT（Network Address Transition）技术连接的一簇终端设备。当我们使用网络传输数据时，是有一台暴露在外网的路由将收到的数据转发给自己的端口上面，但这一层转发，很多实现是广播的，意味着端口上面的每一台设备都能收到传输数据，如果要指定某台机器接收，需要在数据包里包含设备的描述，就好像 90 年代打电话往往要胡同门口小卖铺的王大爷叫一下。实现多设备链接就需要使用 ICE 技术（你的地址描述）的 TURN 或者 STUN 服务（提供地址描述的服务）。\n\n### ICE 技术\n\nICE（Interactive Connectivity Establishment）技术，我称之为「破冰」技术，它提供一个通过 TURN 或者 STUN 服务获取的一堆关于本地地址的描述，在 webRTC 中可以[获得本地描述](https://codesandbox.io/s/reactrtc-f365m?file=/src/components/PeerConnection.tsx:2363-2403)和[添加远端描述](https://codesandbox.io/s/reactrtc-f365m?file=/src/components/PeerConnection.tsx:3078-3139)。\n\n```typescript\nuseEffect(() => {\n  // 获取本地地址\n  connection.addEventListener(\"icecandidate\", (event) => {\n    if (event.candidate) {\n      // TODO: 保存 `event.candidate.toJSON()` 到服务器\n      // ...\n    }\n  });\n}, [connection]);\n\nconst onGetRemoteCandidate = useCallback(async () => {\n  // 添加远端地址\n  await connection.addIceCandidate(new RTCIceCandidate(data));\n}, [connection]);\n```\n\n### STUN 服务和 TURN 服务\n\nSTUN（Session Traversal Utilities for NAT）是一个能够帮助获取到客户端地址描述的协议。\n\n![STUN 服务](https://mdn.mozillademos.org/files/6115/webrtc-stun.png)\n\n在 RTCPeerConnection 中可以使用 google 的 STUN 服务。\n\n```ts\nconst [connection] = useState(() => {\n  return new RTCPeerConnection({\n    iceServers: [\n      {\n        urls: [\n          \"stun:stun1.l.google.com:19302\",\n          \"stun:stun2.l.google.com:19302\",\n        ],\n      },\n    ],\n    iceCandidatePoolSize: 10,\n  });\n});\n```\n\n而 TURN（Traversal Using Relays around NAT）则针对于只能接受对称 NAT（Symmetric NAT） 的路由器，设备对应的端口可变，相对于传统的锥形 NAT（Cone NAT），需要在 STUN 协议的基础上增加 Relay 转发。\n\n![TURN 协议](https://mdn.mozillademos.org/files/6117/webrtc-turn.png)\n\n如果心情好的话，你可以使用[COTURN](https://github.com/coturn/coturn)自己搭建一个 TURN 服务，更多关于 P2P 协议的描述可以参考[这篇博文](https://www.cnblogs.com/pannengzhi/p/5048965.html)。\n\n### SDP 会话描述\n\n如果你写过 HTTP 服务的话，一定会知道，要实现一个有状态的 HTTP 请求的实现基于会话，服务器和客户端通过一个会话 ID 实现双方的认证。会话在 P2P 下一样成立，这个会话 ID 则称为 SDP（Session Description Protocol）。\n\n一个 SDP 的结构如下，m 表示会话中的媒体描述。\n\n```ini\nv=0\no=mozilla...THIS_IS_SDPARTA-76.0.1 8725109466872836540 0 IN IP4 0.0.0.0\ns=-\nt=0 0\na=fingerprint:sha-256 A9:89:58:E6:B5:E3:23:F8:F4:4C:15:13:58:F5:7B\na=group:BUNDLE 0 1\na=ice-options:trickle\na=msid-semantic:WMS *\nm=audio 9 UDP/TLS/RTP/SAVPF 109 9 0 8 101\nc=IN IP4 0.0.0.0\na=sendrecv\na=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level\na=extmap:2/recvonly urn:ietf:params:rtp-hdrext:csrc-audio-level\nm=video 9 UDP/TLS/RTP/SAVPF 120 121 126 97\nc=IN IP4 0.0.0.0\na=sendrecv\na=extmap:3 urn:ietf:params:rtp-hdrext:sdes:mid\na=extmap:4 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time\na=extmap:5 urn:ietf:params:rtp-hdrext:toffset\n```\n\n当然生成二进制 SDP 的过程是不需要人工字符串拼接的，可以使用`connection.createOffer`和`connection.createAnswer`生 SDP，并使用`connection.setLocalDescription`和`connection.setRemoteDescription`建立会话。\n\n```ts\n// 发起端生成SDP\nconst createOffer = useCallback(async () => {\n  const offer = await connection.createOffer();\n  await conn.setLocalDescription(offer);\n  // TODO: 保存发起端的SDP到服务器\n  // ...\n}, [connection]);\n```\n\n## P2P 会议室的流程\n\n### 事前准备\n\n了解了上面的部分，我们需要如下内容以完成一次 P2P 连接\n\n- 一个 STUN 服务或者一个 TURN 服务来获取地址描述\n- 一台服务器，能够实现存储一端 ICECandidate（地址描述） 和 SDP（会话描述），并使另一端通过无论是 websocket 实现还是像 firebase 一样做轮询（polling）的技术获取数据。\n- 两台终端设备，其实要的就是两个`RTCPeerConnection`，但如果需要视频会议的话，还需要两个以上摄像头（反正我有 3 台 PC~）。\n\n### 1. 设置 RTCPeerConnection\n\n注意，网上很多示例会创建一个`localConnection`和一个`remoteConnection`，因为他们是在一台终端上做演示，所以理论上如果只要两台设备联络，代码里面创建一个`RTCPeerConnection`就可以实现两台设备连接了。\n\n[这里](https://codesandbox.io/s/github/gongbaodd/ReactRTC?file=/src/components/PeerConnection.tsx:618-663)因为项目用的是 React，我把实现封装成了一个`PeerConnection`组件。\n\n```ts\nconst config = {\n  iceServers: [\n    {\n      urls: [\"stun:stun1.l.google.com:19302\", \"stun:stun2.l.google.com:19302\"],\n    },\n  ],\n  iceCandidatePoolSize: 10,\n};\n\nconst CTX = createContext<RTCPeerConnection | null>(null);\n\nexport const PeerConnection: FC = ({ children }) => {\n  const [connection] = useState(() => {\n    return new RTCPeerConnection(config);\n  });\n\n  return <CTX.Provider value={connection} children={children} />;\n};\n```\n\n### 2. 处理本地 IceCandidate\n\n建立好 RTCPeerConnection 对象后，需要收集本地的 IceCandidate 并上传至服务器。\n\n```ts\nuseEffect(() => {\n  // 获取本地地址\n  // 假设这段代码是发起端，存储数据到callerAddress\n  // 如果是接收端，则存储到calleeAddress\n  connection.addEventListener(\"icecandidate\", async (event) => {\n    if (event.candidate) {\n      const db = await firebase.firestore();\n      const caller = await db.collection(\"callerAddress\");\n      caller.add(event.candidate);\n    }\n  });\n}, [connection]);\n```\n\n### 3. 获得远端 IceCandidate\n\n从数据库中中找到远端的地址（根据黑暗森林法则，如果知道对方地址，就可以杀死对方了），知道对方地址就可以建立会话了。\n\n```ts\n// 获得远端地址\n// 同样假设这段代码是发起端\n// 如果是接收端，则需要监视callerAddress\nconst db = await firebase.firestore();\nconst caller = await db.collection(\"calleeAddress\");\ncaller.onSnapshot((snapshot) => {\n  snapshot.docChanges().forEach(async (change) => {\n    if (change.type === \"added\") {\n      const address = change.doc.data();\n      await connection.addIceCandidate(new RTCIceCandidate(address));\n    }\n  });\n});\n```\n\n至此两边已经了解对方地址，可以进行会话了。\n\n### 4. 发起方获得本地媒体数据\n\n通过`navigator.mediaDevices.getUserMedia`获得媒体数据后，可以用`addTracks`函数把数据流添加到连接里面。\n\n```ts\nconst getUserMedia = useCallback(async () => {\n  const userStream = await navigator.mediaDevices.getUserMedia({\n    video: true,\n    audio: true,\n  });\n  userStream.getTracks().forEach((t) => {\n    connection.addTrack(t, localStream);\n    console.log(\"[P2P] stream to peer\", localStream);\n  });\n}, [connection]);\n```\n\n### 5. 发起方发送 offer SDP\n\n了解对方地址之后，发起方就可以发送 SDP 来建立会话了。\n\n```ts\nconst createOffer = useCallback(async () => {\n  const offer = await connection.createOffer();\n  await connection.setLocalDescription(offer);\n\n  const db = await firebase.firestore();\n  const offer = await db.collection(\"offer\");\n  offer.add({ type: offer.type, sdp: offer.sdp });\n\n  return offer;\n}, [connection]);\n```\n\n### 6. 接收方收到 offer，并返回 answer SDP\n\n接收方通过轮询服务器得到 offer，为连接添加远端会话描述，生成自己的会话描述（answer SDP），并存储到服务器，注意，这些步骤是不能更换的。\n\n```ts\nconst db = await firebase.firestore();\nconst offerRef = await db.collection(\"offer\");\nconst answerRef = await db.collection(\"answer\");\n\nofferRef.onSnapshot((snapshot) => {\n  snapshot.docChanges().forEach(async (change) => {\n    if (change.type === \"added\") {\n      const offer = change.doc.data();\n      await connection.setRemoteDescription(offer); // 设置远端会话描述\n      const answer = await conn.createAnswer(); // 生成本地会话描述\n      await conn.setLocalDescription(answer); // 设置本地会话描述\n      await answerRef.add(answer); // 存储本地会话到云端\n    }\n  });\n});\n```\n\n### 7. 发起方收到 answer，会话建立\n\n和接收方类似，发送方也需要从服务器收到会话的应答，设置好远端会话描述后，会话开始。\n\n```ts\nconst db = await firebase.firestore();\nconst answerRef = await db.collection(\"answer\");\n\nanswerRef.onSnapshot((snapshot) => {\n  snapshot.docChanges().forEach(async (change) => {\n    if (change.type === \"added\") {\n      const answer = change.doc.data();\n      await connection.setRemoteDescription(answer); // 设置远端会话描述\n    }\n  });\n});\n```\n\n### 8. 收到远端媒体流\n\n通过监听 track 事件，就可以获取远端媒体流了。注意，track 事件返回的是多个媒体流（因为 RTCPeerConnection 的`addTrack`可以使用多个媒体流），每个媒体流包括音轨和画轨。\n\n```ts\nconst video = useRef<HTMLVideoElement>(null);\n\nuseEffect(() => {\n  connection.addEventListener(\"track\", ({ streams: [remoteStream] }) => {\n    const stream = new MediaStream();\n    remoteStream.getTracks().forEach((t) => stream.addTrack(t));\n    video.current && video.current.srcObj = stream; // 设置HTML元素使用远端媒体流\n  });\n}, [connection]);\n```\n\n### 9. 会话结束\n\n停止一个媒体流，要关闭它的轨道。\n\n```ts\nstream.getTracks().forEach((t) => t.stop());\n```\n\n关闭连接则需要调用`close`函数。\n\n```ts\nawait connection.close();\n```\n\n## 传输文字信息\n\nRTCPeerConnection 不仅仅可以传输媒体流，使用[RTCDataChannel](https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Simple_RTCDataChannel_sample)可以传递文字信息。\n\n每一个 RTCPeerConnection 建立之后会有一个\"datachannel\"事件，这个事件会返回一个 chennel 对象，用来接收发送方传来的数据。\n\n```ts\nconnection.addEventListener(\"datachannel\", ({ channel }) => {\n  channel.addEventListener(\"open\", () => {\n    console.log(\"[P2P receiver] open\");\n  });\n  channel.addEventListener(\"message\", ({ data }) => {\n    console.error(\"[P2P receiver] message\", data);\n  });\n  channel.addEventListener(\"close\", () => {\n    console.log(\"[P2P receiver] closed\");\n  });\n});\n```\n\n在发起端创建一个 datachannel 向远端发送数据了。\n\n```ts\nconst sender = connection.createDataChannel(\"xxx\");\n// ... 发送信息必须在sender收到open事件后\nsender.send(\"hello\"); // 向接收端发送\"hello\"字符串\n```\n\n## 附录\n\n### 实现多端链接\n\n目前为止，RTCPeerConnection 只能做一对一连接。不过，要想实现多端连接，可以创建多个 RTCPeerConnection。那么一个浏览器最多能使用多少个 RTCPeerConnection 呢？根据[这篇文章](https://bloggeek.me/webrtc-rtcpeerconnection-one-per-stream/)，显然这个问题比较复杂，这个文章里面提过大概是 200 个，但由于网络等原因，可能并不能顺利建立这么多连接。\n\n### 调试方法\n\n我不太清楚出了什么状况，我的 demo 只能在火狐里面跑起来，但是调试起来类似，可以参考[这篇](https://testrtc.com/webrtc-internals-parameters/)。\n\n### PWA 里面能用 P2P 吗\n\n既然 DataChannel 能够实现端对端传输文字信息，那么结合 ServiceWorker 我们是不是可以创建一个完全去中心化的网页呢？答案是目前不可以，但是方案已经写进 webtorrent，具体内容可以在[此链接](https://github.com/webtorrent/webtorrent/issues/1721)跟进。\n\n### CodeSandbox 的使用体验\n\nCodeSandbox 可以理解为一个线上 Web 前端开发编辑器。\n\n因为现在是五月末六月初，在大陆依赖于 npm 的开发到了无比艰难的一段时间，导致我开始不得不考虑在[CodeSandbox](https://codesandbox.io/)进行开发。开发体验还是很可观的，虽然写代码会出现不跟手的情况，偶尔代码会出现因为远端没同步导致丢失（好在可以通过 github 同步）。\n\n我推荐以下情况可以考虑使用 codeSandbox：\n\n- 一个全新的项目\n- 项目比较简单，浏览器不至于卡死\n","collection":"blog","data":{"type":"post","category":"fe","tag":["webRTC","p2p","codesandbox","firebase"]}},{"id":"2020/06/14/ml5.js-tensorflow.js.md","slug":"2020/06/14/ml5js-tensorflowjs","body":"\n# ml5.js 和 tensorflow.js，终于聊到前端部分了\n\n既然在浏览器中也可以计算多维数组，拿浏览器做深度学习也可以理解了。Google 给浏览器中设计了 [tensorflow.js](https://www.tensorflow.org/js)，跟 python 下面的 tensorflow 是同一套 API。又有一群人在 tensorflow 的基础上封装了一套[ml5.js](https://ml5js.org/)。对比 tensorflow.js，ml5.js 去掉了很多张量计算的部分（说实话，这些东西真不是人学的，我这一周都在研究这些计算...）。所以本文会以 ml5.js 开始。\n\n## ml5.js\n\n这是[Daniel Shiffman](http://www.shiffman.net/)主导的 JS 深度学习库，我特喜欢看他的视频睡觉。这个库的[使用教程](https://learn.ml5js.org/docs/#/reference/index)不能更详细了！\n\n官网的简介，是使用 MobileNet 了`imageClassifier`，这是我的[笔记](https://observablehq.com/@gongbaodd/untitled)，可以用来判断图片、视频中的物体是什么。\n\n另外也可以使用`neuralNetwork`，这是[笔记](https://observablehq.com/@gongbaodd/ml5-js-neural-network)，基本上前面两篇关于 tensorflow 的文章都可以使用它来跑。\n\n使用 ML5.js 很大的简化了 tensorflow 的 API，然而并不是你可以不了解 tensorflow，因为期间会有很多参数难以理解，又不得不回头看它。\n\n## tensorflow.js\n\n基本上会了 python 版本，js 版本就算是个子集了，基本上很多需要的包都有替代。[这里](https://www.tensorflow.org/js/guide/layers_for_keras_users?hl=zh-cn)是一个给 keras 用户使用的 tensorflow.js 指南。另外去强烈建议看看[tensorflow.js 指南](https://www.tensorflow.org/js/guide?hl=zh-cn)。\n\n- `tf.layers` => Keras\n- `@tensorflow/tfjs-vis`原生支持 tensorflow 的数据可视化库（那敢情好啊）\n","collection":"blog","data":{"type":"post","category":"fe","tag":["tensorflow","keras","wsl2","python"],"series":{"slug":"learn-tensorflow","name":"张量麻辣烫"}}},{"id":"2020/07/17/20.md","slug":"2020/07/17/20","body":"\n# 20 年代初的小程序开发浅谈\n\n貌似有两周没怎么更新博客了哈，因为这几天白天就是冲浪游泳晒太阳，晚上就是写代码（啊~惬意），写了一个踏浪 App，用来查看大陆东南沿岸的冲浪浪点情况。\n\n![踏浪小程序码](./2020-07-17.jpg)\n\n## 为什么选择小程序\n\n就国内来说，如果是放到 web 这个纯开放平台上，就是 SEO 做得再好，也要被埋到广告里面；放到酷安和苹果商店...开发者要交钱的...我为爱发电还没这么强。反倒放到小程序里，因为大陆微信普及率很高，基本上说一句「你要是想看看浪情，去微信搜一下踏浪 App」就好了，再一个，微信小程序的云函数也提供了类似于 Google firebase 的前后台 sdk，也不用担心搭建服务器什么的了（毕竟我在旅游，运维的事情还是不想做）。\n\n## 包管理的尴尬\n\n小程序其实就是个优化了的浏览器，但是开发的时候不能搞到浏览器实例（window），这导致大部分 NPM 库里的 JS 都不能不加修改地在小程序中运行（哪怕是 lodash 这样的基础库），甚至是 D3 都跑！不！了！\n\n应该有很多库已经提供解决方案了，毕竟就是个编译就能解决掉的问题，可是像包管理这种东西，小程序上了这么年，一直都很烂，可见它是多不挣钱。\n\n## 云函数\n\n小程序的云函数只能在小程序编辑器里面开发，哪怕是到了腾讯云后台都看不到，这个不知道是不是鹅厂内部的问题。\n\n## SVG\n\n小程序 CSS 中支持 SVG。这点可以有，好多图我都是 figma 里面妥妥拽拽导出 SVG。但是在 Vdom 中直接插入 SVG 还是不行。\n\n## WSL\n\n另外，在 Windows 下面开发小程序是无法使用 WSL 环境的，哪怕是映射过去的文件地址也不行，但是可以把项目放在 Windows 的目录下如`/mnt/c/minprogram`开发。\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2020/07/24/2D-svg-3D.md","slug":"2020/07/24/2d-svg-3d","body":"\n# 快速把 2D 的 svg 生成为 3D\n\n[vectary](www.vectary.com)可以把 2D 的 SVG 渲染成 3D，但是免费版导出的图片是有水印的，导出模型的功能也是收费的（但是我发现可以从 network 中扒`*.obj`文件，是，我知道这很 low🤣）\n","collection":"blog","data":{"type":"post","category":"fe","tag":["svg"],"series":{"slug":"tools","name":"利器"}}},{"id":"2021/01/07/ReactNative-script.md","slug":"2021/01/07/reactnative-script","body":"\n# ReactNative 调试时提示找不到 script\n\n执行以下命令\n\n```\nreact-native bundle --platform android --dev false --entry-file index.js --bundle-output android/app/src/main/assets/index.android.bundle --assets-dest android/app/src/main/res\n```\n\n另外，如果不成功，可以尝试重新安装 react-native-cli 并重复上面命令。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["react-native"]}},{"id":"2023/05/18/ngrok-reverse-proxy-service.md","slug":"2023/05/18/ngrok-reverse-proxy-service","body":"# ngrok: A Reverse Proxy Service\n\nSometimes we need a HTTPs server to develop a web app, surely using mkcert can generate a local certificate. But by using `vite-plugin-mkcert`, I found the server is too easy to breakdown. So I decided to use [ngrok](https://ngrok.com/product) to build a reverse proxy service.\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2023/05/26/tRPC.md","slug":"2023/05/26/trpc","body":"# using tRPC\n\n[tRPC](https://trpc.io/) is a RPC framework for TypeScript. A lot people compare it with graphql. After using it, I found out that they are not the same thing. GraphQL is more like Restful API. tRPC is a package to build Restful API with TypeScript.\n\nI suddenly realized that I can use GraphQL in cloud functions. Compared with Restful API, GraphQL can do many work with only one endpoint.\n","collection":"blog","data":{"type":"post","category":"fe"}}]}