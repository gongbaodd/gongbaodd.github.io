{"posts":[{"id":"2020/04/21/threejs-mesh.md","slug":"2020/04/21/threejs-mesh","body":"\n# threejs 细化-创建一个 mesh、使用加载器、多个场景\n\n记录下最近几天的事，终于 Dell 的维修把我电脑的风扇修好了，不过感觉 inspiron 的风扇设计有 bug，新风扇估计也撑不了多久，但愿只是我多疑了。另外通过神奇的某宝，我将我手上的小米平板二升级了内存和硬盘，考虑到 8GB 内存对于 Atom Z8500 这个 CPU 有点多余，于是升级到了 4GB + 128GB，到手之后果然比 2GB 流畅（当然肯定没法比酷睿了），所以这个配置还是比较推荐的。\n\n回到主题，最近一周我都在使用 react-three-fiber 来学习 threejs，这里会做一个系列来详细整理一下。\n\n## 创建一个 mesh\n\n可以使用 JSX 创建 mesh, 因为 mesh 有 material 和 geometry 两个访问器，在 JSX 中可以作为属性使用。\n\n```JavaScript\nexport default () => (\n    <Canvas>\n        <mesh\n            name=\"mesh\"\n            material={new MeshBasicMaterial()}\n            geometry={new BoxBufferGeometry(1, 1, 1)}\n        />\n    </Canvas>\n);\n```\n\n当然作为参数也可以。\n\n```JavaScript\nexport default () => (\n    <Canvas>\n        <mesh arg={[new BoxBufferGeometry(1, 1, 1), new MeshBasicMaterial()]}/>\n    </Canvas>\n);\n```\n\n官网还提供了一个绝妙的方法。\n\n```JavaScript\n// 实现不了，不知道咋回事儿\nexport default () => (\n    <Canvas>\n        <mesh>\n            <boxBufferGeometry attach=\"geometry\" />\n            <meshBasicMaterial attach=\"material\" />\n        </mesh>\n    </Canvas>\n);\n```\n\n另外因为 Canvas 里面的元素和 JSX 的绑定使用的是 memo，所以如果使用 primitive 定义元素的时候会丢。\n\n```JavaScript\n// 这么做虽然会渲染出来，但是Box有的时候会丢\nconst Box = new Mesh(\n    new BoxBufferGeometry(1, 1, 1),\n    new MeshBasicMaterial(),\n);\n\nexport default () => (\n    <Canvas>\n        <primitive object={Box} />\n    </Canvas>\n);\n```\n\n## 加载器\n\n加载 texture 时，可以使用`useEffect`自己写，当然也有更优雅的方法，利用 react 自己的`useMemo`或者`useCallback`，再就是使用 react three fiber 的`useLoader`。\n\n```JavaScript\n// 使用 useMemo\nconst Plane = () => {\n    const texture = useMemo(() => new TextureLoader().load(\"xxx.jpg\"), [])\n    return <mesh\n        material={new MeshBasicMaterial({map: texture})}\n        geometry={new PlaneGeometry(1, 1)}\n    />\n}\n```\n\n```JavaScript\n// 使用 useLoader\nconst PlaneAsync = () => {\n    const [texture] = useLoader(TextureLoader, \"xxx.jpg\");\n\n    return <mesh\n        material={new MeshBasicMaterial({map: texture})}\n        geometry={new PlaneGeometry(1, 1)}\n    />\n}\n\nconst Plane = () => (\n        <Suspense fallback={<mesh />}>\n            <PlaneAsync />\n        </Suspense>\n    )\n```\n\n## 使用多个场景\n\nthree react fiber 会默认给一个场景(scene)、一个摄像头(camera)还有一个渲染器(render)。可是如果我需要多个场景，比如建模工具往往会给一个正交视图以及正视图，这种情况就需要多个场景。\n\n首先要使用`setDefaultCamera`将新建的摄像头代替默认摄像头。\n\n```TypeScript\nexport default () => {\n    const { setDefaultCamera } = useThree();\n    const camera = useRef<PerspectiveCamera>();\n\n    useLayoutEffect(() => camera.current && setDefaultCamera(camera.current), [])\n\n    return <perspectiveCamera\n      name=\"camera\"\n      ref={camera}\n    />\n}\n```\n\n接下来是创建场景，场景不需要代替原有场景，但是需要使用`useFrame`修改`render`方法。\n\n```TypeScript\n// 再原画面的左上角绘制场景\nexport default () => {\n    const scene = useRef<Scene>();\n    const {\n        size: {left, top, width, height},\n        camera,\n    } = useThree();\n\n    useFrame(({ gl }) => {\n        gl.autoClear = true;\n        gl.setScissor(left, top, width / 2, height / 2);\n        gl.setViewport(left, top, width / 2, height / 2);\n\n        scene.current && gl.render(scene, camera)\n    }, 10);\n\n    return (\n        <scene ref={scene}>\n            <mesh />\n        </scene>\n    );\n}\n```\n\n这里`useFrame`的第二个参数表示它的优先级，值越高，越先渲染，这意味着比它优先级低的场景渲染之前要把`gl.autoClear`设置为`false`，以避免被清除。\n\n## 其它\n\n另外可以看看京东的一篇博客[凹凸实验室](https://aotu.io/notes/2018/10/18/cannonjs/index.html)。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["threejs","JavaScript","webGL"],"series":{"slug":"threejs-howto","name":"细品threejs"}}},{"id":"2020/04/27/threejs.md","slug":"2020/04/27/threejs","body":"\n# threejs 细化-在网格上渲染，停止渲染，使用物理引擎\n\n这是细化了解 threejs 的第二篇，[第一篇](/fe/2020/04/21/threejs细化-创建一个mesh、使用加载器、多个场景.html)\n\n## 在网格上渲染\n\n这里有一点类似于使用多个场景，设想如果想要做一个类似于水晶球的设计，水晶球有一个 scene1，水晶球自己又在另一个 scene0 里面，这里就需要使用 renderTarget 渲染 scene1 到水晶球上面。\n\n先创建一个 target。\n\n```typescript\nconst target = new WebGLRenderTarget(width, height);\n```\n\n再创建一个球，并使用 target 作为材料。\n\n```tsx\nconst ball = () => {\n  return (\n    <mesh name=\"ball\">\n      <sphereBufferGeometry attach=\"geometry\" args={[1, 32, 16]} />\n      <meshPhongMaterial attach=\"material\" map={target.texture} />\n    </mesh>\n  );\n};\n```\n\n然后创建 scene1。\n\n```ts\nconst scene1 = new Scene();\nconst camera = new PerspectiveCamera(75, 1, 0.1, 5, position: [0, 1, 2]);\n\n{\n  const light = new HemisphereLight();\n  scene1.add(light);\n}\n\n{\n  const mesh = new Mesh(\n    new BoxBufferGeometry(1, 1, 1),\n    new MeshPhongMaterial({ color: 0x8844aa }),\n  );\n  scene1.add(mesh);\n}\n```\n\n貌似 react-three-fiber 的 render 函数也可以把 JSX 渲染成 scene。但是使用的时候告诉我需要创建 context，难道是要用 React.createContext? 感觉坑很多，所以暂时没有尝试，以后再补充这里。\n\n```tsx\nconst scene = new Scene();\nconst context = createContext();\n\nrender(\n  <>\n    <perspectiveCamera />\n    <hemishpereLight />\n    <mesh>\n      <boxBufferGeometry args={[1, 1, 1]} attach=\"geometry\" />\n      <meshPhongMaterial color={0x8844aa} attach=\"material\" />\n    </mesh>\n  </>,\n  scene,\n  context\n);\n```\n\n好了，回到正题，现在需要在 target 上面渲染 scene1.\n\n```ts\nuseFrame(({ gl }) => {\n  gl.setRenderTarget(target);\n  gl.render(scene1, camera); // 这里的camera是scene1里面的camera\n  gl.setRenderTarget(null);\n});\n```\n\n和渲染两个 scene 一样，不管打算渲染几个场景，实际的渲染器只有一个，所以渲染好 target 后还要把要渲染的目标换回来。\n\n## 停止渲染\n\nreact-three-fiber 默认会一直渲染每一帧，而在网页上，我们往往不需要它一直耗费 GPU 时间，比如渲染好的动画，只需要它在特殊时间才运动，react-three-fiber 有一个 invalidateFrameloop 选项可以暂停渲染。\n\n```tsx\n<Canvas invalidateFrameloop />\n```\n\n另外`useThree().invalidate`也可以暂停渲染，但这个不太稳定，不确定是不是我的问题。\n\n比如加载进来一个模型，想让它动画结束后就停止 GPU 渲染。\n\n```tsx\nconst animate = useMemo(() => new AnimationMixer(obj));\nconst action = useMemo(() => {\n  const act = animate.clipAction(obj.animations[0]);\n  act.setLoop(LoopOnce, 1);\n  act.enabled = true;\n  act.clampedWhenFinished = true;\n  act.play();\n  return act;\n}, []);\n\nconst { invalidate } = useThree();\n\nuseFrame((_, delta) => {\n  animate.update(delta);\n  if (!act.isRunning()) {\n    invalidate();\n  }\n});\n```\n\n## 使用物理引擎\n\n物理引擎是使用 webGL 最爽的部分，主要是不用考虑那些公式，这里用`Cannon.js`打个比方，（感动常在）。\n\n首先创建世界，比如创建一个 z 轴加速度为 9.82 的世界，还需要 NaiveBroadphase 做碰撞检测。\n\n```ts\nconst world = new World();\nworld.gravity.set(0, 0, -9.82);\nworld.broadphase = new NaiveBroadphase();\n```\n\n接下来创建一个物体，包括它的形状（shape）和在世界中的细节参数（body）。\n\n```ts\nconst shape = new Sphere(1);\nconst body = new Body({ mass: 5, shape });\nworld.add(body);\n```\n\n接下来设置渲染的时间间隔。\n\n```ts\nuseFrame(() => world.step(1 / 60)); // 单位秒\n```\n\n好了，那么怎么和 react-three-fiber 玩耍呢？其实可以写一个[useCannon](https://github.com/gongbaodd/webgl_demos/blob/dev/hooks/useCannon.tsx)。\n\n但是考虑到有现成的 hooks，自己就不用写轮子了，[react-spring/use-cannon](https://github.com/react-spring/use-cannon)，他是用 web worker 跑的，性能肯定更好，直接看例子好了，白嫖真爽。\n\n```jsx\nimport { Canvas } from \"react-three-fiber\";\nimport { Physics, usePlane, useBox } from \"use-cannon\";\n\nfunction Plane(props) {\n  const [ref] = usePlane(() => ({ rotation: [-Math.PI / 2, 0, 0], ...props }));\n  return (\n    <mesh ref={ref}>\n      <planeBufferGeometry attach=\"geometry\" args={[100, 100]} />\n    </mesh>\n  );\n}\n\nfunction Cube(props) {\n  const [ref] = useBox(() => ({ mass: 1, position: [0, 5, 0], ...props }));\n  return (\n    <mesh ref={ref}>\n      <boxBufferGeometry attach=\"geometry\" />\n    </mesh>\n  );\n}\n\nReactDOM.render(\n  <Canvas>\n    <Physics>\n      <Plane />\n      <Cube />\n    </Physics>\n  </Canvas>,\n  document.getElementById(\"root\")\n);\n```\n","collection":"blog","data":{"type":"post","category":"fe","tag":["threejs","webgl"],"series":{"slug":"threejs-howto","name":"细品threejs"}}}]}