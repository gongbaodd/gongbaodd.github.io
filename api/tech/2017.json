{"posts":[{"id":"2017/01/09/PyQt.md","slug":"2017/01/09/pyqt","body":"\n前端做得久了，我的工程根目录下面就会多一个bash脚本，把每一个项目的启动脚本放在里面然后注释掉。这样做的好处是如果要启动一个项目的时候只需要运行脚本就好了。\n\n可是问题随之出现了，项目越来越多，然后那个脚本就变成了下面这样。\n\n![脚本库](http://ww4.sinaimg.cn/mw690/89d0a2e1gw1fbkbh1idg9j20gi046q4s.jpg)\n\n因为用的都是fekit，所以各个工程就mock数据不一样。不久我发现一个问题，工作一天，老眼昏花之后，要想在项目之间切换，就是每次要数出第几行，把它解注释，那简直是件恐怖的事情。\n\n于是我便希望有一个图形化的界面，能实时显示我目前处于什么环境，并且能够切环境（因为是触摸屏，所以图形化界面效率很高😏,同时因为我经常在archLinux和Mac下面切换，所以我对跨平台要求很高）。\n\n# 需求\n\n1. 图形化的界面，能够显示现在mock的是哪个项目。\n2. 兼容ArchLinux(Gnome)和OSX。\n3. 开发时间越短越好（根本没时间在工具上下功夫😢）。\n4. 不要影响到我现有的开发习惯（生成的shell脚本格式不能变）。\n\n# 分析\n\n额，好吧，其实electron也行，可是宝宝就是觉得pyQt好久不用了，就是想用用。\n\n# 编写\n\n文件读写\n\n```python\nimport sys\nimport os\nimport re\n\nQMB_FILE_PATH = os.path.split(os.path.realpath(__file__))[0] + '/qmbrun.sh'# 我那个shell脚本叫qmbrun.sh\nRUN_BASH_PREFIX = '#!/bin/bash\\n'\nFEKIT_SERVER = 'fekit server'\nHASH_CHAR = '#'\nPRD_REG = r'.*-m\\s(.*)/.*'\n\ndef readFile():\n    commands = {}\n    file = open(QMB_FILE_PATH)\n    line = file.readline()\n    while line:\n        if line.find(FEKIT_SERVER) > -1:\n            command = line.replace(HASH_CHAR,'')\n            match = re.match(PRD_REG, command)\n            if match: \n                product = match.groups()[0]\n            if product:\n                commands[product] = {\n                    'selected': line.find(HASH_CHAR) < 0,\n                    'command': command\n                }\n        line = file.readline()\n    file.close()\n    return commands\n\ndef writeFile(str):\n    file = open(QMB_FILE_PATH,'w')\n    file.write(RUN_BASH_PREFIX + str)\n    file.close()\n```\n\n对话框\n\n```python\nfrom PyQt5.QtWidgets import *\n\nclass QMBedit(QDialog):\n    def __init__(self, parent = None):\n        super(QMBedit, self).__init__(parent)\n\n        self.btns = []\n        self.commands = readFile()\n        \n        self.setWindowTitle('QMBedit')\n        layout = QVBoxLayout()\n\n        for cmd in self.commands.keys():\n            btn = QRadioButton(cmd)\n            btn.setChecked(self.commands[cmd]['selected'])\n            btn.clicked.connect(self.btn_clicked)\n            self.btns.append(btn)\n            layout.addWidget(btn)\n\n        self.setLayout(layout)\n    \n    def btn_clicked(self): \n        for btn in self.btns:\n            self.commands[btn.text()]['selected'] = btn.isChecked()\n        self.map2str()\n    \n    def map2str(self):\n        str = ''\n        for cmd in self.commands.keys():\n            if self.commands[cmd]['selected']:\n                str += self.commands[cmd]['command']\n            else:\n                str += HASH_CHAR + self.commands[cmd]['command']\n        writeFile(str)\n```\n\n# 运行\n\n![运行结果](http://ww1.sinaimg.cn/mw690/89d0a2e1gw1fbkbh2aju0j205s04xwex.jpg)\n\nOK，用起来不错，拯救了老眼昏花的我。话说本文是本年度第一文啊！其实我挺用心的，写文章的时间远远超过了写这段代码的时间。。。真的😂。\n\nPS：话说emojipedia真的很好用，可以考虑给vcode开发个插件🤔。","collection":"blog","data":{"type":"post","category":"tech"}},{"id":"2017/01/17/VScode-Python-python3.6.md","slug":"2017/01/17/vscode-python-python36","body":"\n本来想写一篇pyqt+qml的文章，结果今天打开VScode发现Python不语法提示了。打开开发者模式，发现一直在报错，gramar3.6 not found。\n\n打开```~/.vscode/extensions/donjayamanne.python-0.5.5/pythonFiles/preview/jedi/parser```找到里面的```grammar3.5.txt```复制为```grammar3.6.txt```\n\n重启VScode就好了。","collection":"blog","data":{"type":"post","category":"tech"}},{"id":"2017/01/18/PyQt-QML.md","slug":"2017/01/18/pyqt-qml","body":"\n> 翻了翻以前保存的书签，发现了一个pyQt和QML的开发总结，代码跑起来还是有点错误，但是还是比官网的tutorial更简单直观一点。还能从里面找一点hybrid开发的idea（因为QML其实也是一种ECMAScript引擎实现）。\n\n# 在QML上下文插入变量\n\n在```view.setSource```之前将变量插入上下文之中。\n\n```python\nfrom PyQt4.QtDeclarative import QDeclarativeView\nfrom PyQt4.QtGui import QApplication\nfrom PyQt4.QtCore import QUrl\n\napp = QApplication([])\n\nview = QDeclarativeView()\n\nrootCtx = view.rootContext()\nrootCtx.setContextProperty(\"textData\", \"hi\")\n\nview.setSource(QUrl('ctxProp.qml'))\nview.show()\n\napp.exec_()\n```\n\n```qml\nimport Qt 4.7\n\nRectangle {\n    id: test\n\n    width: 1000; height: 300\n\n    Text {\n        \n        anchors.fill: parent;\n        text: textData\n    }\n}\n```\n\n# PyQt修改QML中变量\n\n这样可以先加载qml再修改内部的值，注意```property```后面是有类型的。\n\n```python\nfrom PyQt4.QtDeclarative import QDeclarativeView\nfrom PyQt4.QtGui import QApplication\nfrom PyQt4.QtCore import QUrl\n\napp = QApplication([])\n\nview = QDeclarativeView()\nview.setSource(QUrl('./ownProp.qml'))\n\nrootObj = view.rootObject()\nrootObj.setProperty(\"textData\", 'hi')\n\nview.show()\napp.exec_()\n```\n\n```qml\nimport Qt 4.7\n\nRectangle {\n    width: 1000\n    height: 300\n    id: test\n    \n    property string textData;\n\n    Text {\n        \n        anchors.fill: parent;\n        text: textData;\n    }\n    \n}\n```\n\n# 消息传递\n\nQT最主要的就是它的信号槽机制，对我的影响也很很大，以至于我现在的组件开发也在用这一套思维。那么QT怎么和QML内部进行消息传递呢？\n\n```python\nfrom PyQt4.QtDeclarative import QDeclarativeView\nfrom PyQt4.QtGui import QApplication\nfrom PyQt4.QtCore import QUrl\n\napp = QApplication([])\n\nview = QDeclarativeView()\nview.setSource(QUrl('./signal.qml'))\n\ndef on_click():\n    print(\"hi\")\n\nrootQbj = view.rootObject()\nrootQbj.mclicked.connect(on_click)\nrootQbj.setProperty('name','hello')\nview.show()\napp.exec_()\n```\n\n```qml\nimport Qt 4.7\n\nRectangle {\n    width: 1000\n    height: 300\n    id: test;\n    signal mclicked;\n    property string name;\n    \n\n    Text {\n        anchors.fill: parent;\n        text: name\n    }\n\n    MouseArea {        \n        anchors.fill: parent\n\n        onClicked: {\n            mclicked();\n        }\n    }\n    \n}\n\n```\n\n# 调用QML内部函数\n\n```python\nfrom PyQt4.QtDeclarative import QDeclarativeView\nfrom PyQt4.QtGui import QApplication\nfrom PyQt4.QtCore import QUrl\n\napp = QApplication([])\n\nview = QDeclarativeView()\nview.setSource(QUrl('./interface.qml'))\n\ndef on_click():\n    rootObject.set_text('Clicked')\n\nrootObject = view.rootObject()\nrootObject.mclicked.connect(on_click)\n\nview.show()\napp.exec_()\n```\n\n```qml\nimport Qt 4.7\n\nRectangle {\n    width: 1000\n    height: 300\n    color: \"transparent\"\n    id: test\n    signal mclicked\n    Text {\n        id: testText\n        \n        anchors.fill: parent\n        \n        text: \"Click Me\"\n    }\n    MouseArea {\n        anchors.fill: parent\n        onClicked: {\n            mclicked();\n        }\n    }\n    function set_text(text) {\n        testText.text = text\n    }   \n}\n```\n\n就酱，后面再写一篇QML调用js的文章吧🤔。","collection":"blog","data":{"type":"post","category":"tech"}},{"id":"2017/02/03/node-302.md","slug":"2017/02/03/node-302","body":"\n```javascript\nvar http = require(\"http\");\n\nvar server = http.createServer(function(req, res) {\n    var clientIP = req.headers['x-forwarded-for'] ||\n                   req.connection.remoteAddress ||\n                   req.socket.remoteAddress ||\n                   req.connection.socket.remoteAddress,\n        ServerDate = new Date();\n    console.log('['+ ServerDate +']' + clientIP);\n    res.writeHead( 302, { 'Location': 'http://www.baidu.com/' });\n    res.end();\n});\n\nserver.listen(80);\n```\n\n然后将脚本作为守护进程启动\n\n```bash\nnohup node app.js > app.log &\n```","collection":"blog","data":{"type":"post","category":"tech"}},{"id":"2017/02/10/AP.md","slug":"2017/02/10/ap","body":"","collection":"blog","data":{"type":"post","category":"tech"}},{"id":"2017/05/14/nas.md","slug":"2017/05/14/nas","body":"\n# 树莓派搭建 NAS\n\n好忙啊，写个大纲好了\n\n## 安装 RPI-Monitor\n\n## 安装吸血迅雷\n\n## Samba 共享文件\n\n## ssh 端口映射\n","collection":"blog","data":{"type":"post","category":"tech"}},{"id":"2017/05/28/Second-screen.md","slug":"2017/05/28/second-screen","body":"# 第二块屏幕\n\n作为一个前端程序员，13寸的屏幕显然不够工作，尤其是当你写代码的时候还想看美剧的时候。\n\n我有一个屏幕，15寸的联想800x600 VGA屏幕，以前为了玩树莓派在旧货市场淘来的，分辨率实在太低了。如果连我家的投影的话，为了使用自由，我只会使用无线连接，但是linux下面还没有一个完备的无线连接方案。\n\n## 拆掉我的旧电脑\n\n年前我提到过，我把我的老电脑拆了，硬盘用来接树莓派，当然我也把屏幕拆过来了。我在淘宝上搜了一下五合一屏幕驱动板，加上电源大概100块搞定，卖家比较热心，问好型号之后整块驱动板基本上是连接好就寄过来了。\n\n## 做一个比较好的壳\n\n基本上只能拿垃圾做一个壳了，在北京的家里面，没有螺丝，所以我只能把驱动板缝在巧克力盒包装上。大概如图（如果我传图了）。\n\n## linux处理第二块屏幕\n\n其实连接好屏幕就可以玩了，但是由于我的笔记本是4K的，老屏幕虽然是14寸，但其实只能显示我现在笔记本的1/4.需要xrandr处理缩放。\n\n    xrandr --output eDP1 --auto --scale 1x1 --output DP1 --auto --scale 1.8x1.8 --right-of eDP1\n\n> 为什么不是 2x2 ? 其实我尝试过，可是很快就能挂掉，所以我改成 1.8x1.8 \n\n还有一个bug，屏幕虽然能够显示了，但鼠标能够控制的地方还是1/4。ArchWiki里面说是一个bug，看了一下。貌似还没解决。。。\n\n好吧，最后我选择了妥协，毕竟已经可以美美哒地看美剧了～\n\n---\n\n<p style=\"float:right;\">\n宫不上，2017/05/28【端午节】，在北京9㎡的家中。\n</p>\n","collection":"blog","data":{"type":"post","category":"tech"}},{"id":"2017/05/30/sad-WPS4linux.md","slug":"2017/05/30/sad-wps4linux","body":"# sad,WPS4Linux停止开发\n\n默哀三分钟","collection":"blog","data":{"type":"post","category":"tech"}},{"id":"2017/06/03/sinopia-NPM.md","slug":"2017/06/03/sinopia-npm","body":"# sinopia搭建你的私人NPM\n\n今天本来想边刷CodeWars边看《纸牌屋》的，显然两件烧脑的事情还是不要放到一起做比较好。\n\n简评一下《纸牌屋》第五季，编剧能写五季不错了，赶紧完结吧，剧情开始走下坡路咯。\n\n## 进入正题\n\n为什么要搭建私人NPM？我靠，这还用问。。。（你自己猜吧）\n\n    npm install -g sinopia\n\n安装好sinopia之后，执行sinopia就好了，默认端口4873，只能本地访问。\n\n## 配置\n\n往往我会新建一个用户\n\n    useradd -G users sinopia -d\n\n然后用户这个用户执行sinopia，sinopia执行的根目录需要三个文件，config.yaml，storage，htpasswd\n\n只配置config.yaml就好了，示例在https://github.com/rlidwka/sinopia/tree/master/conf\n\n## 执行\n\n用PM2执行，默认sinopia会在执行目录寻找config。本地访问成功后大工造成。\n\n***注意***\n\n1. 因为我用的是Linux，自从安装了node8+npm5之后，可能涉及到Darwin的包会报警，不过忽略就好。\n\n2. 注册的时候报错crypt3找不到，貌似安装的时候gyp出错被忽略掉了，我到sinopia目录里重装了crypt3解决。","collection":"blog","data":{"type":"post","category":"tech"}},{"id":"2017/07/14/egg-ts.md","slug":"2017/07/14/egg-ts","body":"# 起因\n\n今年我开始在生产环境里试用node（貌似比很多人慢了一年......）。\n由于公司node环境较低，我只能使用一款修改过的express，\n为了解决兼容问题我还用typescript进行编译（事实证明typescript简直awesome）。\n\n随着公司更新了新版的node（也不高，6.1.2）。我也有了更多选择，\n有一天我在cnode上面看到了egg的发布，打算自己试一下。\n\n## 废话少说，从快速入门开始\n\negg有一个详细的快速入门[https://eggjs.org/zh-cn/intro/quickstart.html]()，\n但是时间紧张，我直接用脚手架建项目了。\n\n    egg-init egg-example --type=simple\n\n## 目录结构\n\n我曾一度认为一个较好的框架其实不需要什么目录结构，自打我和其他人合作之后我就彻底打消这个念头了。\n\n```shell\negg-project\n├── tsconfig.json\n├── package.json\n├── app.js (可选)\n├── agent.js (可选)\n├── ts\n|   ├── router.ts\n│   ├── controller\n│   |   └── home.ts\n│   ├── service (可选)\n│   |   └── user.ts\n│   ├── middleware (可选)\n│   |   └── response_time.ts\n│   ├── schedule (可选)\n│   |   └── my_task.ts\n│   ├── public (可选)\n│   |   └── reset.css\n│   └── extend (可选)\n│       ├── helper.ts (可选)\n│       ├── request.ts (可选)\n│       ├── response.ts (可选)\n│       ├── context.ts (可选)\n│       ├── application.ts (可选)\n│       └── agent.ts (可选)\n├── config\n|   ├── plugin.js\n|   ├── config.default.js\n│   ├── config.prod.js\n|   ├── config.test.js (可选)\n|   ├── config.local.js (可选)\n|   └── config.unittest.js (可选)\n└── test\n    ├── middleware\n    |   └── response_time.test.js\n    └── controller\n        └── home.test.js\n```\n\n删了项目里的app文件夹，并把app文件夹加到.gitignore里面。\n修改tsconfig.json，css可以用别的工具解决，不在本次话题里面。\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2016\",\n    \"module\": \"commonjs\",\n    \"outDir\": \"./app\",\n    \"rootDir\": \"./src\"\n  }\n}\n```\n\n另外，我把view文件夹给删掉了，理由是我一直比较推崇前后端同构，所以既然有view层，前后端的模板应该一致，\n目前前端忙于组件化，基于vue和jsx的模板语言也很多（虽然性能不高，但可预见性能问题会很快解决），所以本文暂时不谈view。\n\n## OK，可以愉快地写代码了\n\n因为官网没有TS的相关文档，这里记录一下。\n\n### 新建一个Controller\n\n    // src/controller/home.ts\n    import { Controller } from \"egg\";\n    import { prefix, suffix } from \"../frags\";\n\n    export default class HomeController extends Controller {\n        async index() {\n            this.ctx.body = `${prefix}<h1>Hello World</h1>${suffix}`;\n        }\n    }\n\n### Router的引用\n\n    import { Application } from \"egg\";\n\n    export default (app: Application) => {\n        app.get('/', \"home.index\");\n    }\n\n## 结论\n\negg其实不错，能换自然是最好了。但是不换的话，如果项目已经跑起来了，\n说明egg该趟的坑都被你自己趟过了，而且已经用了typescript，async和await自然都用上了，\n所以（在我看来）generator就没更多优势了。\n\n但是如果你还没用上typescript...真的，动态一时爽，重构火葬场啊。\n\n以上。","collection":"blog","data":{"type":"post","category":"tech"}},{"id":"2017/10/17/linux-swap.md","slug":"2017/10/17/linux-swap","body":"# 给 linux 增加 swap 文件\n\n> 上周末，自己写的公司的服务挂了，心疼自己几分钟。。。\n\n事发之后看了眼服务器，好多配置被当白鼠了，比如机器都没有 SWAP，\n以前都是装机器的时候习惯性分配 SWAP，还没有现挂载的经验，在此记录一下。\n\n1. 创建分页文件（3GB）\n\n        dd if=/dev/zero of=/opt/swapfile bs=1M count=3000\n\n2. 格式化为 SWAP 分区\n\n        mkswap /opt/swapfile \n\n3. 挂载分区\n\n        swapon /opt/swapfile\n\n4. 保证以后重启后自动挂载（在 /etc/fstab 增加信息）\n\n         /opt/swapfile    swap   swap defaults 0 0\n\n5. 重新挂载\n\n        mount -a\n\n> 关于执行 free -m 的提示\n\n内存中的 buffered 和 cached 分别表示可以用来 写入/写出 磁盘的内存","collection":"blog","data":{"type":"post","category":"tech"}},{"id":"2017/11/26/QA-node.md","slug":"2017/11/26/qa-node","body":"# 给 QA 同学看的 node 科普\n\n## 目录\n\n* 什么是 Node.js\n* 什么是 NPM\n* 什么是 QXF\n* 什么是 webpack\n* 什么是 postcss\n* 什么是 sass\n* 什么是 babel\n* 什么是 TypeScript\n* node时代下的前端发布流程\n* 单元测试\n* 端对端测试\n\n## 什么是 Node.js\n\n![](http://click-labs.com/wp-content/uploads/2014/05/nodejs_logo_green.jpg)\n\nNode.js 是一个开源的跨平台 javascript 运行时. \n初期是由 Ryan Dahl 在 2009 年设计开发.\n\n设计 Node.js 的灵感来自于一套向 Flicker 上传进度条的实现. \n\n![](https://upload.wikimedia.org/wikipedia/commons/thumb/b/b2/Ryan_Dahl.jpg/440px-Ryan_Dahl.jpg)\n\n## Node.js 的技术细节\n\n* 基于谷歌 Chrome 的 V8 JavaScript 即时编译器\n* 单线程无阻塞 I/O\n* 基于 CommonJS 的模块机制\n* 一元化的 API\n* 事件轮询\n\n### 单线程无阻塞 I/O\n\nWeb 请求,对于即时性要求并不高,\n服务器需要处理一堆的异步事件,\n照以往的逻辑,\n我们会通过新建线程来处理这套逻辑,\n而这种方式往往是浪费资源的.\n\n在 Node.js 里面程序是单线程的,\n每一个异步事件通过事件轮询的方式解决.\n代码被要求以回调形式编写.\n\n```javascript\nconst server = http.createServer((req, res) => {\n  res.statusCode = 200;\n  res.setHeader('Content-Type', 'text/plain');\n  res.end('Hello World\\n');\n});\n\nserver.listen(port, hostname, () => {\n  console.log(`Server running at http://${hostname}:${port}/`);\n});\n```\n\n### CommonJS\n\n因为 JavaScript 的模块标准是在 2016 年才被定义的,\n所以 Node.js 使用的是另外一套模块机制 CommonJS.\n\nCommonJS 包括 require 函数和 module 对象.\n\n```javascript\nvar a = require(\"path/to/a.js\");\nmodule.exports = {...};\n```\n\n### 一元化的API\n\n使用 JavaScript 做服务器语言的框架其实很多,\n但是 Nodejs 最吸引人的一点就是一元化API.\n\n比如日志API:\n\n```javascript\nvar a = \"浏览器下打印日志\";\nconsole.log(a);\n```\n\n```JavaScript\nvar a = \".Net下打印日志\";\nprint(a);\n```\n\n```JavaScript\nvar a = \"Node.js下打印日志\";\nconsole.log(a);\n```\n\n### 事件轮询\n\n事件轮询是计算机系统的一种机制,\nJavaScript 用的是这种机制来解决单线程运行带来的问题.\n\n![](http://image.beekka.com/blog/201310/2013102001.png)\n\n## Node.js 小结\n\n![](https://img3.doubanio.com/lpic/s27269296.jpg)\n\n## 什么是 NPM\n\n![](http://playnode.io/2012/img/profile/aa.jpg)\n\nNPM 是 2010年由 Isaac Z. Schlueter 开发,\n用于 JavaScript 的模块管理.\n\nNPM 包括一个命令行的前端和一个远端资源库默认是 https://registry.npmjs.org/\n\nnpmjs.org 默认免费, 但是提交者的代码必须面向全网使用,\n也可以购买私有源, 私有模块往往如\n\n```shell\n@xxx/name\n```\n\n由于 NPM 本身开源,\n所以也有很多公司为了省钱单独搭建资源库,\n并定期和NPM同步.\n\n### NPM 在客户端的用途\n\n#### 本地安装 NPM 代码包\n\n```shell\nnpm install <package_name><?:@version>\n```\n\n执行以上代码之后,\n本地文件夹下会增加一个 node_modules 文件夹,\n里面放的是新安装的 NPM 代码包.\n\n代码包会首先按照指定的 version 安装,\n其次会按照本地 npm-shrinkwrap.json 安装,\n再次会按照本地 package.json 按装,\n最后会安装最新版.\n\n#### pacakge.json\n\n```\nnpm init\n```\n\n每一个 NPM 模块必须有一个 package.json,\n一下简单介绍几个重要字段.\n\n* name　代码包的名字\n* version 代码版本\n* main 包的入口文件\n* scripts 自定义命令\n* dependencies 本包需要安装的依赖包\n* devDependencies 本包开发时需要安装的依赖包\n\n#### npm-shrinkwrap.json\n\npackage.json 里面只记录了依赖包的版本信息,\n会导致多端执行 npm install 之后生成的 node_modules 不一致.\n\n```shell\nnpm shrinkwrap\n```\n\n执行上述命令, 本地根目录会新建 npm-shrinkwrap.json,\n文件会记录本地安装的每一个依赖包的确切版本信息以及资源库地址.\n\n#### run-script\n\npackage.json 里面的 script 字段是可以写 shell 命令的.\n\n```javascript\n{\n    \"script\": {\n        \"test\": \"node test.js\",\n        \"dev\": \"NODE_ENV=dev && node index.js\",\n        \"prd\": \"NODE_ENV=prd && node index.js\",\n        \"hello\": \"echo \\\"hello\\\"\"\n    }\n}\n```\n\n执行命令也很简单\n\n```shell\nnpm run test\n```\n\n## 什么是 Express\n\n![](http://img.kuqin.com/upimg/allimg/140806/2330395116-1.jpg)\n\nExpress 是 TJ Holowaychuk 于 2009年开发的, 基于 Node.js 平台，快速、开放、极简的 web 开发框架。\n\n```javascript\nvar express = require('express');\nvar app = express();\n\napp.get('/', function (req, res) {\n  res.send('Hello World!');\n});\n\nvar server = app.listen(3000, function () {\n  var host = server.address().address;\n  var port = server.address().port;\n\n  console.log('Example app listening at http://%s:%s', host, port);\n});\n```\n\n### Connect 中间件\n\nConnect是一个node中间件（middleware）框架。如果把一个http处理过程比作是污水处理，中间件就像是一层层的过滤网。每个中间件在http处理过程中通过改写request或（和）response的数据、状态，实现了特定的功能。\n\n```javascript\napp.use(middleware);\n```\n\n### 路由器\n\nExpress 路由器在我看来算是一种特殊的中间件,\n只不过路由结束之后整个请求就结束了.\n\n```javascript\napp.use('/calendar', router);\n```\n\n### QXF\n\nQXF 是去哪儿基于 Express 修改的 web 框架,\n在 Express 的基础上增加了面向去哪儿内部的监控等服务SDK.\n\n## 什么是 webpack\n\nwebpack 是一个模块的打包工具, 支持打包 CommonJs, AMD, ES6 modules, CSS, Images, JSON, Coffeescript, LESS, ...\n\n### 什么是 FEkit\n\nFEkit 是去哪儿之前一直使用的前端打包工具,能够打包 CSS 和 CommonJS, 现在已经不进行维护.\n\n### 什么是 ykit\n\nykit 基于 webpack, 是去哪儿目前大部分使用的打包工具.\n\n## 什么是 postcss\n\npostcss 是一个类似于 node-sass 的预编译期器,\n只不过编译的是 CSS. 它可以把更高级的 CSS 代码进行降级处理以适配兼容更古老的浏览器.\n\n## 什么是 SASS\n\nSASS 是 CSS 的扩展语言,\nnode-sass 是 SASS 的编译器,\nSASS 编译之后会生成 CSS.\n\n由于去哪儿内部大量使用的 Yo 框架基于 SASS,\n所以 node-sass 编译是一个必选项.\n\n## 什么是 babel\n\nbabel 可以对更高级的 JavaScript 代码进行降级处理,\n以适配兼容更古老的浏览器.\n\n## 什么是 TypeScript\n\nTypeScript 是对 JavaScript 的功能扩展之后的语言,\n增加了类型检查和代码编译以适应更复杂的开发需求.\n它编译后生成代码是 JavaScript.\n\n## node时代下的前端发布流程\n\n### 代码检查\n\n检查JS,TS,SASS,CSS...等文件是否有语法错误\n\n### 资源分拣\n\n* 分离前后端JS\n* 分离CSS\n* 分离大图片\n* 小图片 base64 编码\n\n### 编译检查\n\n* 编译 TypeScript\n* 编译 SASS\n\n### 向下编译\n\n* babel 向下兼容处理\n* postcss 向下兼容处理\n\n### 打包\n\n分别打包前后端代码\n\n### 客户端代码混淆压缩\n\n* JS 使用 Uglify 混淆\n* CSS 使用 cssnano 混淆\n\n### 客户端代码上传 CDN\n\n### Node 代码上传服务器\n\n### 重启服务\n\n## 单元测试\n\nJavaScript 目前已经有多套单元测试框架,\n如 Jest, Jasmine, Tape, AVA...\n\n```javascript\nconst sum = require('./sum');\n\ntest('adds 1 + 2 to equal 3', () => {\n  expect(sum(1, 2)).toBe(3);\n});\n```\n\n## 端对端测试\n\nsuperagent 可以对 http 请求进行断言处理.\n\n```javascript\nconst request = require('supertest');\nconst express = require('express');\n\nconst app = express();\n\napp.get('/user', function(req, res) {\n  res.status(200).json({ name: 'tobi' });\n});\n\nrequest(app)\n  .get('/user')\n  .expect('Content-Type', /json/)\n  .expect('Content-Length', '15')\n  .expect(200)\n  .end(function(err, res) {\n    if (err) throw err;\n  });\n```","collection":"blog","data":{"type":"post","category":"tech"}},{"id":"2017/12/08/ArchLinux.md","slug":"2017/12/08/archlinux","body":"# 树莓派+ArchLinux\n\n大概是今年五月份吧,我的树莓派2又一次吃灰了,\n之前用来当AP, 可是 Tenda U1 的驱动(RTL8192EU)需要配合新内核编译,\n毫无意外的编译失败了, 反正也不想折腾了, 就让它吃灰了.\n\n最近收拾东西, 发现了在吃灰的树莓派, 想想干脆拿出来刷上 Arch,\n就当 rust 的编译环境吧.\n\nwlan就用水星的吧, 起码不用编译驱动了.\n\n安装方法很简单, 照这个链接做就好\n\nhttps://github.com/phortx/Raspberry-Pi-Setup-Guide\n\nArchLinuxARM 不是像 Raspbian 那样烧录的,\n所以要下载好 tar 包, 解压到 SD 卡里.\n\n个人经验, 因为国内读卡器真的不咋地,\n最好先解压到本地在复制过去.\n\n另外 aliyun 没有 ArchLinuxARM 的源,\n但是可以使用清华的源.\n\n安装完 ohmyzsh 之后,\n切换 ssh 默认为 zsh\n\nchsh -s /usr/bin/zsh\n\n然后修改 .zsh 主题(因为我本地也是zsh),\n选择 avit 也行\n\n![](https://cloud.githubusercontent.com/assets/2618447/6316718/51a2fd9a-ba00-11e4-845a-24bed6ae9210.png)\n","collection":"blog","data":{"type":"post","category":"tech"}},{"id":"2017/12/23/P2P.md","slug":"2017/12/23/p2p","body":"# P2P实现不死网络","collection":"blog","data":{"type":"post","category":"tech"}},{"id":"2017/12/26/Mac-20264.md","slug":"2017/12/26/mac-20264","body":"# 解决 MacOS 安装绿联20264网线适配器驱动失败的问题\n\n公司里面配的 Mac 网线适配器快要断了, 我赶紧去狗东定了一个绿联的.\n谁成想, 插上机器没有反应, 翻了说明文档是要安装驱动的,\n到官网下载驱动, 安装成功. 重启后还是没反应...\n\n我插到 linux 机器上面, 没问题, 急忙搜了一下,\n原来是苹果 SIP 机制把第三方驱动拦截了.\n\n[苹果SIP机制](http://www.freebuf.com/articles/system/97411.html)\n\n## 解决方案\n\n1. 重启, 一直按 cmd + R 进入 recovery\n\n+. 执行命令 csrutil disable\n\n+. 重启, 重新安装驱动","collection":"blog","data":{"type":"post","category":"tech"}}]}