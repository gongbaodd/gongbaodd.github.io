{"posts":[{"id":"2017/11/26/QA-node.md","slug":"2017/11/26/qa-node","body":"# 给 QA 同学看的 node 科普\n\n## 目录\n\n* 什么是 Node.js\n* 什么是 NPM\n* 什么是 QXF\n* 什么是 webpack\n* 什么是 postcss\n* 什么是 sass\n* 什么是 babel\n* 什么是 TypeScript\n* node时代下的前端发布流程\n* 单元测试\n* 端对端测试\n\n## 什么是 Node.js\n\n![](http://click-labs.com/wp-content/uploads/2014/05/nodejs_logo_green.jpg)\n\nNode.js 是一个开源的跨平台 javascript 运行时. \n初期是由 Ryan Dahl 在 2009 年设计开发.\n\n设计 Node.js 的灵感来自于一套向 Flicker 上传进度条的实现. \n\n![](https://upload.wikimedia.org/wikipedia/commons/thumb/b/b2/Ryan_Dahl.jpg/440px-Ryan_Dahl.jpg)\n\n## Node.js 的技术细节\n\n* 基于谷歌 Chrome 的 V8 JavaScript 即时编译器\n* 单线程无阻塞 I/O\n* 基于 CommonJS 的模块机制\n* 一元化的 API\n* 事件轮询\n\n### 单线程无阻塞 I/O\n\nWeb 请求,对于即时性要求并不高,\n服务器需要处理一堆的异步事件,\n照以往的逻辑,\n我们会通过新建线程来处理这套逻辑,\n而这种方式往往是浪费资源的.\n\n在 Node.js 里面程序是单线程的,\n每一个异步事件通过事件轮询的方式解决.\n代码被要求以回调形式编写.\n\n```javascript\nconst server = http.createServer((req, res) => {\n  res.statusCode = 200;\n  res.setHeader('Content-Type', 'text/plain');\n  res.end('Hello World\\n');\n});\n\nserver.listen(port, hostname, () => {\n  console.log(`Server running at http://${hostname}:${port}/`);\n});\n```\n\n### CommonJS\n\n因为 JavaScript 的模块标准是在 2016 年才被定义的,\n所以 Node.js 使用的是另外一套模块机制 CommonJS.\n\nCommonJS 包括 require 函数和 module 对象.\n\n```javascript\nvar a = require(\"path/to/a.js\");\nmodule.exports = {...};\n```\n\n### 一元化的API\n\n使用 JavaScript 做服务器语言的框架其实很多,\n但是 Nodejs 最吸引人的一点就是一元化API.\n\n比如日志API:\n\n```javascript\nvar a = \"浏览器下打印日志\";\nconsole.log(a);\n```\n\n```JavaScript\nvar a = \".Net下打印日志\";\nprint(a);\n```\n\n```JavaScript\nvar a = \"Node.js下打印日志\";\nconsole.log(a);\n```\n\n### 事件轮询\n\n事件轮询是计算机系统的一种机制,\nJavaScript 用的是这种机制来解决单线程运行带来的问题.\n\n![](http://image.beekka.com/blog/201310/2013102001.png)\n\n## Node.js 小结\n\n![](https://img3.doubanio.com/lpic/s27269296.jpg)\n\n## 什么是 NPM\n\n![](http://playnode.io/2012/img/profile/aa.jpg)\n\nNPM 是 2010年由 Isaac Z. Schlueter 开发,\n用于 JavaScript 的模块管理.\n\nNPM 包括一个命令行的前端和一个远端资源库默认是 https://registry.npmjs.org/\n\nnpmjs.org 默认免费, 但是提交者的代码必须面向全网使用,\n也可以购买私有源, 私有模块往往如\n\n```shell\n@xxx/name\n```\n\n由于 NPM 本身开源,\n所以也有很多公司为了省钱单独搭建资源库,\n并定期和NPM同步.\n\n### NPM 在客户端的用途\n\n#### 本地安装 NPM 代码包\n\n```shell\nnpm install <package_name><?:@version>\n```\n\n执行以上代码之后,\n本地文件夹下会增加一个 node_modules 文件夹,\n里面放的是新安装的 NPM 代码包.\n\n代码包会首先按照指定的 version 安装,\n其次会按照本地 npm-shrinkwrap.json 安装,\n再次会按照本地 package.json 按装,\n最后会安装最新版.\n\n#### pacakge.json\n\n```\nnpm init\n```\n\n每一个 NPM 模块必须有一个 package.json,\n一下简单介绍几个重要字段.\n\n* name　代码包的名字\n* version 代码版本\n* main 包的入口文件\n* scripts 自定义命令\n* dependencies 本包需要安装的依赖包\n* devDependencies 本包开发时需要安装的依赖包\n\n#### npm-shrinkwrap.json\n\npackage.json 里面只记录了依赖包的版本信息,\n会导致多端执行 npm install 之后生成的 node_modules 不一致.\n\n```shell\nnpm shrinkwrap\n```\n\n执行上述命令, 本地根目录会新建 npm-shrinkwrap.json,\n文件会记录本地安装的每一个依赖包的确切版本信息以及资源库地址.\n\n#### run-script\n\npackage.json 里面的 script 字段是可以写 shell 命令的.\n\n```javascript\n{\n    \"script\": {\n        \"test\": \"node test.js\",\n        \"dev\": \"NODE_ENV=dev && node index.js\",\n        \"prd\": \"NODE_ENV=prd && node index.js\",\n        \"hello\": \"echo \\\"hello\\\"\"\n    }\n}\n```\n\n执行命令也很简单\n\n```shell\nnpm run test\n```\n\n## 什么是 Express\n\n![](http://img.kuqin.com/upimg/allimg/140806/2330395116-1.jpg)\n\nExpress 是 TJ Holowaychuk 于 2009年开发的, 基于 Node.js 平台，快速、开放、极简的 web 开发框架。\n\n```javascript\nvar express = require('express');\nvar app = express();\n\napp.get('/', function (req, res) {\n  res.send('Hello World!');\n});\n\nvar server = app.listen(3000, function () {\n  var host = server.address().address;\n  var port = server.address().port;\n\n  console.log('Example app listening at http://%s:%s', host, port);\n});\n```\n\n### Connect 中间件\n\nConnect是一个node中间件（middleware）框架。如果把一个http处理过程比作是污水处理，中间件就像是一层层的过滤网。每个中间件在http处理过程中通过改写request或（和）response的数据、状态，实现了特定的功能。\n\n```javascript\napp.use(middleware);\n```\n\n### 路由器\n\nExpress 路由器在我看来算是一种特殊的中间件,\n只不过路由结束之后整个请求就结束了.\n\n```javascript\napp.use('/calendar', router);\n```\n\n### QXF\n\nQXF 是去哪儿基于 Express 修改的 web 框架,\n在 Express 的基础上增加了面向去哪儿内部的监控等服务SDK.\n\n## 什么是 webpack\n\nwebpack 是一个模块的打包工具, 支持打包 CommonJs, AMD, ES6 modules, CSS, Images, JSON, Coffeescript, LESS, ...\n\n### 什么是 FEkit\n\nFEkit 是去哪儿之前一直使用的前端打包工具,能够打包 CSS 和 CommonJS, 现在已经不进行维护.\n\n### 什么是 ykit\n\nykit 基于 webpack, 是去哪儿目前大部分使用的打包工具.\n\n## 什么是 postcss\n\npostcss 是一个类似于 node-sass 的预编译期器,\n只不过编译的是 CSS. 它可以把更高级的 CSS 代码进行降级处理以适配兼容更古老的浏览器.\n\n## 什么是 SASS\n\nSASS 是 CSS 的扩展语言,\nnode-sass 是 SASS 的编译器,\nSASS 编译之后会生成 CSS.\n\n由于去哪儿内部大量使用的 Yo 框架基于 SASS,\n所以 node-sass 编译是一个必选项.\n\n## 什么是 babel\n\nbabel 可以对更高级的 JavaScript 代码进行降级处理,\n以适配兼容更古老的浏览器.\n\n## 什么是 TypeScript\n\nTypeScript 是对 JavaScript 的功能扩展之后的语言,\n增加了类型检查和代码编译以适应更复杂的开发需求.\n它编译后生成代码是 JavaScript.\n\n## node时代下的前端发布流程\n\n### 代码检查\n\n检查JS,TS,SASS,CSS...等文件是否有语法错误\n\n### 资源分拣\n\n* 分离前后端JS\n* 分离CSS\n* 分离大图片\n* 小图片 base64 编码\n\n### 编译检查\n\n* 编译 TypeScript\n* 编译 SASS\n\n### 向下编译\n\n* babel 向下兼容处理\n* postcss 向下兼容处理\n\n### 打包\n\n分别打包前后端代码\n\n### 客户端代码混淆压缩\n\n* JS 使用 Uglify 混淆\n* CSS 使用 cssnano 混淆\n\n### 客户端代码上传 CDN\n\n### Node 代码上传服务器\n\n### 重启服务\n\n## 单元测试\n\nJavaScript 目前已经有多套单元测试框架,\n如 Jest, Jasmine, Tape, AVA...\n\n```javascript\nconst sum = require('./sum');\n\ntest('adds 1 + 2 to equal 3', () => {\n  expect(sum(1, 2)).toBe(3);\n});\n```\n\n## 端对端测试\n\nsuperagent 可以对 http 请求进行断言处理.\n\n```javascript\nconst request = require('supertest');\nconst express = require('express');\n\nconst app = express();\n\napp.get('/user', function(req, res) {\n  res.status(200).json({ name: 'tobi' });\n});\n\nrequest(app)\n  .get('/user')\n  .expect('Content-Type', /json/)\n  .expect('Content-Length', '15')\n  .expect(200)\n  .end(function(err, res) {\n    if (err) throw err;\n  });\n```","collection":"blog","data":{"type":"post","category":"tech"}}]}