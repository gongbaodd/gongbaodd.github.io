{"posts":[{"id":"2017/01/09/PyQt.md","slug":"2017/01/09/pyqt","body":"\n前端做得久了，我的工程根目录下面就会多一个bash脚本，把每一个项目的启动脚本放在里面然后注释掉。这样做的好处是如果要启动一个项目的时候只需要运行脚本就好了。\n\n可是问题随之出现了，项目越来越多，然后那个脚本就变成了下面这样。\n\n![脚本库](http://ww4.sinaimg.cn/mw690/89d0a2e1gw1fbkbh1idg9j20gi046q4s.jpg)\n\n因为用的都是fekit，所以各个工程就mock数据不一样。不久我发现一个问题，工作一天，老眼昏花之后，要想在项目之间切换，就是每次要数出第几行，把它解注释，那简直是件恐怖的事情。\n\n于是我便希望有一个图形化的界面，能实时显示我目前处于什么环境，并且能够切环境（因为是触摸屏，所以图形化界面效率很高😏,同时因为我经常在archLinux和Mac下面切换，所以我对跨平台要求很高）。\n\n# 需求\n\n1. 图形化的界面，能够显示现在mock的是哪个项目。\n2. 兼容ArchLinux(Gnome)和OSX。\n3. 开发时间越短越好（根本没时间在工具上下功夫😢）。\n4. 不要影响到我现有的开发习惯（生成的shell脚本格式不能变）。\n\n# 分析\n\n额，好吧，其实electron也行，可是宝宝就是觉得pyQt好久不用了，就是想用用。\n\n# 编写\n\n文件读写\n\n```python\nimport sys\nimport os\nimport re\n\nQMB_FILE_PATH = os.path.split(os.path.realpath(__file__))[0] + '/qmbrun.sh'# 我那个shell脚本叫qmbrun.sh\nRUN_BASH_PREFIX = '#!/bin/bash\\n'\nFEKIT_SERVER = 'fekit server'\nHASH_CHAR = '#'\nPRD_REG = r'.*-m\\s(.*)/.*'\n\ndef readFile():\n    commands = {}\n    file = open(QMB_FILE_PATH)\n    line = file.readline()\n    while line:\n        if line.find(FEKIT_SERVER) > -1:\n            command = line.replace(HASH_CHAR,'')\n            match = re.match(PRD_REG, command)\n            if match: \n                product = match.groups()[0]\n            if product:\n                commands[product] = {\n                    'selected': line.find(HASH_CHAR) < 0,\n                    'command': command\n                }\n        line = file.readline()\n    file.close()\n    return commands\n\ndef writeFile(str):\n    file = open(QMB_FILE_PATH,'w')\n    file.write(RUN_BASH_PREFIX + str)\n    file.close()\n```\n\n对话框\n\n```python\nfrom PyQt5.QtWidgets import *\n\nclass QMBedit(QDialog):\n    def __init__(self, parent = None):\n        super(QMBedit, self).__init__(parent)\n\n        self.btns = []\n        self.commands = readFile()\n        \n        self.setWindowTitle('QMBedit')\n        layout = QVBoxLayout()\n\n        for cmd in self.commands.keys():\n            btn = QRadioButton(cmd)\n            btn.setChecked(self.commands[cmd]['selected'])\n            btn.clicked.connect(self.btn_clicked)\n            self.btns.append(btn)\n            layout.addWidget(btn)\n\n        self.setLayout(layout)\n    \n    def btn_clicked(self): \n        for btn in self.btns:\n            self.commands[btn.text()]['selected'] = btn.isChecked()\n        self.map2str()\n    \n    def map2str(self):\n        str = ''\n        for cmd in self.commands.keys():\n            if self.commands[cmd]['selected']:\n                str += self.commands[cmd]['command']\n            else:\n                str += HASH_CHAR + self.commands[cmd]['command']\n        writeFile(str)\n```\n\n# 运行\n\n![运行结果](http://ww1.sinaimg.cn/mw690/89d0a2e1gw1fbkbh2aju0j205s04xwex.jpg)\n\nOK，用起来不错，拯救了老眼昏花的我。话说本文是本年度第一文啊！其实我挺用心的，写文章的时间远远超过了写这段代码的时间。。。真的😂。\n\nPS：话说emojipedia真的很好用，可以考虑给vcode开发个插件🤔。","collection":"blog","data":{"type":"post","category":"tech"}},{"id":"2017/01/17/VScode-Python-python3.6.md","slug":"2017/01/17/vscode-python-python36","body":"\n本来想写一篇pyqt+qml的文章，结果今天打开VScode发现Python不语法提示了。打开开发者模式，发现一直在报错，gramar3.6 not found。\n\n打开```~/.vscode/extensions/donjayamanne.python-0.5.5/pythonFiles/preview/jedi/parser```找到里面的```grammar3.5.txt```复制为```grammar3.6.txt```\n\n重启VScode就好了。","collection":"blog","data":{"type":"post","category":"tech"}},{"id":"2017/01/18/PyQt-QML.md","slug":"2017/01/18/pyqt-qml","body":"\n> 翻了翻以前保存的书签，发现了一个pyQt和QML的开发总结，代码跑起来还是有点错误，但是还是比官网的tutorial更简单直观一点。还能从里面找一点hybrid开发的idea（因为QML其实也是一种ECMAScript引擎实现）。\n\n# 在QML上下文插入变量\n\n在```view.setSource```之前将变量插入上下文之中。\n\n```python\nfrom PyQt4.QtDeclarative import QDeclarativeView\nfrom PyQt4.QtGui import QApplication\nfrom PyQt4.QtCore import QUrl\n\napp = QApplication([])\n\nview = QDeclarativeView()\n\nrootCtx = view.rootContext()\nrootCtx.setContextProperty(\"textData\", \"hi\")\n\nview.setSource(QUrl('ctxProp.qml'))\nview.show()\n\napp.exec_()\n```\n\n```qml\nimport Qt 4.7\n\nRectangle {\n    id: test\n\n    width: 1000; height: 300\n\n    Text {\n        \n        anchors.fill: parent;\n        text: textData\n    }\n}\n```\n\n# PyQt修改QML中变量\n\n这样可以先加载qml再修改内部的值，注意```property```后面是有类型的。\n\n```python\nfrom PyQt4.QtDeclarative import QDeclarativeView\nfrom PyQt4.QtGui import QApplication\nfrom PyQt4.QtCore import QUrl\n\napp = QApplication([])\n\nview = QDeclarativeView()\nview.setSource(QUrl('./ownProp.qml'))\n\nrootObj = view.rootObject()\nrootObj.setProperty(\"textData\", 'hi')\n\nview.show()\napp.exec_()\n```\n\n```qml\nimport Qt 4.7\n\nRectangle {\n    width: 1000\n    height: 300\n    id: test\n    \n    property string textData;\n\n    Text {\n        \n        anchors.fill: parent;\n        text: textData;\n    }\n    \n}\n```\n\n# 消息传递\n\nQT最主要的就是它的信号槽机制，对我的影响也很很大，以至于我现在的组件开发也在用这一套思维。那么QT怎么和QML内部进行消息传递呢？\n\n```python\nfrom PyQt4.QtDeclarative import QDeclarativeView\nfrom PyQt4.QtGui import QApplication\nfrom PyQt4.QtCore import QUrl\n\napp = QApplication([])\n\nview = QDeclarativeView()\nview.setSource(QUrl('./signal.qml'))\n\ndef on_click():\n    print(\"hi\")\n\nrootQbj = view.rootObject()\nrootQbj.mclicked.connect(on_click)\nrootQbj.setProperty('name','hello')\nview.show()\napp.exec_()\n```\n\n```qml\nimport Qt 4.7\n\nRectangle {\n    width: 1000\n    height: 300\n    id: test;\n    signal mclicked;\n    property string name;\n    \n\n    Text {\n        anchors.fill: parent;\n        text: name\n    }\n\n    MouseArea {        \n        anchors.fill: parent\n\n        onClicked: {\n            mclicked();\n        }\n    }\n    \n}\n\n```\n\n# 调用QML内部函数\n\n```python\nfrom PyQt4.QtDeclarative import QDeclarativeView\nfrom PyQt4.QtGui import QApplication\nfrom PyQt4.QtCore import QUrl\n\napp = QApplication([])\n\nview = QDeclarativeView()\nview.setSource(QUrl('./interface.qml'))\n\ndef on_click():\n    rootObject.set_text('Clicked')\n\nrootObject = view.rootObject()\nrootObject.mclicked.connect(on_click)\n\nview.show()\napp.exec_()\n```\n\n```qml\nimport Qt 4.7\n\nRectangle {\n    width: 1000\n    height: 300\n    color: \"transparent\"\n    id: test\n    signal mclicked\n    Text {\n        id: testText\n        \n        anchors.fill: parent\n        \n        text: \"Click Me\"\n    }\n    MouseArea {\n        anchors.fill: parent\n        onClicked: {\n            mclicked();\n        }\n    }\n    function set_text(text) {\n        testText.text = text\n    }   \n}\n```\n\n就酱，后面再写一篇QML调用js的文章吧🤔。","collection":"blog","data":{"type":"post","category":"tech"}}]}