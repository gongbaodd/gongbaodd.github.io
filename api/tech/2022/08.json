{"posts":[{"id":"2022/08/11/OpenGL-tutorial.md","slug":"2022/08/11/opengl-tutorial","body":"\n# 几个 OpenGL 的 tutorial\n\nOpenGL 和 Rust 算是我一直在学习，但一直没办法实际使用的技术了。\n\n[Rust and OpenGL from scratch](http://nercury.github.io/rust/opengl/tutorial/2018/02/08/opengl-in-rust-from-scratch-00-setup.html) 这是一篇讲 Rust 结合 OpenGL 的博客，照着操作下去，主要的感觉就是 unsafe 太多了，网上几乎所有的 OpenGL 教程都基于[LearnOpenGL](https://learnopengl-cn.github.io/)来做，这是一篇中文译本，非常值得细看。\n\n今天我还会再看一下 Vulkan，希望里面的 unsafe 的部分不要太多。\n","collection":"blog","data":{"type":"post","category":"tech","tag":["OpenGL"]}},{"id":"2022/08/17/Rust.md","slug":"2022/08/17/rust","body":"\n# Rust 实现的几个排序算法\n\n## 冒泡排序\n\n$O(n^2)$ 稳定排序\n\n选择每个元素和后面的作比较，如果前面的元素比后面的大，就交换两个元素的位置。\n\n```rust\nfn bubble_sort<T: Ord>(arr: &mut [T]) {\n    for i in 0..arr.len() {\n        for j in i..arr.len() {\n            if arr[i] > arr[j] {\n                arr.swap(i, j);\n            }\n        }\n    }\n}\n```\n\n## 插入排序\n\n$O(n^2)$ 稳定排序\n\n假定只有两个元素并排好序，每次再插入新的元素，直到全部元素都插入。\n\n```rust\nfn insert<T: Ord>(arr: &mut [T]) {\n    for i in 1..arr.len() {\n        let mut j = i;\n        while j > 0 && arr[j] < arr[j-1] {\n            arr.swap(j, j-1);\n            j -= 1;\n        }\n    }\n}\n```\n\n## 快速排序\n\n期望$O(n\\log{n})$，最坏情况$O(n^2)$，不稳定排序\n\n选中一个元素，把小于它的元素放到左边，再把大于它的放到右边，再继续处理两边数据。\n\n```rust\nfn quick<T:Ord>(arr: &mut [T]) {\n    _quick(arr, 0, (arr.len() - 1) as isize);\n}\n\nfn _quick<T:Ord>(arr: &mut [T], start: usize, end: isize) {\n    if start > end {\n        return;\n    }\n\n    let pivot = partition(arr, start, end as isize);\n    _quick(arr, start, (pivot) as isize - 1);\n    _quick(arr, pivot + 1, end);\n}\n\nfn partition<T:Ord>(arr: &mut [T], mut low: usize, mut high: usize) -> usize {\n    let pivot = 0;\n\n    loop {\n        if low < high && data[low] < pivot {\n            low += 1;\n        }\n        data.swap(low, high);\n\n        if low < high && data[high] > pivot {\n            high -= 1;\n        }\n        data.swap(low, high);\n\n        if low == high {\n            break;\n        }\n    }\n\n    low\n}\n```\n\n## 归并排序\n\n$O(n\\log{n})$ 稳定排序\n\n将两个有序数组合并为一个有序数组\n\n```rust\nfn merge<Ord:T>(arr: &mut [T]) {\n    let length = arr.len();\n    let middle = length / 2;\n\n    if length > 1 {\n        let a = arr[0..middle];\n        let b = arr[middle..length];\n        merge(a);\n        merge(b);\n\n\n    }\n}\n\nfn sort<Ord: T>(a: &[T], b: &[T], arr: &mut[T]) {\n    let mut ia = 0;\n    let mut ib = 0;\n    let mut i = 0;\n\n    while ia < arr.len() && ib < arr.len() {\n        if a[ia] < b[ib] {\n            data[i] = a[ia];\n            ia += 1;\n        } else {\n            data[i] = b[ib];\n            ib += 1;\n        }\n        i += 1;\n    }\n\n    if ia < arr.len() {\n        data[..i].copy_from_slice(&a[ia..]);\n    }\n\n    if ib < arr.len() {\n        data[..i].copy_from_slice(&b[ib..]);\n    }\n}\n```\n\n## 希尔排序\n\n$O(n\\log^2{n})$不稳定排序\n\n升级版的插入排序，每隔一个 gap 进行一次排序，直到 gap 缩到 1。\n\n```Rust\nfn shell<T: Ord>(arr: &mut [T]) {\n    let length = arr.len();\n    let mut gap = length / 2;\n\n    while gap > 0 {\n        for i in gap..length {\n            let mut j = i;\n            while j > gap & data[j] < data[j-gap] {\n                data.swap(j, j-gap);\n                j -= gap;\n            }\n        }\n        gap /= 2;\n    }\n}\n```\n\n## 堆排序\n\n$O(n\\log{n})$不稳定排序\n\n将数组转换成大顶堆，把作为根的最大值排到数组最后，再去除最大值重新排序。\n\n```Rust\nfn heap(data: &mut Vec<i32>) {\n    if data.len() < 2 {\n        return ;\n    }\n\n    // build one max heap\n    let last_root = (data.len() + 2) / 2;\n    for root in (0..=last_root).rev() {\n        to_max_heap(data, root, data.len() - 1);\n    }\n\n    // replace the first element(max element) to the last\n    // make max heap using the other elements\n    for last in (1..data.len()).rev() {\n        data.swap(0, last);\n        to_max_heap(data, 0, last-1);\n    }\n}\n\nfn to_max_heap(data: &mut Vec<i32>, mut root: usize, last: usize) {\n    loop {\n        let left = root * 2 + 1;\n        let right = left + 1;\n        let max_child;\n\n        if left > last {\n            break;\n        }\n\n        if right > last {\n            max_child = left;\n        } else {\n            max_child = if data[right] > data[left] {\n                right\n            } else {\n                left\n            }\n        }\n\n        if data[max_child] > data[root] {\n            data.swap(max_child, root);\n        }\n\n        root = max_child;\n    }\n}\n```\n\n另外还有很多排序算法参考[https://github.com/TheAlgorithms/Rust/tree/master/src/sorting](https://github.com/TheAlgorithms/Rust/tree/master/src/sorting)\n\n## bogo 排序\n\n$O(n\\times n!)$\n\n随机排列直到排序完成\n\n## 桶排序(Bucket Sort)\n\n$O(n)$ 稳定排序\n\n先对元素分类，如 0-10，10-20...然后在每个桶中进行排序\n\n## 鸡尾酒排序(cocktail Sort)\n\n$O(n^2)$ 稳定排序\n\n冒泡排序的变形，先向上冒泡，再进行一次下沉，是两个方向的冒泡排序。\n\n## 梳排序(Comb sort)\n\n$O(n\\log{n})$ 不稳定排序\n\n用希尔排序的方法进化冒泡排序，衰减值默认选 1.3 效率最高\n\n## 计数排序\n\n$O(n+k)$ 稳定排序\n\n新建一个 k 元素的计数数组，k 为排序数组的取值空间，有值的计数数组键值就是排序结果。\n\n## 基数排序(Radix sort)\n\n$O(k\\cdot n)$\n\n按照个位、十位、百位...排序\n\n## Tim sort\n\n长度小于 64 的数组进行二分插入排序，大于 64 的数组进行归并排序，归并排序在比较大于 minrun 时直接对接数组。\n","collection":"blog","data":{"type":"post","category":"tech","tag":["algorithm","Rust"]}},{"id":"2022/08/24/Astro.md","slug":"2022/08/24/astro","body":"\n# Astro 算是比较终极状态的前端框架了\n\n这几天刷油管发现都在推荐一个 Astro 的框架，这算是一个比 React、Vue 更高一维度的框架，\n它可以使用目前已知的主流前端框架作为渲染器生成静态页面，同时可以把页面中需要交互的部分以「岛」的形式添加到页面里。\n\n更有趣的，同一个项目可以接受不同的框架，相比于 Next、Gatsby 等，它看起来是更加简单易用的。\n","collection":"blog","data":{"type":"post","category":"tech","tag":["astro","js"]}},{"id":"2022/08/27/Ziglang.md","slug":"2022/08/27/ziglang","body":"\n# 试用 Zig\n\n最近 bun 大火，带动一个语法看起来很像 JS 的语言 Zig 受到关注。听了 Devtools 播客里面的推荐，我觉得可以试用一下。\n\nZig 官网两个学习链接[ziglearn](https://ziglearn.org/)和[ziglings](https://github.com/ratfactor/ziglings)很有帮助，这个语言的学习曲线远没有 Rust 那么陡，甚至可以说，比 C 简单。可以说 Zig 就是披着高级语言语法外衣的 C 语言，而根据官方文档的说法，Zig 的编译器确实可以直接编译 C。\n\n提到语言安全，比较多提的是类型安全和内存安全。类型在 Zig 中只有编译环境使用，官方介绍 Zig 没有宏语言，实际使用中其实是有的，只不过宏语言用的也是 Zig 语法，前面加上了 comptime 关键字，它的泛型写法也利用了编译时可编程的特点。个人觉得使用的时候会混淆，但是教程里面表示用习惯了就不会...\n\n对比 Golang 的垃圾回收和 Rust 的借用机制，Zig 是完全不管内存安全的，跟 C 类似，想要操作堆内存，要新建 allocator，好在利用 defer 关键词能让回收工作在代码里面看起来不是那么难懂。\n\nasync 几乎和 JS 一模一样，用起来感觉是 JS 里面 generator 和 async 的合体版（但它不是迭代器），感觉 JS 用户体验是无缝的。\n\n个人很推荐 Zig，是一个完全新味道的语言。\n","collection":"blog","data":{"type":"post","category":"tech","tag":["zig"]}}]}