{"posts":[{"id":"2021/01/13/Learning-rust-with-entirely-too-many-linked-list.md","slug":"2021/01/13/learning-rust-with-entirely-too-many-linked-list","body":"\n# Learning Rust with entirely too many linkd lists\n\n## 序言\n\n### 基础\n\n- 指针\n\n\t- &\n\t- &mut\n\t- Box\n\t- Rc\n\t- Arc\n\t- *const\n\t- *mut\n\n- 所有权\n- 关键字\n\n\t- struct\n\t- enum\n\t- fn\n\t- pub\n\t- impl\n\n- 模式匹配\n- 测试\n- 简单的unsafe模式\n\n### 驳斥链表\n\n- 性能不总是重点\n- 链表的处理可以是O(1)的\n- 无需复杂度均摊\n- 节省空间\n- 函数式开发一直使用链表\n- 利于并行开发\n- 内核开发、嵌入式开发使用链表\n- 插入删除不会让迭代器失效\n- 简单且易于教学\n\n\n## 栈\n\n### 一个糟糕的栈\n\n- 布局\n\n\t- List a = Empty | Elem a (List a)\n\t- 布局一： \nenum List  {\n    Empty, \n    Box<List> \n}\n\n\t\t- 必须用Box分配堆内存，否则编译器不知道如何分配栈内存\n\t\t- 可以发现链表最后多余一个Empty，则更改布局二\n\n\t- 布局二：： \nenum List { \n    Empty, \n    More(Box<Node>) \n}\nstruct Node {\n    elem: i32,\n    next: List\n}\n\n- 创建\n\n\t- impl List {\n    pub fn new() -> Self {\n        List{ head: Link::Empty }\n   }\n}\n\n- 所有权入门\n\n\t- self - 值\n\n\t\t- 完全复制的值，函数值执行完会被销毁\n\n\t- &mut self 可变引用\n\n\t\t- 完全控制值所在地址\n\t\t- 不能给值增加引用\n\n\t- &self 不可变引用\n\n\t\t- 完全取得值所在地址，但不能更改\n\n- push\n\n\t- 因为&mut self.head不能增加引用，必须先用mem::replace替换原来引用来释放引用\n\n- pop\n\n\t- 未完成的函数可以使用unimplemented!宏来避免编译报错\n\t- match关键字也如函数一样存在值引用的问题\n\n- 测试\n\n\t- assert_eq!宏来处理断言\n\t- #[cfg(test)]注释来表明模块仅用于测试环境\n\t- #[test]注释用于表明函数用于测试\n\t- 模块内需要引用外部的元素（use super::List;）\n\n- Drop\n\n\t- Box的析构过程无法形尾递归调用，析构时会爆栈\n\n### 一个不错的栈\n\n- 使用Option代替Link\n\n\t- take方法替代mem::replace\n\t- map方法替代match\n\n- 支持泛型\n\n\t- impl<T>\n\n- peek\n\n\t- take方法会把数据取出并把原来的位置用None补充\n\t- as_ref会取得Option中的不可变引用\n\t- as_mut会取得所在内存的可变引用\n\n- 迭代器\n\n\t- 简单迭代\n\n\t\t- pub trait Iterator {\n    type Item;\n    fn next(&mut self) -> Option<Self::Item>;\n}\n\n\t- 不可变迭代\n\n\t\t- 显式声明所有权\n\n\t\t\t- 一个函数引入两个以上引用时\n\t\t\t- 一个泛型结构体\n\t\t\t- 编译器会提醒添加\n\n\t\t- 解开Box可以使用*操作来deRef，如 *node\n\n\t- 可变迭代\n\n## 列表\n\n### Box只能实现单指针\n\n### Rc实现引用计数\n\n- use std::rc::Rc\n- 使用clone方法\n- Option\n\n\t- map： Option<T> -> Option<T>\n\t- and_then： Option<T> -> T.\n\t- as_ref: &Option<T> -> Option<&T>\n\t- as_mut: &mut Option<T> -> Option<&mut T>\n\n### Arc线程安全的引用计数\n\n- Send trait: 可以移动到别的线程\n- Sync trait:可以被多个线程查看\n- Rc实现是基于Cell的\n- Arc基于Atomic\n\n## 队列\n\n### 一个不好但是Safe的队列\n\n- RefCell需要动态借用\n\n\t- borrow(self) -> Ref<T>\n\t- borrow_mut(self) -> RefMut<T>\n\t- into_inner()可以取得包裹的值\n\t- 虽然Ref和RefMut表现和&和&mut相同，但不能由Ref转换到&\n\n- Rc\n\n\t- 解开Rc需要使用try_unwrap()之后再unwrap()\n\t- Rc解决不了环形引用\n\n### 一个可以但是unsafe的队列\n\n- The Rustonomicon\nhttps://doc.rust-lang.org/nightly/nomicon/\n- *mut T\n- std::ptr\n- 具体unsafe的部分只靠这一个例子还搞不懂\n主要先摆正姿态，Unsafe其实并不是不好，只是此时编译器不做检查\n\n## 总结\n\n这次是彻底了解了Rust的所有权生存期的内容，虽然最后unsafe相关内容还是不清楚，单已经有很大进步了。\n\n","collection":"blog","data":{"type":"post","category":"book","tag":["rust"]}}]}