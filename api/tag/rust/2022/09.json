{"posts":[{"id":"2022/09/08/Traversing-a-binary-tree.md","slug":"2022/09/08/traversing-a-binary-tree","body":"\n# 遍历二叉树\n\n遍历二叉树其实也不难，就是利用栈的思维实现遍历挺有意思的，另外在写迭代器的时候还会用的 Rust 的生命周期，刚好能够对 Rust 的生命周期有更多的理解。\n\n## 遍历方法\n\n- 先序遍历，根左右\n- 中序遍历，左根右\n- 后序遍历，左右根\n- 按层遍历\n\n先序遍历，先把跟压入栈，执行 next 出栈取值，并将右子树和左子树压入栈，直到栈空，返回 None。\n\n```Rust\nstruct TreeIter<'tree> {\n    order: Order,\n    stack: Vec<&'tree Tree>,\n}\n\nimpl<'tree> TreeIter<'tree> {\n    pub fn new(tree: &Tree) -> TreeIter {\n            TreeIter {\n                stack: vec![tree],\n                order,\n            }\n    }\n}\n\nimpl<'tree> Iterator for TreeIter<'tree> {\n    type Item = String;\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.stack.is_empty() {\n            return None;\n        }\n\n        let item = self.stack.pop().unwrap();\n\n        if item.right.is_some() {\n            self.stack.push(item.right.as_ref().unwrap());\n        }\n\n        if item.left.is_some() {\n            self.stack.push(item.left.as_ref().unwrap());\n        }\n\n        Some(item.value.to_owned())\n    }\n}\n```\n\n中序遍历，先把根的左手边按节点拆成几棵没有左子树的树压入栈，执行 next 的时候逐一弹出，如果弹出的子树有右子树，把右子树也拆成没有左子树的子树压入栈。\n\n```Rust\nstruct TreeIter<'tree> {\n    order: Order,\n    stack: Vec<&'tree Tree>,\n}\n\nimpl<'tree> TreeIter<'tree> {\n    pub fn new(tree: &Tree) -> TreeIter {\n        let mut iter = TreeIter {\n            stack: vec![tree],\n            order,\n        };\n\n        while let Some(node) = &iter.stack.last().unwrap().left {\n            iter.stack.push(node);\n        }\n\n        iter\n    }\n}\n\nimpl<'tree> Iterator for TreeIter<'tree> {\n    type Item = String;\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.stack.is_empty() {\n            return None;\n        }\n        let item = self.stack.pop().unwrap();\n        if item.right.is_some() {\n           self.stack.push(item.right.as_ref().unwrap());\n              while let Some(node) = &self.stack.last().unwrap().left {\n                  self.stack.push(node);\n              }\n        }\n\n        Some(item.value.to_owned())\n    }\n}\n```\n\n后序遍历，相比于前两个准备工作多一些，需要两个栈，第一个栈按照先序遍历一样压栈，不同的是，先序遍历为了先出栈左子树（根左右）而先压栈右子树，这里要先压栈左子树。第一个栈的出栈元素直接压入第二个栈。执行 next 时，直接从第二个栈出栈即可。\n\n```Rust\nstruct TreeIter<'tree> {\n    order: Order,\n    stack: Vec<&'tree Tree>,\n}\n\nimpl<'tree> TreeIter<'tree> {\n    pub fn new(tree: &Tree) -> TreeIter {\n            let mut iter = TreeIter {\n                stack: vec![],\n                order,\n            };\n            let mut stack = vec![tree];\n            while !stack.is_empty() {\n                let node = stack.pop().unwrap();\n                iter.stack.push(node);\n                if node.left.is_some() {\n                    stack.push(node.left.as_ref().unwrap());\n                }\n                if node.right.is_some() {\n                    stack.push(node.right.as_ref().unwrap());\n                }\n            }\n            iter\n    }\n}\n\nimpl<'tree> Iterator for TreeIter<'tree> {\n    type Item = String;\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.stack.is_empty() {\n            return None;\n        }\n\n        let item = self.stack.pop().unwrap();\n        Some(item.value.to_owned())\n    }\n}\n```\n\n按层遍历，就是把每一层的节点按层压入栈\n\n```Rust\nstruct LevelIter<'tree> {\n    stack: Vec<Vec<&'tree Tree>>,\n}\nimpl<'tree> LevelIter<'tree> {\n    pub fn new(tree: &'tree Tree) -> LevelIter {\n        let mut iter = LevelIter {\n            stack: vec![vec![tree]],\n        };\n\n        loop {\n            let last_row = iter.stack.last().unwrap();\n            let mut row: Vec<&'tree Tree> = vec![];\n            last_row.iter().for_each(|&node| {\n                if node.left.is_some() {\n                    row.push(node.left.as_ref().unwrap());\n                }\n\n                if node.right.is_some() {\n                    row.push(node.right.as_ref().unwrap());\n                }\n            });\n\n            if row.is_empty() {\n                break;\n            }\n\n            iter.stack.push(row);\n        }\n\n        iter.stack.reverse();\n\n        iter\n    }\n}\n\nimpl<'tree> Iterator for LevelIter<'tree> {\n    type Item = Vec<String>;\n    fn next(&mut self) -> Option<Self::Item> {\n        self.stack\n            .pop()\n            .map(|row| row.iter().map(|&tree| tree.value.to_owned()).collect())\n    }\n}\n```\n\n所有的迭代器语法里面都有个类似于泛型的`<'tree>`，这里就是 Rust 的生命周期，每一个迭代器都有一个自身的生命周期和对应的二叉树的生命周期，这里需要向编译器指明这个对象有两个生命周期，以及哪些变量的生命周期不同。\n","collection":"blog","data":{"type":"post","category":"tech","tag":["algorithm","Rust"]}}]}