{"posts":[{"id":"2022/09/08/kmp.md","slug":"2022/09/08/kmp","body":"\n# KMP 匹配算法\n\n要从一个字符串 ababcabcacbababcac 中查中一个片段如 abcac 可以使用 KMP 算法。\n\nKMP 算法，简单来说就是先从要匹配的字符串中找到重复的字缀，并将这些字缀标记跳过的字数以做到匹配时剪掉不许匹配的次数。\n\n- a，首位和末尾没有重复即为 0\n- ab，首位和末尾没有重复即为 0\n- abc，首位和末尾没有重复即为 0\n- abca，首位和末尾有一位重复 a，记为 1\n- abcac，首位和末尾没有重复即为 0\n\n```js\nvar next = ArrayList(usize).init(allocator);\ndefer next.deinit();\n\nfor (word) |_, inext| {\n     if (inext == 0) {\n         try next.append(0);\n         continue;\n    }\n\n     var imatched = next.items[inext - 1];\n     while (imatched > 0 and word[imatched] != word[inext]) {\n            imatched = next.items[imatched - 1];\n     }\n\n     if (word[imatched] == word[inext]) {\n        try next.append(imatched + 1);\n     } else {\n         try next.append(imatched);\n     }\n}\n```\n\n得到匹配列表为 00010，这里的数字对应每个字母的序号 01234，假设匹配长字符串的时候刚好匹配到 abcac 的时候（第五位）没有匹配上，就看`c`前面的字符`a`对应的匹配值，这里是 1，指的可以从字符串中序号为 1 的字符，这里是`b`，继续匹配。\n\n```js\n    var iword: usize = 0;\n    for (str) |c, istr| {\n        while (c != word[iword] and iword > 0) {\n            iword = next.items[iword - 1];\n        }\n\n        if (c == word[iword]) {\n            iword += 1;\n        }\n\n        if (iword == word.len) {\n            try res.append(istr - iword + 1);\n            iword = next.items[iword - 1];\n        }\n    }\n```\n","collection":"blog","data":{"type":"post","category":"tech","tag":["algorithm","zig"]}}]}