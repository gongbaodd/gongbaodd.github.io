{"posts":[{"id":"2020/05/10/Flutter.md","slug":"2020/05/10/flutter","body":"\n# Flutter 的手表应用-从入门到放弃\n\n这是一个写得一头沮丧的文章，可能是期待值比较高吧，所以任何一个想用 Flutter 写 wearOS 的朋友都要注意一点，他能写，但可能没那么好。这篇文章本来想参考[Flutter: Building Wear OS app](https://medium.com/flutter-community/flutter-building-wearos-app-fedf0f06d1b4)，因为`wear`这个包已经年久失修不支持最新的 SDK（我天，这可是 2019 年 6 月的文章），于是后来参考[Experimenting with Flutter on Wear OS](https://medium.com/@mjohnsullivan/experimenting-with-flutter-on-wear-os-f789d843f2ef)。如果不想踩坑，只是想写个应用截图发朋友圈的话，直接 clone[这个 repo](https://github.com/sbis04/flutter_os_wear)就好，热爱生命，避免折腾，哈哈。\n\n## 可以用 Flutter 来写手表应用吗\n\n答案是可以的，而且还意料之外地能用。首先要在本机安装模拟器（注意不要安装中国版，中国版真的会卡住）。然后直接运行 flutter 的官方示例就可以了。\n\n![模拟器下的Flutter示例](./2020-05-10-flutter-watch.png)\n\n## 表盘形状\n\n在 Flutter 中可以使用 MediaQuery 获取到屏幕的大小：\n\n```dart\nfinal screenSize = MediaQuery.of(content).size;\nfinal screenHeight = screenSize.height;\nfinal screenWidth = screenSize.width;\n```\n\n但是不能获取到表盘的形状，但是可以通过 kotlin 从安卓 Wear OS 的库里面获取。Flutter 为 Dart 提供了一个支持双向传输的数据通道[MethodChannels](https://flutter.io/platform-channels/)，比起 QML，这更像 JS bridge 的实现，因为这些数据是异步传输的，这些数据也可以通过流传输[EventChannels](https://docs.flutter.io/flutter/services/EventChannel-class.html)。\n\n在安卓的 MainActivity 中可以调用如下方法向 Flutter 传递表盘状态，注意因为是 Wear OS，所以在`Android/app/build.gradle`修改`minSdkVersion`为 23，并在以下依赖中增加以下项目。\n\n```gradle\ndependencies {\n    ...\n    implementation 'com.android.support:wear:27.1.1'\n    implementation 'com.google.android.support:wearable:2.3.0'\n    compileOnly 'com.google.android.wearable:wearable:2.3.0'\n    ...\n}\n```\n\n`AndroidManifest.xml`中打开权限。\n\n```xml\n<!-- Required for ambient mode support -->\n<uses-permission android:name=\"android.permission.WAKE_LOCK\" />\n\n<!-- Flags the app as a Wear app -->\n<uses-feature android:name=\"android.hardware.type.watch\" />\n\n<!-- Flags that the app doesn't require a companion phone app -->\n<application>\n<meta-data\n    android:name=\"com.google.android.wearable.standalone\"\n    android:value=\"true\" />\n</application>\n```\n\n```kotlin\nprivate fun setShapeMethodChannel() {\n  MethodChannel(flutterView, shapeChannel).setMethodCallHandler { _, result ->\n    setOnApplyWindowInsetsListener(flutterView, {_, insets: WindowInsetsCompat? ->\n      if (insets?.isRound == true) {\n        result.success(0)\n      }\n      else {\n        result.success(1)\n      }\n      WindowInsetsCompat(insets)\n    })\n    requestApplyInsets(flutterView)\n  }\n}\n```\n\n在 Dart 部分通过监听 channel 获得形状\n\n```dart\nenum Shape { square, round };\nShape shape;\ntry {\n  final int result = await platform.invokeMethod('shape');\n  shape = result == 1 ? Shape.square : Shape.round;\n} on PlatformException catch (e) {\n  // Default to round\n  print('Error detecting shape: $e');\n  shape = Shape.round;\n}\n```\n\n## 省电模式(Ambient mode)\n\n手表耗电是很棘手的，所以安卓手表的应用都会选择支持长期显示时进入省电模式（我就惊了，你说用电子纸多好，偏偏所有人都用 LED，又不是拿手表看片，要那么好的显示搞什么？）。\n\n可以在 kotlin 部分获取省电模式的事件并通过 channel 传给 dart。\n\n```kotlin\nclass MainActivity: FlutterActivity(), AmbientMode.AmbientCallbackProvider {\n    private var mAmbientController: AmbientMode.AmbientController? = null\n    override fun onCreate(savedInstanceState: Bundle?) {\n        // Set the Flutter ambient callbacks\n        mAmbientController = AmbientMode.attachAmbientSupport(this)\n    }\n    override fun getAmbientCallback(): AmbientMode.AmbientCallback {\n        return FlutterAmbientCallback(flutterView)\n    }\n}\n\nprivate class FlutterAmbientCallback(val flutterView: FlutterView): AmbientMode.AmbientCallback() {\n    override fun onEnterAmbient(ambientDetails: Bundle) {\n        MethodChannel(flutterView, ambientChannel).invokeMethod(\"enter\", null)\n        super.onEnterAmbient(ambientDetails)\n    }\n    override fun onExitAmbient() {\n        MethodChannel(flutterView, ambientChannel).invokeMethod(\"exit\", null)\n        super.onExitAmbient()\n    }\n    override fun onUpdateAmbient() {\n        MethodChannel(flutterView, ambientChannel).invokeMethod(\"update\", null)\n        super.onUpdateAmbient()\n    }\n}\n```\n\n在 Dart 部分处理事件。\n\n```dart\n@override\ninitState() {\n    super.initState();\n    platformAmbient.setMethodCallHandler((call) {\n        switch (call.method) {\n            case 'enter':\n                setState(() => ambientMode = Mode.ambient);\n            break;\n        case 'update':\n            if (widget.update != null)\n                widget.update();\n            else\n                setState(() => ambientMode = Mode.ambient);\n        break;\n        case 'exit':\n            setState(() => ambientMode = Mode.active);\n        break;\n    }\n  });\n}\n```\n\n## 总结\n\nFlutter 能写安卓应用吗？能，而且比不好用要强得多。但是如果想写出 apple watch 的应用那种，还是道阻且长。不过考虑 wear OS 本身自己的应用都不咋地，感兴趣玩一下还是可以的。\n\n另外 Flutter 没有为 wearOS 设计 Material 设计语言的部件，所以都要自己设计（虽然屏幕也就 1~2 英寸）。也没有左滑后退的能力，只能在界面增加一个后退按钮，如果用户不小心左滑了，应用就关闭了（尴尬）。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["flutter","wearOS"]}}]}