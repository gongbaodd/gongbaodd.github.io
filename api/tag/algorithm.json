{"posts":[{"id":"2022/08/17/Rust.md","slug":"2022/08/17/rust","body":"\n# Rust 实现的几个排序算法\n\n## 冒泡排序\n\n$O(n^2)$ 稳定排序\n\n选择每个元素和后面的作比较，如果前面的元素比后面的大，就交换两个元素的位置。\n\n```rust\nfn bubble_sort<T: Ord>(arr: &mut [T]) {\n    for i in 0..arr.len() {\n        for j in i..arr.len() {\n            if arr[i] > arr[j] {\n                arr.swap(i, j);\n            }\n        }\n    }\n}\n```\n\n## 插入排序\n\n$O(n^2)$ 稳定排序\n\n假定只有两个元素并排好序，每次再插入新的元素，直到全部元素都插入。\n\n```rust\nfn insert<T: Ord>(arr: &mut [T]) {\n    for i in 1..arr.len() {\n        let mut j = i;\n        while j > 0 && arr[j] < arr[j-1] {\n            arr.swap(j, j-1);\n            j -= 1;\n        }\n    }\n}\n```\n\n## 快速排序\n\n期望$O(n\\log{n})$，最坏情况$O(n^2)$，不稳定排序\n\n选中一个元素，把小于它的元素放到左边，再把大于它的放到右边，再继续处理两边数据。\n\n```rust\nfn quick<T:Ord>(arr: &mut [T]) {\n    _quick(arr, 0, (arr.len() - 1) as isize);\n}\n\nfn _quick<T:Ord>(arr: &mut [T], start: usize, end: isize) {\n    if start > end {\n        return;\n    }\n\n    let pivot = partition(arr, start, end as isize);\n    _quick(arr, start, (pivot) as isize - 1);\n    _quick(arr, pivot + 1, end);\n}\n\nfn partition<T:Ord>(arr: &mut [T], mut low: usize, mut high: usize) -> usize {\n    let pivot = 0;\n\n    loop {\n        if low < high && data[low] < pivot {\n            low += 1;\n        }\n        data.swap(low, high);\n\n        if low < high && data[high] > pivot {\n            high -= 1;\n        }\n        data.swap(low, high);\n\n        if low == high {\n            break;\n        }\n    }\n\n    low\n}\n```\n\n## 归并排序\n\n$O(n\\log{n})$ 稳定排序\n\n将两个有序数组合并为一个有序数组\n\n```rust\nfn merge<Ord:T>(arr: &mut [T]) {\n    let length = arr.len();\n    let middle = length / 2;\n\n    if length > 1 {\n        let a = arr[0..middle];\n        let b = arr[middle..length];\n        merge(a);\n        merge(b);\n\n\n    }\n}\n\nfn sort<Ord: T>(a: &[T], b: &[T], arr: &mut[T]) {\n    let mut ia = 0;\n    let mut ib = 0;\n    let mut i = 0;\n\n    while ia < arr.len() && ib < arr.len() {\n        if a[ia] < b[ib] {\n            data[i] = a[ia];\n            ia += 1;\n        } else {\n            data[i] = b[ib];\n            ib += 1;\n        }\n        i += 1;\n    }\n\n    if ia < arr.len() {\n        data[..i].copy_from_slice(&a[ia..]);\n    }\n\n    if ib < arr.len() {\n        data[..i].copy_from_slice(&b[ib..]);\n    }\n}\n```\n\n## 希尔排序\n\n$O(n\\log^2{n})$不稳定排序\n\n升级版的插入排序，每隔一个 gap 进行一次排序，直到 gap 缩到 1。\n\n```Rust\nfn shell<T: Ord>(arr: &mut [T]) {\n    let length = arr.len();\n    let mut gap = length / 2;\n\n    while gap > 0 {\n        for i in gap..length {\n            let mut j = i;\n            while j > gap & data[j] < data[j-gap] {\n                data.swap(j, j-gap);\n                j -= gap;\n            }\n        }\n        gap /= 2;\n    }\n}\n```\n\n## 堆排序\n\n$O(n\\log{n})$不稳定排序\n\n将数组转换成大顶堆，把作为根的最大值排到数组最后，再去除最大值重新排序。\n\n```Rust\nfn heap(data: &mut Vec<i32>) {\n    if data.len() < 2 {\n        return ;\n    }\n\n    // build one max heap\n    let last_root = (data.len() + 2) / 2;\n    for root in (0..=last_root).rev() {\n        to_max_heap(data, root, data.len() - 1);\n    }\n\n    // replace the first element(max element) to the last\n    // make max heap using the other elements\n    for last in (1..data.len()).rev() {\n        data.swap(0, last);\n        to_max_heap(data, 0, last-1);\n    }\n}\n\nfn to_max_heap(data: &mut Vec<i32>, mut root: usize, last: usize) {\n    loop {\n        let left = root * 2 + 1;\n        let right = left + 1;\n        let max_child;\n\n        if left > last {\n            break;\n        }\n\n        if right > last {\n            max_child = left;\n        } else {\n            max_child = if data[right] > data[left] {\n                right\n            } else {\n                left\n            }\n        }\n\n        if data[max_child] > data[root] {\n            data.swap(max_child, root);\n        }\n\n        root = max_child;\n    }\n}\n```\n\n另外还有很多排序算法参考[https://github.com/TheAlgorithms/Rust/tree/master/src/sorting](https://github.com/TheAlgorithms/Rust/tree/master/src/sorting)\n\n## bogo 排序\n\n$O(n\\times n!)$\n\n随机排列直到排序完成\n\n## 桶排序(Bucket Sort)\n\n$O(n)$ 稳定排序\n\n先对元素分类，如 0-10，10-20...然后在每个桶中进行排序\n\n## 鸡尾酒排序(cocktail Sort)\n\n$O(n^2)$ 稳定排序\n\n冒泡排序的变形，先向上冒泡，再进行一次下沉，是两个方向的冒泡排序。\n\n## 梳排序(Comb sort)\n\n$O(n\\log{n})$ 不稳定排序\n\n用希尔排序的方法进化冒泡排序，衰减值默认选 1.3 效率最高\n\n## 计数排序\n\n$O(n+k)$ 稳定排序\n\n新建一个 k 元素的计数数组，k 为排序数组的取值空间，有值的计数数组键值就是排序结果。\n\n## 基数排序(Radix sort)\n\n$O(k\\cdot n)$\n\n按照个位、十位、百位...排序\n\n## Tim sort\n\n长度小于 64 的数组进行二分插入排序，大于 64 的数组进行归并排序，归并排序在比较大于 minrun 时直接对接数组。\n","collection":"blog","data":{"type":"post","category":"tech","tag":["algorithm","Rust"]}},{"id":"2022/09/08/Traversing-a-binary-tree.md","slug":"2022/09/08/traversing-a-binary-tree","body":"\n# 遍历二叉树\n\n遍历二叉树其实也不难，就是利用栈的思维实现遍历挺有意思的，另外在写迭代器的时候还会用的 Rust 的生命周期，刚好能够对 Rust 的生命周期有更多的理解。\n\n## 遍历方法\n\n- 先序遍历，根左右\n- 中序遍历，左根右\n- 后序遍历，左右根\n- 按层遍历\n\n先序遍历，先把跟压入栈，执行 next 出栈取值，并将右子树和左子树压入栈，直到栈空，返回 None。\n\n```Rust\nstruct TreeIter<'tree> {\n    order: Order,\n    stack: Vec<&'tree Tree>,\n}\n\nimpl<'tree> TreeIter<'tree> {\n    pub fn new(tree: &Tree) -> TreeIter {\n            TreeIter {\n                stack: vec![tree],\n                order,\n            }\n    }\n}\n\nimpl<'tree> Iterator for TreeIter<'tree> {\n    type Item = String;\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.stack.is_empty() {\n            return None;\n        }\n\n        let item = self.stack.pop().unwrap();\n\n        if item.right.is_some() {\n            self.stack.push(item.right.as_ref().unwrap());\n        }\n\n        if item.left.is_some() {\n            self.stack.push(item.left.as_ref().unwrap());\n        }\n\n        Some(item.value.to_owned())\n    }\n}\n```\n\n中序遍历，先把根的左手边按节点拆成几棵没有左子树的树压入栈，执行 next 的时候逐一弹出，如果弹出的子树有右子树，把右子树也拆成没有左子树的子树压入栈。\n\n```Rust\nstruct TreeIter<'tree> {\n    order: Order,\n    stack: Vec<&'tree Tree>,\n}\n\nimpl<'tree> TreeIter<'tree> {\n    pub fn new(tree: &Tree) -> TreeIter {\n        let mut iter = TreeIter {\n            stack: vec![tree],\n            order,\n        };\n\n        while let Some(node) = &iter.stack.last().unwrap().left {\n            iter.stack.push(node);\n        }\n\n        iter\n    }\n}\n\nimpl<'tree> Iterator for TreeIter<'tree> {\n    type Item = String;\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.stack.is_empty() {\n            return None;\n        }\n        let item = self.stack.pop().unwrap();\n        if item.right.is_some() {\n           self.stack.push(item.right.as_ref().unwrap());\n              while let Some(node) = &self.stack.last().unwrap().left {\n                  self.stack.push(node);\n              }\n        }\n\n        Some(item.value.to_owned())\n    }\n}\n```\n\n后序遍历，相比于前两个准备工作多一些，需要两个栈，第一个栈按照先序遍历一样压栈，不同的是，先序遍历为了先出栈左子树（根左右）而先压栈右子树，这里要先压栈左子树。第一个栈的出栈元素直接压入第二个栈。执行 next 时，直接从第二个栈出栈即可。\n\n```Rust\nstruct TreeIter<'tree> {\n    order: Order,\n    stack: Vec<&'tree Tree>,\n}\n\nimpl<'tree> TreeIter<'tree> {\n    pub fn new(tree: &Tree) -> TreeIter {\n            let mut iter = TreeIter {\n                stack: vec![],\n                order,\n            };\n            let mut stack = vec![tree];\n            while !stack.is_empty() {\n                let node = stack.pop().unwrap();\n                iter.stack.push(node);\n                if node.left.is_some() {\n                    stack.push(node.left.as_ref().unwrap());\n                }\n                if node.right.is_some() {\n                    stack.push(node.right.as_ref().unwrap());\n                }\n            }\n            iter\n    }\n}\n\nimpl<'tree> Iterator for TreeIter<'tree> {\n    type Item = String;\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.stack.is_empty() {\n            return None;\n        }\n\n        let item = self.stack.pop().unwrap();\n        Some(item.value.to_owned())\n    }\n}\n```\n\n按层遍历，就是把每一层的节点按层压入栈\n\n```Rust\nstruct LevelIter<'tree> {\n    stack: Vec<Vec<&'tree Tree>>,\n}\nimpl<'tree> LevelIter<'tree> {\n    pub fn new(tree: &'tree Tree) -> LevelIter {\n        let mut iter = LevelIter {\n            stack: vec![vec![tree]],\n        };\n\n        loop {\n            let last_row = iter.stack.last().unwrap();\n            let mut row: Vec<&'tree Tree> = vec![];\n            last_row.iter().for_each(|&node| {\n                if node.left.is_some() {\n                    row.push(node.left.as_ref().unwrap());\n                }\n\n                if node.right.is_some() {\n                    row.push(node.right.as_ref().unwrap());\n                }\n            });\n\n            if row.is_empty() {\n                break;\n            }\n\n            iter.stack.push(row);\n        }\n\n        iter.stack.reverse();\n\n        iter\n    }\n}\n\nimpl<'tree> Iterator for LevelIter<'tree> {\n    type Item = Vec<String>;\n    fn next(&mut self) -> Option<Self::Item> {\n        self.stack\n            .pop()\n            .map(|row| row.iter().map(|&tree| tree.value.to_owned()).collect())\n    }\n}\n```\n\n所有的迭代器语法里面都有个类似于泛型的`<'tree>`，这里就是 Rust 的生命周期，每一个迭代器都有一个自身的生命周期和对应的二叉树的生命周期，这里需要向编译器指明这个对象有两个生命周期，以及哪些变量的生命周期不同。\n","collection":"blog","data":{"type":"post","category":"tech","tag":["algorithm","Rust"]}},{"id":"2022/09/08/kmp.md","slug":"2022/09/08/kmp","body":"\n# KMP 匹配算法\n\n要从一个字符串 ababcabcacbababcac 中查中一个片段如 abcac 可以使用 KMP 算法。\n\nKMP 算法，简单来说就是先从要匹配的字符串中找到重复的字缀，并将这些字缀标记跳过的字数以做到匹配时剪掉不许匹配的次数。\n\n- a，首位和末尾没有重复即为 0\n- ab，首位和末尾没有重复即为 0\n- abc，首位和末尾没有重复即为 0\n- abca，首位和末尾有一位重复 a，记为 1\n- abcac，首位和末尾没有重复即为 0\n\n```js\nvar next = ArrayList(usize).init(allocator);\ndefer next.deinit();\n\nfor (word) |_, inext| {\n     if (inext == 0) {\n         try next.append(0);\n         continue;\n    }\n\n     var imatched = next.items[inext - 1];\n     while (imatched > 0 and word[imatched] != word[inext]) {\n            imatched = next.items[imatched - 1];\n     }\n\n     if (word[imatched] == word[inext]) {\n        try next.append(imatched + 1);\n     } else {\n         try next.append(imatched);\n     }\n}\n```\n\n得到匹配列表为 00010，这里的数字对应每个字母的序号 01234，假设匹配长字符串的时候刚好匹配到 abcac 的时候（第五位）没有匹配上，就看`c`前面的字符`a`对应的匹配值，这里是 1，指的可以从字符串中序号为 1 的字符，这里是`b`，继续匹配。\n\n```js\n    var iword: usize = 0;\n    for (str) |c, istr| {\n        while (c != word[iword] and iword > 0) {\n            iword = next.items[iword - 1];\n        }\n\n        if (c == word[iword]) {\n            iword += 1;\n        }\n\n        if (iword == word.len) {\n            try res.append(istr - iword + 1);\n            iword = next.items[iword - 1];\n        }\n    }\n```\n","collection":"blog","data":{"type":"post","category":"tech","tag":["algorithm","zig"]}}]}