{"posts":[{"id":"2020/02/22/hoisting.md","slug":"2020/02/22/hoisting","body":"\n# 我也谈谈 hoisting\n\n最近在看 getify 的[You-Dont-Know-JS](https://github.com/getify/You-Dont-Know-JS)，第二版里面相对于第一版增加了很多个人认为比较硬核的东西。第二版貌似对 var 关键字进行了洗白，就目前来看还是比较争议的，毕竟这几年来我基本上已经用 let 完全替代 var 了。\n\n最近我正好是在学习 Rust，首先说明一下 Rust 的确是一个不太好学习的语言，但是学会了之后就会对编译原理有更高更深一层次的认识（同样学会了 typescript，也会有类似的感觉）。\n\n那也许是时代的问题。人们发现面向对象并不是万能的，面向函数逐渐的从原来不受人注意，变的受人理解。尤其是最近我还跟一些人在讨论到一些面向对象的继承属性。以后的以后的继承，将逐渐被组合所替代。甚至是 rust，里面已经没有了继承关系。而最受欢迎的前端框架 react 框架也逐渐的使用函数来替代对象。\n\n那么我们现在回顾一下，2015 年，那年 TC39 发布了 ECMA2015，包括块级作用域，let，class 等关键字。当时 JavaScript 的作者，Brendan Eich 就说他不赞成这个对象的设计，但是显然很多人没有理解，当然后来还发生了关于 class 成员是否跟分号的 bug。\n\n那么现在我们把当年的事情再拿出来看一看。Hoisting 这个 JavaScript 独有的特性，是不是一个鸡肋的 bug。\n\n参考 BrendanEich 老爷子自己的[话](https://twitter.com/brendaneich/status/562313394431078400)\n\n> function declaration hoisting is for mutual recursion & generally to avoid painful bottom-up ML-like order\n\n> `var` hoisting was an implementation artifact. `function` hoisting was better motivated.\n\n首先是 ML 这个语言呢也是一个基于函数的语言。但是跟 js 不太一样的是，这个语言就没有 hoisting，所以呢，看代码就只能是一行一行的看下去，比较麻烦。\n\n至于 var 的提升，则是实现 function 带来的人工产物。\n\n想一想 2015 年之前我们写前端 js 代码的时候，往往会把依赖的 function 放到最底下。\n\n```javascript\nfunction foo() {\n  bar1();\n  bar2();\n  bar3();\n\n  return;\n\n  function bar1() {}\n\n  function bar2() {}\n\n  function bar3() {}\n}\n```\n\n其实就像你现在这个角度来观察这个代码，也会觉得。这个语言的确有它的独到之处。这样的写法，直接通过 return 关键字，把一个函数分成了构造函数部分和他的私有成员。如果想要了解这个函数的功能的话，大可不必把所有的函数都看一遍。\n\n自从有了块级作用域，JavaScript 就必须要考虑，同时存在块级作用域和函数作用域的情况，就出现了 TDZ 的情况。简单讲就是说，就是块级作用域，变量不能被重复声明，即使是使用函数声明，而以前的 var 关键字是可以重新定义的（当然重新定义的时候没有重新赋值，因为提升的关系重新定义，并不存在）。\n\n```javascript\n{\n  let foo = \"foo\";\n  var foo; // wrong\n}\n```\n\n```javascript\n{\n  var foo = \"foo\";\n  let foo; // wrong\n}\n```\n\n那么块级作用域有没有提升呢？那肯定是有的，因为如果你想判断这个作用域下面的变量是不是被重新定义了，还是要预先申请内存的。只不过在他声明之前被使用的话，相比于函数变量返回未定义的值，块级作用域会报错。\n\n所以我们一般会把块级作用域变量定义放在这个块儿的最上面，来消除 TDZ。\n\n但是把定义放在最上面的话，就如之前所说的失去了 JavaScript 初衷的优雅。所以 function 和 var 关键字并不一定被宣判死刑，而是在特定的情况下还能被拿出来使用。\n\n不过，话说回来，优雅的东西不一定就是所有人喜欢的。块级作用域对 C 语言使用者来说没有学习障碍，工程上还是少数服从多数，选择最简单的而不是选择最对也存在合理性，所以即使现在面向对象逐渐失宠也不一定将来也会被摒弃。\n\n另外，Eich 和 Crockford 还有一篇访谈，可以看一下。\n\n[Eich and Crockford on the Future of JavaScript: Insight from the Creators of JavaScript and JSON](https://www.infoq.com/news/2018/07/eich-crockford-js-future/)\n","collection":"blog","data":{"type":"post","category":"fe","tag":["JavaScript"]}},{"id":"2020/02/25/stryker-mutation test.md","slug":"2020/02/25/stryker-mutation-test","body":"\n# 使用 stryker 做 mutation test\n\n今年年初的时候，我整理了一下前端测试现状，有一项就是 mutation test。本文将会讲一下如何给 typescript 项目添加 mutation test。\n\n## Stryker-mutator\n\n首先，为项目安装 stryker 全家桶。\n\n```shell\nyarn add -D stryker-typescript stryker-jest-runner stryker-html-reporter stryker-api stryker\n```\n\n你可能会接到升级的警告，我发现最新版本（以@stryker-mutator 做域）会有 bug，而且 github 上面显示 CI 编译失败，保守起见，还是使用老版本比较好。\n\n执行`yarn stryker init`初始化项目，修改 stryker.conf.js，详细的参数说明可以参考[这里](https://github.com/stryker-mutator/stryker/tree/master/packages/core)。\n\n```javascript\nmodule.exports = function stryker(config) {\n  config.set({\n    mutator: \"typescript\",\n    mutate: [\"src/linked_node/**/*.ts\", \"!src/**/*.spec.ts\"],\n    packageManager: \"yarn\",\n    reporters: [\"clear-text\", \"dashboard\", \"progress\", \"html\"],\n    testRunner: \"jest\",\n    coverageAnalysis: \"off\",\n    tsconfigFile: \"tsconfig.json\",\n    dashboard: {\n      reportType: \"full\",\n    },\n  });\n};\n```\n\n注意，官网的 tutorial 会要求添加 transpilor 为 typescript，这里因为我们的测试 runner 是已经配置好的 jest，所以不能再添加一次编译。\n\n执行`yarn stryker run`就能执行测试，这个测试很占用性能，我这 10 代 i7 的本都要跑 8 分钟左右，执行成功会生成报告存储在 reports 文件夹下。\n\n## 配置 travis\n\nstryker 官方提供[dashboard](https://dashboard.stryker-mutator.io)，登入配置好环境变量即可生成 stryker 的徽章，可以把它贴到 github 的 readme 中。这样，每次 travis 执行好 mutation test 后都能更新徽章分数。\n\n关于 dashboard 如何配置可以参考[handbook](https://github.com/stryker-mutator/stryker-handbook/blob/master/dashboard.md)。\n\n但是我没能成功上传 report，只能显示出分数，并不确定哪里出了问题，还是看官方如何更新吧。\n\n## 原理\n\n如果我有以下函数，并配合 100%测试覆盖的单元测试。\n\n```typescript\nfunction isGe18(num: number) {\n  return num >= 18;\n}\n\ndescribe(\"the input is 1\", () => {\n  it(\"should return false\", () => {\n    expect(isGe18(1)).toBe(false);\n  });\n});\n```\n\n显然以上的测试是不完备的，那么 stryker 如何找到它不完备的地方？首先修改函数的返回值，如生成如下四个函数。\n\n```typescript\nfunction isGe18_1(num: number) {\n  return num > 18;\n}\nfunction isGe18_2(num: number) {\n  return num < 18;\n}\nfunction isGe18_3(num: number) {\n  return true;\n}\nfunction isGe18_3(num: number) {\n  return false;\n}\n```\n\n分别用他们重新跑测试，只要有一个测试失败，就称这个 mutate 被 killed，如果测试全部通过，则称 mutate 被 survived。\n则对应上面例子：\n\n- isGe18_1 => survived\n- isGe18_2 => killed\n- isGe18_3 => killed\n- isGe18_3 => survived\n\n则此时需要增加测试\n\n```typescript\ndescribe(\"the input is 19\", () => {\n  it(\"should return true\", () => {\n    expect(isGe18(19)).toBe(true);\n  });\n});\n\ndescribe(\"the input is 18\", () => {\n  it(\"should return true\", () => {\n    expect(isGe18(18)).toBe(true);\n  });\n});\n```\n\n重新跑测试\n\n- isGe18_1 => killed（最后一个测试未通过）\n- isGe18_2 => killed\n- isGe18_3 => killed\n- isGe18_3 => killed（新增加的 2 个测试未通过）\n\n此时测试才是完备的。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["test","stryker","javascript"]}},{"id":"2020/03/09/JS.md","slug":"2020/03/09/js","body":"\n# 读完「你不知道的 JS」第一版\n\n![book cover](./you-dont-know-about-JS.jpg)\n\n「你不知道的 JS」是[getify](https://github.com/getify)的一本关于深究 JavaScript 的书，中文版分为三册，前一阵子发现作者正在更新第二版，读了几页真的不错，于是找来第一版读了下。\n\n第一版第一册就是深究词法、上下文，这些东西大部分书都提的比较少，说实话，虽然我已经了解了，但是总是忘。这本书第二版比第一版好太多了，有兴趣的可以去读一下。\n\n第二册，异步，关于 promise 和生成器，应该是现有的关于异步写的最详细的书了，不过我更感兴趣他能更深度讲解一下 observable，虽然这个还不是 JavaScript 的标准。\n\n第三册，ES6 相关，很有趣的是，真本书前半部分都是关于第一第二册的简述，所以如果你刚好上不了网只能买书的话，直接看这一本也差不多。\n\n后面我可能会读一下书中推荐的[Functiional Light JS](https://github.com/getify/Functional-Light-JS)，以及 2ality 写的[Deep JavaScript: Theory and techniques](https://exploringjs.com/deep-js/)。\n","collection":"blog","data":{"type":"post","category":"book","tag":["JavaScript"]}},{"id":"2020/03/21/Functional-Light-JS.md","slug":"2020/03/21/functional-light-js","body":"\n比较简单的一本[开源书](https://github.com/getify/Functional-Light-JS)，大概算函数式编程的入门书+JavaScript 部分介绍了。\n\n推荐章节：\n\n- 第四章，为什么要减少函数参数以及柯里化，这样有利于使用 compose 函数组合步骤。\n- 第八章，递归，利用 es6 上面的尾递归调用提高代码可读性。\n- 附录 A，提高性能，减少运算损耗。\n","collection":"blog","data":{"type":"post","category":"book","tag":["JavaScript","functinal-programming"]}},{"id":"2020/03/27/svelte.md","slug":"2020/03/27/svelte","body":"\n# Svelte 让人眼前一亮的前端框架\n\n我觉得必须要介绍一下 [svelte](https://svelte.dev/) 这个框架，确切的说是 svelte v3，这应该是继 [riotjs](http://riot.js.org/)、[typescript](https://www.typescriptlang.org/) 和 [rust](https://www.rust-lang.org/) 之后又一个能给我眼前一亮的感觉的产品了。\n\n## 关于 Svelte\n\n不得不提到他的作者 [Rich Harris](https://github.com/Rich-Harris)，提到他的另一个作品就是大名鼎鼎的 [rollup](http://rollupjs.org/)，这可是第一个提出 tree-shaking 的前端打包器（说实话，这导致我有更多的担忧，svelte 可能会变成像 rollup 一样的小众狂欢）。\n\n回到 svelte，他从 v1 的时候目标就是简单，只不过 v1 版本看起来太像 zepto 了（那我为什么不用原生 JavaScript）。不过 v3 版本这个框架换了个方向，从框架变成了编译器，类似于 riotjs 和 vuejs，组件的 html、css 和 js 可以写在一起，其实我并不是特别推崇这种做法，往往有时候我更倾向于 angularJS 的做法，但是 svelte 的处理真的太完美。\n\n```html\n<script>\n  const hello = \"world\";\n</script>\n\n<h1>{hello}</h1>\n\n<style>\n  h1 {\n    color: black;\n  }\n</style>\n```\n\n看到了吗？没有多出来的 `Vue.extend()`，HTML 和 JavaScript 部分的交互竟然这儿么完美！要是 CSS 再加把力就更好了（不过如果是 CSS in JS 的话...那还是用某个 preprocessor 勉强一下好了）。HTML 模板类似比较简单的 handlebars 语法，甚至支持异步模板。\n\n另外 svelte 没有虚拟 DOM，这一点我有一些相见恨晚，我之前就写过[文章](/fe/2016/03/31/VUE&Riot&React实力比较.html)质疑虚拟 DOM 是不是真的能带来性能提高（结果是性能很差），但是最终被人喷了，导致一年后不得不[弃坑 riotjs 改用 preact](/fe/2017/05/15/弃坑Riot转向Preact.html)。但我始终认为虚拟 DOM 更是一个范式而不是能带来性能提升的神器。所以你代码差，换什么范式，性能都差，喷别人之前先称称自己几斤几两好么？\n\nsvelte 符合响应式模式，这一点和 riotjs 很类似，借助 svelte 这个编译器，写好的组件会被编译成响应式函数。也许拿 riotjs 做比方会比较难，这里拿 react 做比方，在 react 中实现响应式需要使用`setState()`。\n\n```JavaScript\nconst Com = () => {\n    const [state, setState] = useState(1);\n    useEffect(() => setState(state + 1), [])\n    const stateX2 = state*2;\n\n    return (\n    <>\n        <div>{state*2}</div>\n        <div>{stateX2}</div>\n    </>\n    );\n}\n/* 输出\n * <div>2</div>\n * <div>2</div>\n*/\n```\n\n而由于 svelte 是个编译器，svelte 里面不仅代码更少，而且正确的输出了`stateX2`的值。\n\n```HTML\n<script>\nimport { onMount } from \"svelte\";\n\nlet state = 1;\n\nonMount(() =>  state += 1);\n\n$: let stateX2 = state * 2;\n</script>\n\n<div>{state}</div>\n<div>{stateX2}</div>\n\n<!--\n    输出\n    <div>2</div>\n    <div>4</div>\n-->\n```\n\n没错，完全没有多余的代码（其实 svelte 编译器会默默地给`state`增加一个`observable`的配置，但是这都是编译器自己做的，开发者完全不需要考虑）。这里发现`stateX2`前面有一个`$`标识，表明后面的语句是响应式的。这一点真的很巧妙，因为这个语法是 JavaScript 标准里百年不遇的`goto`语句，svelte 高明的使用 JavaScript 原有的语法实现了新的功能，不像某框架愣是加了一个 JSX 语法（不是鄙视 JSX，JSX 也很牛逼的说）。\n\n在 n 多个框架都在模仿 react 的主流下，这个框架还能别出心裁，不得不赞，如果你感兴趣，我强烈推荐浏览他们的[例子](https://svelte.dev/examples#hello-world)。store 和 context 都非常有启发。\n\n最大的缺点就是目前还没有官方的 TypeScript 支持，这一点很有尴尬，因为 svelte 本身就是 TypeScript 写的。不过现在有第三方的[svelte-preprocess](https://github.com/kaisermann/svelte-preprocess)对 TypeScript 提供支持，不知道啥时候转正。\n\n## Sapper\n\nriotjs 同样没有虚拟 DOM，这使得它在 SSR 方面会[有一些问题](https://riot.js.org/documentation/#riot-dom-caveats)，但是 Svelte 提供了一套 SSR 解决方案，[sapper](https://sapper.svelte.dev/) 同时支持 node 渲染和静态发布。\n\nSapper 受 next.js 启发，使用`src/route`文件夹下的文件做路由。\n\n```\nsrc/routes\n    _layout.svelte -- 布局文件\n    _error.svelte  -- 404目录\n    index.svelte   -- /或者/index\n    posts.json.js  -- /post.json，可以使用类似express路由的方式写接口\n```\n\n想要在 index 里面实现 server 端的预加载，可以使用 sapper 的 preload API。\n\n```html\n<script context=\"module\">\n  export async function preload(page, session) {\n    const res = await this.fetch(\"posts.json\");\n    const { posts } = await res.json();\n\n    return { posts };\n  }\n</script>\n```\n\n这样会在`window`上面注入一个`__SAPPER__`变量把 server 端预加载的值赋上去。\n\n因为 sapper 还在 beta 阶段，我也不敢拿来开发什么大项目，但真心想写写 svelte，因为它在很多地方非常有新意，历史包袱也不大，暂时写个 [CSS playground](https://css.gongbushang.com/) 来做 [CSS Secrets](http://shop.oreilly.com/product/0636920031123.do) 的笔记好了。\n\n## 单元测试\n\n[testing-library](https://testing-library.com/docs/svelte-testing-library/intro) 提供单元测试支持，配置起来绝对比 react 和 vue 简单，只是因为比较新，所以没有类似的 create react app 这种官方脚手架，当然如果 sapper 出正式版了就算有了。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["svelte","sapper","JavaScript","rollup"]}},{"id":"2020/04/04/ObservableHQ-JS-Jupyter.md","slug":"2020/04/04/observablehq-js-jupyter","body":"\n# ObservableHQ-JS 终于有自己的 Jupyter 笔记本了\n\n学习机器学习的时候用上 python 的 Jupyter notebook 是真好用，曾经就想，如果 JavaScript 也有一个就好了，没错[ObservableHQ](https://observablehq.com/)就是基于 D3.js 的数据可视化笔记本。\n\n官方的[入门](https://observablehq.com/@observablehq/a-taste-of-observable)讲的很详细，接下来一周我可能会专心于里面的[D3 教程](https://observablehq.com/@d3/learn-d3)，间或去学习 threejs fundamental。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["observablehq","JavaScript","d3","jupyter"]}},{"id":"2020/04/13/threejs-fundamentals-threejs.md","slug":"2020/04/13/threejs-fundamentals-threejs","body":"\n# threejs fundamentals 名副其实的 threejs 入门书\n\n最近几天真是忙，除了读这本书，我的平板（酷比魔方 Mix Plus）突然进不去系统了，查了一下，原来山寨本硬盘质量不好，莫名其妙全清了（惊！），好在做了备份，当然因为不想花钱，没再买一个 SATA SSD 硬盘，花了一些时间重做系统。\n\n祸不单行，主力机 Dell inspiron 13 风扇坏了，虽然已经报修，但还在走流程，这使得我现在只能以 1.8GHz（关闭风扇） 工作 😭。\n\n正好，刚做完系统，所以这篇文章我争取在平板上写，以保证系统安装正确。\n\n另外，因为抢到了福田的消费券，所以这本书的实现，争取在本周完成。\n","collection":"blog","data":{"type":"post","category":"book","tag":["threejs","JavaScript","webGL"]}},{"id":"2020/04/21/threejs-mesh.md","slug":"2020/04/21/threejs-mesh","body":"\n# threejs 细化-创建一个 mesh、使用加载器、多个场景\n\n记录下最近几天的事，终于 Dell 的维修把我电脑的风扇修好了，不过感觉 inspiron 的风扇设计有 bug，新风扇估计也撑不了多久，但愿只是我多疑了。另外通过神奇的某宝，我将我手上的小米平板二升级了内存和硬盘，考虑到 8GB 内存对于 Atom Z8500 这个 CPU 有点多余，于是升级到了 4GB + 128GB，到手之后果然比 2GB 流畅（当然肯定没法比酷睿了），所以这个配置还是比较推荐的。\n\n回到主题，最近一周我都在使用 react-three-fiber 来学习 threejs，这里会做一个系列来详细整理一下。\n\n## 创建一个 mesh\n\n可以使用 JSX 创建 mesh, 因为 mesh 有 material 和 geometry 两个访问器，在 JSX 中可以作为属性使用。\n\n```JavaScript\nexport default () => (\n    <Canvas>\n        <mesh\n            name=\"mesh\"\n            material={new MeshBasicMaterial()}\n            geometry={new BoxBufferGeometry(1, 1, 1)}\n        />\n    </Canvas>\n);\n```\n\n当然作为参数也可以。\n\n```JavaScript\nexport default () => (\n    <Canvas>\n        <mesh arg={[new BoxBufferGeometry(1, 1, 1), new MeshBasicMaterial()]}/>\n    </Canvas>\n);\n```\n\n官网还提供了一个绝妙的方法。\n\n```JavaScript\n// 实现不了，不知道咋回事儿\nexport default () => (\n    <Canvas>\n        <mesh>\n            <boxBufferGeometry attach=\"geometry\" />\n            <meshBasicMaterial attach=\"material\" />\n        </mesh>\n    </Canvas>\n);\n```\n\n另外因为 Canvas 里面的元素和 JSX 的绑定使用的是 memo，所以如果使用 primitive 定义元素的时候会丢。\n\n```JavaScript\n// 这么做虽然会渲染出来，但是Box有的时候会丢\nconst Box = new Mesh(\n    new BoxBufferGeometry(1, 1, 1),\n    new MeshBasicMaterial(),\n);\n\nexport default () => (\n    <Canvas>\n        <primitive object={Box} />\n    </Canvas>\n);\n```\n\n## 加载器\n\n加载 texture 时，可以使用`useEffect`自己写，当然也有更优雅的方法，利用 react 自己的`useMemo`或者`useCallback`，再就是使用 react three fiber 的`useLoader`。\n\n```JavaScript\n// 使用 useMemo\nconst Plane = () => {\n    const texture = useMemo(() => new TextureLoader().load(\"xxx.jpg\"), [])\n    return <mesh\n        material={new MeshBasicMaterial({map: texture})}\n        geometry={new PlaneGeometry(1, 1)}\n    />\n}\n```\n\n```JavaScript\n// 使用 useLoader\nconst PlaneAsync = () => {\n    const [texture] = useLoader(TextureLoader, \"xxx.jpg\");\n\n    return <mesh\n        material={new MeshBasicMaterial({map: texture})}\n        geometry={new PlaneGeometry(1, 1)}\n    />\n}\n\nconst Plane = () => (\n        <Suspense fallback={<mesh />}>\n            <PlaneAsync />\n        </Suspense>\n    )\n```\n\n## 使用多个场景\n\nthree react fiber 会默认给一个场景(scene)、一个摄像头(camera)还有一个渲染器(render)。可是如果我需要多个场景，比如建模工具往往会给一个正交视图以及正视图，这种情况就需要多个场景。\n\n首先要使用`setDefaultCamera`将新建的摄像头代替默认摄像头。\n\n```TypeScript\nexport default () => {\n    const { setDefaultCamera } = useThree();\n    const camera = useRef<PerspectiveCamera>();\n\n    useLayoutEffect(() => camera.current && setDefaultCamera(camera.current), [])\n\n    return <perspectiveCamera\n      name=\"camera\"\n      ref={camera}\n    />\n}\n```\n\n接下来是创建场景，场景不需要代替原有场景，但是需要使用`useFrame`修改`render`方法。\n\n```TypeScript\n// 再原画面的左上角绘制场景\nexport default () => {\n    const scene = useRef<Scene>();\n    const {\n        size: {left, top, width, height},\n        camera,\n    } = useThree();\n\n    useFrame(({ gl }) => {\n        gl.autoClear = true;\n        gl.setScissor(left, top, width / 2, height / 2);\n        gl.setViewport(left, top, width / 2, height / 2);\n\n        scene.current && gl.render(scene, camera)\n    }, 10);\n\n    return (\n        <scene ref={scene}>\n            <mesh />\n        </scene>\n    );\n}\n```\n\n这里`useFrame`的第二个参数表示它的优先级，值越高，越先渲染，这意味着比它优先级低的场景渲染之前要把`gl.autoClear`设置为`false`，以避免被清除。\n\n## 其它\n\n另外可以看看京东的一篇博客[凹凸实验室](https://aotu.io/notes/2018/10/18/cannonjs/index.html)。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["threejs","JavaScript","webGL"],"series":{"slug":"threejs-howto","name":"细品threejs"}}}]}