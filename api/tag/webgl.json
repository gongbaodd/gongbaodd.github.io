{"posts":[{"id":"2020/03/22/react-three-fiber-WebGL.md","slug":"2020/03/22/react-three-fiber-webgl","body":"\n# 使用 react-three-fiber 体验美好的 WebGL 开发\n\n使用 threejs 开发 webGL 应用应该是几乎每个前端工程师想要做的事儿，然而虽然对比于原生 WebGL 开发来说，threejs 已经做了很多，但是相对于现代的一些前端框架。threejs 还稍显不足。针对这些不足，微软开发了[Babylon.js](https://www.babylonjs.com/)，给 threejs 量身定制了一个节点编辑器，如果做过 blender 或者 unity 的同学，对于节点编辑器肯定不会陌生，但对我本人来说还是没有触碰到 G 点。\n\n## 描述组件关系的重要性\n\n本人觉得，对于前端开发来说，提供一个能够准确描述组件和组件结构关系的语言（DSL）是至关重要的，如 HTML 之于 web 开发，xml 之于安卓开发。这些 DSL 能够以最直观的方式表达页面将会展示什么，就从开发的角度上来说，或许入门不是很方便，毕竟要处理很多文件。但是维护起来却异常的轻松，就是前面提到的原因，直观。当然因为 JavaScript 跟 HTML 的交互有很大的性能缺陷。所以给很多模板语言提供了机会。比如 mustache 还有 react 的 JSX。在安卓也能看到 anko 在 kotlin 社区兴起，但是仅仅一年就没有更多人使用了，个人体验，在 Android studio 中使用 xml 和 anko 开发体验差距并不大，有时候 xml 甚至占优，也许这就是原因之一了吧。\n\n几年前我翻查了很多框架，老实说可能更多人并没有把结构描述放在如我想的位置上，哪怕连个 JSON 的方案都没有。但是的确有[aframejs](https://aframe.io/)这种直接用 HTML 管理 canvas 中元素关系的库，可惜它更关注于 VR 开发，而我更希望 WebGL 能够成为诸如图书注解一样的工具，当然这种专注于一个方面的做法或许是正确的，毕竟能够汇聚一个小圈的开发者，也不会有很多流失。\n\n## 用 JSX 开发 WebGL\n\n今年运气就好多了，react-reconciler 使得我们能够直接接管组件的 render 函数，而 react-hooks 在开发体验上完美超出现有框架，[react-babylonjs](https://github.com/brianzinn/react-babylonJS) 和 [react-three-fiber](https://github.com/react-spring/react-three-fiber) 应运而生。我同时试用了这两个框架，简单来说，react-three-fiber 更加成熟些，对 tTypeScript 的支持更好，而 react-babylonjs 开发的时候往往会因为处理类型而费心，最后又不得不使用 JavaScript 开发。\n\n## 怎么使用 react-three-fiber\n\nreact-three-fiber 的[官方文档链接](https://inspiring-wiles-b4ffe0.netlify.com/)描述很详细，建议详读。另外 threejs 官方来链接的[threejs fundamentals](https://threejsfundamentals.org/)有时间也可以拿来读读。\n\n如果想把原来的 threejs 模块迁移到 react 模块，只需要使用一层 primitive 包装即可。每个拥有 set 和 get 的参数都可以作为 props 的成员，构造器参数则是`props.args: any[]`类型。\n\n```JavaScript\nconst grid = new GridHelper(2000, 20, 0x000000, 0x0000000);\n(grid.material as Material).opacity = 0.2;\n(grid.material as Material).transparent = true;\n\nconst Grid = () => {\n  useFrame(({ scene }) => {\n    if (!scene.fog) {\n      const fog = new Fog(0xa0a0a0, 200, 800);\n      scene.fog = fog;\n    }\n  });\n\n  return <primitive object={grid}></primitive>;\n};\n\n```\n\n## 调试工具\n\n这点 babylonjs 要好得多，一个节点编辑器秒杀一切，但是 threejs 还有一个「够用」的[threejs inspector](https://chrome.google.com/webstore/detail/threejs-inspector/dnhjfclbfhcbcdfpjaeacomhbdfjbebi?hl=en)。\n\n使用时需要把你的 scene 和 THREE 模块暴露给 window 作用域。\n\n```JavaScript\nwindow.scene = scene;\nwindow.THREE = THREE;\n```\n\n然后刷新浏览器就可以在场景添加光源，查看节点等操作了。\n\n## 提示\n\n因为 threejs 及其模块本身不是编译好的 ES5，在 nextjs 中一定记得使用`next-transpile-modules`编译，当然即使已经完美适配 ES5，在 IE11 的展示也不是很乐观 😅。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["threejs","webGL","react"],"series":{"slug":"threejs-howto","name":"细品threejs"}}},{"id":"2020/04/13/threejs-fundamentals-threejs.md","slug":"2020/04/13/threejs-fundamentals-threejs","body":"\n# threejs fundamentals 名副其实的 threejs 入门书\n\n最近几天真是忙，除了读这本书，我的平板（酷比魔方 Mix Plus）突然进不去系统了，查了一下，原来山寨本硬盘质量不好，莫名其妙全清了（惊！），好在做了备份，当然因为不想花钱，没再买一个 SATA SSD 硬盘，花了一些时间重做系统。\n\n祸不单行，主力机 Dell inspiron 13 风扇坏了，虽然已经报修，但还在走流程，这使得我现在只能以 1.8GHz（关闭风扇） 工作 😭。\n\n正好，刚做完系统，所以这篇文章我争取在平板上写，以保证系统安装正确。\n\n另外，因为抢到了福田的消费券，所以这本书的实现，争取在本周完成。\n","collection":"blog","data":{"type":"post","category":"book","tag":["threejs","JavaScript","webGL"]}},{"id":"2020/04/21/threejs-mesh.md","slug":"2020/04/21/threejs-mesh","body":"\n# threejs 细化-创建一个 mesh、使用加载器、多个场景\n\n记录下最近几天的事，终于 Dell 的维修把我电脑的风扇修好了，不过感觉 inspiron 的风扇设计有 bug，新风扇估计也撑不了多久，但愿只是我多疑了。另外通过神奇的某宝，我将我手上的小米平板二升级了内存和硬盘，考虑到 8GB 内存对于 Atom Z8500 这个 CPU 有点多余，于是升级到了 4GB + 128GB，到手之后果然比 2GB 流畅（当然肯定没法比酷睿了），所以这个配置还是比较推荐的。\n\n回到主题，最近一周我都在使用 react-three-fiber 来学习 threejs，这里会做一个系列来详细整理一下。\n\n## 创建一个 mesh\n\n可以使用 JSX 创建 mesh, 因为 mesh 有 material 和 geometry 两个访问器，在 JSX 中可以作为属性使用。\n\n```JavaScript\nexport default () => (\n    <Canvas>\n        <mesh\n            name=\"mesh\"\n            material={new MeshBasicMaterial()}\n            geometry={new BoxBufferGeometry(1, 1, 1)}\n        />\n    </Canvas>\n);\n```\n\n当然作为参数也可以。\n\n```JavaScript\nexport default () => (\n    <Canvas>\n        <mesh arg={[new BoxBufferGeometry(1, 1, 1), new MeshBasicMaterial()]}/>\n    </Canvas>\n);\n```\n\n官网还提供了一个绝妙的方法。\n\n```JavaScript\n// 实现不了，不知道咋回事儿\nexport default () => (\n    <Canvas>\n        <mesh>\n            <boxBufferGeometry attach=\"geometry\" />\n            <meshBasicMaterial attach=\"material\" />\n        </mesh>\n    </Canvas>\n);\n```\n\n另外因为 Canvas 里面的元素和 JSX 的绑定使用的是 memo，所以如果使用 primitive 定义元素的时候会丢。\n\n```JavaScript\n// 这么做虽然会渲染出来，但是Box有的时候会丢\nconst Box = new Mesh(\n    new BoxBufferGeometry(1, 1, 1),\n    new MeshBasicMaterial(),\n);\n\nexport default () => (\n    <Canvas>\n        <primitive object={Box} />\n    </Canvas>\n);\n```\n\n## 加载器\n\n加载 texture 时，可以使用`useEffect`自己写，当然也有更优雅的方法，利用 react 自己的`useMemo`或者`useCallback`，再就是使用 react three fiber 的`useLoader`。\n\n```JavaScript\n// 使用 useMemo\nconst Plane = () => {\n    const texture = useMemo(() => new TextureLoader().load(\"xxx.jpg\"), [])\n    return <mesh\n        material={new MeshBasicMaterial({map: texture})}\n        geometry={new PlaneGeometry(1, 1)}\n    />\n}\n```\n\n```JavaScript\n// 使用 useLoader\nconst PlaneAsync = () => {\n    const [texture] = useLoader(TextureLoader, \"xxx.jpg\");\n\n    return <mesh\n        material={new MeshBasicMaterial({map: texture})}\n        geometry={new PlaneGeometry(1, 1)}\n    />\n}\n\nconst Plane = () => (\n        <Suspense fallback={<mesh />}>\n            <PlaneAsync />\n        </Suspense>\n    )\n```\n\n## 使用多个场景\n\nthree react fiber 会默认给一个场景(scene)、一个摄像头(camera)还有一个渲染器(render)。可是如果我需要多个场景，比如建模工具往往会给一个正交视图以及正视图，这种情况就需要多个场景。\n\n首先要使用`setDefaultCamera`将新建的摄像头代替默认摄像头。\n\n```TypeScript\nexport default () => {\n    const { setDefaultCamera } = useThree();\n    const camera = useRef<PerspectiveCamera>();\n\n    useLayoutEffect(() => camera.current && setDefaultCamera(camera.current), [])\n\n    return <perspectiveCamera\n      name=\"camera\"\n      ref={camera}\n    />\n}\n```\n\n接下来是创建场景，场景不需要代替原有场景，但是需要使用`useFrame`修改`render`方法。\n\n```TypeScript\n// 再原画面的左上角绘制场景\nexport default () => {\n    const scene = useRef<Scene>();\n    const {\n        size: {left, top, width, height},\n        camera,\n    } = useThree();\n\n    useFrame(({ gl }) => {\n        gl.autoClear = true;\n        gl.setScissor(left, top, width / 2, height / 2);\n        gl.setViewport(left, top, width / 2, height / 2);\n\n        scene.current && gl.render(scene, camera)\n    }, 10);\n\n    return (\n        <scene ref={scene}>\n            <mesh />\n        </scene>\n    );\n}\n```\n\n这里`useFrame`的第二个参数表示它的优先级，值越高，越先渲染，这意味着比它优先级低的场景渲染之前要把`gl.autoClear`设置为`false`，以避免被清除。\n\n## 其它\n\n另外可以看看京东的一篇博客[凹凸实验室](https://aotu.io/notes/2018/10/18/cannonjs/index.html)。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["threejs","JavaScript","webGL"],"series":{"slug":"threejs-howto","name":"细品threejs"}}},{"id":"2020/04/27/threejs.md","slug":"2020/04/27/threejs","body":"\n# threejs 细化-在网格上渲染，停止渲染，使用物理引擎\n\n这是细化了解 threejs 的第二篇，[第一篇](/fe/2020/04/21/threejs细化-创建一个mesh、使用加载器、多个场景.html)\n\n## 在网格上渲染\n\n这里有一点类似于使用多个场景，设想如果想要做一个类似于水晶球的设计，水晶球有一个 scene1，水晶球自己又在另一个 scene0 里面，这里就需要使用 renderTarget 渲染 scene1 到水晶球上面。\n\n先创建一个 target。\n\n```typescript\nconst target = new WebGLRenderTarget(width, height);\n```\n\n再创建一个球，并使用 target 作为材料。\n\n```tsx\nconst ball = () => {\n  return (\n    <mesh name=\"ball\">\n      <sphereBufferGeometry attach=\"geometry\" args={[1, 32, 16]} />\n      <meshPhongMaterial attach=\"material\" map={target.texture} />\n    </mesh>\n  );\n};\n```\n\n然后创建 scene1。\n\n```ts\nconst scene1 = new Scene();\nconst camera = new PerspectiveCamera(75, 1, 0.1, 5, position: [0, 1, 2]);\n\n{\n  const light = new HemisphereLight();\n  scene1.add(light);\n}\n\n{\n  const mesh = new Mesh(\n    new BoxBufferGeometry(1, 1, 1),\n    new MeshPhongMaterial({ color: 0x8844aa }),\n  );\n  scene1.add(mesh);\n}\n```\n\n貌似 react-three-fiber 的 render 函数也可以把 JSX 渲染成 scene。但是使用的时候告诉我需要创建 context，难道是要用 React.createContext? 感觉坑很多，所以暂时没有尝试，以后再补充这里。\n\n```tsx\nconst scene = new Scene();\nconst context = createContext();\n\nrender(\n  <>\n    <perspectiveCamera />\n    <hemishpereLight />\n    <mesh>\n      <boxBufferGeometry args={[1, 1, 1]} attach=\"geometry\" />\n      <meshPhongMaterial color={0x8844aa} attach=\"material\" />\n    </mesh>\n  </>,\n  scene,\n  context\n);\n```\n\n好了，回到正题，现在需要在 target 上面渲染 scene1.\n\n```ts\nuseFrame(({ gl }) => {\n  gl.setRenderTarget(target);\n  gl.render(scene1, camera); // 这里的camera是scene1里面的camera\n  gl.setRenderTarget(null);\n});\n```\n\n和渲染两个 scene 一样，不管打算渲染几个场景，实际的渲染器只有一个，所以渲染好 target 后还要把要渲染的目标换回来。\n\n## 停止渲染\n\nreact-three-fiber 默认会一直渲染每一帧，而在网页上，我们往往不需要它一直耗费 GPU 时间，比如渲染好的动画，只需要它在特殊时间才运动，react-three-fiber 有一个 invalidateFrameloop 选项可以暂停渲染。\n\n```tsx\n<Canvas invalidateFrameloop />\n```\n\n另外`useThree().invalidate`也可以暂停渲染，但这个不太稳定，不确定是不是我的问题。\n\n比如加载进来一个模型，想让它动画结束后就停止 GPU 渲染。\n\n```tsx\nconst animate = useMemo(() => new AnimationMixer(obj));\nconst action = useMemo(() => {\n  const act = animate.clipAction(obj.animations[0]);\n  act.setLoop(LoopOnce, 1);\n  act.enabled = true;\n  act.clampedWhenFinished = true;\n  act.play();\n  return act;\n}, []);\n\nconst { invalidate } = useThree();\n\nuseFrame((_, delta) => {\n  animate.update(delta);\n  if (!act.isRunning()) {\n    invalidate();\n  }\n});\n```\n\n## 使用物理引擎\n\n物理引擎是使用 webGL 最爽的部分，主要是不用考虑那些公式，这里用`Cannon.js`打个比方，（感动常在）。\n\n首先创建世界，比如创建一个 z 轴加速度为 9.82 的世界，还需要 NaiveBroadphase 做碰撞检测。\n\n```ts\nconst world = new World();\nworld.gravity.set(0, 0, -9.82);\nworld.broadphase = new NaiveBroadphase();\n```\n\n接下来创建一个物体，包括它的形状（shape）和在世界中的细节参数（body）。\n\n```ts\nconst shape = new Sphere(1);\nconst body = new Body({ mass: 5, shape });\nworld.add(body);\n```\n\n接下来设置渲染的时间间隔。\n\n```ts\nuseFrame(() => world.step(1 / 60)); // 单位秒\n```\n\n好了，那么怎么和 react-three-fiber 玩耍呢？其实可以写一个[useCannon](https://github.com/gongbaodd/webgl_demos/blob/dev/hooks/useCannon.tsx)。\n\n但是考虑到有现成的 hooks，自己就不用写轮子了，[react-spring/use-cannon](https://github.com/react-spring/use-cannon)，他是用 web worker 跑的，性能肯定更好，直接看例子好了，白嫖真爽。\n\n```jsx\nimport { Canvas } from \"react-three-fiber\";\nimport { Physics, usePlane, useBox } from \"use-cannon\";\n\nfunction Plane(props) {\n  const [ref] = usePlane(() => ({ rotation: [-Math.PI / 2, 0, 0], ...props }));\n  return (\n    <mesh ref={ref}>\n      <planeBufferGeometry attach=\"geometry\" args={[100, 100]} />\n    </mesh>\n  );\n}\n\nfunction Cube(props) {\n  const [ref] = useBox(() => ({ mass: 1, position: [0, 5, 0], ...props }));\n  return (\n    <mesh ref={ref}>\n      <boxBufferGeometry attach=\"geometry\" />\n    </mesh>\n  );\n}\n\nReactDOM.render(\n  <Canvas>\n    <Physics>\n      <Plane />\n      <Cube />\n    </Physics>\n  </Canvas>,\n  document.getElementById(\"root\")\n);\n```\n","collection":"blog","data":{"type":"post","category":"fe","tag":["threejs","webgl"],"series":{"slug":"threejs-howto","name":"细品threejs"}}}]}