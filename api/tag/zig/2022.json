{"posts":[{"id":"2022/08/27/Ziglang.md","slug":"2022/08/27/ziglang","body":"\n# 试用 Zig\n\n最近 bun 大火，带动一个语法看起来很像 JS 的语言 Zig 受到关注。听了 Devtools 播客里面的推荐，我觉得可以试用一下。\n\nZig 官网两个学习链接[ziglearn](https://ziglearn.org/)和[ziglings](https://github.com/ratfactor/ziglings)很有帮助，这个语言的学习曲线远没有 Rust 那么陡，甚至可以说，比 C 简单。可以说 Zig 就是披着高级语言语法外衣的 C 语言，而根据官方文档的说法，Zig 的编译器确实可以直接编译 C。\n\n提到语言安全，比较多提的是类型安全和内存安全。类型在 Zig 中只有编译环境使用，官方介绍 Zig 没有宏语言，实际使用中其实是有的，只不过宏语言用的也是 Zig 语法，前面加上了 comptime 关键字，它的泛型写法也利用了编译时可编程的特点。个人觉得使用的时候会混淆，但是教程里面表示用习惯了就不会...\n\n对比 Golang 的垃圾回收和 Rust 的借用机制，Zig 是完全不管内存安全的，跟 C 类似，想要操作堆内存，要新建 allocator，好在利用 defer 关键词能让回收工作在代码里面看起来不是那么难懂。\n\nasync 几乎和 JS 一模一样，用起来感觉是 JS 里面 generator 和 async 的合体版（但它不是迭代器），感觉 JS 用户体验是无缝的。\n\n个人很推荐 Zig，是一个完全新味道的语言。\n","collection":"blog","data":{"type":"post","category":"tech","tag":["zig"]}},{"id":"2022/09/08/kmp.md","slug":"2022/09/08/kmp","body":"\n# KMP 匹配算法\n\n要从一个字符串 ababcabcacbababcac 中查中一个片段如 abcac 可以使用 KMP 算法。\n\nKMP 算法，简单来说就是先从要匹配的字符串中找到重复的字缀，并将这些字缀标记跳过的字数以做到匹配时剪掉不许匹配的次数。\n\n- a，首位和末尾没有重复即为 0\n- ab，首位和末尾没有重复即为 0\n- abc，首位和末尾没有重复即为 0\n- abca，首位和末尾有一位重复 a，记为 1\n- abcac，首位和末尾没有重复即为 0\n\n```js\nvar next = ArrayList(usize).init(allocator);\ndefer next.deinit();\n\nfor (word) |_, inext| {\n     if (inext == 0) {\n         try next.append(0);\n         continue;\n    }\n\n     var imatched = next.items[inext - 1];\n     while (imatched > 0 and word[imatched] != word[inext]) {\n            imatched = next.items[imatched - 1];\n     }\n\n     if (word[imatched] == word[inext]) {\n        try next.append(imatched + 1);\n     } else {\n         try next.append(imatched);\n     }\n}\n```\n\n得到匹配列表为 00010，这里的数字对应每个字母的序号 01234，假设匹配长字符串的时候刚好匹配到 abcac 的时候（第五位）没有匹配上，就看`c`前面的字符`a`对应的匹配值，这里是 1，指的可以从字符串中序号为 1 的字符，这里是`b`，继续匹配。\n\n```js\n    var iword: usize = 0;\n    for (str) |c, istr| {\n        while (c != word[iword] and iword > 0) {\n            iword = next.items[iword - 1];\n        }\n\n        if (c == word[iword]) {\n            iword += 1;\n        }\n\n        if (iword == word.len) {\n            try res.append(istr - iword + 1);\n            iword = next.items[iword - 1];\n        }\n    }\n```\n","collection":"blog","data":{"type":"post","category":"tech","tag":["algorithm","zig"]}}]}