{"posts":[{"id":"2018/08/05/CSS Grid Layout.md","slug":"2018/08/05/css-grid-layout","body":"# CSS Grid Layout 使用总结\n\n最近被猎头催的实在不行了（真的，感觉他们更担心我找不到工作），于是我写了份简历给他们。当然了，既然最后要的是PDF，这种机会不试试新的CSS布局还真说不过去。\n\n##　实现圣杯布局\n\n提到CSS布局，自然想到了圣杯，一行header，中间是sidebar和content，底下是footer。\n\n```css\n.grid {\n    display: grid;\n    grid-template-area: \"header header  header\"\n                        \"left   content right\"\n                        \"footer footer  footer\";\n}\n\n.item1 {\n    grid-area: header;\n}\n\n.item2 {\n    grid-area: left;\n}\n\n.item3 {\n    grid-area: content;\n}\n\n.item4 {\n    grid-area: right;\n}\n\n.item5 {\n    grid-area: footer;\n}\n```\n\n很简单，使用 Grid Layout 的最大好处是页面布局由CSS全部接管，意味着想把```.item5```改成header只需要修改```grid-area```即可，```grid-template-area```结合 media query　可以实现适配不同设备，如打印机布局相比于屏幕来说界面比较窄。\n\n```CSS\n@media print {\n    .grid {\n        grid-template-area: \"header\"\n                            \"left\"\n                            \"content\"\n                            \"right\"\n                            \"footer\";\n    }\n}\n```\n\n## 实现无大小限制瀑布流\n\n前端瀑布流在网格布局之下，结合``` grid-auto-flow: row dense;```可以实现大小不一的网格元素按照最合理的形式行填充。\n\n```css\n.grid {\n    display: grid;\n    grid-template-columns: repeat(auto-fill, 100px);\n    grid-template-rows: 100px;\n}\n\n.size-1 {\n    grid-column: span 1;\n    grid-row: span 1;\n}\n\n.size-2 {\n    grid-column: span 2;\n    grid-row: span 2;\n}\n\n.size-3 {\n    grid-column: span 3;\n    grid-row: span 3;\n}\n\n```\n\n## 兼容性\n\n并没有测试IE11，从caniuse可以看到，主流浏览器除了IE11都是不需要家前缀的，IE11需要加-ms前缀（道听途说autoprefixer不会补grid，所以最好手改）。\n\n国产浏览器兼容性就不理想了，除了UC，百度、QQ浏览器都不支持，汗啊，看来浏览器这行业真的是不挣钱了，所以如果要支持这些浏览器还需要再等等。\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2018/08/07/React16.md","slug":"2018/08/07/react16","body":"# React16 模拟输入框输入事件\n\n照往常，我会新建一个input事件然后dispatch一下，今天在instagram上面试验失败了。原因是React16 内部定义了descriptor拦截了value.\n\n```javascript\nlet input = $0;\nlet value = 'new value';\n\nlet event = new Event('input', { bubble: true });\nevent.simulated = true;\n\nlet tracker = input._valueTracker;\ntracker && tracker.setValue(value);\n\ninput.value = value;\ninput.dispatchEvent(event);\n```\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2018/08/14/AframeJS.md","slug":"2018/08/14/aframejs","body":"# AframeJS 学习笔记\n\n## 创建项目\n\n使用 [npm/angle](https://www.npmjs.com/package/angle)\n\n## ECS(Entity-Component-System)\n\n不懂百度。\n\n## 组件库\n\nhttps://aframe.io/aframe-registry/\n\n## 博客\n\nhttps://aframe.io/blog/\n\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2018/08/22/mock-fs-io.md","slug":"2018/08/22/mock-fs-io","body":"# 单元测试时使用mock-fs模拟IO返回值\n\n最近换工作到了一家对测试要求比较高的公司，相比以前仅仅完成Appnium完全匹配不同，这里要求使用jest自动化测试覆盖率达到80%+，[此处应有jest cheat sheet](https://devhints.io/jest)。\n\n工作过程中有很多需要读配置文件的地方，做法是在本地对应位置放上文件，然后配置ignore掉这个文件进行测试，然而这并不是个很优雅的方式（尤其是当代码中有判断此配置是否存在时，需要手动移动文件），此时即可利用mock-fs。\n\n## 简单使用\n\n```javascript\nconst mock = require('mock-fs');\n\nmock({\n  'path/to/fake/dir': {\n    'some-file.txt': 'file content here',\n    'empty-dir': {/** empty directory */}\n  },\n  'path/to/some.png': Buffer.from([8, 6, 7, 5, 3, 0, 9]),\n  'some/other/path': {/** another empty directory */}\n});\n```\n\n指定的文件夹地址是默认相对于process.cwd()的，当然也可以配置其它地址。执行mock之后，所有有关IO的部分就都被修改了。\n\n## 需要注意的地方\n\n* 因为强制修改了IO，你会发现require也不好用了所以一般放在require之后\n* 记得要在每个用例执行之后回收mock状态\n\n```javascript\ndecribe('# test', () => {\n    const mockfs = require('mock-fs');\n    beforeEach(() => jest.resetModule());\n    afterEach(() => mockfs.restore());\n    it('should do ...', () => {\n        const foo = require('foo.js');\n        mockfs({...});\n        expect(foo)...\n    });\n})\n```","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2018/08/23/prettier-eslint.md","slug":"2018/08/23/prettier-eslint","body":"# 如果prettier和eslint冲突了怎么办\n\n最近工作发现小伙伴都不喜欢用prettier，原因是格式化后的代码其实和之前约定的eslint有出入。\n\n其实安装prettier-eslint之后，你的prettier就不会将代码改成违反eslint规则的样子，在vscode配置中，打开prettier.eslintIntegration。这样自动保存也会避开eslint。\n\n另外prettier文档中也有如何解决二者冲突的方法 https://prettier.io/docs/en/integrating-with-linters.html。","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2018/08/24/eslint-plugin-typelint-jsdoc-linting.md","slug":"2018/08/24/eslint-plugin-typelint-jsdoc-linting","body":"# eslint-plugin-typelint借助jsdoc实现无编译linting级别的类型检查工具","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2018/08/28/Functional Reactive Programming-baconjs.md","slug":"2018/08/28/functional-reactive-programming-baconjs","body":"# Functional Reactive Programming 框架 baconjs","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2018/08/29/OpenAPI-swagger.md","slug":"2018/08/29/openapi-swagger","body":"","collection":"blog","data":{"type":"post","category":"fe"}}]}