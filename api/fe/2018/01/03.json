{"posts":[{"id":"2018/01/03/typescript-AST.md","slug":"2018/01/03/typescript-ast","body":"# TypeScript编译抽象语法树\n\n[代码地址](http://gongbushang.com:3000/gongbushang/typescript_compiler)\n\n两年前我曾写了一个篇\n[Esprima静态分析js代码](http://gongbaodd.github.io/fe/2015/12/25/esprima%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90js%E4%BB%A3%E7%A0%81.html),\n当时的目的是为了检查一个js文件对某些函数的调用数计数来确定这个函数是不是可删的.\n\n自从用了typescript,\n这种方法自然就不需要使用了,\n但是如果我想获取 typescript 的 AST 怎么办?\n\n很简单, 因为 Ts 本身就是开源项目, 官方已经有解决方案.\n\n假设我想看一下 \"const a:number = 11;\" 的 AST 树, 代码如下.\n\n```typescript\nimport ts = require(\"typescript\");\nconst source = \"const a:number = 11;\";\n\nfunction printChildren(node: ts.Node, depth = 0) {\n    console.log(new Array(depth + 1).join(\"---\"), ts.SyntaxKind[node.kind], node.pos, node.end);\n    depth++;\n    node.getChildren().forEach(c => printChildren(c, depth));\n}\n\nconst sourceFile = ts.createSourceFile(\"a.ts\", source, ts.ScriptTarget.ES2016, true);\nprintChildren(sourceFile);\n```\n\n结果\n\n```shell\n SourceFile 0 20\n--- SyntaxList 0 20\n------ VariableStatement 0 20\n--------- VariableDeclarationList 0 19\n------------ ConstKeyword 0 5\n------------ SyntaxList 5 19\n--------------- VariableDeclaration 5 19\n------------------ Identifier 5 7\n------------------ ColonToken 7 8\n------------------ NumberKeyword 8 14\n------------------ FirstAssignment 14 16\n------------------ FirstLiteralToken 16 19\n--------- SemicolonToken 19 20\n--- EndOfFileToken 20 20\n```\n\n一个空对象的抽象语法树.\n\n```typescript\nclass a {}\n```\n\n```shell\n SourceFile 0 10\n--- SyntaxList 0 10\n------ ClassDeclaration 0 10\n--------- ClassKeyword 0 5\n--------- Identifier 5 7\n--------- FirstPunctuation 7 9\n--------- SyntaxList 9 9\n--------- CloseBraceToken 9 10\n--- EndOfFileToken 10 10\n```\n\n那么复杂点的对象\n\n```typescript\nclass a {\n    public num: number = 11;\n    public getNumber() {\n        return this.num;\n    }\n}\n```\n\n```shell\n SourceFile 0 96\n--- SyntaxList 0 96\n------ ClassDeclaration 0 96\n--------- ClassKeyword 0 5\n--------- Identifier 5 7\n--------- FirstPunctuation 7 9\n--------- SyntaxList 9 94\n------------ PropertyDeclaration 9 38\n--------------- SyntaxList 9 20\n------------------ PublicKeyword 9 20\n--------------- Identifier 20 24\n--------------- ColonToken 24 25\n--------------- NumberKeyword 25 32\n--------------- FirstAssignment 32 34\n--------------- FirstLiteralToken 34 37\n--------------- SemicolonToken 37 38\n------------ MethodDeclaration 38 94\n--------------- SyntaxList 38 49\n------------------ PublicKeyword 38 49\n--------------- Identifier 49 59\n--------------- OpenParenToken 59 60\n--------------- SyntaxList 60 60\n--------------- CloseParenToken 60 61\n--------------- Block 61 94\n------------------ FirstPunctuation 61 63\n------------------ SyntaxList 63 88\n--------------------- ReturnStatement 63 88\n------------------------ ReturnKeyword 63 78\n------------------------ PropertyAccessExpression 78 87\n--------------------------- ThisKeyword 78 83\n--------------------------- DotToken 83 84\n--------------------------- Identifier 84 87\n------------------------ SemicolonToken 87 88\n------------------ CloseBraceToken 88 94\n--------- CloseBraceToken 94 96\n--- EndOfFileToken 96 96\n```\n\n那么看看应用, 之前我写过 [plantUML的使用](http://gongbaodd.github.io/fe/2017/12/20/plantUML.html),\n正好可以试一下看看能不能自动生成类图.\n\n```typescript\nimport { readFileSync } from \"fs\";\nimport * as ts from \"typescript\";\n\nexport function uml(src: ts.SourceFile) {\n    const classMap = {};\n    analyseNode(src);\n    console.log(draw());\n\n    function analyseNode(node: ts.Node) {\n        if (node.kind === ts.SyntaxKind.ClassDeclaration) {\n            const cls = {};\n            node.forEachChild(n => {\n                if (n.kind === ts.SyntaxKind.Identifier) {\n                    classMap[n.getText()] = cls;\n                }\n                if (n.kind === ts.SyntaxKind.PropertyDeclaration) {\n                    n.forEachChild(i => {\n                        if (i.kind === ts.SyntaxKind.Identifier) {\n                            cls[i.getText()] = \"var\";\n                        }\n                    });\n                }\n                if (n.kind === ts.SyntaxKind.MethodDeclaration) {\n                    n.forEachChild(i => {\n                        if (i.kind === ts.SyntaxKind.Identifier) {\n                            cls[i.getText()] = \"function\";\n                        }\n                    })\n                }\n            });\n        }\n        node.forEachChild(analyseNode);\n    }\n\n    function draw() {\n        const tpl = `\n@startuml\n#\n@enduml\n        `.trim();\n        let str = \"\";\n\n        Object.keys(classMap).forEach(className => {\n            const classItems = classMap[className];\n            str += `class ${className} {\\n`;\n            Object.keys(classItems).forEach(i => {\n                str += `${classItems[i]} ${i}\\n`;\n            });\n            str += \"}\\n\";\n        });\n\n        return tpl.replace(\"#\", str);\n    }\n}\n\n\nconst file = process.argv.slice(2);\nfile.forEach(f => {\n    const src = ts.createSourceFile(f, readFileSync(f).toString(), ts.ScriptTarget.ES2016, true);\n    uml(src);\n})\n\n```\n\n\n```plantuml\n@startuml\nclass A {\nvar num\nfunction getNumber\n}\n\n@enduml\n```","collection":"blog","data":{"type":"post","category":"fe"}}]}