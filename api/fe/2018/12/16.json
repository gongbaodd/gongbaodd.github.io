{"posts":[{"id":"2018/12/16/postman-prescript.md","slug":"2018/12/16/postman-prescript","body":"# postman的prescript对异步代码支持不足\n\n用过postman做集成测试的话，有个prescript功能很不错，就是在执行发送请求之前要执行的脚本。\n\n我曾经以为这个prescript是直接运行的一个js脚本，执行完之后发送请求。但是貌似postman里面处理异步逻辑与v8有所不同。如果你想先发送一个POST请求，然后执行postman的PATCH请求，中间在加一个大概1s的delay，如下代码竟然能实现！\n\n```javascript\n// prescript\npm.sendRequest({...});\nsetTimeout(() => {}, 1000);\n```\n\n这个prescript其实是会对异步代码进行超时处理。无论是多层callback还是promise还是async，但唯独对setTimeout无效。\n\n```javascript\n// callbacks\npm.sendRequest({}, () => {\n    pm.sendRequest({}, () => { ... }); // 这一步回调可能会超时中断\n})；\n```\n\n```javascript\n// promise\nconst req = () => new Promise(res => {\n    pm.sendRequest({}, () => res());\n});\n\nPromise.resolve()\n    .then(req({ ... }))\n    .then(req({ ... }));// 这一步可能会超时中断\n```\n\n```javascript\n// async - await\nconst req = () => new Promise(res => {\n    pm.sendRequest({}, () => res());\n});\n~ async function() {\n    await req({ ... });\n    await req({ ... });// 这一步可能会超时中断\n} ();\n```\n\n因为只要setTimeout的timer不释放prescript就不会被超时中断，可以借助这一点防止prescript超时。\n\n```javascript\nconst TIME_OUT = 200;\nfunction stop() {\n    if (stop.done) {\n        return clearTimeout(stop.timer);\n    }\n    stop.timer = setTimeout(arguments.callee, TIME_OUT);\n}\nstop.done = false;\nstop.timer = setTimeout(stop, TIME_OUT);\n```\n\n想要停止代码的话，只需把stop.done设置为true就可以了。\n","collection":"blog","data":{"type":"post","category":"fe"}}]}