{"posts":[{"id":"2018/01/03/typescript-AST.md","slug":"2018/01/03/typescript-ast","body":"# TypeScript编译抽象语法树\n\n[代码地址](http://gongbushang.com:3000/gongbushang/typescript_compiler)\n\n两年前我曾写了一个篇\n[Esprima静态分析js代码](http://gongbaodd.github.io/fe/2015/12/25/esprima%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90js%E4%BB%A3%E7%A0%81.html),\n当时的目的是为了检查一个js文件对某些函数的调用数计数来确定这个函数是不是可删的.\n\n自从用了typescript,\n这种方法自然就不需要使用了,\n但是如果我想获取 typescript 的 AST 怎么办?\n\n很简单, 因为 Ts 本身就是开源项目, 官方已经有解决方案.\n\n假设我想看一下 \"const a:number = 11;\" 的 AST 树, 代码如下.\n\n```typescript\nimport ts = require(\"typescript\");\nconst source = \"const a:number = 11;\";\n\nfunction printChildren(node: ts.Node, depth = 0) {\n    console.log(new Array(depth + 1).join(\"---\"), ts.SyntaxKind[node.kind], node.pos, node.end);\n    depth++;\n    node.getChildren().forEach(c => printChildren(c, depth));\n}\n\nconst sourceFile = ts.createSourceFile(\"a.ts\", source, ts.ScriptTarget.ES2016, true);\nprintChildren(sourceFile);\n```\n\n结果\n\n```shell\n SourceFile 0 20\n--- SyntaxList 0 20\n------ VariableStatement 0 20\n--------- VariableDeclarationList 0 19\n------------ ConstKeyword 0 5\n------------ SyntaxList 5 19\n--------------- VariableDeclaration 5 19\n------------------ Identifier 5 7\n------------------ ColonToken 7 8\n------------------ NumberKeyword 8 14\n------------------ FirstAssignment 14 16\n------------------ FirstLiteralToken 16 19\n--------- SemicolonToken 19 20\n--- EndOfFileToken 20 20\n```\n\n一个空对象的抽象语法树.\n\n```typescript\nclass a {}\n```\n\n```shell\n SourceFile 0 10\n--- SyntaxList 0 10\n------ ClassDeclaration 0 10\n--------- ClassKeyword 0 5\n--------- Identifier 5 7\n--------- FirstPunctuation 7 9\n--------- SyntaxList 9 9\n--------- CloseBraceToken 9 10\n--- EndOfFileToken 10 10\n```\n\n那么复杂点的对象\n\n```typescript\nclass a {\n    public num: number = 11;\n    public getNumber() {\n        return this.num;\n    }\n}\n```\n\n```shell\n SourceFile 0 96\n--- SyntaxList 0 96\n------ ClassDeclaration 0 96\n--------- ClassKeyword 0 5\n--------- Identifier 5 7\n--------- FirstPunctuation 7 9\n--------- SyntaxList 9 94\n------------ PropertyDeclaration 9 38\n--------------- SyntaxList 9 20\n------------------ PublicKeyword 9 20\n--------------- Identifier 20 24\n--------------- ColonToken 24 25\n--------------- NumberKeyword 25 32\n--------------- FirstAssignment 32 34\n--------------- FirstLiteralToken 34 37\n--------------- SemicolonToken 37 38\n------------ MethodDeclaration 38 94\n--------------- SyntaxList 38 49\n------------------ PublicKeyword 38 49\n--------------- Identifier 49 59\n--------------- OpenParenToken 59 60\n--------------- SyntaxList 60 60\n--------------- CloseParenToken 60 61\n--------------- Block 61 94\n------------------ FirstPunctuation 61 63\n------------------ SyntaxList 63 88\n--------------------- ReturnStatement 63 88\n------------------------ ReturnKeyword 63 78\n------------------------ PropertyAccessExpression 78 87\n--------------------------- ThisKeyword 78 83\n--------------------------- DotToken 83 84\n--------------------------- Identifier 84 87\n------------------------ SemicolonToken 87 88\n------------------ CloseBraceToken 88 94\n--------- CloseBraceToken 94 96\n--- EndOfFileToken 96 96\n```\n\n那么看看应用, 之前我写过 [plantUML的使用](http://gongbaodd.github.io/fe/2017/12/20/plantUML.html),\n正好可以试一下看看能不能自动生成类图.\n\n```typescript\nimport { readFileSync } from \"fs\";\nimport * as ts from \"typescript\";\n\nexport function uml(src: ts.SourceFile) {\n    const classMap = {};\n    analyseNode(src);\n    console.log(draw());\n\n    function analyseNode(node: ts.Node) {\n        if (node.kind === ts.SyntaxKind.ClassDeclaration) {\n            const cls = {};\n            node.forEachChild(n => {\n                if (n.kind === ts.SyntaxKind.Identifier) {\n                    classMap[n.getText()] = cls;\n                }\n                if (n.kind === ts.SyntaxKind.PropertyDeclaration) {\n                    n.forEachChild(i => {\n                        if (i.kind === ts.SyntaxKind.Identifier) {\n                            cls[i.getText()] = \"var\";\n                        }\n                    });\n                }\n                if (n.kind === ts.SyntaxKind.MethodDeclaration) {\n                    n.forEachChild(i => {\n                        if (i.kind === ts.SyntaxKind.Identifier) {\n                            cls[i.getText()] = \"function\";\n                        }\n                    })\n                }\n            });\n        }\n        node.forEachChild(analyseNode);\n    }\n\n    function draw() {\n        const tpl = `\n@startuml\n#\n@enduml\n        `.trim();\n        let str = \"\";\n\n        Object.keys(classMap).forEach(className => {\n            const classItems = classMap[className];\n            str += `class ${className} {\\n`;\n            Object.keys(classItems).forEach(i => {\n                str += `${classItems[i]} ${i}\\n`;\n            });\n            str += \"}\\n\";\n        });\n\n        return tpl.replace(\"#\", str);\n    }\n}\n\n\nconst file = process.argv.slice(2);\nfile.forEach(f => {\n    const src = ts.createSourceFile(f, readFileSync(f).toString(), ts.ScriptTarget.ES2016, true);\n    uml(src);\n})\n\n```\n\n\n```plantuml\n@startuml\nclass A {\nvar num\nfunction getNumber\n}\n\n@enduml\n```","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2018/01/24/30-kotlin.md","slug":"2018/01/24/30-kotlin","body":"# 完成了30个kotlin安卓挑战\n\n去年逛IT邦看到了关于Kotlin的铁人赛，30个安卓demo．毕竟不是我的原创，这里贴上原地址\n\nhttps://ithelp.ithome.com.tw/users/20107329/ironman/1286\n\n再贴上我的代码地址\n\nhttp://gongbushang.com:3000/gongbushang/kotlinPlayground\n\n## 我的测试机\n\n说来我的测试机，可是我当年拿实习工资买的魅蓝，后来跑步摔碎了，现在打开更新下居然还能用，也是奇迹了．\n\n![](https://wx2.sinaimg.cn/mw690/89d0a2e1ly1fnt8xpefslj20qo0zkwin.jpg)\n\n## 01TapCounter\n\n最简单的计数器\n\nKotlin 的 lamda 表达式的使用,\n使用 kotlin 的一个好处，\n获取 button 或者 textEdit 之类的组件不需要使用 findViewById 了\n\n```kotlin\nthis.tapButton.setOnClickListener {\n    currentNumber += 1\n    numberTextView.text = currentNumber.toString()\n}\n```\n\n## 02seekBarPercentage\n\nprogressBar 的使用\n\n## 03ImgePicker\n\n获取相机\n\n```kotlin\nval intent = Intent(MediaStore.ACTION_IMAGE_CAPTURE)\n\nstartActivityForResult(intent, ACTION_CAMERA_REQUEST_CODE)\n```\n\n获取相册\n\n```kotlin\nval intent = Intent(Intent.ACTION_PICK)\nintent.type = \"image/*\"\nstartActivityForResult(intent, ACTION_ALBUM_REQUEST_CODE)\n```\n\n## 04ScalableImageView\n\n自定义一个 ImageView\n\n## 05WebSearch\n\nwebView\n\n```kotlin\nwebview.webViewClient = webViewClient\nwebview.loadUrl(\"https://www.bing.com\")\n```\n\n## 06ImageList\n\nfragment 的高度要固定\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<android.support.constraint.ConstraintLayout\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"260dp\">\n</android.support.constraint.ConstraintLayout>\n```\n\n## 07MyLocation\n\n没法用谷歌地图, 改用高德地图, 主要还是要很多权限\n\n```xml\n\n    <!--允许程序打开网络套接字-->\n    <uses-permission android:name=\"android.permission.INTERNET\" />\n    <!--允许程序设置内置sd卡的写权限-->\n    <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />\n    <!--允许程序获取网络状态-->\n    <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />\n    <!--允许程序访问WiFi网络信息-->\n    <uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" />\n    <!--允许程序读写手机状态和身份-->\n    <uses-permission android:name=\"android.permission.READ_PHONE_STATE\" />\n    <!--允许程序访问CellID或WiFi热点来获取粗略的位置-->\n    <uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" />\n    <uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\"/>\n```\n\n## 08BottomNavigation\n\n没啥意思就是底部导航栏\n\n## 09ImageSlider\n\nImageSlider的使用\n\n## 10ProgressControl\n\n控制 progressBar\n\n## 11ActivitySchedule\n\n日期弹框\n\n```kotlin\n  DatePickerDialog(\n                    this,\n                    DatePickerDialog.OnDateSetListener { _, year, month, date ->\n                        cal.set(Calendar.YEAR, year)\n                        cal.set(Calendar.MONTH, month)\n                        cal.set(Calendar.DATE, date)\n\n                        val time = SimpleDateFormat(\"yyyy-MM-dd\", Locale.CHINA)\n                        dateTextView.text = time.format(cal.time)\n                    },\n                    cal.get(Calendar.YEAR),\n                    cal.get(Calendar.MONTH),\n                    cal.get(Calendar.DATE)\n            ).show()\n```\n\n时间弹框\n\n```kotlin\nTimePickerDialog(\n                    this,\n                    TimePickerDialog.OnTimeSetListener { _, hour, minute ->\n                        cal.set(Calendar.HOUR_OF_DAY, hour)\n                        cal.set(Calendar.MINUTE, minute)\n\n                        val time = SimpleDateFormat(\"HH:mm\", Locale.CHINA)\n                        timeTextView.text = time.format(cal.time)\n                    },\n                    cal.get(Calendar.HOUR_OF_DAY),\n                    cal.get(Calendar.MINUTE),\n                    true\n            ).show()\n```\n\n## 12GitHubStars\n\nOkHttpClient\n\n```kotlin\nval client = OkHttpClient()\n            val request = Request.Builder()\n                    .url(\"https://api.github.com/users/$username/starred\")\n                    .build()\n\n            client.newCall(request).enqueue(object: Callback {\n                override fun onFailure(call: Call?, e: IOException?) {\n                    Toast.makeText(this@MainActivity, \"get data failed\", Toast.LENGTH_SHORT).show()\n                }\n\n                override fun onResponse(call: Call?, response: Response?) {}\n            })\n```\n\n## 13LocalStorage\n\n存\n\n```kotlin\nval preference = PreferenceManager.getDefaultSharedPreferences(this)\n            val editor = preference.edit()\n            editor.putString(\"login_name\", name)\n            editor.apply()\n\n```\n\n取\n\n```kotlin\nval preference = PreferenceManager.getDefaultSharedPreferences(this)\n            val name = preference.getString(\"login_name\", \"\")\n            if (name.isEmpty()) {\n                Toast.makeText(this, \"name is empty\", Toast.LENGTH_SHORT).show()\n            }\n            nameTextView.text = name\n```\n\n## 14Ball\n\n```kotlin\nanimator = ObjectAnimator.ofFloat(imageView4, \"translationX\", 0f, 600f, 0f)\nanimator.duration = 1500\nanimator.interpolator = AccelerateInterpolator()\nanimator.start()\n```\n\n## 15Notification\n\n其实大部分API魅族都给砍了,所以加title啥的就没有必要了\n\n```kotlin\nval notify = NotificationCompat.Builder(this, \"channel id test\")\n                    .setSmallIcon(R.drawable.img)\n                    .setLargeIcon(BitmapFactory.decodeResource(resources, R.drawable.img))\n                    .setContentTitle(\"Notification\")\n                    .setContentText(\"It's time\")\n                    .setVibrate(longArrayOf(300, 600, 300, 600))\n                    .setLights(Color.RED, 1000, 1000)\n                    .build()\n            val noticeManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager\n            noticeManager.notify(1, notify)\n```\n\n## 16PushMessaging\n\n```kotlin\nval intent = Intent(\"gongMsg\")\nintent.putExtra(\"message\", text)\nbroadcast.sendBroadcast(intent)\n```\n\n## 17PullToRequest\n\nfragment记得加高度\n\n## 18SideMenu\n\n安卓常见的左滑目录\n\n## 19Sound\n\n音乐播放器,还是用默认的style吧,换一个卡得不行\n\n## 20ActivityTransition\n\nActivity转场动画\n\n## 21LayoutSwitcher\n\nGrid布局变化\n\n## 22LocalDatabase\n\n本地的SQL\n\n## 23speech\n\nTTS, 魅族居然不支持\n\n## 24Painter\n\nCanvas\n\n## 25Face\n\n人脸检测, 但是并没检测出来我\n\n## 26ActionRecieve - ActionSend\n\n```kotlin\nval intent = Intent()\nintent.action = Intent.ACTION_SEND\nintent.putExtra(Intent.EXTRA_TEXT, textEdit.text.toString())\nintent.type = \"text/plain\"\nstartActivity(intent)\n```\n\n接受的时候 intentfilter 需要加入\n\n```kotlin\n<action android:name=\"android.intent.action.SEND\" />\n<category android:name=\"android.intent.category.DEFAULT\" />\n<data android:mimeType=\"text/plain\" />\n```\n\n## 27ShakeIt\n\n摇一摇\n\n## 28Tabs\n\n顶部 tab\n\n## 29Floats\n\n自定义悬浮框 和 右下角悬浮按键\n\n## 30Video\n\n和播放器其实类似\n","collection":"blog","data":{"type":"post","category":"fe"}}]}