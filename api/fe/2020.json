{"posts":[{"id":"2020/01/03/2019-Node.md","slug":"2020/01/03/2019-node","body":"\n# 2019 年的 Node 测试最佳实践\n\n这其实不是一篇总结文档，而是一个笔记，基于[NodeJs && JS testing best practise](https://medium.com/@me_37286/yoni-goldberg-javascript-nodejs-testing-best-practices-2b98924c9347)。\n\n比较有趣的是，[Stryker Mutator](https://stryker-mutator.io/)这个工具，可以用来做 mutation testing，简单说，一般测试工具只能保证代码经过了分支，这个工具可以通过修改部分代码逻辑（比如把 true 改成 false）来判断代码是否还会经过这个逻辑。\n\n再一个就是[License Checker](https://www.npmjs.com/package/license-checker)和[plagiarism check](https://www.npmjs.com/package/plagiarism-checker)，就是避免自己养肥了被别人割韭菜。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["test"]}},{"id":"2020/02/10/actix-web-rust-web.md","slug":"2020/02/10/actix-web-rust-web","body":"\n# 利用 actix_web 使用 rust 编写 web 应用\n\n最近我一直在实践 rust 相关的内容，本来想写一篇类似于[scrapy 的文章](http://gongbaodd.github.io/tech/2020/02/04/Windows%E4%B8%8A%E4%BD%BF%E7%94%A8scrapy%E7%88%AC%E7%BD%91%E9%A1%B5.html)，后来发现内容有点多，仅仅一篇文章兜不住，干脆写一个系列好了。\n\n## 使用 Rust 的工具\n\n### rustup\n\n使用 chocolatey 安装，安装好以后只是处理好了 rustup，后面的工具链还要用再次处理。\n\n```shell\nchoco install rust\n```\n\n关于 rustup 的使用，可以查看[文档](https://github.com/rust-lang/rustup/blob/master/README.md)，包括如何做交叉编译都可以使用这个工具完成。\n\n```shell\nrustup toolchain install stable-msvc\n```\n\n### crates.io\n\n[crates.io](https://crates.io/) 是 rust 的模块库，没啥可说的。\n\n### cargo\n\ncargo 是 rust 的包管理工具。以下是几个 cargo 经常使用的命令。\n\n- `cargo new [project name]`，新建一个项目。\n- `cargo init`，初始化一个项目。\n- `cargo clean`，清理编译文件（相信我，这个会经常用）。\n- `cargo run`，编译并运行 main 文件。\n- `cargo run --bin [helper file name]`，直接执行 bin 文件夹下的文件。\n- `cargo build`，编译文件。\n- `cargo install [tools name]`，安装工具。\n\n### cargo-edit\n\n执行`cargo init`之后，项目根目录会生成一个`Cargo.toml`文件本项目的依赖模块都会放到这里，然而手动编写这个文件对于像我这样的懒人显然是无法接受的。因此可以借助`cargo-edit`完成。\n\n```shell\ncargo install cargo-edit\n```\n\n记住`cargo-edit`如下命令即可。\n\n- `cargo add [module name]` 安装一个模块。\n- `cargo rm [module name]` 删除一个模块。\n\n## rust 项目结构\n\n```shell\n- Cargo.toml\n- Cargo.lock\n- src\n-- main.rs # 项目入口文件\n-- lib.rs # 如果作为封装成一个crate，这里配置可以暴露的模块\n-- bin/ # 项目工具文件\n--- helper.rs\n```\n\n## 语法速记\n\n### 函数\n\nrust 的函数还比较有趣，它的`return`关键字是默认省略的，如果这个函数没有中断，这个函数的最后一行就是返回值，且这一行不带分号。\n\n```rust\npub async fn index() -> impl Responder {\n    format!(\"hello\")\n}\n```\n\n如果这个函数没写返回值，其实编译器还会让这个函数返回一个`()`。\n\n```rust\nfn main() {\n    println!(\"hello world\");\n    () // 此处不加()编译器还是会默认理解为返回()。\n}\n```\n\n这么做确实比较符合函数编程的概念，但是一般 rust 库里面的函数都会返回 Result 或者 Option 类型，就用 Result 类型做例子，一般会有四种处理方式。\n\n```rust\nlet bar = foo().expect(\"Panic!\"); // 直接中断程序\nlet bar = match foo() {\n    Ok(value) => Some(value),\n    Err(_) => Some(someError)\n}; // 通过match判断处理错误， 类似于其他语言的switch-case\nlet bar = foo()?; // 把错误处理交给bar\nlet bar = foo().unwrap_or(); // 成功返回成功值，失败返回unwrap_or的值\n```\n\n### 模块\n\n通常想要使用一个模块，只需要使用`use`关键字。\n\n```rust\nuse std::env;\n\nfn main() {\n    let db_url = match env::var(\"DB_URL\") {\n        Ok(_) => { \"OK\".to_owned() }\n        Err(_) => { \"Err\".to_owned() }\n    };\n\n    println!(\"{}\", db_url);\n}\n```\n\n如果引用的这个包是个非 rust 标准包（一个 crate，这里说的是我的理解，如果有个官方中文说法，以它为准），需要在添加`extern crate`关键字，如果还引用了宏，还要加上`#[macro_use]`（这就比较坑了，我哪知道到底用没用上宏，所以一般我都靠编辑器帮我编译一下...）。\n\n```rust\n#[macro_use]\nextern crate log;\n\nfn main() {\n    info!(\"debug\")\n}\n```\n\n如果只是引用本项目相对地址的文件，使用`mod`关键字就好，可以看我的[actix_log](https://github.com/gongbaodd/rust_webAssembly_study/tree/master/actix_log)。\n\n#### 为啥 rust 的模块这么复杂\n\n我猜测毕竟 rust 是对标 C 语言的，相比于很多高级语言的链接工作是在虚拟机里面做的，rust 则全部下放到语言里面，所以一起用起来就会比较复杂。\n\n## trait\n\ntrait 是 rust 上面的一个新概念，类似于 JS 的 mixin 和 Java 的接口，后面我会按例子来讲。\n\n很多库的 trait 需要单独引用，否则会编译失败，这些库往往会封装成一个 prelude 使用。\n\n```rust\nuse gtk::prelude::*;\n```\n\n## rust command\n\nrust 是个系统级语言，可以互相访问其他程序语言分享的堆内存空间，FFI 依靠的是 Box，但是本篇暂时不提及，这个[代码](https://github.com/gongbaodd/rust_webAssembly_study/tree/master/command)实现的是读取并处理其它语言的 std 输出。\n\n## Actix_web\n\n[actix-web](https://actix.rs/)是 Rust 的 web 框架之一，试用了一下，很好上手，有一点 Express 的味道。\n\n```shell\ncargo add actix-web\ncargo add actix_rt\n```\n\n官网首页的例子即是一个简单的应用。\n\n```rust\nuse actix::{\n    web,\n    App,\n    HttpServer,\n    Responder,\n    HttpRequest,\n};\n\nasync fn greet(req: HttpRequest) -> impl Responder {\n    let name = req.match_info()\n        .get(\"name\")\n        .unwrap_or(\"World\");\n\n    format!(\"Hello {}!\", name)\n}\n\n#[actix_rt]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new(\n        || {\n            App::new()\n                .route(\"/\", web::get().to(greet))\n                .route(\"/{name}\", web::get().to(greet))\n        }\n    )\n    .bind(\"127.0.0.1:8080\")?\n    .run()\n    .await\n}\n\n```\n\n当然，如果觉得路由的部分比较难写，还可以使用宏来修改。\n\n```rust\n#[get(\"/\")]\nasync fn greet(req: HttpRequest) -> impl Responder {\n    let name = req.match_info()\n        .get(\"name\")\n        .unwrap_or(\"World\");\n\n    format!(\"Hello {}!\", name)\n}\n\nApp::new().route(greet);\n```\n\n### 利用中间件处理日志和错误\n\nlog 和 env_logger 是 rust 的日志工具，基本上都是宏。\n\n```\ncargo add log\ncargo add env_logger\n```\n\nactix-web 使用 wrap 方法添加中间件，如添加 Logger 打出标准访问日志。\n\n```rust\nuse actix_web::middleware::Logger;\nasync fn main() -> std::io::Result<()> {\n    std::env::set_var(\"RUST_LOG\", \"actix_web=info,info\");\n    env_logger::init();\n\n    let url = \"127.0.0.1:8080\";\n    let app = || {\n        App::new()\n            .wrap(Logger::default())\n            .wrap(Logger::new(\"%a %{User-Agent}i\"))\n            .wrap(middleware::DefaultHeaders::new().header(\"X-Version\", \"0.2\"))\n            .wrap(ErrorHandlers::new().handler(http::StatusCode::INTERNAL_SERVER_ERROR, render_500))\n            .service(routes::index::index)\n    };\n\n    let server = HttpServer::new(app).bind(url);\n    let wait_server = server?.run();\n\n    info!(\"Running Server on {}\", url);\n    wait_server.await\n}\n```\n\n错误处理，详细代码可以查看[actix-log](https://github.com/gongbaodd/rust_webAssembly_study/tree/master/actix_log)。\n\n```rust\nfn render_500<B>(mut res: dev::ServiceResponse<B>) -> Result<ErrorHandlerResponse<B>> {\n    res.response_mut().headers_mut().insert(\n        http::header::CONTENT_TYPE,\n        http::HeaderValue::from_static(\"Error\"),\n    );\n    Ok(ErrorHandlerResponse::Response(res))\n}\n```\n\n### 使用 serde 返回 JSON\n\n想要制作 Restful API，JSON 支持是少不了的。\n\n```shell\ncargo add serde\n```\n\n由于 actix-web 对路由回应格式的支持，一个 json 文件可以这么写。\n\n```rust\nuse acrix_web:{\n    HttpResponse,\n    Responder,\n    get,\n};\nuse serde::{\n    Serialize,\n    Deserialize,\n};\n\n#[derive(Serialize, Deserialize)]\nstruct MyObj {\n    message: String,\n}\n\n#[get(\"/hello\")]\nasync fn hello() -> impl Responder {\n    HttpResponse::Ok().json(MyObj {\n        message: \"SUCCESS\"\n    })\n}\n\n```\n\n更多详细的代码可以查看我的[github](https://github.com/gongbaodd/rust_webAssembly_study/tree/master/actixweb)。\n\n## diesel 处理 ORM(sqlite)\n\n强烈安利大家去看一下 diesel 的[Get Start](http://diesel.rs/guides/getting-started/)，确实是一种下一代 ORM 的感觉。\n\n```shell\ncargo add diesel\n```\n\n### diesel_cli\n\ndiesel_cli 是 diesel 的命令行工具，提供数据部署和 schema 生成的功能，如果不指定 feature 的话，安装时会同时编译 sqlite、postgreSQL 以及 MySQL。\n\n```shell\ncargo install diesel_cli --no-default-features --features sqlite\n```\n\n第一次编译的时候，在 Windows 下面失败了，翻了一下[issue](https://github.com/diesel-rs/diesel/issues/487)找到了解决方案。\n\n首先安装 Visual Studio（反正现在免费安），使用 VS 的终端打开 sqlite 文件夹。\n\n```batch\ncd C:\\ProgramData\\chocolatey\\lib\\SQLite\\tools\nlib /def:sqlite3.def /out:sqlite3.lib\n```\n\n然后记得把`C:\\ProgramData\\chocolatey\\lib\\SQLite\\tools`放到环境变量 PATH 里面。\n\n再次编译即可，具体如何使用 diesel 的 get start 已经足够了，在此不做赘述，可以查看[源码](https://github.com/gongbaodd/rust_webAssembly_study/tree/master/diesel_demo)。\n\n这里列举一下经常用的命令\n\n- `diesel setup` 初始化。\n- `diesel migration generate [step name]` 生成 down.sql 和 up.sql。\n- `diesel migration run` 按照 SQL 文件部署数据库和 schema 文件（目前发现一个 bug，生成的 schema 不完全，没能完全复现）。\n- `diesel migration revert` 撤回数据库操作。\n\n### 补充一下 rust 语法里面的生命周期\n\ndemo 里面的 lib 文件 create_post 语法很奇怪。\n\n```rust\npub fn create_post<'a>(conn: &SqliteConnection, title: &'a str, body: &'a str) -> usize {\n    use schema::posts;\n\n    let new_post = NewPost {\n        title: title,\n        body: body,\n    };\n\n    diesel::insert_into(posts::table)\n        .values(&new_post)\n        .execute(conn)\n        .expect(\"Error saving new post\")\n}\n```\n\n`<'a>`的写法是指明函数的生命周期标注，因为 rust 没有垃圾回收机制，所有申请的堆内存在一个函数执行结束后就会回收。所以当一个函数的输入值是堆内存的变量，就发生「借用」，如这个函数里面的三个参数，借用都用`&`来标注。\n\n假设一个变量借出给另一个函数，而在借用变量的函数执行阶段借出函数就结束并销毁变量，程序就会出错，因此生命周期就是用来确定一个借出的变量必须还回后才能被销毁。默认 rust 都会给一个生命周期，然而当出现两个以上生命周期时，如`create_post`则需要程序员指定参数必须在一个生命周期内。\n\n## juniper 实现 graphql\n\n写一个 Query 的方法\n\n```rust\n#[derive(juniper::GraphQLObject)]\nstruct MyObj {\n    name: String,\n}\n\nstruct QueryRoot;\n#[derive(juniper::object)]\nimpl QueryRoot {\n    fn myObj() -> juniper::FieldResult {\n        Ok(MyObj {\n            name: \"World\"\n        })\n    }\n}\n```\n\nMutation 也类似，基本很简单，可以查看[代码](https://github.com/gongbaodd/rust_webAssembly_study/blob/master/graphql_only)了解。\n\n### rust 语法里面闭包里面 move 的使用\n\n前面说过，如果一个函数想调用另一个函数的堆内存，可以借用。但是还有另一种函数，闭包，理论上闭包可以处理闭包所在词法作用域下的所有变量。在动态执行时如果闭包中依赖的一个变量已经销毁也是很危险的事儿，所以这里可以用 move 关键字将变量所有权交给闭包，在闭包外则无权再次处理已经 move 的变量。\n\n```rust\nasync fn main() -> io::Result<()> {\n    let schema = std::sync::Arc::new(create_schema());\n\n    let app = move || {\n        App::new()\n            .data(schema.clone())\n            .wrap(middleware::Logger::default())\n            .service(graphql)\n            .service(graphiql)\n    };\n\n    HttpServer::new(app)\n        .bind(\"127.0.0.1:8080\")?\n        .run()\n        .await\n}\n```\n\n当然 graphql 的代码里面还有 RC 和 ARC 的概念，现在暂时了解他们时 Rust 下面的引用计数的一种实现，RC 用于单线程，ARC 用于多线程。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["rust","actix_web"]}},{"id":"2020/02/21/Windows-flutter.md","slug":"2020/02/21/windows-flutter","body":"\n# Windows 安装 flutter 开发环境\n\n从 chocolatey 可以直接安装 flutter。\n\n```shell\nsudo choco install flutter\n```\n\n运行成功后可以运行`flutter doctor`检查环境是否完备，比如我会有`X Android license status unknown.`报错，可以运行以下命令检查详情。\n\n```shell\nflutter doctor --android-licenses\n```\n\n发现 SDK 管理的问题，进而发现要把 JDK 降级到 8.0，好在有 chocolatey，很快就解决了。\n\n```shell\nsudo choco install ojdkbuild8\n```\n\n然后修改.bashrc 设置代理\n\n```shell\nexport HTTP_PROXY=127.0.0.1:1080\nexport HTTPS_PROXY=127.0.0.1:1080\nexport NO_PROXY=127.0.0.1,localhost\n```\n\n打开 VScode，安装 flutter，打开命令面板输入`flutter new`，就可以创建工程了（然后下载了巨多文件，感觉如果写个 hello world 都要加载这么多文件真是比较坑）。\n\n打开模拟器，在 VSCode 里面按 F5 就能实时 debug 了。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["flutter","dart"]}},{"id":"2020/02/22/hoisting.md","slug":"2020/02/22/hoisting","body":"\n# 我也谈谈 hoisting\n\n最近在看 getify 的[You-Dont-Know-JS](https://github.com/getify/You-Dont-Know-JS)，第二版里面相对于第一版增加了很多个人认为比较硬核的东西。第二版貌似对 var 关键字进行了洗白，就目前来看还是比较争议的，毕竟这几年来我基本上已经用 let 完全替代 var 了。\n\n最近我正好是在学习 Rust，首先说明一下 Rust 的确是一个不太好学习的语言，但是学会了之后就会对编译原理有更高更深一层次的认识（同样学会了 typescript，也会有类似的感觉）。\n\n那也许是时代的问题。人们发现面向对象并不是万能的，面向函数逐渐的从原来不受人注意，变的受人理解。尤其是最近我还跟一些人在讨论到一些面向对象的继承属性。以后的以后的继承，将逐渐被组合所替代。甚至是 rust，里面已经没有了继承关系。而最受欢迎的前端框架 react 框架也逐渐的使用函数来替代对象。\n\n那么我们现在回顾一下，2015 年，那年 TC39 发布了 ECMA2015，包括块级作用域，let，class 等关键字。当时 JavaScript 的作者，Brendan Eich 就说他不赞成这个对象的设计，但是显然很多人没有理解，当然后来还发生了关于 class 成员是否跟分号的 bug。\n\n那么现在我们把当年的事情再拿出来看一看。Hoisting 这个 JavaScript 独有的特性，是不是一个鸡肋的 bug。\n\n参考 BrendanEich 老爷子自己的[话](https://twitter.com/brendaneich/status/562313394431078400)\n\n> function declaration hoisting is for mutual recursion & generally to avoid painful bottom-up ML-like order\n\n> `var` hoisting was an implementation artifact. `function` hoisting was better motivated.\n\n首先是 ML 这个语言呢也是一个基于函数的语言。但是跟 js 不太一样的是，这个语言就没有 hoisting，所以呢，看代码就只能是一行一行的看下去，比较麻烦。\n\n至于 var 的提升，则是实现 function 带来的人工产物。\n\n想一想 2015 年之前我们写前端 js 代码的时候，往往会把依赖的 function 放到最底下。\n\n```javascript\nfunction foo() {\n  bar1();\n  bar2();\n  bar3();\n\n  return;\n\n  function bar1() {}\n\n  function bar2() {}\n\n  function bar3() {}\n}\n```\n\n其实就像你现在这个角度来观察这个代码，也会觉得。这个语言的确有它的独到之处。这样的写法，直接通过 return 关键字，把一个函数分成了构造函数部分和他的私有成员。如果想要了解这个函数的功能的话，大可不必把所有的函数都看一遍。\n\n自从有了块级作用域，JavaScript 就必须要考虑，同时存在块级作用域和函数作用域的情况，就出现了 TDZ 的情况。简单讲就是说，就是块级作用域，变量不能被重复声明，即使是使用函数声明，而以前的 var 关键字是可以重新定义的（当然重新定义的时候没有重新赋值，因为提升的关系重新定义，并不存在）。\n\n```javascript\n{\n  let foo = \"foo\";\n  var foo; // wrong\n}\n```\n\n```javascript\n{\n  var foo = \"foo\";\n  let foo; // wrong\n}\n```\n\n那么块级作用域有没有提升呢？那肯定是有的，因为如果你想判断这个作用域下面的变量是不是被重新定义了，还是要预先申请内存的。只不过在他声明之前被使用的话，相比于函数变量返回未定义的值，块级作用域会报错。\n\n所以我们一般会把块级作用域变量定义放在这个块儿的最上面，来消除 TDZ。\n\n但是把定义放在最上面的话，就如之前所说的失去了 JavaScript 初衷的优雅。所以 function 和 var 关键字并不一定被宣判死刑，而是在特定的情况下还能被拿出来使用。\n\n不过，话说回来，优雅的东西不一定就是所有人喜欢的。块级作用域对 C 语言使用者来说没有学习障碍，工程上还是少数服从多数，选择最简单的而不是选择最对也存在合理性，所以即使现在面向对象逐渐失宠也不一定将来也会被摒弃。\n\n另外，Eich 和 Crockford 还有一篇访谈，可以看一下。\n\n[Eich and Crockford on the Future of JavaScript: Insight from the Creators of JavaScript and JSON](https://www.infoq.com/news/2018/07/eich-crockford-js-future/)\n","collection":"blog","data":{"type":"post","category":"fe","tag":["JavaScript"]}},{"id":"2020/02/25/stryker-mutation test.md","slug":"2020/02/25/stryker-mutation-test","body":"\n# 使用 stryker 做 mutation test\n\n今年年初的时候，我整理了一下前端测试现状，有一项就是 mutation test。本文将会讲一下如何给 typescript 项目添加 mutation test。\n\n## Stryker-mutator\n\n首先，为项目安装 stryker 全家桶。\n\n```shell\nyarn add -D stryker-typescript stryker-jest-runner stryker-html-reporter stryker-api stryker\n```\n\n你可能会接到升级的警告，我发现最新版本（以@stryker-mutator 做域）会有 bug，而且 github 上面显示 CI 编译失败，保守起见，还是使用老版本比较好。\n\n执行`yarn stryker init`初始化项目，修改 stryker.conf.js，详细的参数说明可以参考[这里](https://github.com/stryker-mutator/stryker/tree/master/packages/core)。\n\n```javascript\nmodule.exports = function stryker(config) {\n  config.set({\n    mutator: \"typescript\",\n    mutate: [\"src/linked_node/**/*.ts\", \"!src/**/*.spec.ts\"],\n    packageManager: \"yarn\",\n    reporters: [\"clear-text\", \"dashboard\", \"progress\", \"html\"],\n    testRunner: \"jest\",\n    coverageAnalysis: \"off\",\n    tsconfigFile: \"tsconfig.json\",\n    dashboard: {\n      reportType: \"full\",\n    },\n  });\n};\n```\n\n注意，官网的 tutorial 会要求添加 transpilor 为 typescript，这里因为我们的测试 runner 是已经配置好的 jest，所以不能再添加一次编译。\n\n执行`yarn stryker run`就能执行测试，这个测试很占用性能，我这 10 代 i7 的本都要跑 8 分钟左右，执行成功会生成报告存储在 reports 文件夹下。\n\n## 配置 travis\n\nstryker 官方提供[dashboard](https://dashboard.stryker-mutator.io)，登入配置好环境变量即可生成 stryker 的徽章，可以把它贴到 github 的 readme 中。这样，每次 travis 执行好 mutation test 后都能更新徽章分数。\n\n关于 dashboard 如何配置可以参考[handbook](https://github.com/stryker-mutator/stryker-handbook/blob/master/dashboard.md)。\n\n但是我没能成功上传 report，只能显示出分数，并不确定哪里出了问题，还是看官方如何更新吧。\n\n## 原理\n\n如果我有以下函数，并配合 100%测试覆盖的单元测试。\n\n```typescript\nfunction isGe18(num: number) {\n  return num >= 18;\n}\n\ndescribe(\"the input is 1\", () => {\n  it(\"should return false\", () => {\n    expect(isGe18(1)).toBe(false);\n  });\n});\n```\n\n显然以上的测试是不完备的，那么 stryker 如何找到它不完备的地方？首先修改函数的返回值，如生成如下四个函数。\n\n```typescript\nfunction isGe18_1(num: number) {\n  return num > 18;\n}\nfunction isGe18_2(num: number) {\n  return num < 18;\n}\nfunction isGe18_3(num: number) {\n  return true;\n}\nfunction isGe18_3(num: number) {\n  return false;\n}\n```\n\n分别用他们重新跑测试，只要有一个测试失败，就称这个 mutate 被 killed，如果测试全部通过，则称 mutate 被 survived。\n则对应上面例子：\n\n- isGe18_1 => survived\n- isGe18_2 => killed\n- isGe18_3 => killed\n- isGe18_3 => survived\n\n则此时需要增加测试\n\n```typescript\ndescribe(\"the input is 19\", () => {\n  it(\"should return true\", () => {\n    expect(isGe18(19)).toBe(true);\n  });\n});\n\ndescribe(\"the input is 18\", () => {\n  it(\"should return true\", () => {\n    expect(isGe18(18)).toBe(true);\n  });\n});\n```\n\n重新跑测试\n\n- isGe18_1 => killed（最后一个测试未通过）\n- isGe18_2 => killed\n- isGe18_3 => killed\n- isGe18_3 => killed（新增加的 2 个测试未通过）\n\n此时测试才是完备的。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["test","stryker","javascript"]}},{"id":"2020/02/27/rust-webassembly-game-of-life.md","slug":"2020/02/27/rust-webassembly-game-of-life","body":"\n# 使用 rust 和 webassembly 开发 game of life\n\n这是一篇翻译，[原文](https://github.com/rustwasm/book.git)，这可能是第一篇系统讲解 rustwasm 的文章了。\n\n## 这本书适合谁？\n\n这本书适合任何对快速编译 Rust 和 Webassembly 感兴趣的人，相关的代码已经发布在网上。你应该已经了解一些 Rust 的知识，对 JavaScript HTML 和 css 很熟悉，但你不需要是在这些方面的专家。\n\n还不了解 rust？请先参阅[开始使用 rust 语言](https://doc.rust-lang.org/book/)。\n不了解 JavaScript 的 html 或者是 css？请参阅[MDN](https://developer.mozilla.org/en-US/docs/Learn)\n\n## 为什么用 rust 和 webAssembly\n\n### 底层支持和高效(Low-Level Control with Hign-Level Ergonomics)\n\nJavascript 的应用，纠结于如何保持高效运作。但是 JavaScript 的动态类型系统和垃圾回收机制，使他们不能高效。看起来很小的修改，如果不小心走出了 JIT 的舒适区，看起来很小的修改都会导致很严重的错误。\n\n### .wasm 文件大小\n\n因为要通过网络下载，代码的大小就变得异常重要。Rust 不需要运行环境，使得编译文件不需要包括垃圾回收器。这些文件包括的只有真正需要的函数。\n\n### 不要重写所有的东西\n\n现有的代码不需要被扔走，你可以把性能最严重的 JavaScript 函数，交给 rust 去执行。\n\n### 和其他工具交互融洽\n\nRust 和 WebAssembly 支持现有的工具链，它支持 ecmascript 模块，并且你依然可以使用现有的工具链如 NPM，webpack 和 greenkeeper。\n\n## 背景和相关概念\n\n### 什么是 WebAssembly\n\nWebAssembly（wasm）是一个简单的机器模块拥有大量的[定义](https://webassembly.github.io/spec/)。它被设计得以相近于原生的速度便携紧密地执行。\n\n作为一个开发语言，尽管是以两种方式展示的格式，wasm 依然表示于同样的结构。\n\n- `.wat`文本格式（叫做 WebAssembly Text），使用[S-expression](https://en.wikipedia.org/wiki/S-expression)，有点类似于 Lisp 家族，像是 Scheme 和 Clojure。\n- `.wasm`二机制格式，是一个底层的目标是让 wasm 虚拟机使用的格式，有些类似于 ELF 和 Mach-O。\n\n以`.wat`书写的斐波那契数列如下：\n\n```wasm\n(module\n  (func $fac (param f64) (result f64)\n    get_local 0\n    f64.const 1\n    f64.lt\n    if (result f64)\n      f64.const 1\n    else\n      get_local 0\n      get_local 0\n      f64.const 1\n      f64.sub\n      call $fac\n      f64.mul\n    end)\n  (export \"fac\" (func $fac)))\n```\n\n如果感兴趣的话，可以使用[此工具](https://webassembly.github.io/wabt/demo/wat2wasm/)执行上面的代码。\n\n#### 线性内存\n\nWasm 使用的[内存模式](https://webassembly.github.io/spec/core/syntax/modules.html#syntax-mem)很简单。一个 wasm 模块，可以访问的一系列内存，被限制于一个字节数组中。这些内存会[增长](https://webassembly.github.io/spec/core/syntax/instructions.html#syntax-instr-memory)为多个页（64K）不会收缩。\n\n#### Wasm 是仅仅为 web 开发的吗？\n\n尽管在 JavaScript 和 web 社区中有很多讨论。WASM 并没有考虑过它的运用环境。所以目前只能定义它为将来可以使用的便携运行格式。但就目前而言，wasm 仍然在很多方面与 JavaScript 有关。不仅仅是浏览器，还有 Node.js。\n\n## 关于本书\n\n这一部分开始使用 Rust 和 WebAssembly 开发[Conway 的 Game of Life](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life)。\n\n本章会讲到以下内容。\n\n- 如何搭建编译 WebAssembly 的 Rust 工具链。\n- 一个支持开发多语言程序（Rust、wasm、JavaScript、HTML 和 CSS）的工作流。\n- 设计最大利用 rust 和 wasm 的优势配合 JavaScript 的优点的 API。\n- 如何调试 wasm 模块。\n- 如何查看 wasm 的时间日志（time profile）。\n- 如何减少生成的二进制文件包大小。\n\n## 安装工具\n\n本节将会介绍编译 Rust 编译 WASM 并和 JavaScript 集成的工具链。\n\n### Rust 工具链\n\n你需要安装 rust 的标准工具链，[rustup，rustc 和 cargo](https://www.rust-lang.org/tools/install)（强烈建议你们在 WSl 的环境下面工作）。\n\nWASM 已经推动 Rust 新特性进入稳定版，所以我们需要有 1.30 或更新版本。\n\n### wasm-pack\n\n`wasm-pack`是一站式的建造测试以及发布 rust 相关的 wasm 应用工具。\n\n```shell\ncargo install wasm-pack\n```\n\n### cargo-generate\n\n`cargo-generate`帮助你使用现存的 Git 仓库作为模板新建 Rust 项目。\n\n```shell\ncargo install cargo-generate\n```\n\n### NPM\n\n`npm`是 JavaScript 的包装管理器。我们将利用它，去安装和运行 JavaScript 的打包和测试部署。我们将把我们编译好的`.wasm`文件放到 npm 的包中。\n\n如果你已经安装了 NPM 可以执行以下命令，安装最新版。\n\n```shell\nnpm install npm@latest -g\n```\n\n## 你好，世界\n\n通过本部分可以创建一个 Rust+WASM 页面，并能在页面弹窗展示`\"Hello, World!\"`。\n\n### 复制项目模板\n\n这个项目的模板已经提前编译好，可以借此快速绑定、集成和打包成 Web 项目。\n\n利用模板创建项目的命令：\n\n```shell\ncargo generate --git https://github.com/rustwasm/wasm-pack-template\n```\n\n它会提醒你新建一个项目名称，这里我们先使用\"wasm-game-of-life\"。\n\n### 文件结构\n\n进入项目文件夹。\n\n```shell\ncd wasm-game-of-life\n```\n\n以下是项目文件夹：\n\n```\nwasm-game-of-life/\n├── Cargo.toml\n├── LICENSE_APACHE\n├── LICENSE_MIT\n├── README.md\n└── src\n    ├── lib.rs\n    └── utils.rs\n```\n\n接下来详细看一下：\n\n#### wasm-game-of-life/Cargo.toml\n\n`Cargo.toml`文件描述`cargo`的依赖和源文件，Rust 的包管理工具和编译工具。这个包括`wasm-bindgen`依赖，我们会稍后了解其他的依赖，还有一些用来初始化`.wasm`的`crate-type`库。\n\n#### wasm-game-of-life/src/lib.rs\n\n`src/lib`文件放在 Rust 项目的更目录下面。它使用`wasm-bindgen`去和 JavaScript 链接。它能引入`window.alert`这个 JavaScript 函数，并暴露`greet`函数，并弹出弹框。\n\n```Rust\nmod utils;\nuse wasm_bindgen::prelude::*;\n\n// 当wee_alloc特性被打开，将会使用wee_alloc作为全局分匹配器\n#[cfg(feature = \"wee_alloc\")]\n#[global_allocator]\nstatic ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;\n\n#[wasm_bindgen]\nextern {\n    fn alert(s: &str);\n}\n\n#[wasm_bindgen]\npub fn greet() {\n    alert(\"Hello, wasm-game-of-life!\");\n}\n```\n\n#### wasm-game-of-life/src/utils.rs\n\n`src/utils`模块为编译 Rust 到 WASM 提供工具函数，我们后面会在调试时提到它，现在先忽略。\n\n### 编译项目\n\n使用`wasm-pack`依赖以下工具：\n\n- 保证 Rust 版本在 1.30 以上，且已经通过`rustup`安装`wasm32-unknown-unknown`工具链。\n- 使用`cargo`编译 Rust 到 WASM。\n- 使用`wasm-bindgen`去生成 JavaScript 的 API。\n\n为了完成以上内容，需要在根目录执行以下命令：\n\n```shell\nwasm-pack build\n```\n\n编译完成后，我们可以看到`pkg`里面的结构，里面应该有如下文件。\n\n```\npkg/\n├── package.json\n├── README.md\n├── wasm_game_of_life_bg.wasm\n├── wasm_game_of_life.d.ts\n└── wasm_game_of_life.js\n```\n\n`README.md`文件是直接从根目录复制的，但是其他文件完全是新生成的。\n\n#### wasm-game-of-life/pkg/wasm_game_of_life_bg.wasm\n\n`.wasm`文件是 Rust 工具链使用 Rust 源代码生成的 WASM 的二进制文件，它包括全部的函数和数据，比方说，爆露出来的`greet`函数。\n\n#### wasm-game-of-life/pkg/wasm_game_of_life.js\n\n这个`.js`文件是`wasm-bindgen`引入 DOM 和 JavaScript 方法到 Rust 中，并油耗地暴露 WASM 的 API 到 JavaScript 中。举个例子，这里个`greet`函数包裹了 WASM 中的`greet`函数，目前，这个粘合还没做任何功能，当我们逐渐从 WASM 和 JavaScript 中传输数据，他会提供帮助。\n\n```javascript\nimport * as wasm from \"./wasm_game_of_life_bg\";\n\nexport function greet() {\n  return wasm.greet();\n}\n```\n\n#### wasm-game-of-life/pkg/wasm_game_of_life.d.ts\n\n这个`.d.ts`是 TypeScript 链接 JavaScript 的文件。如果你的项目中使用了 TypeScript，你可以让你的 WebAssembly 项目被类型检查，并且你的 IDE 会提供代码提醒和自动完成功能。\n\n```TypeScript\nexport function greet(): void;\n```\n\n#### wasm-game-of-life/pkg/package.json\n\n这个文件包括了所有生成的文件描述，并使得这个项目能够作为一个使用 WebAssembly 的 NPM 包，能够集成到 JavaScript 工具链并发布至 NPM。\n\n```json\n{\n  \"name\": \"wasm-game-of-life\",\n  \"collaborators\": [\"Your Name <your.email@example.com>\"],\n  \"description\": null,\n  \"version\": \"0.1.0\",\n  \"license\": null,\n  \"repository\": null,\n  \"files\": [\"wasm_game_of_life_bg.wasm\", \"wasm_game_of_life.d.ts\"],\n  \"main\": \"wasm_game_of_life.js\",\n  \"types\": \"wasm_game_of_life.d.ts\"\n}\n```\n\n### 开始加入页面\n\n想要`wasm-game-of-life`能够展示到页面中，需要使用[`create-wasm-app` JavaScript 模板](https://github.com/rustwasm/create-wasm-app)。\n\n在项目根目录执行以下命令：\n\n```shell\nnpm init wasm-app www\n```\n\n这是`wasm-game-of-life/www`文件夹包括的文件。\n\n```\nwasm-game-of-life/www/\n├── bootstrap.js\n├── index.html\n├── index.js\n├── LICENSE-APACHE\n├── LICENSE-MIT\n├── package.json\n├── README.md\n└── webpack.config.js\n```\n\n#### wasm-game-of-life/www/package.json\n\n这个文件包括已经配置好的`webpack`和`webpack-dev-server`依赖，和`hello-wasm-pack`，版本号为已经发布到 NPM 上面的版本号。\n\n#### wasm-game-of-life/www/webpack.conf.js\n\n这个是用来配置 webpack 和开发服务器的文件。该文件已经提前布置好，如果只是开发则无需过多关心这个文件。\n\n#### wasm-game-of-life/www/index.html\n\n这是页面的 HTML 文件，它是来调用`bootstrap.js`的。\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\" />\n    <title>Hello wasm-pack!</title>\n  </head>\n  <body>\n    <script src=\"./bootstrap.js\"></script>\n  </body>\n</html>\n```\n\n#### wasm-game-of-life/www/index.js\n\n这是 JavaScript 的入口文件，他引入了`hello-wasm-pack`，并带哦用了 greet 函数。\n\n```JavaScript\nimport * as wasm from \"hello-wasm-pack\";\n\nwasm.greet();\n```\n\n#### 安装 NPM 依赖\n\n首先保证已经在`www`文件夹下面执行过`npm i`，这个命令会安装好现有依赖包括 webpack 和开发服务器。\n\n> 注意 webpack 并不是必须的，他只是个打包器并提供了开发服务器，这是我们选择它的原因。Parcel 和 Rollup 一样支持 WebAssembly 模块。你也可以选择[不使用打包器](https://rustwasm.github.io/docs/wasm-bindgen/examples/without-a-bundler.html)。\n\n#### 在 www 文件夹中使用本地 wasm-game-of-life 包\n\n相比于使用 NPM 线上的`hello-wasm-pack`，使用本地文件会提高我们的开发舒适度。\n\n打开`www/package.json`，找到`devDependencies`，在兄弟节点增加`dependencies`字段，并在里面增加`\"wasm-game-of-life\": \"file:../pkg\"`。\n\n```JSON\n{\n  // ...\n  \"dependencies\": {                     // Add this three lines block!\n    \"wasm-game-of-life\": \"file:../pkg\"\n  },\n  \"devDependencies\": {\n    //...\n  }\n}\n```\n\n接下来修改`www/index.js`引入 greet 函数。\n\n```JavaScript\nimport * as wasm from \"wasm-game-of-life\";\n\nwasm.greet();\n```\n\n既然修改了 package.json，则需要重新安装他。\n\n```shell\nnpm install\n```\n\n好了，现在服务器可以成功运行了。\n\n#### 启动本地服务\n\n接下来，打开一个新终端来在后台运行服务器，请在`www`文件夹下执行如下命令。\n\n```shell\nnpm run start\n```\n\n打开http://localhost:8080，应当会弹出如下弹窗。\n\n![弹窗](https://rustwasm.github.io/book/images/game-of-life/hello-world.png)\n\n### 练习\n\n修改 greet 函数，引入参数`name: &str`，重新执行`wasm-pack build`，并刷新页面使得弹窗中能够显示\"Hello, {name}\"。\n\n**_答案，不许看！_**\n\n修改`src/lib.rs`\n\n```Rust\n#[wasm_bindgen]\npub fn greet(name: &str) {\n    alert(&format!(\"Hello, {}!\", name));\n}\n```\n\n再修改 JavaScript 绑定`www/index.js`\n\n```JavaScript\nwasm.greet(\"Your name\");\n```\n\n## Conway 的生命游戏的游戏规则\n\n如果你已经了解[Conway 的生命游戏](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life)，可以跳过这部分。\n\n整个 Conway 的生命游戏是在一个无限的二维的正交格子宇宙中，每一个细胞拥有两种生命状态，生或者死。或者说可增殖或者不可增殖。每一个细胞都和它的 8 个邻居交互，它们分别是纵向的，斜向的，横向的相邻。并且每一步都会发生如下的变化。\n\n1. 任何一个活着的细胞，如果有少于两个邻居就会死亡。\n2. 任何一个活细胞拥有两个或三个活着的邻居，则会继续增殖。\n3. 任何一个活着的细胞拥有三个以上活着的的邻居，则会死亡。\n4. 任何一个死掉的细胞，如果有三个活着的邻居，则会重生。\n\n最初的图案组成了最初的世界。第 1 代是按照以上的规则生成的，每一个细胞的生成和死亡都是同时的。他们的生存和死亡这一个时间我们称之为一刻。用程序的语言来说，这一刻是上一次生成的纯函数。这个规则一直有效。\n\n考虑设置如下的初始宇宙：\n\n![初始宇宙](https://rustwasm.github.io/book/images/game-of-life/initial-universe.png)\n\n我们可以通过考虑每一个细胞来确定下一代。最左上角的细胞已经死亡，第 4 条规则是唯一一个能够处理死亡细胞的规则。所以第 1 排的所有细胞都有相同的规则。他们都没有三个活着的邻居。只能保持死亡。\n\n当我们看到最上面的活着的细胞时，这个游戏开始变得有趣了。在第 2 排第 3 列。对于活着细胞前三个规则都可以应用。对于这一个细胞，他只有一个活着的邻居，所以规则一可用。这个细胞会在下一次争执死亡。下面那几个活着的细胞也是有一样的命运。\n\n中间的活着的细胞，还有两个邻居，上面的和下面的，这就意味着它符合规则二，他可以活到下一次增值。\n\n最后一个比较有趣的例子，就是当我们看到死掉的细胞。嗯。在中间这活着的细胞的左边和右边。这三个活着的细胞都是他们的邻居。这使得他们按照规则是可以在下一轮重生。\n\n将这些规则放在一起，我们可以获得下一刻的世界。\n\n![下一刻的世界](https://rustwasm.github.io/book/images/game-of-life/next-universe.png)\n\n根据这个例子，和确定的规则。不去并精彩的事情将会发生。\n\n![Gosper's glider gun](https://upload.wikimedia.org/wikipedia/commons/e/e5/Gospers_glider_gun.gif)\n\n![Pulsar](https://upload.wikimedia.org/wikipedia/commons/0/07/Game_of_life_pulsar.gif)\n\n![Space ship](https://upload.wikimedia.org/wikipedia/commons/3/37/Game_of_life_animated_LWSS.gif)\n\n### 练习\n\n手动计算出下一刻，宇宙应该是什么样\n\n**_答案，不许看！_**\n\n![下一刻宇宙](https://rustwasm.github.io/book/images/game-of-life/initial-universe.png)\n\n你能找到一个稳定的没有变化的宇宙吗？\n\n**_答案，不许看！_**\n\n这个答案，不许看！其实有无数个，最平凡的答案，不许看！就是它是一个空宇宙。如果是一个 2×2 的方格，也可以形成一个稳定的宇宙。\n\n## 实现 Conway 的生命游戏\n\n### 设计\n\n在开始之前呢，我们要先考虑以下几种设计模式。\n\n#### 无限宇宙\n\n生命游戏是在一个无限宇宙中玩的。但是我们没有无限的内存和计算能力。在这种情况下，我们往往会有三个选项。\n\n1. 始终追踪这个宇宙的发展，并适当的扩展宇宙。这个扩张是无限的，所以这个实现实现了就会逐渐逐渐的变得越来越慢，直到把内存全部用完。\n2. 创建一个固定的宇宙，当细胞碰到宇宙的边缘的时候，将会有更少的邻居。更简单的策略就是当他们已经达到边缘的时候，直接被宇宙剪掉。\n3. 创建一个固定的宇宙，当细胞达到边缘的时候，将会从另外一边滑入这样，我的我们的应用就可以一直跑下去。\n\n我们会按照第 3 个选项来实现。\n\n#### 连接 Rust 和 JavaScript\n\n> 此部分是本人最重要的一节。\n\nJavaScript 的垃圾回收堆内存，是用来调用 Object 和 Array 还有 DOM 结点的。而 Rust 存在的 WebAssembly 线性内存和它是截然不同的。WebAssembly 目前还不能直接操作垃圾回收堆内存（在 2018 年 4 月，一个关于[接口类型（Interface Type）](https://github.com/WebAssembly/interface-types/blob/master/proposals/interface-types/Explainer.md)的提案将会改变这一局面）。JavaScript 却可以读写 WebAssembly 的线性内存，但仅限于 ArrayBuffe 支持的标量（u8, i32, f64 等等）。WebAssembly 行数一样能处理和返回这些标量。以下讲解 WebAssembly 和 JavaScript 如何链接。\n\nwasm_bindgen 定义了如何穿过这段链接计算数据结构的方法。它包括装箱 Rust 结构，并包装指针成为一个 JavaScript 类以供使用，或者提供 JavaScript 对象给 Rust 使用。wasm_bindgen 非常便利，但并不是无需考虑怎样在这个链接上传输数据结构。你应该把它当作一个实现接口的工具。\n\n当设计 WebAssembly 和 JavaScript 的接口时，我们需要考虑到以下内容。\n\n1. **减少复制到和移出 WebAssembly 线性内存中的值**，无效的复制会造成无用的性能损耗。\n2. **最小的序列化和解序列化**，和复制类似，序列化和解序列化一样造成性能损耗，如果想要把数据无副作用地从一端传到另一端，与其说在一端序列化，到另一端解序列化，不如使用 wasm_bindgen 帮助我们将 JavaScript 的 Object 装箱成 Rust 的 structure。\n\n一个结论，处理 JavaScript 和 WebAssembly 接口设计时，经常将大的、生命周期长的数据结构作为 Rust 类型，存储在 WebAssembly 线性内存中，并给 JavaScript 暴露一个处理方法，JavaScript 调用 WebAssembly 转换文件，处理运算，并最终得到一个小的，可复制的结果。通过只返回计算结果，我们可以躲过复制和序列化数据的过程。\n\n#### 在生命游戏中链接 Rust 和 JavaScript\n\n接下来结局几个要规避的问题。我们不想每刻都复制整个宇宙到 WebAssembly 的内存中，我们不想处理宇宙中所有的细胞，也不想在每次读写细胞的时候都穿过 WebAssembly 和 JavaScript 的分界。\n\n这是我们的 4x4 宇宙在内存中的结构。\n\n![4x4宇宙在内存中的结构](https://rustwasm.github.io/docs/book/images/game-of-life/universe.png)\n\n为了寻找细胞在内存中的位置，我们可以使用下面的公式。\n\n```\nindex(row, column, universe) = row * width(universe) + column\n```\n\n我们有很多方法来给 JavaScript 暴露宇宙中的细胞。开始我们要为宇宙实现一个`std::fmt::Display`。我们可以使用一个 Rust 的 String，每个字符代表一个细胞。这个 Rust 的 string 将会从 WebAssembly 的内存中复制到 JavaScript 的内存里，并接下来作为 textContent 展示到 HTML 里面。本节的后面，将会讲到如何把细胞展示到 canvas 中。\n\n> 另一种设计是让 Rust 返回每个细胞的生存状态列表，这样 JavaScript 就不需要在渲染时解析整个宇宙，这不过这个是先更加复杂些。\n\n#### Rust 的实现\n\n上一章，我们复制了初始化模板，我们现在要修改这个模板。\n\n从删除 greet 函数，并定义宇宙中的细胞开始。\n\n```Rust\n#[wasm_bindgen]\n#[repr(u8)]\n#[derive(Clone, Copy, Debug, PartialEq, Eq)]\npub enum Cell {\n    Dead = 0,\n    Alive = 1,\n}\n```\n\n`#[repr(u8)]`很重要，这样每个细胞都会以一个字节存储，另外 Alive 为 1，Dead 为 0 也很重要，这样我们就可以使用加法计算邻居数目。\n\n接下来定义宇宙，一个宇宙包括宽度，高度和一个向量的细胞。\n\n```Rust\n#[wasm_bindgen]\npub struct Universe {\n    width: u32,\n    height: u32,\n    cells: Vec<Cell>,\n}\n```\n\n访问并转换细胞的实现如下。\n\n```Rust\nimpl Univers {\n    fn get_index(&self, row: u32, column: u32) -> usize {\n        (row*self.width + column) as usize\n    }\n}\n```\n\n为了计算细胞接下来的状态，我们要统计某个细胞有多少个邻居存活。\n\n```Rust\nimpl Univers {\n    fn live_neighbor_count(&self, row: u32, column: u32) -> u8 {\n        let mut count = 0;\n        for delta_row in [self.height - 1, 0, 1].iter().cloned() {\n            for delta_col in [self.width - 1, 0, 1].iter().cloned() {\n                if delta_row == 0 && delta_col ==0 {\n                    continue;\n                }\n\n                let neighbor_row = (row + delta_row) % self.height;\n                let neighbor_col = (column + delta_col) % self.width;\n                let idx = self.get_index(neighbor_row, neighbor_col);\n                count += self.cells[idx] as u8\n            }\n        }\n        count\n    }\n}\n```\n\n这个函数使用取余处理边界问题。现在我们已经有所有的必须函数了，最后只需要生成下一刻的状态即可（记住，每个函数必须在`#[wasm_bindgen]`属性之下，这样 JavaScript 才能接到暴露的函数）。\n\n```Rust\n#[wasm_bindgen]\nimpl Universe {\n    pub fn tick(&mut self) {\n        let mut next = self.cells.clone();\n\n        for row in 0..self.height {\n            for col in 0..self.width {\n                let idx = self.get_index(row, col);\n                let cell = self.cells[idx];\n                let live_neighbors = self.live_neighbor_count(row, col);\n\n                let next_cell = match (cell, live_neighbors) {\n                    (Cell::Alive, x) if x < 2 => Cell::Dead,\n                    (Cell::Alive, 2) | (Cell::Alive, 3) => Cell::Alive,\n                    (Cell::Alive, x) if x > 3 => Cell::Dead,\n                    (Cell::Dead, 3) => Cell::Alive,\n                    (otherwise, _) => oterwise,\n                };\n\n                next[idx] = next_cell;\n            }\n        }\n        self.cells = next;\n    }\n}\n```\n\n目前为止，一个宇宙的状态就都被存储在 cell 这个向量里面了。为了提高它的可读性，让我们实现一个文本渲染器，目的是将整个宇宙按行输出为文字，每一个活着的细胞标注为 Unicode 符号“■”，死掉的细胞则为“□”。\n\n通过实现 Rust 标准库中的`Display`trait，我们可以将数据结构以一种用户交互方式输出，它也提供了一个`to_string`方法。\n\n```Rust\nuse std::fmt;\n\nimpl fmt::Display for Universe {\n  fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n    for line in self.cells.as_slice().chunks(self.width as usize) {\n      for &cell in line {\n        let symbol = if cell == Cell::Dead {\"□\"} else {\"■\"};\n        write!(f, \"\\n\")?;\n      }\n    }\n\n    Ok(())\n  }\n}\n```\n\n最后，我们定义一个构造器去初始化一个有趣的图案和一个渲染函数。\n\n```Rust\n#[wasm_bindgen]\nimpl Universe {\n  pub fn new() -> {\n    let width = 64;\n    let height = 64;\n\n    let cells = (0..width * height)\n      .map(|i| {\n        if i%2 == 0 || i%7 == 0 {\n          Cell::Alive\n        } else {\n          Cell::Dead\n        }\n      }).collect();\n\n    Universe {\n      width,\n      height,\n      cells,\n    }\n  }\n\n  pub fn render(&self) -> String {\n    self.to_string()\n  }\n}\n```\n\n以上，Rust 部分已经完工。\n\n#### 使用 JavaScript 渲染\n\n首先在 HTML 中插入<pre>标签用来展示整个宇宙。\n\n```html\n<body>\n  <pre id=\"game-of-life-canvas\"></pre>\n  <script src=\"./bootstrap.js\"></script>\n</body>\n```\n\n另外我们希望<pre>标签能处于页面中央。我们可以通过 CSS flex box 实现这个任务，在 html 中增加<style>标签。\n\n```css\nbody {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n}\n```\n\n修改 JavaScript 入口文件，将原来引入的 greet 函数改为 Universe。\n\n```JavaScript\nimport { Universe } from \"wasm-game-of-life\";\n```\n\n让我们在那个<pre>标签中增加新的宇宙实例吧。\n\n```JavaScript\nconst pre = document.getElementById(\"game-of-life-canvas\");\nconst universe = Universe.new();\n```\n\n使用 JavaScript 创建一个 requestAnimationFrame 循环，每一次循环，就在<pre>标签中绘制一遍宇宙，并执行一次`Universe::tick`。\n\n```JavaScript\nfunction renderLoop() {\n  pre.textContent = universe.render();\n  universe.tick();\n\n  requestAnimationFrame(renderLoop);\n}\n```\n\n想要实现渲染，只需执行`requestAnimationFrame(renderLoop)`。\n\n确保你的本地服务任然在运行，此时你的页面应该如下所示。\n\n![浏览器页面](https://rustwasm.github.io/book/images/game-of-life/initial-game-of-life-pre.png)\n\n#### 渲染到 Canvas 上\n\n在 Rust 中生成字符串并通过 wasm-bindgen 拷贝到 JavaScript 中做了很多无关的复制。既然 JavaScript 已经知道宇宙的长度和宽度，而且 JavaScript 本来可以直接读 WebAssembly 的内存，我们将要修改 render 方法，直接返回细胞向量的指针。\n\n同时，与其渲染 Unicode 字符，不如开始用 Canvas API。接下来我们会开始设计这些。\n\n在 html 中，修改<pre>为<canvas>。\n\n```html\n<body>\n  <canvas id=\"game-of-life-canvas\"></canvas>\n  <script src=\"./bootstrap.js\"></script>\n</body>\n```\n\n为了能拿到 Rust 中的相关数据结构，我们需要为宇宙增加 getter 函数，暴露宇宙的宽度、高度和细胞的向量。增加如下函数。\n\n```Rust\n#[wasm_bindgen]\nimpl Universe {\n  pub fn width(&self) -> u32 {\n    self.width\n  }\n\n  pub fn height(&self) -> u32 {\n    self.height\n  }\n\n  pub fn cells(&self) -> *const Cell {\n    self.cells.as_ptr()\n  }\n}\n```\n\n接下来，在 JavaScript 中，引入 Cell，并设置几个渲染画布的常量。\n\n```JavaScript\nimport { Universe, Cell } from \"wasm-game-of-life\";\n\nconst CELL_SIZE = 5;\nconst GRID_COLOR = \"#CCCCCC\";\nconst DEAD_COLOR = \"#FFFFFF\";\nconst LIVE_COLOR = \"#000000\";\n```\n\n接下来修改实现 canvas 的部分。\n\n```JavaScript\nconst universe = Universe.new();\nconst width = universe.width();\nconst height = universe.height();\n\nconst canvas = documnet.getElementById(\"game-of-life-canvas\");\ncanvas.height = (CELL_SIZE+1)*height + 1;\ncanvas.width = (CELL_SIZE+1)*width + 1;\n\nconst ctx = canvas.getContext(\"2d\");\n\nfunction renderLoop() {\n  universe.tick();\n\n  drawGrid();\n  drawCells();\n\n  requestAnimationFrame(renderLoop);\n}\n```\n\n世界的网格，是一系列等宽的竖线和横线。\n\n```JavaScript\nfunction drawGrid() {\n  ctx.beginPath();\n  ctx.strokeStyle = GRID_COLOR;\n\n  for(let i =0; i <= width; i+=1) {\n    ctx.moveTo(i*(CELL_SIZE+1) + 1, 0);\n    ctx.lineTo(i*(CELL_SIZE+1) + 1, (CELL_SIZE+1)*height+1);\n  }\n\n  for(let i=0; i<=height; j++) {\n    ctx.moveTo(0, i*(CELL_SIZE+1)+1);\n    ctx.lineTo((CELL_SIZE+1)*width+1, i*(CELL_SIZE+1)+1);\n  }\n\n  ctx.stroke();\n}\n```\n\n我们可以直接访问 WebAssembly 的内存，他是直接定义在`wasm_game_of_life_bg`。为了画细胞，我们先找到一个细胞的指针，并将它们转换成 Unit8Array，迭代这些细胞，并按照他们的生命状态绘制白色和黑色方块。计量避免复制所有细胞。\n\n```JavaScript\nimport { memory } from \"wasm-game-of-life/wasm_game_of_life_bg\";\n\nfunction getIndex(row, column) {\n  return row*width+column;\n}\n\nfunction drawCells() {\n  const cellsPtr = universe.cells();\n  const cells = new Unit8Array(\n    memory.buffer,\n    cellPtr,\n    width*height,\n  );\n\n  ctx.beginPath();\n\n  for(let row=0; row<height; row+=1) {\n    for (let col=0; col<width; col+=1) {\n      const idx = getIndex(row, col);\n\n      ctx.fillStyle = cells[idx] === CellDead\n        ? DEAD_COLOR\n        : LIVE_COLOR;\n\n      ctx.fillRect(\n        cell*(CELL_SIZE+1) + 1,\n        row*(CELL_SIZE+1) + 1,\n        CELL_SIZE,\n        CELL_SIZE,\n      );\n    }\n  }\n\n  ctx.stroke();\n}\n```\n\n开始渲染，需要添加以下表达式。\n\n```JavaScript\ndrawGrid();\ndrawCells();\nrequestAnimationFrame(renderLoop);\n```\n\n注意 drawGrid 和 drawCell 必须要在 requestAnimationFrame 之前执行。\n\n#### 成功了！\n\n重建 WebAssembly 绑定。\n\n```shell\nwasm-pack build\n```\n\n确定开发服务器还在运行，如果不是，需要执行以下命令。\n\n```shell\nnpm run start\n```\n\n刷新`http://localhost:8080/`，你应该能看到如下结果。\n\n![页面](https://rustwasm.github.io/docs/book/images/game-of-life/initial-game-of-life.png)\n\n结束之前，这里还有一个不错的实现生命游戏的算法，[hashlife](https://en.wikipedia.org/wiki/Hashlife)。它使用缓存，使得程序有指数级性能提升！但是为什么我们不实现它呢？它已经超出本文涉及的范围了，本文只是专注于 Rust 和 WebAssembly 集成，但是我们强烈期望你能实现这一算法。\n\n### 练习\n\n#### 实现一台宇宙飞船\n\n#### 生成一个随机的初始环境，每个细胞有 50%的生存可能\n\n**_答案，不许看！_**\n\n先增加 js-sys 依赖\n\n```toml\n[dependencies]\njs-sys=\"0.3\"\n```\n\n接下来使用 js 的随机函数\n\n```Rust\nextern crate js_sys;\n\nif js_sys::Math::random() < 0.5 {\n\n} else {\n\n}\n```\n\n#### 以 bit 形式存储每个 cell\n\n**_答案，不许看！_**\n\n在 Rust 中，使用 fixedbitset 代替`Vec<Cell>`;\n\n```Rust\nextern crate fixedbitset;\nuse fixedbitset::FixedBitSet;\n\n#[wasm_bindgen]\npub struct Universe {\n  width: u32,\n  height: u32,\n  cells: FixedBitSet,\n}\n```\n\n宇宙的构造器应该这么修改。\n\n```Rust\npub fn new() -> Universe {\n  let width = 64;\n  let height = 64;\n\n  let size = (width*height) as usize;\n  let mut cells = FixedBitSet::with_capacity(size);\n\n  for i in 0..size {\n    cells.set(i, i%2==0 || i%7==0);\n  }\n\n  Universe {\n    width,\n    height,\n    cells,\n  }\n}\n```\n\n使用 FixedBitSet 的 set 方法更新宇宙的下一刻。\n\n```Rust\nnext.set(idx, match (cell, live_neighbors) {\n  (true, x) if x<2 => false,\n  (true, 2) | (true, 3) => true,\n  (true, x) if x>3 => false,\n  (false, 3) => true,\n  (otherwise, _) => otherwise\n});\n```\n\n传输指针的时候，需要返回 slice。\n\n```Rust\n#[wasm_bindgen]\nimpl Universe {\n  pub fn cells(&self) -> *const u32 {\n    self.cells.as_slice().as_ptr()\n  }\n}\n```\n\n在 JavaScript 中，构造 Unit8Array 的时候需要除以 8，以为我们是以 bit 存储细胞的。\n\n```JavaScript\nconst cells = new Unit8Array(\n  memory.buffer,\n  cellsPtr,\n  width*height/8\n);\n```\n\n通过判断 Unit8Array 是否被赋值而判断细胞是否是活着的。\n\n```JavaScript\nfunction bitIsSet(n, arr) {\n  const byte = Math.floor(n/8);\n  const mask = 1<<(n%8);\n  return (arr[byte] & mask) == mask;\n}\n```\n\n根据以上变化，新版本的 drawCells 如下。\n\n```JavaScript\nfunction drawCells() {\n  const cellsPtr = universe.cells();\n  const cells = new Unit8Array(\n    memory.buffer,\n    cellsPtr,\n    width*height/8\n  );\n\n  ctx.beginPath();\n\n  for (let row=0; row<height; row+=1) {\n    for(let col=0; col<width; col+=1) {\n      const idx = getIndex(row, col);\n\n      ctx.fillStyle = bitIsSet(idex, cells)\n        ? LIVE_COLOR\n        : DEAD_COLOR;\n\n      ctx.fillRect(\n        col*(CELL_SIZE+1)+1,\n        row*(CELL_SIZE+1)+1,\n        CELL_SIZE,\n        CELL_SIZE,\n      );\n    }\n  }\n\n  ctx.stroke();\n}\n```\n\n## 测试\n\n现在我们已经实现了 Rust 的实现，并成功渲染在浏览器中。现在来谈谈测试 WebAssembly 中的 Rust 函数。\n\n我们将要测试 tick 函数，确保它能返回正确的值。\n\n接下来，我们将处理 Universe 的 setter 函数，让我们能构造不同大小的 universe。\n\n```Rust\n#[wasm_bindgen]\nimpl Universe {\n  pub fn set_width(&mut self, width: u32) {\n    self.width = width;\n    self.cells = (0..width * self.height).map(|_| Cell::Dead).collect()\n  }\n\n  pub fn set_height(&mut self, height: u32) {\n    self.height = height;\n    self.cells = (0..self.width * height).map(|_| Cell::Dead).collect()\n  }\n}\n```\n\n我们将会创建另一个不需要`#[wasm_bindgen]`的`impl Universe`实现，因为我们不能把所有的 WebAssembly 函数暴露给 JavaScript，Rust 生成的 WebAssembly 函数是不能返回引用的。可以尝试让 Rust 返回一个引用，查看一下编译结果中是什么错误。\n\n接下来我们要写一个 get_cells 来获得细胞，和一个 set_cells 来设置哪些细胞是活的，哪些是死的。\n\n```Rust\nimpl Universe {\n  pub fn get_cells(&self) -> &[Cell] {\n    &self.cells\n  }\n\n  pub fn set_cells(&mut self, cells: &[(u32, u32)]) {\n    for (row, col) in cells.iter().cloned() {\n      let idx = self.get_index(row, col);\n      self.cells[idx] = Cell::Alive;\n    }\n  }\n}\n```\n\n现在我们将创建测试文件`tests/web.rs`。\n\n在这之前，测试环境已经配置好，请确定`wasm-pack test --chrome --headless`能够在根目录下运行。你也可以使用`--firefox`，`--safari`和`--node`选项来在其他浏览器测试你的代码。\n\n在`test/web.rs`中，我们需要到处 Universe 类型。\n\n```Rust\nextern crate wasm_game_of_life;\nuse wasm_game_of_life:Universe;\n```\n\n在测试文件中，我们要创建一个飞船构造函数。\n\n我们要构造一个 tick 函数执行之前的飞船，和一个 tick 函数执行后的期望值。\n\n```Rust\n#[cfg(test)]\npub fn input_spaceship() -> Universe {\n  let mut universe = Universe::new();\n\n  universe.set_width(6);\n  universe_set_height(6);\n  universe_set_cells(\n    &[\n      (1,2),\n      (2,3),\n      (3,1), (3,2),(3,3)\n    ]\n  );\n\n  universe\n}\n\n#[cfg(test)]\npub fn expected_spaceship() -> Universe {\n  let mut universe = Universe::new();\n\n  universe.set_width(6);\n  universe_set_height(6);\n  universe_set_cells(\n    &[\n      (2,1), (2,3),\n      (3,2), (3,3),(4,2)\n    ]\n  );\n\n  universe\n}\n```\n\n现在我们写一个 test_tick 函数，创建以上的两个飞船。最后使用`assert_eq!`宏比较 expected_ship 来确保 tick 函数运行正确。我们添加`#[wasm_bindgen_test]`属性保证这个函数可以在 WebAssembly 环境下测试。\n\n```Rust\n#[wasm_bindgen_test]\npub fn test_tick() {\n  let mut input_universe = input_spaceship();\n  let expected_universe = expected_spaceship();\n\n  input_universe.tick();\n  assert_eq!(\n    &input_universe.get_cells(),\n    &expected_universe.get_cells(),\n  )\n}\n```\n\n测试这个测试函数使用`wasm-pack test --firefox --headless`。\n\n## 调试\n\n写这么多代码之前（虽然上面都写完了，我也不知道原作者抽什么风），先看一看 Rust 的调试工具。\n\n### 调试工具\n\n此部分将会介绍 WebAssembly 的调试工具。\n\n#### 使用 debug 标记编译\n\n如果没有打开 debug 标记，\"name\"这个部分就不会被编译到二进制程序中，错误栈也不会显示函数名，你会收到`wasm-functions[42]`而不是`wasm_game_of_file::Universe::live_neighbor_count`。\n\n调试编译，`wasm-pack build --debug`或者`cargo build`总是会默认打开 debug 标记。\n\n版本编译（release build），debug 标记是默认关闭的，要打开 debug 标记，需要声明`debug=true`。\n\n```toml\n[profile.release]\ndebug = true\n```\n\n#### 使用 console API 打印日志\n\n打印日志是最好的判断程序是否是有错的方式。在浏览器中，`console.log`函数可以将日志打印到浏览器的 dev 工具里。\n\n我们可以使用 web-sys 包去调用 console API。\n\n```Rust\nextern crate web_sys;\n\nweb_sys::console::log_1(&\"Hello, world!\".into());\n```\n\n相应的`console.error`函数用法一致，但是浏览器的调用栈还是按照`console.error`来打印。\n\n使用`console.log`：\n\n- [`web_sys::console::log`，接受一个向量的数据做参数](https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.log.html)。\n- [`web_sys::console::log_1`，接受一个数据做参数](https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.log_1.html)。\n- [`web_sys::console::log_2`，接受两个数据做参数](https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.log_2.html)。\n- ...\n\n使用`console.error`：\n\n- [`web_sys::console::error`，接受一个向量的数据做参数](https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.error.html)。\n- [`web_sys::console::error_1`，接受一个数据做参数](https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.error_1.html)。\n- [`web_sys::console::error_2`，接受两个数据做参数](https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.error_2.html)。\n- ...\n\n#### 打印崩溃日志\n\n[`console_error_panic_hook`包能通过`console.error`打印崩溃日志](https://github.com/rustwasm/console_error_panic_hook)。他能打印出格式化的崩溃信息而不是难以理解的`RuntimeError: unreachable executed`。\n\n你只需要增加调用这个钩子函数。\n\n```Rust\n#[wasm_bindgen]\npub fn init_panic_hook() {\n  console_error_panic_hook::set_once();\n}\n```\n\n#### 使用调试器\n\n不幸的，WebAssembly 的调试器依然不成熟，在很多 unix 系统中，DWARF 是用来解析调试程序需要的数据的工具。虽然，Windows 上面也有一个类似的工具。但还没有相当的工具提供给 WebAssembly。所以，调试器目前能给予的功能有限，我们只能收到 WebAssembly 的错误而不是 Rust 源代码的错误。\n\n> 这里有一个故事是[跟踪 WebAssembly 的调试](https://github.com/WebAssembly/debugging)的，我们希望它将来会有所改善！\n\n尽管如此，调试器还是能够给调试 JavaScript 方面提供效力。\n\n#### 一开始就规避在 WebAssembly 上面使用调试\n\n如果错误和交互 JavaScript 和 Web API 有关，则使用`wasm-bindgen-test`写测试。\n\n如果和 JavaScript 和 Web API 无关，这是用默认的`#[test]`属性。使用[`quickcheck`包](https://crates.io/crates/quickcheck)可以减少写测试上面的时间。\n\n为了避免`#[test]`编译器出现连接错误，你需要一个 rlib 依赖，在`Cargo.toml`文件按照如下修改。\n\n```toml\n[lib]\ncrate-type [\"cdylib\", \"rlib\"]\n```\n\n### 在生命游戏中打开崩溃日志\n\n如果程序崩溃，最好是能够在审查工具中看到日志。\n\n在``src/utils.rs`里面有一个可选的 console_error_panic_hook 包，可以在 Universe 初始化的时候调用它。\n\n```Rust\npub fn new() -> Universe {\n  utils::set_panic_hook();\n}\n```\n\n### 为生命游戏增加日志\n\n让我们在 Rust 中利用 web-sys 调用 console，打印出每一刻的细胞状态。\n\n首先在以来中增加 web-sys，修改 Cargo.toml。\n\n```toml\n[dependencies.web-sys]\nversion = \"0.3\"\nfeatures = [\n  \"console\",\n]\n```\n\n为了高效，我们把`console.log`函数封装到`println!`一样的宏中。\n\n```Rust\nextern crate web_sys;\n\nmacro_rules! log {\n  ($( $t:tt )*) => {\n    web_sys::console::log_1(&format!( $( $t )* ).into());\n  }\n}\n```\n\n现在可以通过调用 log 发送日志了。\n\n```Rust\nlog!(\n  \"cell[{}, {}] is initially {:?} and has {} live neighbors\",\n  row,\n  col,\n  cell,\n  live_neighbors,\n)\n```\n\n### 使用调试器\n\n浏览器的调试器在调试 JavaScript 和 Rust 生成的 WebAssembly 很有效。\n\n举个例子，在 renderLoop 函数中增加`debugger;`可以暂停页面执行的某一刻。\n\n者给予我们查看每一刻细胞状态的能力。\n\n![调试画面](https://rustwasm.github.io/docs/book/images/game-of-life/debugging.png)\n\n### 练习\n\n1. 给 tick 方法增加 log，查看细胞状态。\n2. 加入`panic!()`查看打印出来的崩溃日志。\n\n## 增加交互\n\n接下来我们要给这个游戏增加一些交互，我们会允许用户选择细胞的生死，并且允许暂停游戏，并使绘制初始图案更加简单。\n\n### 暂停和继续游戏\n\n首先修改 html，在画布上面增加一个<button>标签。\n\n```html\n<button id=\"play-pause\"></button>\n```\n\n在 JavaScript 中，我们要做以下几点改动。\n\n- 追踪调用 requestAnimationFrame 的标识符，这样我们就能通过调用 cancelAnimationFrame 来终止动画。\n- 当点击播放或者暂停键的时候，先检查标识符是否存在，一旦存在，则表示动画正在运行，我们需要取消动画以保证 renderLoop 不再被调用。如果标识符不存在，我们需要调用 requestAnimationFrame 以保证动画继续运行。\n\n因为是 JavaScript 控制着 Rust 和 WebAssembly，我们不需要修改 Rust 部分。\n\n我们引入 animationId 变量，保存 requestAnimationFrame 的结果。当没有排队的动画时，这个变量值为 null。\n\n```JavaScript\nlet animationId = null;\n\nfunction renderLoop() {\n  drawGrid();\n  drawCells();\n\n  universe.tick();\n\n  animationId = requestAnimationFrame(renderLoop);\n}\n```\n\n任何一个时间，我们可以通过判断 animationId 来判断这个动画是否被暂停。\n\n```JavaScript\nfunction isPaused() {\n  return animationId === null;\n}\n```\n\n现在，当播放暂停键被点击，当正在播放时，暂停动画。并把按钮的状态改为播放。\n\n```JavaScript\nconst playPauseButton = document.getElementById(\"play-pause\");\n\nfunction play() {\n  playPauseButton.textContent = \"⏸\";\n  renderLoop();\n};\n\nfunction pause() {\n  playPauseButton.textContent = \"▶\";\n  cancelAnimationFrame(animationId);\n  animationId = null;\n};\n\nplayPauseButton.addEventListener(\"click\", function playBtnListener(event) {\n  if (isPaused()) {\n    play();\n  } else {\n    pause();\n  }\n});\n```\n\n最后我们把之前的 requestAnimationFrame 函数封装成`play()`。刷新本地服务器，可以看到网页上已经有暂停按钮了。尝试点击一下它吧。\n\n### 修改一个细胞的状态\n\n现在我们能暂停这个游戏了，是时候增加一个修改细胞的功能了。\n\n想控制细胞的生死，需要给`src/lib.rs`下的 Cell 增加一个 toggle 函数。\n\n```Rust\nimpl Cell {\n    fn toggle(&mut self) {\n        *self = match *self {\n            Cell::Dead => Cell::Alive,\n            Cell::Alive => Cell::Dead,\n        };\n    }\n}\n```\n\n想要修改在宇宙中的细胞需要获得细胞的行纵值，并转换为细胞的序号。\n\n```Rust\n#[wasm_bindgen]\nimpl Universe {\n    pub fn toggle_cell(&mut self, row: u32, column: u32) {\n        let idx = self.get_index(row, column);\n        self.cells[idx].toggle();\n    }\n}\n```\n\n这个方法增加第 1 行的属性声明是为了能够在 JavaScript 环境里面直接调用。在 JavaScript 文件中，监听<canvas>标签，将页面上的点击事件转换成画布上的点击事件，并调用 toggle_cell 方法重绘场景。\n\n```Rust\ncanvas.addEventListener(\"click\", function canvasClickListener(event) {\n  const boundingRect = canvas.getBoundingClientRect();\n\n  const scaleX = canvas.width / boundingRect.width;\n  const scaleY = canvas.height / boundingRect.height;\n\n  const canvasLeft = (event.clientX - boundingRect.left) * scaleX;\n  const canvasTop = (event.clientY - boundingRect.top) * scaleY;\n\n  const row = Math.min(Math.floor(canvasTop/(CELL_SIZE + 1)), height - 1);\n  const col = Math.min(Math.floor(canvasLeft/(CELL_SIZE + 1)), width - 1);\n\n  universe.toggle_cell(row, col);\n\n  drawGrid();\n  drawCells();\n});\n```\n\n使用`wasm-pack build`重新编译，刷新网页，并更新细胞状态。\n\n### 练习\n\n- 新建一个<input>标签来处理每帧更新多少个刻。\n- 增加一个重置按钮，把宇宙恢复到初始状态；再增加一个消灭按钮，毁灭所有细胞。\n- 当使用`Ctrl+Click`的时候，增加一个[glider](<https://en.wikipedia.org/wiki/Glider_(Conway%27s_Life)>)，使用`Shift+Click`增加一个 pulsar。\n\n## 性能日志(Time Profiling)\n\n本节我们将会提高这个游戏的性能，我们将会用 time profiling 来完成。\n\n### Time Profiling\n\n此部分将会讲解如何获得页面的性能分析，目标是提高 JavaScript 和 WebAssembly 之间的吞吐。\n\n> 永远使用`wasm-pack build`编译最新的代码，以确定你的优化正确。\n\n#### windows.performance.now()\n\n这个函数会返回以毫秒为单位的时间戳来计算页面加载速度。\n\n调用`performance.now()`的性能损耗低，所以我们可以利用它创造一个简单的测算工具而不是产生很大误差值。\n\n我们可以通过`web-sys`调用时间函数。\n\n```Rust\nextern crate web_sys;\n\nfn now() -> f64 {\n  web_sys::window()\n    .expect(\"should have window\")\n    .performance()\n    .expect(\"should have a Performance\")\n    .now()\n}\n```\n\n#### 开发者工具的性能查看器\n\n所有的浏览器的开发者工具都有性能查看器。这个查看器通过火焰图展示函数调用栈来表示哪一个函数耗时更长。\n\n如果你编译的时候打开了调试，则函数名将会显示在这里（如果没打开则显示一个不透明的名字，比如`wasm-function[123]`）。\n\n注意，因为性能查看器不会显示内联函数，又因为 Rust 和 LVVM 很重地依赖于内联函数，其结果就会让人感到头疼。\n\n![性能查看器无法处理内联函数](https://rustwasm.github.io/docs/book/images/game-of-life/profiler-with-rust-names.png)\n\n#### console.time 和 console.timeEnd\n\n这两个函数是浏览器的内置函数。以调用`console.time(\"foo\")`作为开始，以`console.time(\"foo\")`作为结束，参数是可选的。\n\n你可以通过 web-sys 调用`web_sys::console::time_with_label(\"foo\")`和`web_sys::console::time_end_with_label(\"foo\")`。\n\n如下是浏览器的截图。\n\n![使用console.time的截图](https://rustwasm.github.io/docs/book/images/game-of-life/console-time.png)\n\n另外，`console.time`和`console.timeEnd`会调用性能检查器统计出瀑布图。\n\n#### 使用#[bench]调用原生代码\n\n就像我们能使用原生的测试方法`#[test]`来测试代码，我们可以使用`#[bench]`通过操作系统的工具来查看函数性能。\n\n写好标准函数并放到`benches`文件夹下。确保`crate-type`已经引入 rlib，能使测试代码能够链接。\n\n无论如何，先搞明白你知道 WebAssembly 里面的瓶颈之后再花费精力去调查原生的性能调查器！用你的浏览器的性能调查器，或者使用这些时间去优化你的代码不是更好？\n\n### 利用 window.performance.now 创建一个计时器\n\n创建一个 FPS 的计时器用来调查游戏的渲染速度不失为一个好办法。\n\n我们在 JavaScript 增加 fps 对象。\n\n```JavaScript\nconst fps = new class {\n  constructor() {\n    this.fps = document.getElementById(\"fps\");\n    this.frames = [];\n    this.lastFrameTimeStamp = performance.now();\n  }\n\n  render() {\n    // Convert the delta time since the last frame render into a measure\n    // of frames per second.\n    const now = performance.now();\n    const delta = now - this.lastFrameTimeStamp;\n    this.lastFrameTimeStamp = now;\n    const fps = 1 / delta * 1000;\n\n    // Save only the latest 100 timings.\n    this.frames.push(fps);\n    if (this.frames.length > 100) {\n      this.frames.shift();\n    }\n\n    // Find the max, min, and mean of our 100 latest timings.\n    let min = Infinity;\n    let max = -Infinity;\n    let sum = 0;\n    for (let i = 0; i < this.frames.length; i++) {\n      sum += this.frames[i];\n      min = Math.min(this.frames[i], min);\n      max = Math.max(this.frames[i], max);\n    }\n    let mean = sum / this.frames.length;\n\n    // Render the statistics.\n    this.fps.textContent = `\nFrames per Second:\n         latest = ${Math.round(fps)}\navg of last 100 = ${Math.round(mean)}\nmin of last 100 = ${Math.round(min)}\nmax of last 100 = ${Math.round(max)}\n`.trim();\n  }\n};\n```\n\n接下来再每次迭代中调用 fps render 函数。\n\n```JavaScript\nconst renderLoop = () => {\n    fps.render(); //new\n\n    universe.tick();\n    drawGrid();\n    drawCells();\n\n    animationId = requestAnimationFrame(renderLoop);\n};\n```\n\n最后在 HTML 中增加 fps 的展示。\n\n```JavaScript\n<div id=\"fps\"></div>\n```\n\n增加 CSS，让它展示得更好。\n\n```CSS\n#fps {\n  white-space: pre;\n  font-family: monospace;\n}\n```\n\n好了，现在可以在页面上看到 FPS 计数器了。\n\n### 给每一刻计算时间\n\n每一刻开始调用`console.time`，结束的时候调用`console.timeEnd`。\n\n首先，要在`Cargo.toml`里面增加 web-sys。\n\n```toml\n[dependencies.web-sys]\nversion = \"0.3\"\nfeatures = [\n  \"console\",\n]\n```\n\n因为每次执行`console.time`后总要执行`console.timeEnd`，把他们包再[RAII](https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization)类型下就会更加便利。\n\n```Rust\nextern crate web_sys;\nuse web_sys::console;\n\npub struct Timer<'a> {\n    name: &'a str,\n}\n\nimpl<'a> Timer<'a> {\n    pub fn new(name: &'a str) -> Timer<'a> {\n        console::time_with_label(name);\n        Timer { name }\n    }\n}\n\nimpl<'a> Drop for Timer<'a> {\n    fn drop(&mut self) {\n        console::time_end_with_label(self.name);\n    }\n}\n```\n\n接下来，统计每一刻用的时间是多久，只需把初始化 Timer 放到 Universe 的构造函数里。\n\n```Rust\nlet _timer = Timer::new(\"Universe::tick\");\n```\n\n如下是每一刻执行的时间。\n\n![每一刻的执行时间](https://rustwasm.github.io/book/images/game-of-life/console-time.png)\n\n另外，通过使用`console.time`和`console.timeEnd`也能获得执行性能数据。\n\n![性能数据](https://rustwasm.github.io/book/images/game-of-life/console-time-in-profiler.png)\n\n### 增加宇宙大小\n\n> 本部分是拿火狐浏览器做例子，当然还有很多浏览器有类似的功能，只是有细微的差别。这个数据是一致的，但是部分命名和标量可能不一样。\n\n如果我们把宇宙修改的大一些，会发生什么？把 64x64 改成 128x128，结果会把 fps 从 60 降到 40。\n\n如果我们打开性能监控器，并看到它的瀑布图，我们可以看到动画帧用了 20 毫秒，回顾 60fps 时渲染一页则需要 16 毫秒，这不仅仅是 JavaScript 和 WebAssembly，还包括重绘的部分。\n\n![性能监视](https://rustwasm.github.io/book/images/game-of-life/drawCells-before-waterfall.png)\n\n如果仔细查看，可以看到`CanvasRenderingContext2D.fillStyle`的 setter 是很耗费时间的。\n\n> 再火狐，你可能看到的是\"DOM\"而不是\"CanvasRenderingContext2D.fillStyle\"，你需要打开\"展示 Gecko 平台数据\"。\n\n![火狐的性能监视器](https://rustwasm.github.io/book/images/game-of-life/profiler-firefox-show-gecko-platform.png)\n\n当然，这并不稀奇，40%的的时间都浪费在这个 setter 上面。\n\n> 我们可能期望性能瓶颈再 tik 函数上，但并不是。永远选择性能监视器观察，因为你可能浪费很多时间在无关的地方上面。\n\n在 drawCell 上面，fillStyle 在每次动画和每个细胞上面使用。\n\n```JavaScript\nfor (let row = 0; row < height; row++) {\n  for (let col = 0; col < width; col++) {\n    const idx = getIndex(row, col);\n\n    ctx.fillStyle = cells[idx] === DEAD\n      ? DEAD_COLOR\n      : ALIVE_COLOR;\n\n    ctx.fillRect(\n      col * (CELL_SIZE + 1) + 1,\n      row * (CELL_SIZE + 1) + 1,\n      CELL_SIZE,\n      CELL_SIZE\n    );\n  }\n}\n```\n\n现在我们知道 fillStyle 资源耗费比较多，那么我们该怎么避免他呢？我们需要判断细胞的生命状态来自决定 fillStyle 的值，设想，如果先设定`fillStyle = ALIVE_COLOR`，再绘制所有的活着的细胞，然后设置`fillStyle = DEAD_COLOR`，再设置所有的死细胞，最后我们只设置 fillStyle 两次。\n\n```JavaScript\n// Alive cells.\nctx.fillStyle = ALIVE_COLOR;\nfor (let row = 0; row < height; row++) {\n  for (let col = 0; col < width; col++) {\n    const idx = getIndex(row, col);\n    if (cells[idx] !== Cell.Alive) {\n      continue;\n    }\n\n    ctx.fillRect(\n      col * (CELL_SIZE + 1) + 1,\n      row * (CELL_SIZE + 1) + 1,\n      CELL_SIZE,\n      CELL_SIZE\n    );\n  }\n}\n\n// Dead cells.\nctx.fillStyle = DEAD_COLOR;\nfor (let row = 0; row < height; row++) {\n  for (let col = 0; col < width; col++) {\n    const idx = getIndex(row, col);\n    if (cells[idx] !== Cell.Dead) {\n      continue;\n    }\n\n    ctx.fillRect(\n      col * (CELL_SIZE + 1) + 1,\n      row * (CELL_SIZE + 1) + 1,\n      CELL_SIZE,\n      CELL_SIZE\n    );\n  }\n}\n```\n\n修改之后，刷新页面，此时的 fps 已经上升到 60。\n\n如果重新看原来的数据，现在每一刻只使用 10 毫秒。\n\n![更新后的性能检查](https://rustwasm.github.io/book/images/game-of-life/drawCells-after-waterfall.png)\n\n消除了 fillStyle 的性能瓶颈，发现比较消耗资源的是 fillRect，用来绘制每一个细胞的。\n\n![目前的性能损耗都在fillRect上面](https://rustwasm.github.io/book/images/game-of-life/drawCells-after-flamegraph.png)\n\n### 让时间变快\n\n有些人可能不喜欢等待，更希望一帧跑完九刻而不是一刻。我们可以通过修改 renderLoop 函数实现。\n\n```JavaScript\nfor (let i = 0; i < 9; i++) {\n  universe.tick();\n}\n```\n\n在机器上，fps 降到了 35，但是我们一定要到 60fps！\n\n现在我们知道性能瓶颈在 tick 函数上面，所以我们给函数的每一步都加上 Timer 监视，我猜测是创建向量和释放向量占用了很多资源造成的。\n\n```Rust\npub fn tick(&mut self) {\n    let _timer = Timer::new(\"Universe::tick\");\n\n    let mut next = {\n        let _timer = Timer::new(\"allocate next cells\");\n        self.cells.clone()\n    };\n\n    {\n        let _timer = Timer::new(\"new generation\");\n        for row in 0..self.height {\n            for col in 0..self.width {\n                let idx = self.get_index(row, col);\n                let cell = self.cells[idx];\n                let live_neighbors = self.live_neighbor_count(row, col);\n\n                let next_cell = match (cell, live_neighbors) {\n                    // Rule 1: Any live cell with fewer than two live neighbours\n                    // dies, as if caused by underpopulation.\n                    (Cell::Alive, x) if x < 2 => Cell::Dead,\n                    // Rule 2: Any live cell with two or three live neighbours\n                    // lives on to the next generation.\n                    (Cell::Alive, 2) | (Cell::Alive, 3) => Cell::Alive,\n                    // Rule 3: Any live cell with more than three live\n                    // neighbours dies, as if by overpopulation.\n                    (Cell::Alive, x) if x > 3 => Cell::Dead,\n                    // Rule 4: Any dead cell with exactly three live neighbours\n                    // becomes a live cell, as if by reproduction.\n                    (Cell::Dead, 3) => Cell::Alive,\n                    // All other cells remain in the same state.\n                    (otherwise, _) => otherwise,\n                };\n\n                next[idx] = next_cell;\n            }\n        }\n    }\n\n    let _timer = Timer::new(\"free old cells\");\n    self.cells = next;\n}\n```\n\n看这些时间戳，很明显我的猜测是错误的：大部分时间确实用在计算下一代细胞上面，每一刻都调用和释放向量竟然无足轻重。所以一定要使用性能监视器！\n\n![性能监视](https://rustwasm.github.io/book/images/game-of-life/console-time-in-universe-tick.png)\n\n下一部分需要`nightly`编译，因为我们将会使用[test-feature-gate](https://doc.rust-lang.org/unstable-book/library-features/test.html)来跑 benchmark（性能测试）。我们将会安装另一个工具[cargo-benchcmp](https://github.com/BurntSushi/cargo-benchcmp)。一个迷你的有`cargo bench`支持的性能测试工具。\n\n让我们写一个函数使用`#[bench]`属性，我们可以使用更成熟的测试工具测试它。\n\n```Rust\n#![feature(test)]\n\nextern crate test;\nextern crate wasm_game_of_life;\n\n#[bench]\nfn universe_ticks(b: &mut test::Bencher) {\n    let mut universe = wasm_game_of_life::Universe::new();\n\n    b.iter(|| {\n        universe.tick();\n    });\n}\n```\n\n我们也要注释掉所有`#[wasm_bindgen]`，否则\"cdylib\"或则其他编译流程会失败，\n\n此时，我们可以跑`cargo bench | tee before.txt`来编译项目查看性能日志了！\n\n```shell\n$ cargo bench | tee before.txt\n    Finished release [optimized + debuginfo] target(s) in 0.0 secs\n     Running target/release/deps/wasm_game_of_life-91574dfbe2b5a124\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n     Running target/release/deps/bench-8474091a05cfa2d9\n\nrunning 1 test\ntest universe_ticks ... bench:     664,421 ns/iter (+/- 51,926)\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out\n```\n\n他也告诉我们二进制文件的位置，我们可以跑第二次性能测试。但这次可以使用系统的性能测试工具。因为我用的是 Linux，所以 perf 就是我的测试工具。\n\n```shell\n$ perf record -g target/release/deps/bench-8474091a05cfa2d9 --bench\nrunning 1 test\ntest universe_ticks ... bench:     635,061 ns/iter (+/- 38,764)\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out\n\n[ perf record: Woken up 1 times to write data ]\n[ perf record: Captured and wrote 0.178 MB perf.data (2349 samples) ]\n```\n\n查看性能测试报告，得知所有的时间都如期使用在`Universe::tick`。\n\n![perf的结果](https://rustwasm.github.io/book/images/game-of-life/bench-perf-report.png)\n\nperf 会指明函数中到底是什么操作引起的性能损耗（译者：虽然我也没看出来）。\n\n![perf的结果](https://rustwasm.github.io/book/images/game-of-life/bench-perf-annotate.png)\n\n它告诉我们 26.67%的时间花在总和细胞数目，23.41%的时间花在获取列序号，另外 15.42%花在取得行序号。这三个性能瓶颈中，第二和第三都使用了比较耗费性能的 DIV 命令。这些 DIV 的实现是在`Universe::live_neighbor_count`。\n\n回想这个函数的定义：\n\n```Rust\nfn live_neighbor_count(&self, row: u32, column: u32) -> u8 {\n    let mut count = 0;\n    for delta_row in [self.height - 1, 0, 1].iter().cloned() {\n        for delta_col in [self.width - 1, 0, 1].iter().cloned() {\n            if delta_row == 0 && delta_col == 0 {\n                continue;\n            }\n\n            let neighbor_row = (row + delta_row) % self.height;\n            let neighbor_col = (column + delta_col) % self.width;\n            let idx = self.get_index(neighbor_row, neighbor_col);\n            count += self.cells[idx] as u8;\n        }\n    }\n    count\n}\n```\n\n使用取余运算是为了避免使用杂乱的 if 代码来处理边界，但导致我不得不用 DIV 这样比较耗费性能的指令。相反，如果用 if 处理边界，并展开循环，则分支条件将会比较适合 CPU 处理。\n\n```Rust\nfn live_neighbor_count(&self, row: u32, column: u32) -> u8 {\n    let mut count = 0;\n\n    let north = if row == 0 {\n        self.height - 1\n    } else {\n        row - 1\n    };\n\n    let south = if row == self.height - 1 {\n        0\n    } else {\n        row + 1\n    };\n\n    let west = if column == 0 {\n        self.width - 1\n    } else {\n        column - 1\n    };\n\n    let east = if column == self.width - 1 {\n        0\n    } else {\n        column + 1\n    };\n\n    let nw = self.get_index(north, west);\n    count += self.cells[nw] as u8;\n\n    let n = self.get_index(north, column);\n    count += self.cells[n] as u8;\n\n    let ne = self.get_index(north, east);\n    count += self.cells[ne] as u8;\n\n    let w = self.get_index(row, west);\n    count += self.cells[w] as u8;\n\n    let e = self.get_index(row, east);\n    count += self.cells[e] as u8;\n\n    let sw = self.get_index(south, west);\n    count += self.cells[sw] as u8;\n\n    let s = self.get_index(south, column);\n    count += self.cells[s] as u8;\n\n    let se = self.get_index(south, east);\n    count += self.cells[se] as u8;\n\n    count\n}\n```\n\n接下来再跑一次性能测试，将他输出到`after.txt`。\n\n```shell\n$ cargo bench | tee after.txt\n   Compiling wasm_game_of_life v0.1.0 (file:///home/fitzgen/wasm_game_of_life)\n    Finished release [optimized + debuginfo] target(s) in 0.82 secs\n     Running target/release/deps/wasm_game_of_life-91574dfbe2b5a124\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n     Running target/release/deps/bench-8474091a05cfa2d9\n\nrunning 1 test\ntest universe_ticks ... bench:      87,258 ns/iter (+/- 14,632)\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out\n```\n\n感觉性能提高了不少，现在对比一下前后的数据。\n\n```shell\n$ cargo benchcmp before.txt after.txt\n name            before.txt ns/iter  after.txt ns/iter  diff ns/iter   diff %  speedup\n universe_ticks  664,421             87,258                 -577,163  -86.87%   x 7.61\n```\n\n哇！提高了 7.61 倍！\n\nWebAssembly 意图和原生系统贴近，但是我们确实需要在 WebAssembly 环境下也作一次测试。\n\n从新编译程序，刷新浏览器页面，画面重新跑在 60fps，每一帧大概是 10 毫秒。\n\n成功！\n\n![测试结果](https://rustwasm.github.io/book/images/game-of-life/waterfall-after-branches-and-unrolling.png)\n\n### 练习\n\n- 现在，下一个性能瓶颈是`Universe::tick`调用和释放函数的部分，尝试缓存细胞状态，让 Universe 维护两个向量，永远不释放他们，也不掉用新的区间。\n- 换一种方式实现游戏，让 Rust 和 JavaScript 以细胞的列表交互，这样能让渲染画布更快吗？你能实现这个设计同时不在每个 tick 函数中调用新的列表吗？\n- 就性能显示来看 2D 画布渲染显然不够快，使用 WebGL 画布重新渲染，WebGL 能多快？使用 WebGL 能在遇到瓶颈前创建多大的宇宙空间？\n\n## 压缩.wasm 文件大小\n\nrustc 有很多配置项，可以让`.wasm`二进制文件更加小。在很多情况下更小的生成文件意味着更长的编译时间。另外更小的文件使得 WebAssembly 的运行时间更长。我们应该意识到这些方面上的牺牲。在这些情况下，当我们要减少编译文件大小时，我们应该考虑到使用性能监视器衡量一下这种改动是否值得。\n\n### 使用链接配置器编译\n\n在`Cargo.toml`，增加`lto=true`：\n\n```toml\n[profile.release]\nlto = true\n```\n\n者给予 LLVM 更多机会去内联和简化函数，不仅仅会使`.wasm`更小，还会让他在运行时运行得更快！但是会让他编译得更长。\n\n### 配置 LLVM 牺牲速度换文件大小\n\nLLVM 默认配置是为了运行速度，并不是大小。我们可以通过更改`Cargo.toml`去修改这一配置。\n\n```toml\n[profile.release]\nopt-level = 's'\n```\n\n或者，更激进的可以把它改成\"z\"。\n\n但是，配置为\"s\"的时候有的时候会比\"z\"更小，所以一定要做测量！\n\n### 使用 wasm-opt 工具\n\n[Binaryen](https://github.com/WebAssembly/binaryen)是一个关于 WebAssembly 编译工具的集合。他比 LLVM 更加后端，使用`wasm-opt`处理生成文件常常会节省 15%~20%的代码，同时又会提高运行速度。\n\n```\n# 输出为压缩的文件大小。\nwasm-opt -Os -o output.wasm input.wasm\n\n# 更激进的输出为压缩的文件大小。\nwasm-opt -Oz -o output.wasm input.wasm\n\n# 输出文件追求运行速度。\nwasm-opt -O -o output.wasm input.wasm\n\n# 输出文件更激进的追求运行速度。\nwasm-opt -O3 -o output.wasm input.wasm\n```\n\n#### 注意调试信息\n\n占用生成文件大小的主要成分是调试信息和函数名。`wasm-pack`能够默认移除调试信息。然而`wasm-opt`在使用`-g`参数时能删除函数名。\n\n这意味着，如果你按照以上操作，生成文件应该既没有调试信息也没有函数名。如果你想保留某些调试信息，请一定注意这一点。\n\n### 文件大小检查调查\n\n如果修改编译配置不能获得更小的文件大小，就应该调查一下是什么代码导致文件太大。\n\n> 就像做性能测试，我们应让工具来判断哪里出了问题，否则我们会浪费更多自己的时间。\n\n#### twiggy 代码检查器\n\n[twiggy](https://github.com/rustwasm/twiggy)是一个支持 WebAssembly 的代码大小检查器，他能分析二进制代码的调用图，并解决如下问题：\n\n- 为什么这个函数被编译到这段代码中。\n- 这个函数占用大小是多少？如果我删除这个函数以及其相关函数我能节省多大的空间？\n\n```\n$ twiggy top -n 20 pkg/wasm_game_of_life_bg.wasm\n Shallow Bytes │ Shallow % │ Item\n───────────────┼───────────┼────────────────────────────────────────────────────────────────────────────────────────\n          9158 ┊    19.65% ┊ \"function names\" subsection\n          3251 ┊     6.98% ┊ dlmalloc::dlmalloc::Dlmalloc::malloc::h632d10c184fef6e8\n          2510 ┊     5.39% ┊ <str as core::fmt::Debug>::fmt::he0d87479d1c208ea\n          1737 ┊     3.73% ┊ data[0]\n          1574 ┊     3.38% ┊ data[3]\n          1524 ┊     3.27% ┊ core::fmt::Formatter::pad::h6825605b326ea2c5\n          1413 ┊     3.03% ┊ std::panicking::rust_panic_with_hook::h1d3660f2e339513d\n          1200 ┊     2.57% ┊ core::fmt::Formatter::pad_integral::h06996c5859a57ced\n          1131 ┊     2.43% ┊ core::str::slice_error_fail::h6da90c14857ae01b\n          1051 ┊     2.26% ┊ core::fmt::write::h03ff8c7a2f3a9605\n           931 ┊     2.00% ┊ data[4]\n           864 ┊     1.85% ┊ dlmalloc::dlmalloc::Dlmalloc::free::h27b781e3b06bdb05\n           841 ┊     1.80% ┊ <char as core::fmt::Debug>::fmt::h07742d9f4a8c56f2\n           813 ┊     1.74% ┊ __rust_realloc\n           708 ┊     1.52% ┊ core::slice::memchr::memchr::h6243a1b2885fdb85\n           678 ┊     1.45% ┊ <core::fmt::builders::PadAdapter<'a> as core::fmt::Write>::write_str::h96b72fb7457d3062\n           631 ┊     1.35% ┊ universe_tick\n           631 ┊     1.35% ┊ dlmalloc::dlmalloc::Dlmalloc::dispose_chunk::hae6c5c8634e575b8\n           514 ┊     1.10% ┊ std::panicking::default_hook::{{closure}}::hfae0c204085471d5\n           503 ┊     1.08% ┊ <&'a T as core::fmt::Debug>::fmt::hba207e4f7abaece6\n```\n\n#### 手动修改 LLVM-IR\n\nLLVM-IR 是 LLVM 生成 WebAssembly 代码的最后一步。所以，他和最终生成的 WebAssembly 很像。更多的 LLVM-IR 代码意味着生成的文件越大，当一个函数占用了 LLVM-IR 中 25%的位置，则代表他占用了 25%的文件大小。当然这些数字只是个经验值，因为 LLVM-IR 还有一些 WebAssembly 没有的重要的信息（因为 WebAssembly 没有诸如 DWARF 调试信息）。\n\n你可以使用 cargo 生成 LLVM-IR 代码：\n\n```shell\ncargo rustc --release -- --emit llvm-ir\n```\n\n接下来你可以使用 find 命令去寻找存储在 cargo 生成目录(target)下的`.ll`文件。\n\n```shell\nfind target/release -type f -name '*.ll'\n```\n\n相关可以参考[LLVM 语言](https://llvm.org/docs/LangRef.html)\n\n#### 更激进的工具\n\n修改编译配置是比较好上手的。如果你想前进一个里程，你可以使用一些更激进的工具，像是重写代码以减少冗余。以下是一些不太优雅的代码，但是的确能减少生成文件大小。\n\n##### 避免字符串格式化\n\n`format!`,`to_string`等，能加入很多冗余代码。如果可能，在调试环境用格式化，而在发布环境使用静态字符串。\n\n##### 避免使用崩溃\n\n这很明显，使用 twiggy 之类的工具或者人工检查 LLVM-IR 能帮助你查出到底哪个函数崩溃。\n\n崩溃并不总是出现在`panic!()`宏，他们会在很多情况下出现。\n\n- 访问切片越界，如：`my_slice[i]`\n- 除 0，如：`dividend/divider`\n- 解 Option 类型或者 Result 类型，如：`opt.unwrap()`或者`res.unwrap()`\n\n前两个可以被改成第三个，访问切片可以使用`my_slice.get(i)`。除法可以使用`checked_div`，所以你只有一种需要处理的情况。\n\n解开`Option`或者`Result`有两种方法安全的和不安全的。\n\n安全的方式是使用 abort 方法而不是返回 None 和 Error 值。\n\n```Rust\n#[inline]\npub fn unwrap_abort<T>(o: Option<T>) -> T {\n  use std::process;\n  match o {\n    Some(t) => t,\n    None => process::abort(),\n  }\n}\n```\n\n最终，崩溃在`wasm32-unknown-unknown`被翻译成退出，因此不会造成代码冗余。\n\n相反的，[unreachable](https://crates.io/crates/unreachable)包为 Option 和 Result 类型提供不安全的[unchecked_unwrap](https://docs.rs/unreachable/1.0.0/unreachable/trait.UncheckedOptionExt.html#tymethod.unchecked_unwrap)方法。让 Rust 编译器假定 Option 类型是 Some 类型而 Result 类型是 Ok 类型。如果值是不正确的的情况是未被考虑的。你一定要在 110%确认的情况下使用这个包，因为编译器可没那么聪明能预估出错误。即使你这么做了，你一定要在调试环境下面做检查，而在发布环境下去掉检查。\n\n#### 避免调用内存或者使用 wee_alloc\n\nRust 的默认调用器是`dlmalloc`的一部分。它能达到 10KB。如果能够避免动态调用，你应该能省下 10KB。\n\n完全避免动态语言调用可能会非常困难。但是删除调用却在某些情况下很简单，在这些情况下，可以使用[`wee_alloc`](https://github.com/rustwasm/wee_alloc)代替全局的调用器可以从 10KB 中节省很多。`we_alloc`是当你想要一些调用器时的一个选择，并能同时减少代码大小。\n\n#### 使用 trait 来替代泛型\n\n当你创建一些泛型函数。\n\n```Rust\nfn whatever<T: MyTrait>(t: T) { ... }\n```\n\n`rustc`和 LLVM 会为不同类型生成新的函数拷贝。这为编译器提供了各种类型使用这个函数的机会。但会增加代码大小。\n\n如果你为对象提供 trait，如下：\n\n```Rust\nfn whatever(t: Box<MyTrait>) { ... }\n// or\nfn whatever(t: &MyTrait) { ... }\n// etc...\n```\n\n这样经过虚调用动态派遣（dynamic dispatch）的方法就被使用了，如此只会用一个函数会放在`.wasm`。这样的缺点是丢失了编译器自定义的机会，并且增加了不直接的，动态的语言调用。\n\n#### 使用 wasm-snip 工具\n\n[`wasm-snip`](https://github.com/fitzgen/wasm-snip)使用`unreachable`方法代替了 WebAssembly 的函数。这是一个又沉又钝的锤子，更像是徒手。\n\n也许你知道有些函数可能永远不会在运行时被调用，但是编译器不能保证？掐了他！执行`wasm-opt`加上`--dce`参数，所有无关函数就会被剪掉。\n\n这个工具对删除崩溃及其有用。\n\n### 我们能把生命游戏缩到多小？\n\n默认的配置下，WebAssembly 二进制大小为 29410 字节。\n\n```shell\n$ wc -c pkg/wasm_game_of_life_bg.wasm\n29410 pkg/wasm_game_of_life_bg.wasm\n```\n\n打开 LTO 之后设置`opt-level=\"z\"`执行`wasm-opt -Oz`，结果是 17317 字节。\n\n```shell\n$ wc -c pkg/wasm_game_of_life_bg.wasm\n17317 pkg/wasm_game_of_life_bg.wasm\n```\n\n如果使用 gzip 压缩，你能搞到 9045 字节！\n\n```shell\n$ gzip -9 < pkg/wasm_game_of_life_bg.wasm | wc -c\n9045\n```\n\n### 练习\n\n- 使用`wasm-snp`工具删掉会有崩溃的函数，它能减少多少字节？\n- 使用`wee_alloc`作为全局调用器，，修改`Cargo.toml`：\n\n```\n[features]\ndefault = [\"wee_alloc\"]\n```\n\n能够减少多少大小呢？\n\n- 我们只实现了一个 Universe，所以相比使用构造器，我们可以导出一个`static mut`实例，如果这个实例使用的是双向缓存，我们也可以让这些缓存也是全局`staic mut`。这样就移除了所有的动态调用，我们可以增加`#![no_std]`包取消掉调用器。这回能缩小多少大小？\n\n## 发布到 NPM\n\n首先，确保你登入了 npm。\n\n接着，使用`wasm-pack login`登入。\n\n### 发布\n\n确保已经执行`wasm-pack build`并且 pkg 文件已经编译好。\n\n已经准备好之后，跑`wasm-pack publish`上传包到 npm。\n\n这样就发布了！\n\n有哥们照着这个指导做完发布失败，是因为\"name\"字段存在重名\n\n```toml\n[package]\nname = \"wasm-game-of-life-my-username\"\n```\n\n接着，重新编译并发布\n\n```shell\nwasm-pack build\nwasm-pack publish\n```\n\n这会应该能行。\n\n## 与 JavaScript 相互交互\n\n### JavaScript 函数的输出和引用\n\n#### 在 Rust 一边\n\n在 JavaScript 为主的世界里使用 WebAssembly，引入和输出函数比较直接，有点类似于 C。\n\nWebAssembly 模块声明了一系列引入，每一个都有模块名。模块名可以使用`#[link(wasm_import_module)]`提供给`extern {...}`。\n\n导出的 WebAssembly 线性内存被导出作\"memory\"。\n\n```Rust\n// import a JS function called `foo` from the module `mod`\n#[link(wasm_import_module = \"mod\")]\nextern { fn foo(); }\n\n// export a Rust function called `bar`\n#[no_mangle]\npub extern fn bar() { /* ... */ }\n```\n\n因为 WebAssembly 的值类型有局限，这些函数只有基础的数字类型。\n\n#### 在 JavaScript 一边\n\n在 JavaScript 中，wasm 二进制文件转换成 ES6 模块。它必须被实例化为线性内存并由一系列函数能对应到这些引入。细节描述可在[MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiateStreaming)找到。\n\nES6 的模块包括从 Rust 暴露给 JavaScript 的函数，现在可以用 JavaScript 调用。\n\n[这里](https://www.hellorust.com/demos/add/index.html)有一个很简单的构建流程。\n\n### 除了数字\n\n当在 JavaScript 中使用 WebAssembly，WebAssembly 的内存和 JavaScript 的内存有很大的不同。\n\n- 每个 WebAssembly 模块的线性内存，JavaScript 可以自由访问。\n- 对应之下，WebAssembly 不能访问 JavaScript 的内存。\n\n所以，有两种复杂的交互。\n\n- 复制二进制数据到 WebAssembly 内存。\n- 建立一个在 JavaScript 上的堆内存，提供一堆地址。这样 WebAssembly 访问 JavaScript 对象，间接通过 JavaScript 访问。\n\n幸运的是，通过`bindgen`框架[`wasm-bindgen`](https://github.com/rustwasm/wasm-bindgen)可以帮助交互。这个框架可以将已习惯的 Rust 语言自动翻译到 JavaScript。\n\n### 自定义部分（译者：所以这个到底是干什么用的？）\n\n自定义部分允许随意继承人一的数据进入 WebAssembly 模块，这个数据是在编译时设置，不能在运行时修改。\n\n在 Rust 中，自定义部分是通过`#[link_section]`属性暴露的静态数组([T; size])。\n\n```Rust\n#[link_section = \"hello\"]\npub static SECTION: [u8; 24] = *b\"This is a custom section\";\n```\n\n这样给 wasm 增加一个 hello 部分，这个 SECTION 变量是随意的，但是无论怎么赋值，内容总是这些文字。\n\n这个自定义内容可以被 JavaScript 通过[`WebAssembly.Module.customSections`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Module/customSections)获得自定义部分，它返回一个`ArrayBuffer`，如果有同名的部分，他们会被放到一个数组中。\n\n```JavaScript\nWebAssembly.compileStreaming(fetch(\"sections.wasm\"))\n.then(mod => {\n  const sections = WebAssembly.Module.customSections(mod, \"hello\");\n\n  const decoder = new TextDecoder();\n  const text = decoder.decode(sections[0]);\n\n  console.log(text); // -> \"This is a custom section\"\n});\n```\n\n## 哪些包能在 WebAssembly 下面使用\n\n最简单的就是列出 WebAssembly 上能用的 Rust 包：如果避开了以下内容，则这些包可以在 WebAssembly 使用。如果一个包支持`#![no_std]`\n的包，这个包也可能支持 WebAssembly。\n\n### 以下包不能使用\n\n#### C 和系统级依赖\n\nWebAssembly 不提供系统一级别的库，所以任何链接系统库的地方都无法成功。\n\n使用 C 库可能不会成功，既然没有稳定的交叉编译 ABI，和提供给 WebAssembly 交叉链接的连接库。虽然 clang 已经发布 wasm32 的生成，但是还远远不足。\n\n#### 文件 I/O\n\nWebAssembly 没有访问文件系统的功能，所以访问文件系统的库都不能使用。\n\n#### 调用线程\n\n目前有计划[加入线程](https://rustwasm.github.io/2018/10/24/multithreading-rust-and-wasm.html)，但是还没被发布。尝试调用线程会导致崩溃。\n\n### 有哪些目的的包能在 WebAssembly 下面使用\n\n如果只是提供[算法](https://crates.io/categories/algorithms)和[数据结构](https://crates.io/categories/data-structures)的包。\n\n#### #![no-std]\n\n[不依赖于标准库的包](https://crates.io/categories/no-std)能够运行在 WebAssembly 下面。\n\n#### 解析器\n\n只要是接受输入且无需文件操作的[解析器](https://crates.io/categories/parser-implementations)就可能运行在 WebAssembly 下。\n\n#### 文字处理\n\n[复杂的语言处理](https://crates.io/categories/text-processing)可能会运行在 WebAssembly 下面。\n\n#### Rust 范式\n\n[适用于不同情况下的包](https://crates.io/categories/rust-patterns)可能运行在 WebAssembly 下。\n\n## 如何给常用库增加 WebAssembly 支持\n\n本部分讲解如何将常用库增加 WebAssembly 支持。后面的内容我就捡感兴趣的写了。\n\n### 在 CI 增加 wasm32-unknown-unknown\n\n保证 CI 中增加如下命令\n\n```shell\nrustup target add wasm32-unknown-unknown\ncargo check --target wasm32-unknown-unknown\n```\n\n举个例子，在 travis 的配置中增加如下配置：\n\n```yaml\nmatrix:\n  include:\n    - language: rust\n      rust: stable\n      name: \"check wasm32 support\"\n      install: rustup target add wasm32-unknown-unknown\n      script: cargo check --target wasm32-unknown-unknown\n```\n\n### 在 node.js 或者无头浏览器（译者：卧槽是这么翻译么）\n\n你可以使用`wasm-bindgen-test`和`wasm-pack test`去跑测试，详细内容上面已经提到。\n\n## 发布 WebAssembly 到线上\n\n> 发布过程几乎和任何 web 应用发布是一样的。\n\n为了发布 Web 应用，复制生成文件到线上环境，配置你的 HTTP 服务器让他们可访问。\n\n### 保证服务器支持 application/wasm\n\n为了让浏览器加载变快，[WebAssembly.instantiateStreaming](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiateStreaming)函数会使用管道传输文件（请确定你的打包器能够使用这个函数）。但是 instantiateStreaming 需要 HTTP 返回类型支持`application/wasm`，否则会丢出错误。\n\n- [如何配置 Apache 服务器](https://httpd.apache.org/docs/2.4/mod/mod_mime.html#addtype)\n- [如何配置 Nginx 服务器](https://nginx.org/en/docs/http/ngx_http_core_module.html#types)\n\n### 更多内容\n\n- [webpack 线上打包的最佳实践](https://webpack.js.org/guides/production/)\n","collection":"blog","data":{"type":"post","category":"fe","tag":["rust","wasm"]}},{"id":"2020/03/05/Jekyll-Gatsby.md","slug":"2020/03/05/jekyll-gatsby","body":"\n# 从 Jekyll 迁移博客到 Gatsby\n\n很久以前就想迁移了，但是一直没下手，原因很简单，就是 ruby 不太熟悉，而使用 node 工具链比较趁手。\n\n当然了，Gatsby 的主题对比 Jekyll 就少太多了，没关系，大不了自己设计（又是一个大坑）。\n\n[Gatsby 官网](https://www.gatsbyjs.org/)的 tutorial 已经很详细了，这里只提简单的几个注意。\n\n- 所谓的 TypeScript 项目仅仅指的是前端，后端部分（因为是静态服务，应该说成编译的钩子`gatsby-node.js`）还是用的是 JavaScript，但是可以通过引入`ts-node`实现引用 TypeScript 文件。\n\n- 不确定是不是 WSL 或者 Windows 的锅，执行`gatsby develop`或者`gatsby build`的时候会偶尔出现权限无法访问并在根目录创建`reduxcache*`文件，挺烦人的其实，回头还得执行`sudo rm -Rf reduxcahce*`删除。\n\n- 无论`components`还是`pages`，其实都做了一层隐式封装，所以只有`default`暴露的组件参能使用 Gatsby 里面诸如`useStaticQuery`的钩子函数。\n\n- Gatsby 默认的 URL 格式和 Jekyll 不一样，为了保持持续性，我修改了`server/onCreateNode`来修改文件的 URL。\n\n- 修改 Travis 上传到`gh-pages`分支后，服务竟然挂了，查看 setting 说我只能在`master`分支上面放编译后的文件（莫非政策有变化？）。无所谓了，把`gatsby`分支改成默认分支，设置`master`分支为部署分支即可。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["jekyll","gatsby"]}},{"id":"2020/03/06/Utterance-GitHub-issue.md","slug":"2020/03/06/utterance-github-issue","body":"\n# 使用 Utterance 为博客添加基于 Github-issue 的评论系统\n\n最近在重构我部署在 GitHub pages 的博客，本来不想添加评论系统的，但是手贱，非想要加一个。\n\n尝试了 disqus（一个在国内无法使用的评论系统），貌似`page.url`中不能使用中文字符...这就尴尬了，突然想起来以前看 hackernews 的时候有人提起过使用 GitHub issue 搭建博客的想法。如果你是直接使用静态页面做网站，只需要去[Utterance](https://utteranc.es/)授权 GitHub 账号，复制对应的代码粘贴到网站即可。\n\n因为我新重构的网站是基于 Gatsby 的，Utterance 也提供了[react 高阶组件](https://www.npmjs.com/package/with-utterances)可以使用。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["github"]}},{"id":"2020/03/10/docker-strapi.md","slug":"2020/03/10/docker-strapi","body":"\n# 腾讯云 docker 安装 strapi\n\n## Docker engine\n\n如下是[官网的安装过程](https://docs.docker.com/install/linux/docker-ce/ubuntu/)，首先移出 Ubuntu 原有的 docker（如果有的话）\n\n```shell\n sudo apt-get remove docker docker-engine docker.io containerd runc\n sudo apt-get update\n```\n\n安装相关依赖\n\n```\nsudo apt-get install \\\n    apt-transport-https \\\n    ca-certificates \\\n    curl \\\n    gnupg-agent \\\n    software-properties-common\n```\n\n增加 docker 的安装源\n\n```shell\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n```\n\n开始安装（我的架构是 x86_64）\n\n```shell\nsudo add-apt-repository \\\n   \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\\n   $(lsb_release -cs) \\\n   stable\"\n\nsudo apt-get update\nsudo apt-get install docker-ce docker-ce-cli containerd.io\n```\n\n## Docker compose\n\n安装新版本`docker-compose`，因为文件存储在 github 上面，这里直接从 DaoCloud 下载。\n\n```\nsudo curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.4/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose\nsudo chmod +x /usr/local/bin/docker-compose\n```\n\n## 解决 ERROR: Couldn't connect to Docker daemon at http+docker://localhost - is it running？\n\n需要增加自己用户到 docker 组，然后重新进入即可\n\n```shell\nsudo gpasswd -a ${USER} docker\n```\n\n## Strapi\n\n按照[strapi 官方文档](https://strapi.io/documentation/3.0.0-beta.x/installation/docker.html)执行如下操作。\n\n新建文件夹，并增加`docker-compose.yaml`\n\n```yaml\nversion: \"3\"\nservices:\n  strapi:\n    image: strapi/strapi\n    environment:\n      DATABASE_CLIENT: mongo\n      DATABASE_NAME: strapi\n      DATABASE_HOST: mongo\n      DATABASE_PORT: 27017\n      DATABASE_USERNAME: strapi\n      DATABASE_PASSWORD: strapi\n    links:\n      - mongo:mongo\n    volumes:\n      - ./app:/srv/app\n    ports:\n      - \"1337:1337\"\n\n  mongo:\n    image: mongo\n    environment:\n      MONGO_INITDB_ROOT_USERNAME: strapi\n      MONGO_INITDB_ROOT_PASSWORD: strapi\n    volumes:\n      - ./data/db:/data/db\n    ports:\n      - \"27017:27017\"\n```\n\n修改 docker 镜像选择[腾讯加速器](https://cloud.tencent.com/document/product/457/9113)。\n\n```json\n//  /etc/docker/daemon.json\n{\n  \"registry-mirrors\": [\"https://mirror.ccs.tencentyun.com\"]\n}\n```\n\n重启服务\n\n```shell\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n```\n\n下载镜像。\n\n```shell\ndocker-compose pull\n```\n\n启动镜像\n\n```shell\ndocker-compose up -d\n```\n\n现在你的 1337 端口已经交给 strapi 了。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["docker","tencent","strapi"]}},{"id":"2020/03/17/Windows-Cypress.md","slug":"2020/03/17/windows-cypress","body":"\n# Windows 下面搞 Cypress 真心不容易\n\n最近在忙活让网站使用 [Cypress](https://www.cypress.io/) 做测试，之前使用苹果电脑以及 Linux 下面用起来还不错，这次在 Windows 下面碰壁比较多（其实我国的网络也有一部分功劳），所以在这里记录一下。\n\n## 尝试使用 WSL（失败）\n\nWSL 可以使用 XServer，所以我打算在 WSL 下面搭建，需要安装 [VcXsrv](https://sourceforge.net/projects/vcxsrv/) ，启动之后一路下一步就可以了，最后将 WSL 显示映射上去（在 bashrc 里面添加下面代码）。\n\n```shell\n# Display\nexport DISPLAY=localhost:0\nsudo /etc/init.d/dbus start &> /dev/null\n```\n\n另外需要把用户加到 sudoers 里面，否则每次启动还要输一遍密码\n\n```shell\nsudo echo \"{user} ALL = (root) NOPASSWD: /etc/init.d/dbus\" >> /etc/sudoers.d/dbus\n```\n\n然而，失败了，启动程序会报 GPU 渲染错误，同样的操作在 WSL2 中依然不行，可是[网络中有人成功了](https://nickymeuleman.netlify.com/blog/gui-on-wsl2-cypress/)。\n\n我相信更多的原因在于编译的时候网络环境太差了。\n\n## 尝试使用 MSYS\n\n直接跑 Windows 原生应用除了运行起来会更快，还可测试如 Edge 等浏览器，[MSYS](https://www.msys2.org/) 安装起来很简单，软件仓库管理使用的是 pacman，安装源可以尝试华中科大和清华的。\n\n```ini\n# C:\\msys64\\etc\\pacman.d\\mirrorlist.mingw32\nServer = http://mirrors.ustc.edu.cn/msys2/mingw/i686/\nServer = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/i686/\n```\n\n```ini\n# C:\\msys64\\etc\\pacman.d\\mirrorlist.mingw64\nServer = http://mirrors.ustc.edu.cn/msys2/mingw/x86_64/\nServer = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/x86_64/\n```\n\n```ini\n# C:\\msys64\\etc\\pacman.d\\mirrorlist.msys\nServer = http://mirrors.ustc.edu.cn/msys2/msys/$arch/\nServer = https://mirrors.tuna.tsinghua.edu.cn/msys2/msys/$arch/\n```\n\n另外需要在「控制面板>系统安全>系统>高级系统设置>环境变量」中增加`MSYS2_PATH_TYPE`值为`inherit`，这样 MSYS 里面的 PATH 就是用的是系统的 PATH 了。\n\n如果习惯使用 WWindows Terminal，可以尝试这个[issue](https://github.com/msys2/MSYS2-packages/issues/1684)，在 Windows Terminal 里面运行 MSYS。\n\n```shell\n$ cat .ms-terminal/wt-msys2.cmd\n@echo off\nsetlocal\n\nrem To activate windows native symlinks uncomment next line\nset MSYS=winsymlinks:nativestrict\n\nrem Shell types\nif \"x%~1\" == \"x-msys2\" set MSYSTEM=MSYS\nif \"x%~1\" == \"x-mingw32\" set MSYSTEM=MINGW32\nif \"x%~1\" == \"x-mingw64\" set MSYSTEM=MINGW64\n\n\nrem Shell types\nrem set MSYSTEM=MSYS\n\nC:\\msys64\\usr\\bin\\bash.exe --login -i\n\nexit /b 0\n```\n\n```json\n{\n  \"guid\": \"{e129fe71-3c94-40b5-8d92-961a3248f175}\",\n  \"commandline\": \"C:\\\\\\\\msys64\\\\home\\\\gongb\\\\wt-msys2.cmd\",\n  \"name\": \"MSYS2\",\n  \"startingDirectory\": \"%USERPROFILE%\",\n  \"icon\": \"ms-appx:///ProfileIcons/{0caa0dad-35be-5f56-a8ff-afceeeaa6101}.png\",\n  \"useAcrylic\": true,\n  \"acrylicOpacity\": 0.75\n}\n```\n\nWindows 下面的开发环境配置比较困难的原因之一就是这些链接库，比如安装一个`libpng-dev`，可以使用 Visual Studio Toolchain，也可以使用 MSYS，还可以使用微软开源的 VCPKG，然而没有一个体验能够达到极致。这导致 Gatsby 在我国的网络下永远不能部署成功。\n\n但是，直接在官网下载下来二进制包再进行[安装](https://docs.cypress.io/guides/getting-started/installing-cypress.html#Install-binary)也是可以的。\n\n```shell\nCYPRESS_INSTALL_BINARY=/local/path/to/cypress.zip npm install cypress\n```\n\n这样就可以运行 Cypress 了。\n\n## 最佳实践\n\n由此可知，其实 Cypress 可以在 Windows 下面原生执行，那么可以单独使用一个代码仓库管理测试用例，如本博客的测试用例放在[这里](https://github.com/gongbaodd/cy-blog.gongbusang.com)，在持续集成的时候将代码下载下来测试即可。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["cypress","Windows","WSL2","MSYS","VcXsrv"]}},{"id":"2020/03/22/react-three-fiber-WebGL.md","slug":"2020/03/22/react-three-fiber-webgl","body":"\n# 使用 react-three-fiber 体验美好的 WebGL 开发\n\n使用 threejs 开发 webGL 应用应该是几乎每个前端工程师想要做的事儿，然而虽然对比于原生 WebGL 开发来说，threejs 已经做了很多，但是相对于现代的一些前端框架。threejs 还稍显不足。针对这些不足，微软开发了[Babylon.js](https://www.babylonjs.com/)，给 threejs 量身定制了一个节点编辑器，如果做过 blender 或者 unity 的同学，对于节点编辑器肯定不会陌生，但对我本人来说还是没有触碰到 G 点。\n\n## 描述组件关系的重要性\n\n本人觉得，对于前端开发来说，提供一个能够准确描述组件和组件结构关系的语言（DSL）是至关重要的，如 HTML 之于 web 开发，xml 之于安卓开发。这些 DSL 能够以最直观的方式表达页面将会展示什么，就从开发的角度上来说，或许入门不是很方便，毕竟要处理很多文件。但是维护起来却异常的轻松，就是前面提到的原因，直观。当然因为 JavaScript 跟 HTML 的交互有很大的性能缺陷。所以给很多模板语言提供了机会。比如 mustache 还有 react 的 JSX。在安卓也能看到 anko 在 kotlin 社区兴起，但是仅仅一年就没有更多人使用了，个人体验，在 Android studio 中使用 xml 和 anko 开发体验差距并不大，有时候 xml 甚至占优，也许这就是原因之一了吧。\n\n几年前我翻查了很多框架，老实说可能更多人并没有把结构描述放在如我想的位置上，哪怕连个 JSON 的方案都没有。但是的确有[aframejs](https://aframe.io/)这种直接用 HTML 管理 canvas 中元素关系的库，可惜它更关注于 VR 开发，而我更希望 WebGL 能够成为诸如图书注解一样的工具，当然这种专注于一个方面的做法或许是正确的，毕竟能够汇聚一个小圈的开发者，也不会有很多流失。\n\n## 用 JSX 开发 WebGL\n\n今年运气就好多了，react-reconciler 使得我们能够直接接管组件的 render 函数，而 react-hooks 在开发体验上完美超出现有框架，[react-babylonjs](https://github.com/brianzinn/react-babylonJS) 和 [react-three-fiber](https://github.com/react-spring/react-three-fiber) 应运而生。我同时试用了这两个框架，简单来说，react-three-fiber 更加成熟些，对 tTypeScript 的支持更好，而 react-babylonjs 开发的时候往往会因为处理类型而费心，最后又不得不使用 JavaScript 开发。\n\n## 怎么使用 react-three-fiber\n\nreact-three-fiber 的[官方文档链接](https://inspiring-wiles-b4ffe0.netlify.com/)描述很详细，建议详读。另外 threejs 官方来链接的[threejs fundamentals](https://threejsfundamentals.org/)有时间也可以拿来读读。\n\n如果想把原来的 threejs 模块迁移到 react 模块，只需要使用一层 primitive 包装即可。每个拥有 set 和 get 的参数都可以作为 props 的成员，构造器参数则是`props.args: any[]`类型。\n\n```JavaScript\nconst grid = new GridHelper(2000, 20, 0x000000, 0x0000000);\n(grid.material as Material).opacity = 0.2;\n(grid.material as Material).transparent = true;\n\nconst Grid = () => {\n  useFrame(({ scene }) => {\n    if (!scene.fog) {\n      const fog = new Fog(0xa0a0a0, 200, 800);\n      scene.fog = fog;\n    }\n  });\n\n  return <primitive object={grid}></primitive>;\n};\n\n```\n\n## 调试工具\n\n这点 babylonjs 要好得多，一个节点编辑器秒杀一切，但是 threejs 还有一个「够用」的[threejs inspector](https://chrome.google.com/webstore/detail/threejs-inspector/dnhjfclbfhcbcdfpjaeacomhbdfjbebi?hl=en)。\n\n使用时需要把你的 scene 和 THREE 模块暴露给 window 作用域。\n\n```JavaScript\nwindow.scene = scene;\nwindow.THREE = THREE;\n```\n\n然后刷新浏览器就可以在场景添加光源，查看节点等操作了。\n\n## 提示\n\n因为 threejs 及其模块本身不是编译好的 ES5，在 nextjs 中一定记得使用`next-transpile-modules`编译，当然即使已经完美适配 ES5，在 IE11 的展示也不是很乐观 😅。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["threejs","webGL","react"],"series":{"slug":"threejs-howto","name":"细品threejs"}}},{"id":"2020/03/26/Tailwind-CSS.md","slug":"2020/03/26/tailwind-css","body":"\n# [Tailwind](https://tailwindcss.com/) 一个像宏语言的 CSS 解决方案\n\n先把刀放下，我知道，现在已经有 n 种 CSS 的解决方案，而且基本上没有一个用着顺心的。\n\n我记得曾有一段时间，好像是使用 YUI 那会儿，CSS 的 class 往往会命名成布局规则，比如希望一个 div 有 10 像素的留白，就给他添加一个 class，`.margin-10px`，然后对这个 class 的描述为。\n\n```CSS\n.margin-10px {\n    margin: 10px;\n}\n```\n\n当然，这种方式在我入职一段时间后马上消失了，大家都更倾向于使用组件语义化的 class，如显示头像，则把 class 命名为`.avatar`而不是`.margin-10px.padding-5px.radius-50`这种怎么看都不知道是干什么的命名。\n\n于是 CSS 开始和组件越来越近，自从有了 scope CSS， React 和 Vue 的组件库逐渐成形，更多的方案逐渐青睐[CSS in JS](https://cssinjs.org/?v=v10.1.1)，单纯的 CSS 解决方案除了 [bulma](https://bulma.io/) 剩下的就不多了。设计的时候往往要先考虑使用的这个组件库的设计语言能给改造预留出多大的空间，然后再设计。\n\n## 回头想一想\n\n其实把几个 CSS 语句合起来作为一个集合使用并不是错的，现有的 SASS 框架也会用 utils 库专门存储封装好的`@mixins`。想到以前使用[Yo](https://github.com/doyoe/Yo)做前端样式时常会用`@yo-flex('.box'){}`这样的函数，这个函数其实就是将 flex 布局的以及它的降级 box 布局，甚至是优雅降级到不支持 box 布局的样式集合到一起。\n\n如果你认同上面这段话，那么 tailwind 一定是个适合你的工具，个人比较喜欢的是这个工具仅仅基于 postcss，这意味着你不需要使用 SASS（并不是 SASS 不好，只是国内用起来太悲剧，即使已经有 sass dart，但是因为普遍还没支持，每次使用的时候神经都要紧绷一下），它和 SASS 也不冲突。你还可以使用 config 文件来自定义样式（这很像很多 CSS in JS 的样式库，这应该是我喜欢那些库的唯一一点了）。\n\n## 操练起来\n\n[官网安装方式](https://tailwindcss.com/docs/installation)很详细，基本上能提到的工具都提过了。\n\n就拿前面的`.avatar`来举例，使用 tailwind 的代码应如下（注意 tailwind 单位不是 px 而是 rem，这里假定 html 的字体大小为 10px）。\n\n```CSS\n.avatar {\n    @apply m-4;\n    @apply p-2;\n    @apply rounded-full;\n}\n```\n\n这样既满足了，类名的语义化，还能使用 config 文件来统一自己的设计语言，最重要的，如果你拿 houdini 写个什么奇葩的 polyfill，就算预编译器读不懂，他也会容错，毕竟这就是原生 CSS。\n\n至于官网的示例，我个人很不支持，感觉是一种开倒车的方式，但萝卜白菜各有所爱，如果有公司会因为我写那样的代码而给我钱的话，我当然无所谓。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["css","tailwind","postcss"]}},{"id":"2020/03/27/svelte.md","slug":"2020/03/27/svelte","body":"\n# Svelte 让人眼前一亮的前端框架\n\n我觉得必须要介绍一下 [svelte](https://svelte.dev/) 这个框架，确切的说是 svelte v3，这应该是继 [riotjs](http://riot.js.org/)、[typescript](https://www.typescriptlang.org/) 和 [rust](https://www.rust-lang.org/) 之后又一个能给我眼前一亮的感觉的产品了。\n\n## 关于 Svelte\n\n不得不提到他的作者 [Rich Harris](https://github.com/Rich-Harris)，提到他的另一个作品就是大名鼎鼎的 [rollup](http://rollupjs.org/)，这可是第一个提出 tree-shaking 的前端打包器（说实话，这导致我有更多的担忧，svelte 可能会变成像 rollup 一样的小众狂欢）。\n\n回到 svelte，他从 v1 的时候目标就是简单，只不过 v1 版本看起来太像 zepto 了（那我为什么不用原生 JavaScript）。不过 v3 版本这个框架换了个方向，从框架变成了编译器，类似于 riotjs 和 vuejs，组件的 html、css 和 js 可以写在一起，其实我并不是特别推崇这种做法，往往有时候我更倾向于 angularJS 的做法，但是 svelte 的处理真的太完美。\n\n```html\n<script>\n  const hello = \"world\";\n</script>\n\n<h1>{hello}</h1>\n\n<style>\n  h1 {\n    color: black;\n  }\n</style>\n```\n\n看到了吗？没有多出来的 `Vue.extend()`，HTML 和 JavaScript 部分的交互竟然这儿么完美！要是 CSS 再加把力就更好了（不过如果是 CSS in JS 的话...那还是用某个 preprocessor 勉强一下好了）。HTML 模板类似比较简单的 handlebars 语法，甚至支持异步模板。\n\n另外 svelte 没有虚拟 DOM，这一点我有一些相见恨晚，我之前就写过[文章](/fe/2016/03/31/VUE&Riot&React实力比较.html)质疑虚拟 DOM 是不是真的能带来性能提高（结果是性能很差），但是最终被人喷了，导致一年后不得不[弃坑 riotjs 改用 preact](/fe/2017/05/15/弃坑Riot转向Preact.html)。但我始终认为虚拟 DOM 更是一个范式而不是能带来性能提升的神器。所以你代码差，换什么范式，性能都差，喷别人之前先称称自己几斤几两好么？\n\nsvelte 符合响应式模式，这一点和 riotjs 很类似，借助 svelte 这个编译器，写好的组件会被编译成响应式函数。也许拿 riotjs 做比方会比较难，这里拿 react 做比方，在 react 中实现响应式需要使用`setState()`。\n\n```JavaScript\nconst Com = () => {\n    const [state, setState] = useState(1);\n    useEffect(() => setState(state + 1), [])\n    const stateX2 = state*2;\n\n    return (\n    <>\n        <div>{state*2}</div>\n        <div>{stateX2}</div>\n    </>\n    );\n}\n/* 输出\n * <div>2</div>\n * <div>2</div>\n*/\n```\n\n而由于 svelte 是个编译器，svelte 里面不仅代码更少，而且正确的输出了`stateX2`的值。\n\n```HTML\n<script>\nimport { onMount } from \"svelte\";\n\nlet state = 1;\n\nonMount(() =>  state += 1);\n\n$: let stateX2 = state * 2;\n</script>\n\n<div>{state}</div>\n<div>{stateX2}</div>\n\n<!--\n    输出\n    <div>2</div>\n    <div>4</div>\n-->\n```\n\n没错，完全没有多余的代码（其实 svelte 编译器会默默地给`state`增加一个`observable`的配置，但是这都是编译器自己做的，开发者完全不需要考虑）。这里发现`stateX2`前面有一个`$`标识，表明后面的语句是响应式的。这一点真的很巧妙，因为这个语法是 JavaScript 标准里百年不遇的`goto`语句，svelte 高明的使用 JavaScript 原有的语法实现了新的功能，不像某框架愣是加了一个 JSX 语法（不是鄙视 JSX，JSX 也很牛逼的说）。\n\n在 n 多个框架都在模仿 react 的主流下，这个框架还能别出心裁，不得不赞，如果你感兴趣，我强烈推荐浏览他们的[例子](https://svelte.dev/examples#hello-world)。store 和 context 都非常有启发。\n\n最大的缺点就是目前还没有官方的 TypeScript 支持，这一点很有尴尬，因为 svelte 本身就是 TypeScript 写的。不过现在有第三方的[svelte-preprocess](https://github.com/kaisermann/svelte-preprocess)对 TypeScript 提供支持，不知道啥时候转正。\n\n## Sapper\n\nriotjs 同样没有虚拟 DOM，这使得它在 SSR 方面会[有一些问题](https://riot.js.org/documentation/#riot-dom-caveats)，但是 Svelte 提供了一套 SSR 解决方案，[sapper](https://sapper.svelte.dev/) 同时支持 node 渲染和静态发布。\n\nSapper 受 next.js 启发，使用`src/route`文件夹下的文件做路由。\n\n```\nsrc/routes\n    _layout.svelte -- 布局文件\n    _error.svelte  -- 404目录\n    index.svelte   -- /或者/index\n    posts.json.js  -- /post.json，可以使用类似express路由的方式写接口\n```\n\n想要在 index 里面实现 server 端的预加载，可以使用 sapper 的 preload API。\n\n```html\n<script context=\"module\">\n  export async function preload(page, session) {\n    const res = await this.fetch(\"posts.json\");\n    const { posts } = await res.json();\n\n    return { posts };\n  }\n</script>\n```\n\n这样会在`window`上面注入一个`__SAPPER__`变量把 server 端预加载的值赋上去。\n\n因为 sapper 还在 beta 阶段，我也不敢拿来开发什么大项目，但真心想写写 svelte，因为它在很多地方非常有新意，历史包袱也不大，暂时写个 [CSS playground](https://css.gongbushang.com/) 来做 [CSS Secrets](http://shop.oreilly.com/product/0636920031123.do) 的笔记好了。\n\n## 单元测试\n\n[testing-library](https://testing-library.com/docs/svelte-testing-library/intro) 提供单元测试支持，配置起来绝对比 react 和 vue 简单，只是因为比较新，所以没有类似的 create react app 这种官方脚手架，当然如果 sapper 出正式版了就算有了。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["svelte","sapper","JavaScript","rollup"]}},{"id":"2020/03/29/Rust-crate.io.md","slug":"2020/03/29/rust-crateio","body":"\n# Rust 开发更换 crate.io 源\n\n使用 VSCode 开发 Rust 的我，最难过的一刻就是打开编辑器时的 RLS 检查，可以看做它是一个用来检查代码语法的后台程序，在 RLS 的 issue 里面有很多人吐槽他初始化的速度实在是太慢了，然而大佬的回复都是说他们不需要使用这种辅助工具。作为使用 JavaScript 都一定要 TypeScript 编译，打字都是通过语音输入来打字的我来说（没错，这篇博文是语音转换过来的），臣妾做不到啊。\n\nRLS 检查有一个步骤是`cargo check`，这里会链接`crate.io`检查包的完整性。由于`crate.io`的包大多托管在 GitHub，所以外网的宝宝们吐槽的慢只是秒级别的，而中国的宝宝是小时级的 😭。\n\n但是尚有修补的余地，中科大爸爸给国内开发者提供国内的镜像了。修改`~/.cargo/config`增加中科大的源。\n\n```ini\n[source.crates-io]\nregistry = \"https://github.com/rust-lang/crates.io-index\"\nreplace-with = 'ustc'\n\n[source.ustc]\nregistry = \"git://mirrors.ustc.edu.cn/crates.io-index\"\n```\n\n中科大就是我的神啊！开发 Rust 终于可以和国外一样慢了 😂！\n","collection":"blog","data":{"type":"post","category":"fe","tag":["rust","crate.io","ustc","cargo"]}},{"id":"2020/03/30/CSS Secret.md","slug":"2020/03/30/css-secret","body":"\n# CSS Secret 有感\n\n虽然维多利亚的秘密没有了，但是 CSS 的秘密还是可以考虑考虑的，这本书是 2015 年出版的，相比于现在，显然里面的很多属性已经可以做到多平台兼容了，当然里面还没有涉及 grid 布局，强烈推荐 [wesbos 的 grid 课程](https://cssgrid.io/)，虽然看完也是忘 😅。\n\n要说编程算法难学，跟 CSS 比起来还是个弟弟，不仅仅要了解一些拓扑的知识，编出来的图形还得好看。\n\n书中的实现都放在[这里](http://play.csssecrets.io/)，同时我也挑了一些喜欢的[自己实现了一下](http://css.gongbushang.com/)。\n\n书里面涉及到的有\n\n- outline\n- box-shadow\n- background-image（里面提到了一个纯 CSS 实现北京图案的[网站](https://leaverou.github.io/css3patterns/)，值得拥有）\n- background-origin\n- border-image\n- path-clip\n- transform\n- filter\n- font-variable\n- keyframe\n\n目前个人比较感兴趣然而未被涉及的是\n\n- grid\n- css variables\n\n当然这些那会儿都还没有，所以闲着没事儿干的时候还要多逛逛[css-tricks](https://css-tricks.com/)。\n\n还有，在写[svelte](/fe/2020/03/27/svelte一个让人眼前一亮的的前端框架.html)曾经提过如果有一个比较好的 CSS 和 JavaScript 以及 HTML 交互的方法就好了，细想之下 css variables 或许可以。试想如下结构。\n\n```html\n// Back.svelte\n<div class=\"bg\">\n  <slot></slot>\n</div>\n\n<style>\n  .bg {\n    --color: red;\n  }\n</style>\n```\n\n```html\n// Menu.svelte\n<ul>\n  <li>Menu</li>\n</ul>\n\n<style>\n  ul > li {\n    color: var(--color, blue);\n  }\n</style>\n```\n\n```html\n// App.svelte\n<script>\n  import Back from \"Back.svelte\";\n  import Menu from \"Menu.svelte\";\n</script>\n\n<Back>\n  <menu></menu>\n</Back>\n```\n\n此时的 Menu 应该是 Back 里面设置好的红色（我自己没尝试，只是写这个博文的时候临时起意）。这最大的好处显而易见，类似于 react 里面的 theme，`<Back/>`组件给`<Menu/>`组件提供了配合的样式，而不仅仅局限于 JavaScript 传入的数据。\n\n只可惜 CSS variables 需要做向下兼容，而且就算是 postcss 的[postcss-css-variables](https://www.npmjs.com/package/postcss-css-variables)也只能兼容放到`:root`下的变量（那要你有何用囧），不过就[caniuse](https://caniuse.com/#feat=css-variables)的数据，不考虑中国用户的话，确实可以大胆使用 CSS variables，就算是降级估计也没那么难看吧。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["CSS"]}},{"id":"2020/04/04/ObservableHQ-JS-Jupyter.md","slug":"2020/04/04/observablehq-js-jupyter","body":"\n# ObservableHQ-JS 终于有自己的 Jupyter 笔记本了\n\n学习机器学习的时候用上 python 的 Jupyter notebook 是真好用，曾经就想，如果 JavaScript 也有一个就好了，没错[ObservableHQ](https://observablehq.com/)就是基于 D3.js 的数据可视化笔记本。\n\n官方的[入门](https://observablehq.com/@observablehq/a-taste-of-observable)讲的很详细，接下来一周我可能会专心于里面的[D3 教程](https://observablehq.com/@d3/learn-d3)，间或去学习 threejs fundamental。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["observablehq","JavaScript","d3","jupyter"]}},{"id":"2020/04/07/D3.md","slug":"2020/04/07/d3","body":"\n# 学习 D3 的新姿势\n\n今天用了半天的时间把 observable HQ 上面的 [Learn D3](https://observablehq.com/@d3/learn-d3) 学习了一遍，[这](https://observablehq.com/@gongbaodd/d3-js)是纯笔记版。\n\n不过今天真的是爽到了，没错，我终于找到了以前学习 D3 没动力的原因了，那么厚的一本书，基本上就是把 D3 gallery 抄了一遍。最开始基本上还要学一个 D3 版本的 jQuery 选择器，数据还要自己搞，基本读了两章就打算放弃。\n\n```JavaScript\nvalues = [...\"123456\"];\nimport {chart as chart1} with {values as data} from \"@d3/histogram\";\n```\n\n这就是一个柱状图了！！！爽到有没有？\n\n如果你想写一个控制界面\n\n```JavaScript\nviewof replay = html`<button>Replay</button>`\n```\n\n使用这个控制器\n\n```JavaScript\nreplay, html`\n<svg viewBox=\"0 0 ${width} ${height}\">\n  ${d3.select(svg`<g>`).call(shape_xAxis).node()}\n  ${d3.select(svg`<g>`).call(shape_yAxis).node()}\n  ${d3.select(svg`\n    <path\n      d=\"${line(shape_data)}\"\n      fill=\"none\"\n      stroke=\"steelblue\"\n      stroke-width=\"1.5\"\n      stroke-miterlimit=\"1\"\n      stroke-dasharray=\"0,1\"\n    >\n    </path>\n  `).call(reveal).node()}\n</svg>\n`\n```\n\n哈哈，有趣，这语法很有想象力，比 svelte 更加大胆，仿佛用 JavaScript 实现了一个类似于 python 的词法。如果你想创建一个复杂的变量，你可以：\n\n```JavaScript\nsum = {\n  let s = 0;\n  for (let i = 0; i < 10; ++i) {\n    s += i;\n  }\n  return s;\n}\n```\n\nObservable HQ 的每个语句类似于 react 的 render 函数，你甚至可以把它写成一个迭代器。当 replay 被点击，页面展示的数值会从 1 逐渐增加到 299。\n\n```JavaScript\n{\n  replay;\n  for (let i = 0, n = 300; i < n; ++i) {\n    yield i;\n  }\n}\n```\n\n另外可以参考[如何利用 Wikipedia 的数据](https://observablehq.com/@mbostock/working-with-wikipedia-data)进一步使用 observable HQ。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["observablehq","d3"]}},{"id":"2020/04/16/CSS.md","slug":"2020/04/16/css","body":"\n# CSS 渐变利器\n\n[CSS gradient generator](https://mybrandnewlogo.com/color-gradient-generator)\n","collection":"blog","data":{"type":"post","category":"fe","tag":["css","gradient"],"series":{"slug":"tools","name":"利器"}}},{"id":"2020/04/21/threejs-mesh.md","slug":"2020/04/21/threejs-mesh","body":"\n# threejs 细化-创建一个 mesh、使用加载器、多个场景\n\n记录下最近几天的事，终于 Dell 的维修把我电脑的风扇修好了，不过感觉 inspiron 的风扇设计有 bug，新风扇估计也撑不了多久，但愿只是我多疑了。另外通过神奇的某宝，我将我手上的小米平板二升级了内存和硬盘，考虑到 8GB 内存对于 Atom Z8500 这个 CPU 有点多余，于是升级到了 4GB + 128GB，到手之后果然比 2GB 流畅（当然肯定没法比酷睿了），所以这个配置还是比较推荐的。\n\n回到主题，最近一周我都在使用 react-three-fiber 来学习 threejs，这里会做一个系列来详细整理一下。\n\n## 创建一个 mesh\n\n可以使用 JSX 创建 mesh, 因为 mesh 有 material 和 geometry 两个访问器，在 JSX 中可以作为属性使用。\n\n```JavaScript\nexport default () => (\n    <Canvas>\n        <mesh\n            name=\"mesh\"\n            material={new MeshBasicMaterial()}\n            geometry={new BoxBufferGeometry(1, 1, 1)}\n        />\n    </Canvas>\n);\n```\n\n当然作为参数也可以。\n\n```JavaScript\nexport default () => (\n    <Canvas>\n        <mesh arg={[new BoxBufferGeometry(1, 1, 1), new MeshBasicMaterial()]}/>\n    </Canvas>\n);\n```\n\n官网还提供了一个绝妙的方法。\n\n```JavaScript\n// 实现不了，不知道咋回事儿\nexport default () => (\n    <Canvas>\n        <mesh>\n            <boxBufferGeometry attach=\"geometry\" />\n            <meshBasicMaterial attach=\"material\" />\n        </mesh>\n    </Canvas>\n);\n```\n\n另外因为 Canvas 里面的元素和 JSX 的绑定使用的是 memo，所以如果使用 primitive 定义元素的时候会丢。\n\n```JavaScript\n// 这么做虽然会渲染出来，但是Box有的时候会丢\nconst Box = new Mesh(\n    new BoxBufferGeometry(1, 1, 1),\n    new MeshBasicMaterial(),\n);\n\nexport default () => (\n    <Canvas>\n        <primitive object={Box} />\n    </Canvas>\n);\n```\n\n## 加载器\n\n加载 texture 时，可以使用`useEffect`自己写，当然也有更优雅的方法，利用 react 自己的`useMemo`或者`useCallback`，再就是使用 react three fiber 的`useLoader`。\n\n```JavaScript\n// 使用 useMemo\nconst Plane = () => {\n    const texture = useMemo(() => new TextureLoader().load(\"xxx.jpg\"), [])\n    return <mesh\n        material={new MeshBasicMaterial({map: texture})}\n        geometry={new PlaneGeometry(1, 1)}\n    />\n}\n```\n\n```JavaScript\n// 使用 useLoader\nconst PlaneAsync = () => {\n    const [texture] = useLoader(TextureLoader, \"xxx.jpg\");\n\n    return <mesh\n        material={new MeshBasicMaterial({map: texture})}\n        geometry={new PlaneGeometry(1, 1)}\n    />\n}\n\nconst Plane = () => (\n        <Suspense fallback={<mesh />}>\n            <PlaneAsync />\n        </Suspense>\n    )\n```\n\n## 使用多个场景\n\nthree react fiber 会默认给一个场景(scene)、一个摄像头(camera)还有一个渲染器(render)。可是如果我需要多个场景，比如建模工具往往会给一个正交视图以及正视图，这种情况就需要多个场景。\n\n首先要使用`setDefaultCamera`将新建的摄像头代替默认摄像头。\n\n```TypeScript\nexport default () => {\n    const { setDefaultCamera } = useThree();\n    const camera = useRef<PerspectiveCamera>();\n\n    useLayoutEffect(() => camera.current && setDefaultCamera(camera.current), [])\n\n    return <perspectiveCamera\n      name=\"camera\"\n      ref={camera}\n    />\n}\n```\n\n接下来是创建场景，场景不需要代替原有场景，但是需要使用`useFrame`修改`render`方法。\n\n```TypeScript\n// 再原画面的左上角绘制场景\nexport default () => {\n    const scene = useRef<Scene>();\n    const {\n        size: {left, top, width, height},\n        camera,\n    } = useThree();\n\n    useFrame(({ gl }) => {\n        gl.autoClear = true;\n        gl.setScissor(left, top, width / 2, height / 2);\n        gl.setViewport(left, top, width / 2, height / 2);\n\n        scene.current && gl.render(scene, camera)\n    }, 10);\n\n    return (\n        <scene ref={scene}>\n            <mesh />\n        </scene>\n    );\n}\n```\n\n这里`useFrame`的第二个参数表示它的优先级，值越高，越先渲染，这意味着比它优先级低的场景渲染之前要把`gl.autoClear`设置为`false`，以避免被清除。\n\n## 其它\n\n另外可以看看京东的一篇博客[凹凸实验室](https://aotu.io/notes/2018/10/18/cannonjs/index.html)。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["threejs","JavaScript","webGL"],"series":{"slug":"threejs-howto","name":"细品threejs"}}},{"id":"2020/04/27/threejs.md","slug":"2020/04/27/threejs","body":"\n# threejs 细化-在网格上渲染，停止渲染，使用物理引擎\n\n这是细化了解 threejs 的第二篇，[第一篇](/fe/2020/04/21/threejs细化-创建一个mesh、使用加载器、多个场景.html)\n\n## 在网格上渲染\n\n这里有一点类似于使用多个场景，设想如果想要做一个类似于水晶球的设计，水晶球有一个 scene1，水晶球自己又在另一个 scene0 里面，这里就需要使用 renderTarget 渲染 scene1 到水晶球上面。\n\n先创建一个 target。\n\n```typescript\nconst target = new WebGLRenderTarget(width, height);\n```\n\n再创建一个球，并使用 target 作为材料。\n\n```tsx\nconst ball = () => {\n  return (\n    <mesh name=\"ball\">\n      <sphereBufferGeometry attach=\"geometry\" args={[1, 32, 16]} />\n      <meshPhongMaterial attach=\"material\" map={target.texture} />\n    </mesh>\n  );\n};\n```\n\n然后创建 scene1。\n\n```ts\nconst scene1 = new Scene();\nconst camera = new PerspectiveCamera(75, 1, 0.1, 5, position: [0, 1, 2]);\n\n{\n  const light = new HemisphereLight();\n  scene1.add(light);\n}\n\n{\n  const mesh = new Mesh(\n    new BoxBufferGeometry(1, 1, 1),\n    new MeshPhongMaterial({ color: 0x8844aa }),\n  );\n  scene1.add(mesh);\n}\n```\n\n貌似 react-three-fiber 的 render 函数也可以把 JSX 渲染成 scene。但是使用的时候告诉我需要创建 context，难道是要用 React.createContext? 感觉坑很多，所以暂时没有尝试，以后再补充这里。\n\n```tsx\nconst scene = new Scene();\nconst context = createContext();\n\nrender(\n  <>\n    <perspectiveCamera />\n    <hemishpereLight />\n    <mesh>\n      <boxBufferGeometry args={[1, 1, 1]} attach=\"geometry\" />\n      <meshPhongMaterial color={0x8844aa} attach=\"material\" />\n    </mesh>\n  </>,\n  scene,\n  context\n);\n```\n\n好了，回到正题，现在需要在 target 上面渲染 scene1.\n\n```ts\nuseFrame(({ gl }) => {\n  gl.setRenderTarget(target);\n  gl.render(scene1, camera); // 这里的camera是scene1里面的camera\n  gl.setRenderTarget(null);\n});\n```\n\n和渲染两个 scene 一样，不管打算渲染几个场景，实际的渲染器只有一个，所以渲染好 target 后还要把要渲染的目标换回来。\n\n## 停止渲染\n\nreact-three-fiber 默认会一直渲染每一帧，而在网页上，我们往往不需要它一直耗费 GPU 时间，比如渲染好的动画，只需要它在特殊时间才运动，react-three-fiber 有一个 invalidateFrameloop 选项可以暂停渲染。\n\n```tsx\n<Canvas invalidateFrameloop />\n```\n\n另外`useThree().invalidate`也可以暂停渲染，但这个不太稳定，不确定是不是我的问题。\n\n比如加载进来一个模型，想让它动画结束后就停止 GPU 渲染。\n\n```tsx\nconst animate = useMemo(() => new AnimationMixer(obj));\nconst action = useMemo(() => {\n  const act = animate.clipAction(obj.animations[0]);\n  act.setLoop(LoopOnce, 1);\n  act.enabled = true;\n  act.clampedWhenFinished = true;\n  act.play();\n  return act;\n}, []);\n\nconst { invalidate } = useThree();\n\nuseFrame((_, delta) => {\n  animate.update(delta);\n  if (!act.isRunning()) {\n    invalidate();\n  }\n});\n```\n\n## 使用物理引擎\n\n物理引擎是使用 webGL 最爽的部分，主要是不用考虑那些公式，这里用`Cannon.js`打个比方，（感动常在）。\n\n首先创建世界，比如创建一个 z 轴加速度为 9.82 的世界，还需要 NaiveBroadphase 做碰撞检测。\n\n```ts\nconst world = new World();\nworld.gravity.set(0, 0, -9.82);\nworld.broadphase = new NaiveBroadphase();\n```\n\n接下来创建一个物体，包括它的形状（shape）和在世界中的细节参数（body）。\n\n```ts\nconst shape = new Sphere(1);\nconst body = new Body({ mass: 5, shape });\nworld.add(body);\n```\n\n接下来设置渲染的时间间隔。\n\n```ts\nuseFrame(() => world.step(1 / 60)); // 单位秒\n```\n\n好了，那么怎么和 react-three-fiber 玩耍呢？其实可以写一个[useCannon](https://github.com/gongbaodd/webgl_demos/blob/dev/hooks/useCannon.tsx)。\n\n但是考虑到有现成的 hooks，自己就不用写轮子了，[react-spring/use-cannon](https://github.com/react-spring/use-cannon)，他是用 web worker 跑的，性能肯定更好，直接看例子好了，白嫖真爽。\n\n```jsx\nimport { Canvas } from \"react-three-fiber\";\nimport { Physics, usePlane, useBox } from \"use-cannon\";\n\nfunction Plane(props) {\n  const [ref] = usePlane(() => ({ rotation: [-Math.PI / 2, 0, 0], ...props }));\n  return (\n    <mesh ref={ref}>\n      <planeBufferGeometry attach=\"geometry\" args={[100, 100]} />\n    </mesh>\n  );\n}\n\nfunction Cube(props) {\n  const [ref] = useBox(() => ({ mass: 1, position: [0, 5, 0], ...props }));\n  return (\n    <mesh ref={ref}>\n      <boxBufferGeometry attach=\"geometry\" />\n    </mesh>\n  );\n}\n\nReactDOM.render(\n  <Canvas>\n    <Physics>\n      <Plane />\n      <Cube />\n    </Physics>\n  </Canvas>,\n  document.getElementById(\"root\")\n);\n```\n","collection":"blog","data":{"type":"post","category":"fe","tag":["threejs","webgl"],"series":{"slug":"threejs-howto","name":"细品threejs"}}},{"id":"2020/05/04/RN-Flutter-Dart.md","slug":"2020/05/04/rn-flutter-dart","body":"\n# 从 RN 到 Flutter-从 Dart 开始\n\n这是一篇翻译，原文来自于[官方文档](https://flutter.dev/docs/get-started/flutter-for/react-native-devs)，当然，里面夹带私货，哈哈。\n\n## 从 JavaScript 到 Dart\n\n就像 React Native，Flutter 也是用响应式界面。但是 React Native 是链接原生环境，而 flutter 则是直接编译到原生环境中。Flutter 可以控制屏幕上面的每一个像素，可以避免 JavaScript 和原生环境桥的性能问题。\n\nDart 是一个简单的语言，并提供以下功能。\n\n- 提供一个开源可伸缩的开发环境并提供给网页端、服务器端、移动端使用。\n- 提供单继承面向对象的 C 语法支持，并支持 AOT 编译至原生环境。\n- 可翻译到 JavaScript\n- 支持接口和虚基类的数据结构\n\n以下是几处 JavaScript 和 Dart 的不同之处。\n\n### 入口\n\nJavaScript 没有与设定的入口函数。\n\n```js\nfunction startHere() {\n  // 可以用来做入口函数\n}\n```\n\nDart 有一个顶级`main()`函数作为入口函数使用。\n\n```Dart\nmain() {}\n```\n\n在 [DartPad](https://dartpad.dev/0df636e00f348bdec2bc1c8ebc7daeb1) 上使用。\n\n### 打印日志\n\n在 Dart 中打印日志需要使用`print()`函数。\n\n```js\nconsole.log(\"Hello JavaScript!\");\n```\n\n```Dart\nprint(\"Hello Dart!\");\n```\n\n在 [DartPad](https://dartpad.dev/cf9e652f77636224d3e37d96dcf238e5) 试用。\n\n### 变量\n\nDart 是类型安全的——它结合静态类型检查和动态类型检查确保变量总是符合它的静态类型。即使类型是强制的，但类型标识并不是必须的，因为 Dart 会预判类型。\n\n#### 声明变量并赋值\n\n在 JavaScript 中，变量是无类型的（这是原文说的，不是我说的，我不是很同意）。\n\n```js\nvar name = \"JavaScript\";\n```\n\n在 Dart 中，变量必须声明类型，或者让系统能够预判类型。\n\n```Dart\nString name = \"Dart\";\nvar otherName = \"Dart\";\n```\n\n在 [DartPad](https://dartpad.dev/3f4625c16e05eec396d6046883739612) 中试用。\n\n点[这里](https://dart.dev/guides/language/sound-dart)了解 Dart 的类型系统。\n\n#### 默认值\n\n在 Javascript 中，未初始化的变量是`undefined`（他可能指的是函数作用域变量）。\n\n```js\nvar name; // undefined\n```\n\n在 Dart 中，未初始化的变量值为`null`。因为 Dart 中的类型都是对象，所以即使定义了类型但没有赋值它的默认值依然是 null。\n\n```dart\nvar name; // null\nint x; // null\n```\n\n在 [DartPad](https://dartpad.dev/57ec21faa8b6fe2326ffd74e9781a2c7) 使用。\n\n更多关于 [Dart 变量](https://dart.dev/guides/language/language-tour#variables) 的信息。\n\n#### 空值检查和零值检查\n\n在 JavaScript 中非空对象被认为是真值。\n\n```JavaScript\nvar myNull = null;\nif (!myNull) {\n  console.log(\"null是假值\");\n}\nvar zero = 0;\nif (!zero) {\n  console.log(\"0是假值\");\n}\n```\n\nDart 中，只有布尔真值是真值。\n\n```Dart\nvar myNull = null;\nif (myNull == null) {\n  print(\"使用 == null 做空值检查\");\n}\nvar zero = 0;\nif (zero == 0) {\n  print(\"使用 == 0 做零值检查\");\n}\n```\n\n在 [DartPad](https://dart.dev/guides/language/language-tour#variables) 上使用。\n\n#### 函数\n\n两个语言的函数基本上相同。\n\n```JavaScript\nfunction fn() {\n  return true;\n}\n```\n\n不同点是他们的声明。\n\n```dart\n{\n  fn() {\n    return true;\n  }\n}\n\n{// 也能这么写\n  bool fn() {\n    return true;\n  }\n}\n```\n\n在 [DartPad](https://dartpad.dev/5454e8bfadf3000179d19b9bc6be9918) 上使用，点[这里](https://dart.dev/guides/language/language-tour#functions)查看函数细节。\n\n#### 异步开发\n\n##### Futures\n\n和 Javascript 一样，Dart 支持单线程执行。JavaScript 使用 promise 对象处理异步的成功以及失败状态，并获取它的值。\n\n```js\nconst getIp = () =>\n  fetch(\"https://httpbin.org/ip\")\n    .then((res) => res.json())\n    .then(({ origin: { ip } }) => ip);\n\ngetIp()\n  .then((ip) => console.log(ip))\n  .catch((errpr) => console.error(error));\n```\n\n而在 Dart 中，使用 [Future](https://dart.dev/tutorials/language/futures) 对象处理异步。\n\n```Dart\nimport \"dart:convert\";\nimport \"package:http/http.dart\" as http;\n\nFuture<string> getIp() {\n  return http.get(\"https://httpbin.org/ip\")\n    .then((res) {\n      String ip = jsonDecode(res.body)[\"origin\"];\n      return ip;\n    });\n}\n\nmain() {\n  getIp()\n    .then(ip => print(ip))\n    .catchError((error) ==> print(error));\n}\n```\n\n点击[这里](https://dart.dev/tutorials/language/futures)了解 Future 对象。\n\n##### `async` 和 `await`\n\n使用 `async` 标识符声明异步函数。\n\n在 JavaScript 中，`async`函数返回一个`Promise`对象，并使用`await`处理它。\n\n```js\nasync function getIp() {\n  const res = await fetch(\"http://httpbin/ip\");\n  const { origin } = await res.json();\n  return origin;\n}\n\nasync function main() {\n  try {\n    const ip = await getIp();\n    console.log(ip);\n  } catch (e) {\n    console.log(e);\n  }\n}\n```\n\n在 Dart 中，`async`函数返回`Future`类型，函数体会被安排运行，`await`运算符被用来获取`Future`的返回值。\n\n```dart\nimport \"package:http/http.dart\" as http;\nimport \"dart:convert\"\n\nFuture<string> getIp() {\n  final res = await http.get(\"http://httpbin.org/ip\");\n  String ip = jsonDecode(res.body)['origin'];\n  return ip;\n}\n\nmain() async {\n  try {\n    final ip = await getIp();\n    print(ip);\n  } catch(e) {\n    print(e);\n  }\n}\n```\n\n了解更多[async 和 await](https://dart.dev/guides/language/language-tour#asynchrony-support)的信息。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["react-native","flutter","dart"],"series":{"slug":"Flutter-for-RN-devs","name":"从RN到Flutter","number":1}}},{"id":"2020/05/05/RN-Flutter.md","slug":"2020/05/05/rn-flutter","body":"\n# 从 RN 到 Flutter-简单说说\n\n## 如何创建一个 Flutter 应用\n\n创建一个 React Native，可以在终端中使用`create-react-native-typescript-app`，或者`expo-cli`。\n\n```shell\ncreate-react-native-typescript-app <projectname>\n```\n\n使用 Flutter 创建应用，可以采用以下两种方式。\n\n- 使用 IDE 中的 Flutter 和 Dart 插件。\n- 使用`flutter create`命令，请确保 Flutter SDK 已经在 PATH 中，[Windows 用户可以参考此文](/fe/2020/02/21/Windows安装flutter开发环境.html)。\n\n```shell\nflutter create <projectname>\n```\n\n更多内容，可以参考[快速入门](https://flutter.dev/docs/get-started)，入门是一个创建单按钮的计数项目，并能够部署在 Android 和 iOS 设备中的示例应用。\n\n## 如何运行应用\n\n在 React Native 中，你可以使用`npm run`或者`yarn run`。\n\n在 Flutter 中，可以参考如下方式：\n\n- 使用 IDE 中的\"run\"选项。\n- 在项目根目录执行 `flutter run`。\n\n你的应用会在连接好的设备上执行。\n\n更多信息，请参考 Flutter 的[快速入门](https://flutter.dev/docs/get-started)。\n\n## 如何引入部件\n\n在 React Native 中，你需要引入组件。\n\n```JavaScript\nimport React from \"react\";\nimport { StyleSheet, Text, View } from \"react-native\";\n```\n\n在 Flutter 中，需要引入`material.dart`包来使用 Material Design 库中的部件。要使用 iOS 样式的部件则需要引入 Cupertino 库。想使用更多基础部件，需要引入他们的库，或者你也可以自己写一个部件库，并引入。\n\n```Dart\nimport \"package:flutter/material.dart\";\nimport \"package:flutter/cupertino.dart\";\nimport \"package:flutter/widgets.dart\";\nimport \"package:flutter/my_widgets.dart\";\n```\n\n无论你引入了什么包，Dart 只会使用你在应用中使用的部件。\n\n## 写一个和 React Native 中一样的 Hello World 应用\n\n在 React Native 中，`HelloWorldApp`是`React.Component`的一个实现，并返回如下 view 组件实现。\n\n```tsx\nimport React, { FC } from \"react\";\nimport { StyleSheet, Text, View } from \"react-native\";\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: \"#fff\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n});\n\nconst App: FC = () => (\n  <View style={styles.container}>\n    <Text>Hello world!</Text>\n  </View>\n);\n\nexport default App;\n```\n\n在 Flutter 中，创建一个 Hello World 应用需要使用`Center`和`Text`核心部件，`Center`部件在部件树的根部件，并拥有唯一子部件`Text`。\n\n```Dart\nimport \"package:flutter/material.dart\";\n\nmain() {\n  runApp(\n    Center(\n      child: Text(\n        \"Hello World!\",\n        textDirection: TextDirection.ltr,\n      )\n    )\n  );\n}\n```\n\n（卧槽，写 Hello World 还挺简短的，怕不是错觉...）\n\n| Android                                                                                                                                                                | iOS                                                                                                                                                            |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| ![Android展示样式](https://flutter.dev/assets/get-started/android/react-native/hello-world-basic-ed1ed2698fc492892552a8d719b0e124b7a50e2f8e0327f1548e2834b0aa515a.png) | ![iOS展示样式](https://flutter.dev/assets/get-started/ios/react-native/hello-world-basic-1ba3dfcb9fcbee11f5307cde947ab29dd4f52683f311b049242a28fefb37412b.png) |\n\n这就是 Flutter 中最基础的应用，下一个部分将会利用 Flutter 丰富的组件库创建现代应用。\n\n## 如何使用在部件树中增加部件\n\n在 Flutter 中，几乎一切都是部件。\n\n部件是创建用户界面的基础块。部件组成的层级结构叫做部件树。每个部件接入它的父部件，并继承它们的属性。即使应用对象本身也是个部件。并没有分离的\"application\"对象，根部件就是它。\n\n一个部件可以定义如下内容：\n\n- 一个有结构的元素 —— 如一个按钮或菜单。\n- 一个样式元素 —— 如字体或者颜色方案。\n- 一个布局或视角 —— 如边距或者对齐。\n\n如下的例子使用 Material Design 创建部件，在此例子中，部件树链接在`MaterialApp`跟部件下。\n\n```Dart\nimport \"package:flutter/material.dart\";\n\nWidget MyApp() {\n  return MaterialApp(\n    title: \"Welcome to Flutter\",\n    home: Scaffold(\n      appBar: AppBar(\n        title: Text(\"Welcome to Flutter\"),\n      ),\n      body: Center(\n        child: Text(\"Hello world\"),\n      ),\n    ),\n  );\n}\n\nmain() => runApp(MyApp());\n```\n\n如下是使用 Material Design 部件创建的 “Hello world!” 应用。\n\n| Android                                                                                                                                                                             | iOS                                                                                                                                                                          |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| ![Adroid Material Design Hello World](https://flutter.dev/assets/get-started/android/react-native/hello-world-198f4b19ca6d3dd72f6a17dd858814cc42cf2bc696f61d7f273be95818110777.png) | ![iOS Material Design Hello World](https://flutter.dev/assets/get-started/ios/react-native/hello-world-ed7cf47213953bfca5eaa74fba63a78538d782f2c63a7c575068f3c2f7298bde.png) |\n\n写应用的时候，会使用到两种部件`StatelessWidget`和`StatefulWidget`（上面我写的就是`StatelessWidget`不过没有按照面向对象的写法去写）。一个`StatelessWidget`是一个没有状态的部件，它一旦被创建就不会改变。一个`StatefulWidget`会基于数据变化或者用户输入动态改变。\n\n`StatelessWidget`和`StatefulWidget`二者的最大不同点，就是`StatefulWidget`拥有一个`State`对象来存储数据，以避免在部件树渲染的时候丢失。\n\n在简单的项目中，写部件树是容易的，但是当代码变多之后，应用会越来越复杂，你应该将很深的部件封装成函数或者简单的类。创建封装好的函数和类有利于在复杂项目中实现复用。\n\n## 如何创建可复用的组件\n\n在 React Native 中，创建一个可复用的组件，并使用`props`向它传入属性和值。在如下的例子中，`CustomCard`就是个可复用组件。\n\n```tsx\nconst CustomCard: FC<{ index?: number; onPress?: () => void }> = ({\n  index,\n  onPress,\n}) => (\n  <View>\n    <Text>Card {index}</Text>\n    <Button title=\"Press\" onPress={() => onPress()} />\n  </View>\n);\n\n// Usage\n<CustomCard onPress={() => console.log(1)} index={1} />;\n```\n\n在 Flutter 中，可以通过创建一个后浪于（怎么样，这说法阳春不？）部件的类，并实现它的`build`函数，你也可以创建一个函数并复用它。\n\n```dart\nWidget CustomCard({int index, Function onPress}) {\n  return Card(\n    child: Column(\n      children: <Widget>[\n        Text('Card $index'),\n        FlatButton(\n          child: const Text('Press'),\n          onPress: onPress,\n        ),\n      ],\n    ),\n  );\n}\n\n// Usage\nCustomCard(index = 1, onPress = () { print('Card 1'); })\n```\n\n以上`CustomCard`参数的大括号是 Dart[可选参数](https://dart.dev/guides/language/language-tour#optional-parameters)。\n\n在类的构造函数中，可以使用`@required`实现必要参数。\n\n如下截图是`CustomCard`的展示效果。\n\n| Android                                                                                                                                                              | iOS                                                                                                                                                          |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| ![Android CustomCard](https://flutter.dev/assets/get-started/android/react-native/custom-cards-6bdba4664044a9e5328c0304a51c45fc2812bb37b3d0d57b0c93b98d5bab1f42.png) | ![iOS CustomCard](https://flutter.dev/assets/get-started/ios/react-native/custom-cards-47e3e1e3e73a0ce419eacbee11dc2f15b9acac9b5877c43cd1a783a792b519dc.png) |\n","collection":"blog","data":{"type":"post","category":"fe","tag":["react-native","flutter","dart"],"series":{"slug":"Flutter-for-RN-devs","name":"从RN到Flutter","number":2}}},{"id":"2020/05/06/RN-Flutter.md","slug":"2020/05/06/rn-flutter","body":"\n# 从 RN 到 Flutter-部件\n\n在 Flutter 中，你应该使用部件去描述针对于现有状态和配置的界面。\n\n部件是由许多很小或者单一目的的部件组成。比如`Container`部件就包括几个相关布局、绘制、定位和定型组件，像是`LimitedBox`、`ConstrainedBox`、`Align`、`Padding`、`DecoratedBox`以及`Transform`部件。除了使用`Container`来实现效果，你也可以用几个组件来实现它。\n\n`Center`部件是另一个控制布局的例子。想要剧中部件，就用`Center`包住它。这些部件没有自己的展示，他们的目标就是控制内部部件的布局。想要理解部件是如何渲染，可以去查看他们的相邻部件。\n\n了解更多信息，可以查看[Flutter 技术概览](https://flutter.dev/docs/resources/technical-overview)。\n\n想要了解更多部件信息，可以查看[Flutter 基础部件](https://flutter.dev/docs/development/ui/widgets/basics)，[Flutter 部件目录](https://flutter.dev/docs/development/ui/widgets) 或者 [Flutter 部件索引](https://flutter.dev/docs/reference/widgets)。\n\n## 界面\n\n### Flutter 中的 `View` 组件\n\n在 React Native 中，`View`是支持`Flexbox`布局、样式处理、触摸处理和无障碍化的组件。\n\n在 Flutter 中，你可以使用诸如`Container`、`Column Row`和`Center`的核心布局部件。更多信息可以参考[布局部件](https://flutter.dev/docs/development/ui/widgets/layout)目录。\n\n### Flutter 中的 `FlatList` 和 `SectionList` 组件\n\n一个`List`是垂直排布的可滚动列表。\n\n在 React Native 中，`FlatList`和`SectionList`可以用来渲染简单的或者复杂内容的列表。\n\n```tsx\n<FlatList data={[]} renderItem={({ item }) => <Text>{item.key}</Text>} />\n```\n\n`ListView`是 Flutter 中最常被使用的滚动部件。默认的构造器接受一列准确定义的数据。`ListView`适合少量个数部件渲染。对于无限滚动，需要使用`ListView.builder`，它会按需渲染，并之渲染能展示出来的数据。\n\n```dart\nvar data = [];\nListView.builder(\n    itemCount: data.length,\n    itemBuilder: (context, int index) {\n        return Text(data[index]);\n    },\n);\n```\n\n| Adroid ListVIew                                                                                                                                                | iOS ListView                                                                                                                                           |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| ![Android ListView](https://flutter.dev/assets/get-started/android/react-native/flatlist-91d7c8beaadff16f52d663e94aae7b4c9959d1d811dd7f12ea2005a10e166d34.gif) | ![iOS ListView](https://flutter.dev/assets/get-started/ios/react-native/flatlist-2a18c0173248dd8bf250b29fab7e4cdbc917c27d90ac33c1c791ecb73463f3a5.gif) |\n\n阅读[你的第一个 Flutter 应用，第一部分](https://codelabs.developers.google.com/codelabs/first-flutter-app-pt1)更多了解如何实现无限滚动。\n\n### 如何使用画布\n\n在 React Native 中是没有相关组件的，需要引入类似于`react-native-canvas`的第三方组件。\n\n```tsx\nconst App = () => {\n  return (\n    <View>\n      <Canvas\n        ref={(canvas) => {\n          const ctx = canvas.getContext(\"2d\");\n          ctx.fillStyle = \"skyblue\";\n          ctx.beginPath();\n          ctx.arc(75, 75, 50, 0, 2 * Math.PI);\n          ctx.fillRect(150, 100, 300, 300);\n          ctx.stroke();\n        }}\n      />\n    </View>\n  );\n};\n```\n\n在 Flutter 中，你可以使用`CustomPaint`和`CustomPainter`类去绘制画布。\n\n下面的例子展示的是如何使用`CustomPaint`部件绘制。它实现了虚类 `CustomPainter`，并传递了 `CustomPaint` 的属性。`CustomPaint` 的子类必须实现 `paint()` 和 `shouldRepaint()` 方法。\n\n```dart\nclass MyCanvasPainter extends CustomPainter {\n    paint(Canvas anvas, Size size) {\n        {\n            Paint paint = Paint();\n            paint.color = Colors.amber;\n            canvas.drawCircle(Offset(100.0, 200.0), 40.0, paint);\n        }\n        {\n            Paint paint = Paint();\n            paint.color = Colors.lightBlue;\n            Rect rect = Rect.fromPoints(Offset(150.0, 300.0), Offset(300.0, 400.0));\n            canvas.drawRect(rect, paintRect);\n        }\n    }\n    shouldRepaint() => false;\n}\n\nWidget getCanvas() {\n    return Scaffold(\n        body: CustomPaint(\n            paint: MyCanvasPainter(),\n        ),\n    );\n}\n```\n\n| Android CustomPaint                                                                                                                                             | iOS CustomPaint                                                                                                                                         |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| ![Android CustomPaint](https://flutter.dev/assets/get-started/android/react-native/canvas-cf039fc10bae17fb60b21adb4228eb928b2bf284f95fee71c5a20033c217e333.png) | ![iOS CustomPaint](https://flutter.dev/assets/get-started/ios/react-native/canvas-2cc207759f6ab912bf73e1c3298dc2183618ef207ed989f4d83f6c08fd3a3279.png) |\n\n## 布局\n\n### 如何使用布局部件\n\n在 React Native，许多布局可以通过 props 传入。比如，你可以使用`View`的`style`属性去指定 flexbox 布局。想要让组件成列排列，可以指定样式为`flexDirection: \"column\"`。\n\n```JavaScript\n<View\n    style={{\n        flex: 1,\n        flexDirection: \"column\",\n        justifyContent: \"space-between\",\n        alignItems: \"center\"\n    }}\n/>\n```\n\n在 Flutter 中，布局主要是由既定的布局部件和他们的参数实现。\n\n举个例子，`Column`和`Row`组件接受一个数组作为参数来以列或者以行排列。一个`Container`部件既能处理样式也能处理布局，一个`Center`部件可以将组件居中。\n\n```Dart\nCenter(\n    child: Column(\n        children: <Widget> [\n            Container(\n                color: Colors.red,\n                width: 100.0,\n                height: 100.0,\n            ),\n            Container(\n                color: Colors.blue,\n                width: 100.0,\n                height: 100.0\n            ),\n            Container(\n                color: Colors.green,\n                width: 100.0,\n                height: 100.0,\n            ),\n        ],\n    ),\n)\n```\n\nFlutter 提供一堆布局部件，比方说，`Padding`、`Align`和`Stack`。\n\n了解全部的布局部件，可以查看[布局部件](https://flutter.dev/docs/development/ui/widgets/layout)。\n\n| Adroid Layout                                                                                                                                                    | iOS Layout                                                                                                                                               |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| ![Adroid Layout ](https://flutter.dev/assets/get-started/android/react-native/basic-layout-2490ba3bed87bbf579b422977dcaa34f51a5b77dab53abbd460028acda33a000.gif) | ![iOS Layout](https://flutter.dev/assets/get-started/ios/react-native/basic-layout-bb720a0054daf418b7bafb40619c490933b730f9e45bd9003254ea9d80d6c163.gif) |\n\n### 如何堆叠部件\n\n在 React Native，可以使用绝对定位`absolute`来堆叠组件。\n\nFlutter 使用`Stack`部件让部件按照图层分布。部件会部分覆盖于下面的部件。\n\n```dart\nStack(\n    alignment: cont Alignment(0.6, 0.6),\n    children: <Widget>[\n        CircleAvatar(\n            backgroundImage: NetworkImage(\n                'https://avatars3.githubusercontent.com/u/14101776?v=4'\n            )\n        ),\n        Container(\n            decoration: BoxDecoration(\n                color: Colors.black45,\n            ),\n            child: Text(\"Flutter\"),\n        ),\n    ],\n)\n```\n\n上面的例子使用`Stack`来布局一个`Container`并展示一个拥有黑色半透明背景的`Text`部件覆盖于`CircleAvatar`部件。这个部件通过对齐参数来规定文字位置。\n\n| Android Stack                                                                                                                                            | iOS Stack                                                                                                                                        |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------ |\n| ![Android Stack](https://flutter.dev/assets/get-started/android/react-native/stack-65e0c9e7fc3db73d80d3943f6e88fc788819b1ab4c1354c11e4711298e26ecd0.png) | ![iOS Stack](https://flutter.dev/assets/get-started/ios/react-native/stack-04b7bf2727e1eb71f5dfea8430ee833f24be1ced1893ae86270795b2ab76c5b9.png) |\n\n更多信息可以查看`Stack`对象[文档](https://api.flutter.dev/flutter/widgets/Stack-class.html)。\n\n## 样式\n\n### 如何处理组件样式\n\n在 React Native 中，内联样式和`stylesheets.create`是用来处理组件样式的。\n\n```tsx\nconst style = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: \"#fff\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n});\n\n<View style={styles.container}>\n  <Text style={{ fontSize: 32, color: \"cyan\", fontWeight: \"600\" }}>\n    This is a simple text\n  </Text>\n</View>;\n```\n\n在 Flutter 中，`Text`部件可以使用`TextStyle`类，这个类的对象也可以给多个部件复用。\n\n```dart\nvar textStyle = TextStyle(\n    fontSize: 32.0,\n    color: Colors.cyan,\n    fontWeight: FontWeight.w600,\n);\n\nCenter(\n    child: Column(\n        children: <Widget>[\n            Text(\n                'sample text',\n                style: textStyle,\n            ),\n            Padding(\n                padding: EdgeInsets.all(20.0),\n                child: Icon(\n                    Icons.lightbulb_outline,\n                    size: 48.0,\n                    color: Colors.redAccent,\n                ),\n            ),\n        ],\n    ),\n)\n```\n\n| Android Style                                                                                                                                                     | iOS Style                                                                                                                                                 |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| ![Android Style](https://flutter.dev/assets/get-started/android/react-native/flutterstyling-10cfb607a02859b2a1e9767237029b3cc47891fd017bd70d84536de26383b39c.gif) | ![iOS Style](https://flutter.dev/assets/get-started/ios/react-native/flutterstyling-8b812e5226435b0db6f72b4f2f03a7c72b45bf0794965a0bee882fea909fc7b8.gif) |\n\n### 如何使用图标和颜色\n\nReact Native 没有支持图标的库（这点我不是很同意）。\n\n在 Flutter 中，引入 Material 库包含一堆[Material 图标](https://api.flutter.dev/flutter/material/Icons-class.html)和[颜色](https://api.flutter.dev/flutter/material/Colors-class.html)。\n\n```dart\nIcon(Icons.lightbulb_outline, color: COlors.redAccent)\n```\n\n使用`Icons`类时，记住要把`uses-material-design: true`设置在`pubspec.yaml`中。这保证`MaterialIcons`字体会被包括在应用中。\n\n```yaml\nname: my_awesome_application\nflutter:\n  uses-material-design: true\n```\n\nFlutter 的[Cupertino](https://flutter.dev/docs/development/ui/widgets/cupertino)包，完全遵守 iOS 设计语言。要使用`CupertinoIcons`字体，在项目中增加`cupertino_icons`依赖。\n\n```yaml\nname: my_awesome_application\ndependencies:\n  cupertino_icons: ^0.1.0\n```\n\n要完全的自定义组件的色彩和样式，使用`ThemeData`来定义主题。设置`MaterialApp`的`ThemeData`对象。`Colors`类提供遵守 Material 设计语言的调色盘。\n\n```dart\nWidget build() {\n    return MaterialApp(\n        title: \"Sample App\",\n        theme: ThemeData(\n            primarySwatch: Colors.blue,\n            textSelectionColor: Colors.red,\n        ),\n        home: SampleAppPage()\n    );\n}\n```\n\n### 如何增加主题样式\n\n在 Ract Native，主题是组件定义好的。\n\n在 Flutter 中，使用`ThemeData`类为整个`MaterialApp`部件提供主题。\n\n```dart\nWidget build() {\n    return MaterialApp(\n        title: \"Sample App\",\n        theme: ThemeData(\n            primarySwatch: Colors.blue,\n            textSelectionColor: Colors.red,\n        ),\n        home: SampleAppPage()\n    );\n}\n```\n\n一个`Theme`甚至可以不依赖于`MaterialApp`部件。[Theme](https://api.flutter.dev/flutter/material/Theme-class.html)部件需要一个`ThemeData`传入它的`data`参数中，以适配它的所有子部件。\n\n```dart\nclass SampleTheme extends StatelessWidget {\n    Widget build(BuildContext context) {\n      return Theme(\n           data: ThemeData(\n               primaryColor: Colors.cyan,\n               brightness: brightness,\n           ),\n           child: Scaffold(\n               backgroundColor: Theme.of(context).primaryColor,\n           )\n       )\n    }\n}\n```\n","collection":"blog","data":{"type":"post","category":"fe","tag":["react-native","flutter","dart"],"series":{"slug":"Flutter-for-RN-devs","name":"从RN到Flutter","number":4}}},{"id":"2020/05/07/RN-Flutter.md","slug":"2020/05/07/rn-flutter","body":"\n# 从 RN 到 Flutter-路由器\n\n> 我要死了，这个系列怎么这么长。\n\n许多应用都有多个页面来展示不同信息。比方说，你可能在页面展示一个产品的图片，当用户点击时打开这个产品的详情。\n\n在 Android，新的页面叫做 Activities。在 iOS 新的页面叫 ViewControllers，在 Flutter，新的页面也是部件！包括导航至这些页面的导航器也是导航器部件。\n\n## 如何在页面中导航\n\n在 React Native 里面，有三个导航器`StackNavigator`，`TabNavigator`和`DrawerNavigator`。都提供了配置的接口。\n\n```js\n// React Native\nconst MyApp = TabNavigator(\n  { Home: { screen: HomeScreen }, Notifications: { screen: tabNavScreen } },\n  { tabBarOptions: { activeTintColor: \"#e91e63\" } }\n);\nconst SimpleApp = StackNavigator({\n  Home: { screen: MyApp },\n  stackScreen: { screen: StackScreen },\n});\nexport default MyApp1 = DrawerNavigator({\n  Home: {\n    screen: SimpleApp,\n  },\n  Screen2: {\n    screen: drawerScreen,\n  },\n});\n```\n\n在 Flutter 中，有两个部件用于处理页面路由。\n\n- `Route` 是页面的抽象。\n- `Navigator` 是管理路由的部件。\n\n`Navigator`通过将一列页面以堆的方式覆盖，并提供方法管理这个堆，像是[Navigator.push](https://api.flutter.dev/flutter/widgets/Navigator/push.html)和[Navigator.pop](https://api.flutter.dev/flutter/widgets/Navigator/pop.html)。[MaterialApp](https://api.flutter.dev/flutter/material/MaterialApp-class.html) 部件提供 routes 参数接受这些路由，这些路由可能会明确指出或者动态生成，比如标题动画。下面是一个指明路由的例子。\n\n```dart\nclass App extends StatelessWidget{\n    Widget build(BuildContext: context) {\n        return MaterialApp(\n           routes: <String, WidgetBuilder> {\n                '/a': (BuildContext: context) => usualNavscreen(),\n                '/b': (BuildContext: context) => drawerNavscreen(),\n          },\n       ),\n    }\n}\n```\n\n使用`Navigator.of()`并指定一个`BuildContext`来处理导航，比如前往某个特定页面，可以使用`pushNamed`。\n\n```dart\nNavigator.of(context).pushNamed('/a');\n```\n\n你可以使用`push`方法调用已存在的[Route](https://api.flutter.dev/flutter/widgets/Route-class.html)，这样会动画打开 Route。下面的例子中[MaterialPageRoute](https://api.flutter.dev/flutter/material/MaterialPageRoute-class.html)提供一个模态的页面，并适配系统动画。\n\n```dart\nNavigator.push(context, MaterialPageRoute(builder: (BuildContext context)\n => UsualNavscreen()));\n```\n\n## 如何使用选项卡和抽屉导航\n\n在 Material 设计语言中，为 Flutter 提供了两种导航选项，tab 和 drawer。如果空间使用 tab 很紧张，则 drawer 是个不错的替代。\n\n### 选项卡导航\n\n在 React Native 中，`createBottomTabNavigator`和`TabNavigation`被用来处理选项卡和导航。\n\n```js\nimport { createBottomTabNavigator } from \"react-navigation\";\n\nconst MyApp = TabNavigator(\n  { Home: { screen: HomeScreen }, Notifications: { screen: tabNavScreen } },\n  { tabBarOptions: { activeTintColor: \"#e91e63\" } }\n);\n```\n\nFlutter 提供特别的部件处理抽屉和选项卡导航。\n\n- [TabController](https://api.flutter.dev/flutter/material/TabController-class.html)\n\n  提供`TabBar`和`TabBarView`的控制器\n\n- [TabBar](https://api.flutter.dev/flutter/material/TabBar-class.html)\n\n  展示横向的选项卡\n\n- [Tab](https://api.flutter.dev/flutter/material/Tab-class.html)\n\n  展示 Material 设计语言的单一选项\n\n- [TabBarView](https://api.flutter.dev/flutter/material/TabBarView-class.html)\n\n  展示选中的选项卡\n\n```dart\nTabController controller = TabController(length: 2, vsync: this);\n\nTabBar(\n    tabs: <Tab>[\n        Tab(icon: Icon(Icons.person),),\n        Tab(icon: Icon(Icons.email),),\n    ],\n    controller: controller,\n),\n```\n\n一个`TabController`用于协调`TabBar`和`TabBarView`。构造参数中的`length`属性，提供选项卡的个数。一个`TickerProvider`被用来处理框架状态变化的消息的，通过`vsync`传入。`vsync:this`参数是创建`TabController`必要的。\n\n[TickerProvider](https://api.flutter.dev/flutter/scheduler/TickerProvider-class.html)是可以产生[Ticker](https://api.flutter.dev/flutter/scheduler/Ticker-class.html)对象的类的接口。Ticker 是可以用来接收框架消息的对象，但是他们基本上都是间接通过[AnimationController](https://api.flutter.dev/flutter/animation/AnimationController-class.html)。`AnimationController`需要`TickerProvider`来获取`Ticker`对象。如果你正在从 State 里面创建一个 AnimationController，你可以使用[TickerProviderStateMixin](https://api.flutter.dev/flutter/widgets/TickerProviderStateMixin-mixin.html)或者[SingleTickerProviderStateMixin](https://api.flutter.dev/flutter/widgets/SingleTickerProviderStateMixin-mixin.html)对象以得到`TrickerProvider`。如果你用的是`flutter-hooks`你可以使用`useSingleTickerProvider`获取`Ticker`对象。\n\n[Scaffold](https://api.flutter.dev/flutter/material/Scaffold-class.html)部件封装了一个新的`TabBar`部件并创建两个选项卡。`TabBarView`部件通过`body`参数传入。所有页面的`TabBar`都是`TabBarView`部件的子部件。\n\n```dart\nclass Home extends StatefulWidget {\n  Home() : super();\n  @override\n  State<StatefulWidget> createState() {\n    return _Home();\n  }\n}\n\nclass _Home extends State<Home> with SingleTickerProviderStateMixin {\n  @override\n  Widget build(BuildContext context) {\n    TabController controller = TabController(length: 2, vsync: this);\n    return Scaffold(\n        appBar: AppBar(\n          title: Text('home'),\n        ),\n        bottomNavigationBar: Material(\n          color: Colors.blue,\n          child: TabBar(\n            controller: controller,\n            tabs: <Tab>[\n              Tab(\n                icon: Icon(Icons.person),\n              ),\n              Tab(\n                icon: Icon(Icons.email),\n              )\n            ],\n          ),\n        ),\n        body: TabBarView(\n          children: <Widget>[\n            Center(\n              child: Text('person'),\n            ),\n            Center(\n              child: Text('email'),\n            )\n          ],\n          controller: controller,\n        ));\n  }\n}\n\n```\n\n当然也可以使用`flutter-hooks`，其实如果收拾一下的话都要写两个类，就看你爱怎么写了。\n\n```dart\nclass Home extends HookWidget {\n  @override\n  Widget build(BuildContext context) {\n    final vsync = useSingleTickerProvider();\n    final controller = useMemoized(() {\n      return TabController(length: 2, vsync: vsync);\n    });\n\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Home'),\n      ),\n      bottomNavigationBar: Material(\n        color: Colors.blue,\n        child: TabBar(\n          controller: controller,\n          tabs: <Widget>[\n            Tab(icon: Icon(Icons.person)),\n            Tab(icon: Icon(Icons.email))\n          ],\n        ),\n      ),\n      body: TabBarView(\n        controller: controller,\n        children: <Widget>[\n          Center(child: Text(\"person\")),\n          Center(\n            child: Text(\"email\"),\n          )\n        ],\n      ),\n    );\n  }\n}\n\n```\n\n## 抽屉导航\n\n在 React Native 中，需要引入`react-navigation`包，并使用`createDrawerNavigator`和`DrawerNavigation`。\n\n```js\nexport default MyApp = DrawerNavigator({\n  Home: {\n    screen: SimpleApp,\n  },\n  Screen2: {\n    screen: drawScreen,\n  },\n});\n```\n\n在 Flutter 中，我们可以使用`Drawer`部件结合`Scaffold`部件创建 Material 设计语言的抽屉。想要创建一个带有抽屉的应用，需要将`Drawer`封装至`Scaffold`中。`Scaffold`部件提供一套基于[Material 设计标准](https://material.io/design)的样式结构，并且还支持许多特殊的 Material 设计组件，比如`Drawer`、`AppBar`和`SnackBar`。\n\n`Drawer`部件是一个基于 Material 设计的控制台，它在`Scaffold`水平方向的边缘，展示应用的导航链接。你可以在这个部件中使用[RaisedButton](https://api.flutter.dev/flutter/material/RaisedButton-class.html)和[Text](https://api.flutter.dev/flutter/widgets/Text-class.html)组件，或者一个列表。在下面的例子中[ListTile](https://api.flutter.dev/flutter/material/ListTile-class.html)就提供了点击导航的功能。\n\n```dart\n// Flutter\nDrawer(\n  child:ListTile(\n    leading: Icon(Icons.change_history),\n    title: Text('Screen2'),\n    onTap: () {\n      Navigator.of(context).pushNamed('/b');\n    },\n  ),\n  elevation: 20.0,\n),\n```\n\n在`Scaffold`部件的`AppBar`会自动适配给`Drawer`一个图标，并且`Scaffold`能够自动处理`Drawer`的左滑手势。\n\n```dart\n// Flutter\n@override\nWidget build(BuildContext context) {\n  return Scaffold(\n    drawer: Drawer(\n      child: ListTile(\n        leading: Icon(Icons.change_history),\n        title: Text('Screen2'),\n        onTap: () {\n          Navigator.of(context).pushNamed('/b');\n        },\n      ),\n      elevation: 20.0,\n    ),\n    appBar: AppBar(\n      title: Text('Home'),\n    ),\n    body: Container(),\n  );\n}\n```\n\n另外，如果不爽页面转场动画单一，然后自己又懒得写动画，可以直接用[page_transition](https://pub.dev/packages/page_transition)包。\n\n| Android Drawer                                                                                                                                                 | iOS Drawer                                                                                                                                             |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| ![Android Drawer](https://flutter.dev/assets/get-started/android/react-native/navigation-98906732ed22d9aa8e0ce0eb846dbcc7d24c123ad026c359f9f7fcc44ba99230.gif) | ![iOS Drawer](https://flutter.dev/assets/get-started/ios/react-native/navigation-1939f60628bec820bad0fe88d58c562984c1c00d8cfd755a4135f4321a37417e.gif) |\n","collection":"blog","data":{"type":"post","category":"fe","tag":["React-Native","flutter"],"series":{"slug":"Flutter-for-RN-devs","name":"从RN到Flutter","number":6}}},{"id":"2020/05/08/RN-Flutter.md","slug":"2020/05/08/rn-flutter","body":"\n# 从 RN 到 Flutter-动画\n\n好的动画会使 UI 更加直观，是应用更加精致，并提高用户体验。Flutter 的动画使简单动画和复杂动画的实现变得容易。Flutter SDK 所遵守的 Material 设计语言包含了标准的动态效果，你可以简单地自定义它们并应用于你的应用。\n\n在 React Native 中，Animated API 被应用于创建动画。\n\n在 Flutter 中，使用[Animation](https://api.flutter.dev/flutter/animation/Animation-class.html)类和[AnimationController](https://api.flutter.dev/flutter/animation/AnimationController-class.html)类。`Animation`是包括一个动画初始状态到它终态（完成或者取消）状态的抽象类。`AnimationController`类控制动画的执行、反转或者停止动画，乃至于设置动画为某一个值以做到自定义的目的。\n\n## 实现一个淡入动画\n\n下面的 React Native 例子是利用 Animated API 创建的`FadeInView`组件。初始状态、终止状态已经过程都需要定义。该组件包裹需要动画的组件，透明值`fadeAnim`向下继承到`Text`组件中，使得执行`start()`后，动画就开始了。\n\n```js\n// React Native\nclass FadeInView extends React.Component {\n  state = {\n    fadeAnim: new Animated.Value(0) // Initial value for opacity: 0\n  };\n  componentDidMount() {\n    Animated.timing(this.state.fadeAnim, {\n      toValue: 1,\n      duration: 10000\n    }).start();\n  }\n  render() {\n    return (\n      <Animated.View style={{...this.props.style, opacity: this.state.fadeAnim }} >\n        {this.props.children}\n      </Animated.View>\n    );\n  }\n}\n    ...\n<FadeInView>\n  <Text> Fading in </Text>\n</FadeInView>\n    ...\n```\n\n想在 Flutter 中实现相应效果，需要创建一个 [AnimationController](https://api.flutter.dev/flutter/animation/AnimationController-class.html) 对象，命名为`controller`并指明持续时间。默认`AnimationController`会在持续时间内线性执行动画。这个动画控制器在每一帧都会返回一个新值，默认是每秒 60 个值。\n\n使用`AnimationController`时，必须传入`vsync`对象。引入`vsync`的目的是避免不在屏幕上的动画浪费资源。你可以使用你的状态机作为`vsync`，只要在类定义的时候混入`TickerProviderStateMixin`。一个`AnimationController`构造时需要一个 TickerProvider 作为`vsync`参数。\n\n[Tween](https://api.flutter.dev/flutter/animation/Tween-class.html)描述初始值和结束值之间的插值。动画中使用`Tween`对象，可以将`Tween`的`animate()`返回值传给要修改的`Animation`对象。\n\n使用`controller.forward()`开始动画。其他操作如`fling()`和`repeat()`也可以开始动画。比如下面的例子，将[FlutterLogo](https://api.flutter.dev/flutter/material/FlutterLogo-class.html)部件放在`FadeTransition`部件中。\n\n```dart\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(Center(child: LogoFade()));\n}\n\nclass LogoFade extends StatefulWidget {\n  _LogoFadeState createState() => _LogoFadeState();\n}\n\nclass _LogoFadeState extends State<LogoFade> with TickerProviderStateMixin {\n  Animation animation;\n  AnimationController controller;\n\n  initState() {\n    super.initState();\n    controller = AnimationController(\n        duration: const Duration(milliseconds: 3000), vsync: this);\n    final CurvedAnimation curve =\n    CurvedAnimation(parent: controller, curve: Curves.easeIn);\n    animation = Tween(begin: 0.0, end: 1.0).animate(curve);\n    controller.forward();\n  }\n\n  Widget build(BuildContext context) {\n    return FadeTransition(\n      opacity: animation,\n      child: Container(\n        height: 300.0,\n        width: 300.0,\n        child: FlutterLogo(),\n      ),\n    );\n  }\n\n  dispose() {\n    controller.dispose();\n    super.dispose();\n  }\n}\n```\n\n也可以把动画的实现封装成 hook。\n\n```dart\nAnimation useFadeIn() {\n  final ticker = useSingleTickerProvider();\n  final controller = useMemoized(() => AnimationController(\n      duration: const Duration(milliseconds: 3000), vsync: ticker));\n  final animation = useMemoized(() => Tween(begin: 0.0, end: 1.0)\n      .animate(CurvedAnimation(parent: controller, curve: Curves.easeIn)));\n\n  useEffect(() {\n    controller.forward();\n    return () => controller.dispose();\n  });\n\n  return animation;\n}\n```\n\n| Android fadeIn                                                                                                                                                   | iOS fadeIn                                                                                                                                               |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| ![Android fadeIn](https://flutter.dev/assets/get-started/android/react-native/flutter-fade-241787290a9da1d7406516a96845a65c42c97b5a8219f4ff29f0c3412ab281ba.gif) | ![iOS fadeIn](https://flutter.dev/assets/get-started/ios/react-native/flutter-fade-2596d382757ecf7c4a2db020871d715da585db9fabed9956cbff6ef011b2786b.gif) |\n\n## 为卡片增加滑动关闭动画\n\n在 React Native 里，可以使用如`PanResponder`或者第三方库实现华东关闭。\n\n在 Flutter 中，为部件增加滑动动画可以使用[Dismissible](https://api.flutter.dev/flutter/widgets/Dismissible-class.html)部件。\n\n```dart\nchild: Dismissible(\n  key: key,\n  onDismissed: (DismissDirection dir) {\n    cards.removeLast();\n  },\n  child: Container(\n    ...\n  ),\n),\n```\n\n| Android Dismissable                                                                                                                                                 | iOS dismissable                                                                                                                                             |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| ![Android Dissmisable](https://flutter.dev/assets/get-started/android/react-native/card-swipe-20a57fe25c2e274bfbe0e9f3d4d1aebd5443fc9d2ce81bd6e9d2588e94e28b16.gif) | ![iOS Dismissible](https://flutter.dev/assets/get-started/ios/react-native/card-swipe-ed0bd70d7698b81793f2a44bea69ddf51be44ac486e8410961aabff16176e3ce.gif) |\n\n啊啊啊啊，这个系列翻译完了！！！后面还有一个 Flutter 和 React Native 组件的[对照表格](https://flutter.dev/docs/get-started/flutter-for/react-native-devs#react-native-and-flutter-widget-equivalent-components)，我就不贴上来了。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["React-Native","flutter"],"series":{"slug":"Flutter-for-RN-devs","name":"从RN到Flutter","number":8}}},{"id":"2020/05/10/Flutter.md","slug":"2020/05/10/flutter","body":"\n# Flutter 的手表应用-从入门到放弃\n\n这是一个写得一头沮丧的文章，可能是期待值比较高吧，所以任何一个想用 Flutter 写 wearOS 的朋友都要注意一点，他能写，但可能没那么好。这篇文章本来想参考[Flutter: Building Wear OS app](https://medium.com/flutter-community/flutter-building-wearos-app-fedf0f06d1b4)，因为`wear`这个包已经年久失修不支持最新的 SDK（我天，这可是 2019 年 6 月的文章），于是后来参考[Experimenting with Flutter on Wear OS](https://medium.com/@mjohnsullivan/experimenting-with-flutter-on-wear-os-f789d843f2ef)。如果不想踩坑，只是想写个应用截图发朋友圈的话，直接 clone[这个 repo](https://github.com/sbis04/flutter_os_wear)就好，热爱生命，避免折腾，哈哈。\n\n## 可以用 Flutter 来写手表应用吗\n\n答案是可以的，而且还意料之外地能用。首先要在本机安装模拟器（注意不要安装中国版，中国版真的会卡住）。然后直接运行 flutter 的官方示例就可以了。\n\n![模拟器下的Flutter示例](./2020-05-10-flutter-watch.png)\n\n## 表盘形状\n\n在 Flutter 中可以使用 MediaQuery 获取到屏幕的大小：\n\n```dart\nfinal screenSize = MediaQuery.of(content).size;\nfinal screenHeight = screenSize.height;\nfinal screenWidth = screenSize.width;\n```\n\n但是不能获取到表盘的形状，但是可以通过 kotlin 从安卓 Wear OS 的库里面获取。Flutter 为 Dart 提供了一个支持双向传输的数据通道[MethodChannels](https://flutter.io/platform-channels/)，比起 QML，这更像 JS bridge 的实现，因为这些数据是异步传输的，这些数据也可以通过流传输[EventChannels](https://docs.flutter.io/flutter/services/EventChannel-class.html)。\n\n在安卓的 MainActivity 中可以调用如下方法向 Flutter 传递表盘状态，注意因为是 Wear OS，所以在`Android/app/build.gradle`修改`minSdkVersion`为 23，并在以下依赖中增加以下项目。\n\n```gradle\ndependencies {\n    ...\n    implementation 'com.android.support:wear:27.1.1'\n    implementation 'com.google.android.support:wearable:2.3.0'\n    compileOnly 'com.google.android.wearable:wearable:2.3.0'\n    ...\n}\n```\n\n`AndroidManifest.xml`中打开权限。\n\n```xml\n<!-- Required for ambient mode support -->\n<uses-permission android:name=\"android.permission.WAKE_LOCK\" />\n\n<!-- Flags the app as a Wear app -->\n<uses-feature android:name=\"android.hardware.type.watch\" />\n\n<!-- Flags that the app doesn't require a companion phone app -->\n<application>\n<meta-data\n    android:name=\"com.google.android.wearable.standalone\"\n    android:value=\"true\" />\n</application>\n```\n\n```kotlin\nprivate fun setShapeMethodChannel() {\n  MethodChannel(flutterView, shapeChannel).setMethodCallHandler { _, result ->\n    setOnApplyWindowInsetsListener(flutterView, {_, insets: WindowInsetsCompat? ->\n      if (insets?.isRound == true) {\n        result.success(0)\n      }\n      else {\n        result.success(1)\n      }\n      WindowInsetsCompat(insets)\n    })\n    requestApplyInsets(flutterView)\n  }\n}\n```\n\n在 Dart 部分通过监听 channel 获得形状\n\n```dart\nenum Shape { square, round };\nShape shape;\ntry {\n  final int result = await platform.invokeMethod('shape');\n  shape = result == 1 ? Shape.square : Shape.round;\n} on PlatformException catch (e) {\n  // Default to round\n  print('Error detecting shape: $e');\n  shape = Shape.round;\n}\n```\n\n## 省电模式(Ambient mode)\n\n手表耗电是很棘手的，所以安卓手表的应用都会选择支持长期显示时进入省电模式（我就惊了，你说用电子纸多好，偏偏所有人都用 LED，又不是拿手表看片，要那么好的显示搞什么？）。\n\n可以在 kotlin 部分获取省电模式的事件并通过 channel 传给 dart。\n\n```kotlin\nclass MainActivity: FlutterActivity(), AmbientMode.AmbientCallbackProvider {\n    private var mAmbientController: AmbientMode.AmbientController? = null\n    override fun onCreate(savedInstanceState: Bundle?) {\n        // Set the Flutter ambient callbacks\n        mAmbientController = AmbientMode.attachAmbientSupport(this)\n    }\n    override fun getAmbientCallback(): AmbientMode.AmbientCallback {\n        return FlutterAmbientCallback(flutterView)\n    }\n}\n\nprivate class FlutterAmbientCallback(val flutterView: FlutterView): AmbientMode.AmbientCallback() {\n    override fun onEnterAmbient(ambientDetails: Bundle) {\n        MethodChannel(flutterView, ambientChannel).invokeMethod(\"enter\", null)\n        super.onEnterAmbient(ambientDetails)\n    }\n    override fun onExitAmbient() {\n        MethodChannel(flutterView, ambientChannel).invokeMethod(\"exit\", null)\n        super.onExitAmbient()\n    }\n    override fun onUpdateAmbient() {\n        MethodChannel(flutterView, ambientChannel).invokeMethod(\"update\", null)\n        super.onUpdateAmbient()\n    }\n}\n```\n\n在 Dart 部分处理事件。\n\n```dart\n@override\ninitState() {\n    super.initState();\n    platformAmbient.setMethodCallHandler((call) {\n        switch (call.method) {\n            case 'enter':\n                setState(() => ambientMode = Mode.ambient);\n            break;\n        case 'update':\n            if (widget.update != null)\n                widget.update();\n            else\n                setState(() => ambientMode = Mode.ambient);\n        break;\n        case 'exit':\n            setState(() => ambientMode = Mode.active);\n        break;\n    }\n  });\n}\n```\n\n## 总结\n\nFlutter 能写安卓应用吗？能，而且比不好用要强得多。但是如果想写出 apple watch 的应用那种，还是道阻且长。不过考虑 wear OS 本身自己的应用都不咋地，感兴趣玩一下还是可以的。\n\n另外 Flutter 没有为 wearOS 设计 Material 设计语言的部件，所以都要自己设计（虽然屏幕也就 1~2 英寸）。也没有左滑后退的能力，只能在界面增加一个后退按钮，如果用户不小心左滑了，应用就关闭了（尴尬）。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["flutter","wearOS"]}},{"id":"2020/05/12/flutter-CICD.md","slug":"2020/05/12/flutter-cicd","body":"\n# 多平台上的 flutter 以及 CICD\n\nFlutter 是一个号称面向全平台的框架，既然立了 flag，早晚要去摘的。除了 iOS 和 Android，beta 版本的 flutter 还支持 web 网页以及 mac 桌面端，alpha（master 分支）版本还提供 Windows 和 Linux 桌面端的支持，本篇除了介绍 flutter 在各端如何开发发布还会提及如何通过 CICD 发布安卓 apk，以及这段时间使用 Flutter 的感想。\n\n## Web 支持\n\nWeb 应该是 dart 语言一直想抢的蛋糕，在早期 chrome 上面就有 dart VM，甚至提供了 dart2js 这样的工具，所以 Flutter 在一炮走红之后立刻提供 web 支持是不意外的。\n\n创建 Web 端的 Flutter 应用，以下几项是必须的：\n\n- 安装 Flutter SDK\n- Chrome 浏览器\n- 一个支持开发 Flutter 的编辑器\n\n确定以上几项后执行下面命令切换 Flutter 到 beta 版本，并打开 Web 端支持。\n\n```shell\n flutter channel beta\n flutter upgrade\n flutter config --enable-web\n```\n\n以上命令执行成功后执行`flutter devices`应该能看到 Chrome 浏览器和 Web 伺服器的支持。\n\n打开任何一个 Flutter 项目的根目录，执行`flutter run -d chrome`，稍等片刻 chrome 会被自动打开并渲染项目（这个体验很割裂，真的，这个片刻其实比较久，而且你的终端会不会显示任何东西）。\n\n执行`flutter build web`就会编译项目至`/build/web`文件夹下。\n\n### Web 支持总结\n\n编译 web 应用已经相对稳定，基本上你老姑（谷歌）想要的功能也都有（比如 service-worker 什么的），但因为是 js 渲染，SEO 什么的可能没 SSR 项目号，再一个，我在使用的时候没发现有 sourcemap，估计 debug 的方法也会和普遍 web 应用不太一致。\n\n## Windows 桌面支持\n\n到 Flutter 的目录下，将它 checkout 到 master 分支，此时执行`flutter doctor`，它会检查你是否安装`Visual Studio`、`MSVC`以及`Windows10 SDK`（当然了，这是在 Windows 下面执行才有），没错，alpha 版本的 flutter 已经可以编译 Windows 桌面应用了，只需安装社区版的`Visual Studio`，在安装项里面添加`Clang`、`MSVC`和`Windows10 SDK`即可。\n\n另外还需要在项目中增加[flutter desktop embedding](https://github.com/google/flutter-desktop-embedding)，尝试到这里我有点失望，看了这个项目的 issue，目前 Windows 的桌面支持还是用 Win32 的 API，项目正在计划使用 UWP 来替换。同样 Linux 桌面也在纠结于到底使用 QT 还是 GTK 做框架，因此这两个桌面端的支持相较于 Mac 延后。\n\n## flutter-rs\n\n这是我的另一个 Flag，几个月前我在尝试用 rust 写桌面应用，几个平台都不理想，于是尝试了这个包。然而[flutter-rs](https://github.com/flutter-rs/flutter-rs)依然不太理想，不过更多原因可能是因为这个项目还在 WIP 阶段。\n\n目前 rust 推荐在 WSL 上面开发，考虑到 WSL1 对图形的支持不太好，我更新了[WSL2](https://aka.ms/wsl2kernel)的内核，并使用 Ubuntu 20.04 开发。\n\n这里注意下，WSL2 是完整的 Linux 内核，所以代理什么的都不能使用 WSL1 里面的`localhost`。\n\n```shell\nexport WSL_VERSION=$(wsl.exe -l -v | grep -a '[*]' | sed 's/[^0-9]*//g')\nexport WSL_HOST=$(tail -1 /etc/resolv.conf | cut -d' ' -f2)\nexport DISPLAY=$WSL_HOST:0\n\nexport HTTP_PROXY=http://$WSL_HOST:1080\nexport HTTPS_PROXY=http://$WSL_HOST:1080\nexport NO_PROXY=127.0.0.1,localhost,$WSL_HOST\n```\n\n同样在运行`vcXsrv`时也要加上`-ac`参数已打开远端支持。\n\n安装编译`flutter-rs`需要很多依赖，\n\n```shell\nsudo apt install build-essential libssl-dev pkg-config libxcb-util-dev libxcb-render-util0-dev libxcb-shape0-dev libxcb-xfixes0-dev libclang-dev libglfw3\n\ncargo install flutter-rs\n```\n\n尴尬的来了，执行`cargo flutter run`，打开的 flutter 窗口闪了一下就崩溃了...查了下，好像是 Skia 在 rust 上面链接的问题，哎，不跟进了。\n\n## hover\n\n那么就没有一个能稳定点的桌面端方案了么？有！go 提供了一套 API 接口[hover](https://hover.build/)也叫[go-flutter](https://github.com/go-flutter-desktop/go-flutter)，框架是 GLFW。\n\n在 MSYS 里面就可以安装 golang（太好了，WSL 下面编译 GUI 不敢恭维啊）。\n\n```shell\npacman -S mingw-w64-x86_64-go\n```\n\n初次运行提示找不到 go 命令，貌似`mingw-w64`不在 PATH 上，查了好多都没找到原因，干脆直接添加上好了。\n\n```shell\nexport PATH=/c/tools/msys64/mingw64/bin:$PATH\n```\n\n下面安装 hover\n\n```shell\nGO111MODULE=on go get -u -a github.com/go-flutter-desktop/hover\n```\n\n随便找个已有的 flutter 项目，执行`hover run`，它会询问你是否增加一段 fushia 的代码`lib/main_desktop.dart`，没错，所有的 desktop 端都叫 fushia，它也是桌面端的入口文件，直接回复 Y 即可。\n\n和 flutter 的命令类似，执行`hover build windows`就会在`/build/output/windows`下生成编译好的可执行文件。\n\nhover 相对来说是目前唯一比较成熟的 Flutter 桌面运行时了，更多内容可以查看它的[文档](https://github.com/go-flutter-desktop/hover)。但是运行结果不能说如意，比如在处理改变窗口大小时，界面不会跟着鼠标变化，直到释放之后才会改变，这对于 2020 年的人类来说，体验真是不够好，但是运行起来确实是比 electron 好些，起码笔记本风扇没有疯狂打转。\n\n### Windows 桌面支持总结\n\n在官方支持遥遥无期的情况下，桌面支持真是百花齐放，不过另一方面微软爸爸直接提供亲生的[React Native Windows](https://github.com/Microsoft/react-native-windows)可是支持 UWP 下面的 Fluent Design 哦，所以在多段支持上，起码 Windows 这里，React Native 略胜一筹。\n\n## CICD\n\n本来想写一下测试的，结果发现没啥新东西。干脆提一下利用 Github action 做 CICD 好了。（其实基本上就复制[别人](https://github.com/nabilnalakath/flutter-githubaction)的`/.github/workflows`文件夹就好，白嫖很开心）。\n\n```yaml\non: push\nname: Test, Build and Release apk\njobs:\n  build:\n    name: Build APK\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v1\n      - uses: actions/setup-java@v1\n        with:\n          java-version: \"12.x\"\n      - uses: subosito/flutter-action@v1\n        with:\n          flutter-version: \"1.7.8+hotfix.4\"\n      - run: flutter pub get\n      - run: flutter test\n      - run: flutter build apk --debug --split-per-abi\n      - name: Push APK to Releases\n        uses: ncipollo/release-action@v1\n        with:\n          artifacts: \"build/app/outputs/apk/debug/*.apk\"\n          token: ${{ secrets.TOKEN }}\n```\n\n## 总结\n\nFlutter 相对于 React Native 的确有性能上的优势，毕竟跳过了 js 和原生环境交互的沟壑，但是对比开发环境还是没有 RN 全面。\n\n- 如果只是移动端应用，两者皆可，Flutter 有对 Material Design 更原生的支持，所以如果设计上是 Material Design，开发效率会更高；但是 RN 则在可定制上更高一筹。\n- 如果是 Wear OS，必然 Flutter。\n- 如果是桌面应用，目前我站 RN，除了工具链全面，它对比 Electron 已经很好了，而 Flutter 即使理论上性能更高，但其 alpha 的不稳定也要考虑在内。\n- 如果是 Web 端，感觉 Flutter 根本打不过现有的框架，不过仅仅对比 RN 的话，Flutter 可以不做配置就直接编译 Web，也就是说如果你有一个移动应用，又不想关心 Web 是怎么回事儿，用它还是可以的。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["flutter","CICD","rust","golang","wsl2","hover","github-action","vcXsrv","MSYS"]}},{"id":"2020/05/29/WebRTC.md","slug":"2020/05/29/webrtc","body":"\n# WebRTC，谈谈我这几天对它的研究\n\nWebRTC 是一个我在大学时期就关注的技术了，然而由于时间过早，很多技术细节都还在草案上就暂时罢休。今年年初，全世界都进入在家办公状态，视频会议工具被推到风口浪尖，webRTC 技术又一次被推到小高潮，于是便有了[这个实现](https://github.com/gongbaodd/ReactRTC)以及这篇文章。\n\n## WebRTC 是什么\n\nWebRTC 是实现网络端视频会议的技术，包括实现获取客户端的媒体 API，如获取摄像头以及麦克风的 `navigator.mediaDevices.getUserMedia()` 以及录制屏幕的 `navigator.mediaDevices.getDisplayMedia()`；还有实现双端数据传输的 `RTCPeerConnection` 类。\n\n目前主流的实现方式是将用户本地视频上传到后台服务器，由服务器转发视频数据到客户端。很恐怖是吧，没错，这就是为什么疫情刚刚开始大部分视频服务都因为访问过多而宕机，但是因为技术架构相对简单，容易实现并可以迁移到多个平台上面。\n\nWebRTC 依赖的是 P2P 技术，一旦两台机器实现连接，双方直接进行数据传输而不需要第三方转发，所以相对安全，但是实现细节比较困难，强烈推荐看一下 MDN 的[介绍](https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API)。\n\n## 两台机器如何连接\n\nP2P 说起来简单，实现起来并不容易，目前互联网主流使用 IPv4 协议，这意味着在网络环境中，真正暴漏的单一 IP 对应的是后台基于 NAT（Network Address Transition）技术连接的一簇终端设备。当我们使用网络传输数据时，是有一台暴露在外网的路由将收到的数据转发给自己的端口上面，但这一层转发，很多实现是广播的，意味着端口上面的每一台设备都能收到传输数据，如果要指定某台机器接收，需要在数据包里包含设备的描述，就好像 90 年代打电话往往要胡同门口小卖铺的王大爷叫一下。实现多设备链接就需要使用 ICE 技术（你的地址描述）的 TURN 或者 STUN 服务（提供地址描述的服务）。\n\n### ICE 技术\n\nICE（Interactive Connectivity Establishment）技术，我称之为「破冰」技术，它提供一个通过 TURN 或者 STUN 服务获取的一堆关于本地地址的描述，在 webRTC 中可以[获得本地描述](https://codesandbox.io/s/reactrtc-f365m?file=/src/components/PeerConnection.tsx:2363-2403)和[添加远端描述](https://codesandbox.io/s/reactrtc-f365m?file=/src/components/PeerConnection.tsx:3078-3139)。\n\n```typescript\nuseEffect(() => {\n  // 获取本地地址\n  connection.addEventListener(\"icecandidate\", (event) => {\n    if (event.candidate) {\n      // TODO: 保存 `event.candidate.toJSON()` 到服务器\n      // ...\n    }\n  });\n}, [connection]);\n\nconst onGetRemoteCandidate = useCallback(async () => {\n  // 添加远端地址\n  await connection.addIceCandidate(new RTCIceCandidate(data));\n}, [connection]);\n```\n\n### STUN 服务和 TURN 服务\n\nSTUN（Session Traversal Utilities for NAT）是一个能够帮助获取到客户端地址描述的协议。\n\n![STUN 服务](https://mdn.mozillademos.org/files/6115/webrtc-stun.png)\n\n在 RTCPeerConnection 中可以使用 google 的 STUN 服务。\n\n```ts\nconst [connection] = useState(() => {\n  return new RTCPeerConnection({\n    iceServers: [\n      {\n        urls: [\n          \"stun:stun1.l.google.com:19302\",\n          \"stun:stun2.l.google.com:19302\",\n        ],\n      },\n    ],\n    iceCandidatePoolSize: 10,\n  });\n});\n```\n\n而 TURN（Traversal Using Relays around NAT）则针对于只能接受对称 NAT（Symmetric NAT） 的路由器，设备对应的端口可变，相对于传统的锥形 NAT（Cone NAT），需要在 STUN 协议的基础上增加 Relay 转发。\n\n![TURN 协议](https://mdn.mozillademos.org/files/6117/webrtc-turn.png)\n\n如果心情好的话，你可以使用[COTURN](https://github.com/coturn/coturn)自己搭建一个 TURN 服务，更多关于 P2P 协议的描述可以参考[这篇博文](https://www.cnblogs.com/pannengzhi/p/5048965.html)。\n\n### SDP 会话描述\n\n如果你写过 HTTP 服务的话，一定会知道，要实现一个有状态的 HTTP 请求的实现基于会话，服务器和客户端通过一个会话 ID 实现双方的认证。会话在 P2P 下一样成立，这个会话 ID 则称为 SDP（Session Description Protocol）。\n\n一个 SDP 的结构如下，m 表示会话中的媒体描述。\n\n```ini\nv=0\no=mozilla...THIS_IS_SDPARTA-76.0.1 8725109466872836540 0 IN IP4 0.0.0.0\ns=-\nt=0 0\na=fingerprint:sha-256 A9:89:58:E6:B5:E3:23:F8:F4:4C:15:13:58:F5:7B\na=group:BUNDLE 0 1\na=ice-options:trickle\na=msid-semantic:WMS *\nm=audio 9 UDP/TLS/RTP/SAVPF 109 9 0 8 101\nc=IN IP4 0.0.0.0\na=sendrecv\na=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level\na=extmap:2/recvonly urn:ietf:params:rtp-hdrext:csrc-audio-level\nm=video 9 UDP/TLS/RTP/SAVPF 120 121 126 97\nc=IN IP4 0.0.0.0\na=sendrecv\na=extmap:3 urn:ietf:params:rtp-hdrext:sdes:mid\na=extmap:4 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time\na=extmap:5 urn:ietf:params:rtp-hdrext:toffset\n```\n\n当然生成二进制 SDP 的过程是不需要人工字符串拼接的，可以使用`connection.createOffer`和`connection.createAnswer`生 SDP，并使用`connection.setLocalDescription`和`connection.setRemoteDescription`建立会话。\n\n```ts\n// 发起端生成SDP\nconst createOffer = useCallback(async () => {\n  const offer = await connection.createOffer();\n  await conn.setLocalDescription(offer);\n  // TODO: 保存发起端的SDP到服务器\n  // ...\n}, [connection]);\n```\n\n## P2P 会议室的流程\n\n### 事前准备\n\n了解了上面的部分，我们需要如下内容以完成一次 P2P 连接\n\n- 一个 STUN 服务或者一个 TURN 服务来获取地址描述\n- 一台服务器，能够实现存储一端 ICECandidate（地址描述） 和 SDP（会话描述），并使另一端通过无论是 websocket 实现还是像 firebase 一样做轮询（polling）的技术获取数据。\n- 两台终端设备，其实要的就是两个`RTCPeerConnection`，但如果需要视频会议的话，还需要两个以上摄像头（反正我有 3 台 PC~）。\n\n### 1. 设置 RTCPeerConnection\n\n注意，网上很多示例会创建一个`localConnection`和一个`remoteConnection`，因为他们是在一台终端上做演示，所以理论上如果只要两台设备联络，代码里面创建一个`RTCPeerConnection`就可以实现两台设备连接了。\n\n[这里](https://codesandbox.io/s/github/gongbaodd/ReactRTC?file=/src/components/PeerConnection.tsx:618-663)因为项目用的是 React，我把实现封装成了一个`PeerConnection`组件。\n\n```ts\nconst config = {\n  iceServers: [\n    {\n      urls: [\"stun:stun1.l.google.com:19302\", \"stun:stun2.l.google.com:19302\"],\n    },\n  ],\n  iceCandidatePoolSize: 10,\n};\n\nconst CTX = createContext<RTCPeerConnection | null>(null);\n\nexport const PeerConnection: FC = ({ children }) => {\n  const [connection] = useState(() => {\n    return new RTCPeerConnection(config);\n  });\n\n  return <CTX.Provider value={connection} children={children} />;\n};\n```\n\n### 2. 处理本地 IceCandidate\n\n建立好 RTCPeerConnection 对象后，需要收集本地的 IceCandidate 并上传至服务器。\n\n```ts\nuseEffect(() => {\n  // 获取本地地址\n  // 假设这段代码是发起端，存储数据到callerAddress\n  // 如果是接收端，则存储到calleeAddress\n  connection.addEventListener(\"icecandidate\", async (event) => {\n    if (event.candidate) {\n      const db = await firebase.firestore();\n      const caller = await db.collection(\"callerAddress\");\n      caller.add(event.candidate);\n    }\n  });\n}, [connection]);\n```\n\n### 3. 获得远端 IceCandidate\n\n从数据库中中找到远端的地址（根据黑暗森林法则，如果知道对方地址，就可以杀死对方了），知道对方地址就可以建立会话了。\n\n```ts\n// 获得远端地址\n// 同样假设这段代码是发起端\n// 如果是接收端，则需要监视callerAddress\nconst db = await firebase.firestore();\nconst caller = await db.collection(\"calleeAddress\");\ncaller.onSnapshot((snapshot) => {\n  snapshot.docChanges().forEach(async (change) => {\n    if (change.type === \"added\") {\n      const address = change.doc.data();\n      await connection.addIceCandidate(new RTCIceCandidate(address));\n    }\n  });\n});\n```\n\n至此两边已经了解对方地址，可以进行会话了。\n\n### 4. 发起方获得本地媒体数据\n\n通过`navigator.mediaDevices.getUserMedia`获得媒体数据后，可以用`addTracks`函数把数据流添加到连接里面。\n\n```ts\nconst getUserMedia = useCallback(async () => {\n  const userStream = await navigator.mediaDevices.getUserMedia({\n    video: true,\n    audio: true,\n  });\n  userStream.getTracks().forEach((t) => {\n    connection.addTrack(t, localStream);\n    console.log(\"[P2P] stream to peer\", localStream);\n  });\n}, [connection]);\n```\n\n### 5. 发起方发送 offer SDP\n\n了解对方地址之后，发起方就可以发送 SDP 来建立会话了。\n\n```ts\nconst createOffer = useCallback(async () => {\n  const offer = await connection.createOffer();\n  await connection.setLocalDescription(offer);\n\n  const db = await firebase.firestore();\n  const offer = await db.collection(\"offer\");\n  offer.add({ type: offer.type, sdp: offer.sdp });\n\n  return offer;\n}, [connection]);\n```\n\n### 6. 接收方收到 offer，并返回 answer SDP\n\n接收方通过轮询服务器得到 offer，为连接添加远端会话描述，生成自己的会话描述（answer SDP），并存储到服务器，注意，这些步骤是不能更换的。\n\n```ts\nconst db = await firebase.firestore();\nconst offerRef = await db.collection(\"offer\");\nconst answerRef = await db.collection(\"answer\");\n\nofferRef.onSnapshot((snapshot) => {\n  snapshot.docChanges().forEach(async (change) => {\n    if (change.type === \"added\") {\n      const offer = change.doc.data();\n      await connection.setRemoteDescription(offer); // 设置远端会话描述\n      const answer = await conn.createAnswer(); // 生成本地会话描述\n      await conn.setLocalDescription(answer); // 设置本地会话描述\n      await answerRef.add(answer); // 存储本地会话到云端\n    }\n  });\n});\n```\n\n### 7. 发起方收到 answer，会话建立\n\n和接收方类似，发送方也需要从服务器收到会话的应答，设置好远端会话描述后，会话开始。\n\n```ts\nconst db = await firebase.firestore();\nconst answerRef = await db.collection(\"answer\");\n\nanswerRef.onSnapshot((snapshot) => {\n  snapshot.docChanges().forEach(async (change) => {\n    if (change.type === \"added\") {\n      const answer = change.doc.data();\n      await connection.setRemoteDescription(answer); // 设置远端会话描述\n    }\n  });\n});\n```\n\n### 8. 收到远端媒体流\n\n通过监听 track 事件，就可以获取远端媒体流了。注意，track 事件返回的是多个媒体流（因为 RTCPeerConnection 的`addTrack`可以使用多个媒体流），每个媒体流包括音轨和画轨。\n\n```ts\nconst video = useRef<HTMLVideoElement>(null);\n\nuseEffect(() => {\n  connection.addEventListener(\"track\", ({ streams: [remoteStream] }) => {\n    const stream = new MediaStream();\n    remoteStream.getTracks().forEach((t) => stream.addTrack(t));\n    video.current && video.current.srcObj = stream; // 设置HTML元素使用远端媒体流\n  });\n}, [connection]);\n```\n\n### 9. 会话结束\n\n停止一个媒体流，要关闭它的轨道。\n\n```ts\nstream.getTracks().forEach((t) => t.stop());\n```\n\n关闭连接则需要调用`close`函数。\n\n```ts\nawait connection.close();\n```\n\n## 传输文字信息\n\nRTCPeerConnection 不仅仅可以传输媒体流，使用[RTCDataChannel](https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Simple_RTCDataChannel_sample)可以传递文字信息。\n\n每一个 RTCPeerConnection 建立之后会有一个\"datachannel\"事件，这个事件会返回一个 chennel 对象，用来接收发送方传来的数据。\n\n```ts\nconnection.addEventListener(\"datachannel\", ({ channel }) => {\n  channel.addEventListener(\"open\", () => {\n    console.log(\"[P2P receiver] open\");\n  });\n  channel.addEventListener(\"message\", ({ data }) => {\n    console.error(\"[P2P receiver] message\", data);\n  });\n  channel.addEventListener(\"close\", () => {\n    console.log(\"[P2P receiver] closed\");\n  });\n});\n```\n\n在发起端创建一个 datachannel 向远端发送数据了。\n\n```ts\nconst sender = connection.createDataChannel(\"xxx\");\n// ... 发送信息必须在sender收到open事件后\nsender.send(\"hello\"); // 向接收端发送\"hello\"字符串\n```\n\n## 附录\n\n### 实现多端链接\n\n目前为止，RTCPeerConnection 只能做一对一连接。不过，要想实现多端连接，可以创建多个 RTCPeerConnection。那么一个浏览器最多能使用多少个 RTCPeerConnection 呢？根据[这篇文章](https://bloggeek.me/webrtc-rtcpeerconnection-one-per-stream/)，显然这个问题比较复杂，这个文章里面提过大概是 200 个，但由于网络等原因，可能并不能顺利建立这么多连接。\n\n### 调试方法\n\n我不太清楚出了什么状况，我的 demo 只能在火狐里面跑起来，但是调试起来类似，可以参考[这篇](https://testrtc.com/webrtc-internals-parameters/)。\n\n### PWA 里面能用 P2P 吗\n\n既然 DataChannel 能够实现端对端传输文字信息，那么结合 ServiceWorker 我们是不是可以创建一个完全去中心化的网页呢？答案是目前不可以，但是方案已经写进 webtorrent，具体内容可以在[此链接](https://github.com/webtorrent/webtorrent/issues/1721)跟进。\n\n### CodeSandbox 的使用体验\n\nCodeSandbox 可以理解为一个线上 Web 前端开发编辑器。\n\n因为现在是五月末六月初，在大陆依赖于 npm 的开发到了无比艰难的一段时间，导致我开始不得不考虑在[CodeSandbox](https://codesandbox.io/)进行开发。开发体验还是很可观的，虽然写代码会出现不跟手的情况，偶尔代码会出现因为远端没同步导致丢失（好在可以通过 github 同步）。\n\n我推荐以下情况可以考虑使用 codeSandbox：\n\n- 一个全新的项目\n- 项目比较简单，浏览器不至于卡死\n","collection":"blog","data":{"type":"post","category":"fe","tag":["webRTC","p2p","codesandbox","firebase"]}},{"id":"2020/06/14/ml5.js-tensorflow.js.md","slug":"2020/06/14/ml5js-tensorflowjs","body":"\n# ml5.js 和 tensorflow.js，终于聊到前端部分了\n\n既然在浏览器中也可以计算多维数组，拿浏览器做深度学习也可以理解了。Google 给浏览器中设计了 [tensorflow.js](https://www.tensorflow.org/js)，跟 python 下面的 tensorflow 是同一套 API。又有一群人在 tensorflow 的基础上封装了一套[ml5.js](https://ml5js.org/)。对比 tensorflow.js，ml5.js 去掉了很多张量计算的部分（说实话，这些东西真不是人学的，我这一周都在研究这些计算...）。所以本文会以 ml5.js 开始。\n\n## ml5.js\n\n这是[Daniel Shiffman](http://www.shiffman.net/)主导的 JS 深度学习库，我特喜欢看他的视频睡觉。这个库的[使用教程](https://learn.ml5js.org/docs/#/reference/index)不能更详细了！\n\n官网的简介，是使用 MobileNet 了`imageClassifier`，这是我的[笔记](https://observablehq.com/@gongbaodd/untitled)，可以用来判断图片、视频中的物体是什么。\n\n另外也可以使用`neuralNetwork`，这是[笔记](https://observablehq.com/@gongbaodd/ml5-js-neural-network)，基本上前面两篇关于 tensorflow 的文章都可以使用它来跑。\n\n使用 ML5.js 很大的简化了 tensorflow 的 API，然而并不是你可以不了解 tensorflow，因为期间会有很多参数难以理解，又不得不回头看它。\n\n## tensorflow.js\n\n基本上会了 python 版本，js 版本就算是个子集了，基本上很多需要的包都有替代。[这里](https://www.tensorflow.org/js/guide/layers_for_keras_users?hl=zh-cn)是一个给 keras 用户使用的 tensorflow.js 指南。另外去强烈建议看看[tensorflow.js 指南](https://www.tensorflow.org/js/guide?hl=zh-cn)。\n\n- `tf.layers` => Keras\n- `@tensorflow/tfjs-vis`原生支持 tensorflow 的数据可视化库（那敢情好啊）\n","collection":"blog","data":{"type":"post","category":"fe","tag":["tensorflow","keras","wsl2","python"],"series":{"slug":"learn-tensorflow","name":"张量麻辣烫"}}},{"id":"2020/07/17/20.md","slug":"2020/07/17/20","body":"\n# 20 年代初的小程序开发浅谈\n\n貌似有两周没怎么更新博客了哈，因为这几天白天就是冲浪游泳晒太阳，晚上就是写代码（啊~惬意），写了一个踏浪 App，用来查看大陆东南沿岸的冲浪浪点情况。\n\n![踏浪小程序码](./2020-07-17.jpg)\n\n## 为什么选择小程序\n\n就国内来说，如果是放到 web 这个纯开放平台上，就是 SEO 做得再好，也要被埋到广告里面；放到酷安和苹果商店...开发者要交钱的...我为爱发电还没这么强。反倒放到小程序里，因为大陆微信普及率很高，基本上说一句「你要是想看看浪情，去微信搜一下踏浪 App」就好了，再一个，微信小程序的云函数也提供了类似于 Google firebase 的前后台 sdk，也不用担心搭建服务器什么的了（毕竟我在旅游，运维的事情还是不想做）。\n\n## 包管理的尴尬\n\n小程序其实就是个优化了的浏览器，但是开发的时候不能搞到浏览器实例（window），这导致大部分 NPM 库里的 JS 都不能不加修改地在小程序中运行（哪怕是 lodash 这样的基础库），甚至是 D3 都跑！不！了！\n\n应该有很多库已经提供解决方案了，毕竟就是个编译就能解决掉的问题，可是像包管理这种东西，小程序上了这么年，一直都很烂，可见它是多不挣钱。\n\n## 云函数\n\n小程序的云函数只能在小程序编辑器里面开发，哪怕是到了腾讯云后台都看不到，这个不知道是不是鹅厂内部的问题。\n\n## SVG\n\n小程序 CSS 中支持 SVG。这点可以有，好多图我都是 figma 里面妥妥拽拽导出 SVG。但是在 Vdom 中直接插入 SVG 还是不行。\n\n## WSL\n\n另外，在 Windows 下面开发小程序是无法使用 WSL 环境的，哪怕是映射过去的文件地址也不行，但是可以把项目放在 Windows 的目录下如`/mnt/c/minprogram`开发。\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2020/07/24/2D-svg-3D.md","slug":"2020/07/24/2d-svg-3d","body":"\n# 快速把 2D 的 svg 生成为 3D\n\n[vectary](www.vectary.com)可以把 2D 的 SVG 渲染成 3D，但是免费版导出的图片是有水印的，导出模型的功能也是收费的（但是我发现可以从 network 中扒`*.obj`文件，是，我知道这很 low🤣）\n","collection":"blog","data":{"type":"post","category":"fe","tag":["svg"],"series":{"slug":"tools","name":"利器"}}}]}