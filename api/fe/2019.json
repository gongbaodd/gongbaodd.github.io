{"posts":[{"id":"2019/01/08/Webpack-V3-V4-globalObject-window.md","slug":"2019/01/08/webpack-v3-v4-globalobject-window","body":"# Webpack从v3升级到v4后默认globalObject会变成window\n\n今天小伙伴出于安全考虑把Webpack从v3升级到v4（太可怕了直接一个大版本更新），结果导致我们node上面引用的umd包竟然就挂了，报错内容是 window is undefined.\n\n搜了下Stack Overflow，果然很多人也有这样的问题。从v4开始，webpack默认globalObject为window。\n\n```\nmodule.exports = {\n    ...\n\toutput: {\n\t\t...\n\t\tglobalObject: 'this'\n\t}\n}\n```\n\n如上改动即可\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2019/02/19/jest-exceedsMaxOf500kb.md","slug":"2019/02/19/jest-exceedsmaxof500kb","body":"# jest 报警 exceedsMaxOf500KB\n\n已经工作快半年了，做个小记录，jest测试的时候偶尔会报lodash exceeds the max of 500KB错误。\n\n查了很多配置，应该是coverage哪里的问题，在coveragePathIgnorePatterns里面忽略```<rootDir>/node_modules/```即可。 ","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2019/03/30/CSS.md","slug":"2019/03/30/css","body":"# 第五届中国CSS大会\r\n\r\n感谢宇神赠票了~大会很多内容收获很多，待我稍加整理发出来。","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2019/04/01/XSS.md","slug":"2019/04/01/xss","body":"# Google 的 XSS 漏洞\r\n\r\n视频地址： [An actual XSS on google.com by Masato Kinugawa. ](https://youtu.be/lG7U3fuNw3A)\r\n\r\n## 简单的背景\r\n\r\n首先正常浏览器在控制台执行以下代码是会弹窗的，也就是说如果一个输入框输入了`<img src=\"\" onerror=\"alert(1)\"/>`，同时前端在回显的时候并没有处理它，页面就会弹窗。\r\n\r\n```javascript\r\nconst a = document.createElement('div');\r\na.innerHTML = '<img src=\"\" onerror=\"alert(1)\"/>';\r\n```\r\n\r\n很简单，只要把里面的标签都给替换成纯文字不就行了？问题又来了，如果我们需要的就是富文本呢？\r\n好在，现在已经有很多`sanitize`的包用来把可能注入代码的地方做转义处理了。\r\n\r\n## 在深入一点\r\n\r\n但是，假设用户输入的不是标准HTML呢？\r\n\r\n如果用户输入的是下面的代码\r\n\r\n```html\r\n<script><p title=\"</script>\">\r\n```\r\n\r\n浏览器会解析成两个节点\r\n\r\n```html\r\n<script><p title=\"</script>\r\n\"&gt;\r\n```\r\n\r\n如果换成DIV标签\r\n\r\n```html\r\n<div><p title=\"</div>\">\r\n```\r\n\r\n则会解析成一个节点\r\n\r\n```html\r\n<div><p title=\"</div>\"></p></div>\r\n```\r\n\r\nscript标签在执行innerHTML的时候并不解析，可见，浏览器对不同标签的处理是不同的，那么，干脆让浏览器来做标签标准化如何？借助template标签就可以。\r\n\r\n```javascript\r\nconst a = document.createElement('template');\r\na.innerHTML = '<div><p title=\"</div>\">';\r\nconsole.log(a.innerHTML); // 输出 <div><p title=\"</div>\"></p></div>\r\n```\r\n\r\n## 问题出现\r\n\r\n问题出现了，假设用户输入的是如下代码呢？\r\n\r\n```html\r\n<noscript><p title=\"</noscript><img src='' onerror='alert(1)'/>\">\r\n```\r\n\r\n在`template`的输出如下\r\n\r\n```html\r\n<noscript>\r\n    <p title=\"</noscript><img src='' onerror='alert(1)'/>\"></p>\r\n</noscript>\r\n```\r\n\r\n可浏览器的解析却如下\r\n\r\n```html\r\n<noscript>\r\n    <p title=\"\r\n</noscript>\r\n    <img src=\"\" onerror=\"alert(1)\">\r\n\"&gt;\r\n```\r\n\r\n怎么会这样？？？原因在于noscript是在不支持script的环境下作为script标签的兼容标签，在template环境下是不支持script的，此时noscript被解析了，而在开了script功能的浏览器却不解析noscript。\r\n\r\n## 修复\r\n\r\n这个问题很快就被Google回滚修复了，bug源于2月的一个功能性提交。","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2019/09/04/webpack.md","slug":"2019/09/04/webpack","body":"# 为webpack工程的本地开发提供代理\n\n首先，我绝对反对线上和本地环境有这种不同配置，但是如果代理是必选项的时候，选择工程化的配置要比每个人维护一套更有效。\n\n需要在webpack.dev.server.config中增加setProxy文件\n\n```\nconst proxy = require('http-proxy-middleware');\n\nmodule.exports = function(app) {\n    app.use(\n        proxy('/api', {\n            target: 'https://xxx.api.com',\n            changeOrigin: true,\n            secure: false,\n            pathRewrite: {\n                '^/api': '/',\n            },\n        })\n    );\n};\n\n```\n\n这样，每个请求`localhost/api`的请求就被代理到`https://xxx.api.com`下了。","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2019/09/06/CSP.md","slug":"2019/09/06/csp","body":"Web UI Security matters\nRead 51 penetration test and Front-End-Checklist first.\n\n1. Reverse tab nabbing\nCRITICALITY:\n\nAn attacker might use this technique to silently load other pages on the parent tab which can be used for malicious operations such as phishing attacks.\n\nSUGGESTED FIX:\n\nPlease ensure that user-controlled (anchor tag with target=\"_blank\") links have the following attribute set: \n\nCopy\nrel=\"noopener noreferrer\"\nMore about the fix: https://cheatsheetseries.owasp.org/cheatsheets/HTML5_Security_Cheat_Sheet.html#tabnabbing﻿\n\n\n2. Content security policy\nCRITICALITY:\nAn attacker may inject scripts into the HTML files to steal user's information, such as Cookie, JWT token. If the CSP header is not offered, the browser will use same-origin policy standard, attackers can do XSS attack by injecting <img/> tags or <script/> tags.\n\nSUGGESTED FIX:\nCurrently we have two kinds of projects:\n\nS3 bucket project: The CI uploads webpack compiled static files to AWS S3 bucket,  the server is served by AWS cloud front.\nNode project: The project has one node server to serve itself.\nFor S3 bucket project\nMost of the CSP directives can be added using <meta/> tags.\n\ninstall csp-html-webpack-plugin into the projectyarn add -D csp-html-webpack-plugin\n\nyou can use the configuration in admin.aftership.com, including reCAPTCHA, Newrelic Browser & google-analytics.\n\nSome directives such as frame-ancestors can not be added by <meta/> tag. A response header is needed to add to the website.\n\nYou cannot add frame-ancestors directive using <meta/>\n\nadd  frame-ancestor _and _X-Frame-Options _in AWS cloudfront _to avoid click jacking attack.\n\nValidations\n\nYou can check your CSP content in [CSP Evaluator](https://csp-evaluator.withgoogle.com/).\n\n3. Subresource Integrity\n#\nCRITICALITY\nAttackers can inject arbitrary malicious content info files on the CDN.\n\nSUGGESTED FIX\nFor files from CDN add integrity & crossorigin field in script and link  tags, you can calculate the hash by using SRI Hash Generator.\n\nCopy\n<script src=\"https://example.com/example-framework.js\"\n        integrity=\"sha384-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/uxy9rx7HNQlGYl1kPzQho1wx4JwY8wC\"\n        crossorigin=\"anonymous\"></script>\n<link href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css\" \n        rel=\"stylesheet\" \n        integrity=\"sha256-MfvZlkHCEqatNoGiOXveE8FIwMzZg4W85qfrfIFBfYc= sha512-dTfge/zgoMYpP7QbHy4gWMEGsbsdZeCXz7irItjcC3sPUFtf0kuFbDz/ixG7ArTxmDjLXDmezHubeNikyKGVyQ==\" \n        crossorigin=\"anonymous\"/>\n﻿\n\nIf the project is a S3 bucket project, the following webpack plugin can add integrity for the compiled statics.\n\n﻿\n\nwebpack-subresource-integrity\n﻿\n\nYou need to set output.crossOriginLoading to anonymous in webpack.config.js.\n\n不推荐用SRI，因为integrity会加上用户的UA","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2019/09/10/cloudflare worker-CSP.md","slug":"2019/09/10/cloudflare-worker-csp","body":"# cloudflare worker 增加 CSP\n\n```javascript\naddEventListener('fetch', event => {\n\n  event.respondWith(fetch(event.request)\n      .then(function(response){\n            response = new Response(response.body, response);\n            // Set content-security-policy header to self and also include \n            // cloudflare workers dashboard to make it easy to preview\n            response.headers.set(\"content-security-policy\",\n               \"frame-ancestors 'self' https://dash.cloudflare.com;\");\n\n            return response;\n        }\n\n      ));\n    \n\n});\n```","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2019/09/27/jest.md","slug":"2019/09/27/jest","body":"# 总结一下最近 jest 上面的经验\n\n## mock localStorage\n\njsdom里面的localStorage是不能通过赋值覆盖的，但是有一个hack就是利用Object.defineProperty。\n\n```javascript\nObject.defineProperty(window, 'localStorage', {\n    writable: true,\n    value:{\n        getItem: jest.fn(),\n        setItem: jest.fn()\n    }\n});\n```\n\n## setTimeout\n\n有的时候需要让测试代码以为自己已经跑了一会儿。\n\n```javascript\njest.useFakeTimers();\n\njest.advanceTimersByTime();\n\njest.clearAllTimers();\n```\n\n## matchMedia\n\njsdom 还没提供，需要自己mock。\n\n```javascript\nwindow.matchMedia = jest.fn(query => ({\n    matches: false,\n    media: query,\n    onchange: null,\n    addListener: jest.fn(),\n    removeListener: jest.fn(),\n}));\n```","collection":"blog","data":{"type":"post","category":"fe"}}]}