{"posts":[{"id":"2020/03/05/Jekyll-Gatsby.md","slug":"2020/03/05/jekyll-gatsby","body":"\n# 从 Jekyll 迁移博客到 Gatsby\n\n很久以前就想迁移了，但是一直没下手，原因很简单，就是 ruby 不太熟悉，而使用 node 工具链比较趁手。\n\n当然了，Gatsby 的主题对比 Jekyll 就少太多了，没关系，大不了自己设计（又是一个大坑）。\n\n[Gatsby 官网](https://www.gatsbyjs.org/)的 tutorial 已经很详细了，这里只提简单的几个注意。\n\n- 所谓的 TypeScript 项目仅仅指的是前端，后端部分（因为是静态服务，应该说成编译的钩子`gatsby-node.js`）还是用的是 JavaScript，但是可以通过引入`ts-node`实现引用 TypeScript 文件。\n\n- 不确定是不是 WSL 或者 Windows 的锅，执行`gatsby develop`或者`gatsby build`的时候会偶尔出现权限无法访问并在根目录创建`reduxcache*`文件，挺烦人的其实，回头还得执行`sudo rm -Rf reduxcahce*`删除。\n\n- 无论`components`还是`pages`，其实都做了一层隐式封装，所以只有`default`暴露的组件参能使用 Gatsby 里面诸如`useStaticQuery`的钩子函数。\n\n- Gatsby 默认的 URL 格式和 Jekyll 不一样，为了保持持续性，我修改了`server/onCreateNode`来修改文件的 URL。\n\n- 修改 Travis 上传到`gh-pages`分支后，服务竟然挂了，查看 setting 说我只能在`master`分支上面放编译后的文件（莫非政策有变化？）。无所谓了，把`gatsby`分支改成默认分支，设置`master`分支为部署分支即可。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["jekyll","gatsby"]}},{"id":"2020/03/06/Utterance-GitHub-issue.md","slug":"2020/03/06/utterance-github-issue","body":"\n# 使用 Utterance 为博客添加基于 Github-issue 的评论系统\n\n最近在重构我部署在 GitHub pages 的博客，本来不想添加评论系统的，但是手贱，非想要加一个。\n\n尝试了 disqus（一个在国内无法使用的评论系统），貌似`page.url`中不能使用中文字符...这就尴尬了，突然想起来以前看 hackernews 的时候有人提起过使用 GitHub issue 搭建博客的想法。如果你是直接使用静态页面做网站，只需要去[Utterance](https://utteranc.es/)授权 GitHub 账号，复制对应的代码粘贴到网站即可。\n\n因为我新重构的网站是基于 Gatsby 的，Utterance 也提供了[react 高阶组件](https://www.npmjs.com/package/with-utterances)可以使用。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["github"]}},{"id":"2020/03/10/docker-strapi.md","slug":"2020/03/10/docker-strapi","body":"\n# 腾讯云 docker 安装 strapi\n\n## Docker engine\n\n如下是[官网的安装过程](https://docs.docker.com/install/linux/docker-ce/ubuntu/)，首先移出 Ubuntu 原有的 docker（如果有的话）\n\n```shell\n sudo apt-get remove docker docker-engine docker.io containerd runc\n sudo apt-get update\n```\n\n安装相关依赖\n\n```\nsudo apt-get install \\\n    apt-transport-https \\\n    ca-certificates \\\n    curl \\\n    gnupg-agent \\\n    software-properties-common\n```\n\n增加 docker 的安装源\n\n```shell\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n```\n\n开始安装（我的架构是 x86_64）\n\n```shell\nsudo add-apt-repository \\\n   \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\\n   $(lsb_release -cs) \\\n   stable\"\n\nsudo apt-get update\nsudo apt-get install docker-ce docker-ce-cli containerd.io\n```\n\n## Docker compose\n\n安装新版本`docker-compose`，因为文件存储在 github 上面，这里直接从 DaoCloud 下载。\n\n```\nsudo curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.4/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose\nsudo chmod +x /usr/local/bin/docker-compose\n```\n\n## 解决 ERROR: Couldn't connect to Docker daemon at http+docker://localhost - is it running？\n\n需要增加自己用户到 docker 组，然后重新进入即可\n\n```shell\nsudo gpasswd -a ${USER} docker\n```\n\n## Strapi\n\n按照[strapi 官方文档](https://strapi.io/documentation/3.0.0-beta.x/installation/docker.html)执行如下操作。\n\n新建文件夹，并增加`docker-compose.yaml`\n\n```yaml\nversion: \"3\"\nservices:\n  strapi:\n    image: strapi/strapi\n    environment:\n      DATABASE_CLIENT: mongo\n      DATABASE_NAME: strapi\n      DATABASE_HOST: mongo\n      DATABASE_PORT: 27017\n      DATABASE_USERNAME: strapi\n      DATABASE_PASSWORD: strapi\n    links:\n      - mongo:mongo\n    volumes:\n      - ./app:/srv/app\n    ports:\n      - \"1337:1337\"\n\n  mongo:\n    image: mongo\n    environment:\n      MONGO_INITDB_ROOT_USERNAME: strapi\n      MONGO_INITDB_ROOT_PASSWORD: strapi\n    volumes:\n      - ./data/db:/data/db\n    ports:\n      - \"27017:27017\"\n```\n\n修改 docker 镜像选择[腾讯加速器](https://cloud.tencent.com/document/product/457/9113)。\n\n```json\n//  /etc/docker/daemon.json\n{\n  \"registry-mirrors\": [\"https://mirror.ccs.tencentyun.com\"]\n}\n```\n\n重启服务\n\n```shell\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n```\n\n下载镜像。\n\n```shell\ndocker-compose pull\n```\n\n启动镜像\n\n```shell\ndocker-compose up -d\n```\n\n现在你的 1337 端口已经交给 strapi 了。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["docker","tencent","strapi"]}},{"id":"2020/03/17/Windows-Cypress.md","slug":"2020/03/17/windows-cypress","body":"\n# Windows 下面搞 Cypress 真心不容易\n\n最近在忙活让网站使用 [Cypress](https://www.cypress.io/) 做测试，之前使用苹果电脑以及 Linux 下面用起来还不错，这次在 Windows 下面碰壁比较多（其实我国的网络也有一部分功劳），所以在这里记录一下。\n\n## 尝试使用 WSL（失败）\n\nWSL 可以使用 XServer，所以我打算在 WSL 下面搭建，需要安装 [VcXsrv](https://sourceforge.net/projects/vcxsrv/) ，启动之后一路下一步就可以了，最后将 WSL 显示映射上去（在 bashrc 里面添加下面代码）。\n\n```shell\n# Display\nexport DISPLAY=localhost:0\nsudo /etc/init.d/dbus start &> /dev/null\n```\n\n另外需要把用户加到 sudoers 里面，否则每次启动还要输一遍密码\n\n```shell\nsudo echo \"{user} ALL = (root) NOPASSWD: /etc/init.d/dbus\" >> /etc/sudoers.d/dbus\n```\n\n然而，失败了，启动程序会报 GPU 渲染错误，同样的操作在 WSL2 中依然不行，可是[网络中有人成功了](https://nickymeuleman.netlify.com/blog/gui-on-wsl2-cypress/)。\n\n我相信更多的原因在于编译的时候网络环境太差了。\n\n## 尝试使用 MSYS\n\n直接跑 Windows 原生应用除了运行起来会更快，还可测试如 Edge 等浏览器，[MSYS](https://www.msys2.org/) 安装起来很简单，软件仓库管理使用的是 pacman，安装源可以尝试华中科大和清华的。\n\n```ini\n# C:\\msys64\\etc\\pacman.d\\mirrorlist.mingw32\nServer = http://mirrors.ustc.edu.cn/msys2/mingw/i686/\nServer = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/i686/\n```\n\n```ini\n# C:\\msys64\\etc\\pacman.d\\mirrorlist.mingw64\nServer = http://mirrors.ustc.edu.cn/msys2/mingw/x86_64/\nServer = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/x86_64/\n```\n\n```ini\n# C:\\msys64\\etc\\pacman.d\\mirrorlist.msys\nServer = http://mirrors.ustc.edu.cn/msys2/msys/$arch/\nServer = https://mirrors.tuna.tsinghua.edu.cn/msys2/msys/$arch/\n```\n\n另外需要在「控制面板>系统安全>系统>高级系统设置>环境变量」中增加`MSYS2_PATH_TYPE`值为`inherit`，这样 MSYS 里面的 PATH 就是用的是系统的 PATH 了。\n\n如果习惯使用 WWindows Terminal，可以尝试这个[issue](https://github.com/msys2/MSYS2-packages/issues/1684)，在 Windows Terminal 里面运行 MSYS。\n\n```shell\n$ cat .ms-terminal/wt-msys2.cmd\n@echo off\nsetlocal\n\nrem To activate windows native symlinks uncomment next line\nset MSYS=winsymlinks:nativestrict\n\nrem Shell types\nif \"x%~1\" == \"x-msys2\" set MSYSTEM=MSYS\nif \"x%~1\" == \"x-mingw32\" set MSYSTEM=MINGW32\nif \"x%~1\" == \"x-mingw64\" set MSYSTEM=MINGW64\n\n\nrem Shell types\nrem set MSYSTEM=MSYS\n\nC:\\msys64\\usr\\bin\\bash.exe --login -i\n\nexit /b 0\n```\n\n```json\n{\n  \"guid\": \"{e129fe71-3c94-40b5-8d92-961a3248f175}\",\n  \"commandline\": \"C:\\\\\\\\msys64\\\\home\\\\gongb\\\\wt-msys2.cmd\",\n  \"name\": \"MSYS2\",\n  \"startingDirectory\": \"%USERPROFILE%\",\n  \"icon\": \"ms-appx:///ProfileIcons/{0caa0dad-35be-5f56-a8ff-afceeeaa6101}.png\",\n  \"useAcrylic\": true,\n  \"acrylicOpacity\": 0.75\n}\n```\n\nWindows 下面的开发环境配置比较困难的原因之一就是这些链接库，比如安装一个`libpng-dev`，可以使用 Visual Studio Toolchain，也可以使用 MSYS，还可以使用微软开源的 VCPKG，然而没有一个体验能够达到极致。这导致 Gatsby 在我国的网络下永远不能部署成功。\n\n但是，直接在官网下载下来二进制包再进行[安装](https://docs.cypress.io/guides/getting-started/installing-cypress.html#Install-binary)也是可以的。\n\n```shell\nCYPRESS_INSTALL_BINARY=/local/path/to/cypress.zip npm install cypress\n```\n\n这样就可以运行 Cypress 了。\n\n## 最佳实践\n\n由此可知，其实 Cypress 可以在 Windows 下面原生执行，那么可以单独使用一个代码仓库管理测试用例，如本博客的测试用例放在[这里](https://github.com/gongbaodd/cy-blog.gongbusang.com)，在持续集成的时候将代码下载下来测试即可。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["cypress","Windows","WSL2","MSYS","VcXsrv"]}},{"id":"2020/03/22/react-three-fiber-WebGL.md","slug":"2020/03/22/react-three-fiber-webgl","body":"\n# 使用 react-three-fiber 体验美好的 WebGL 开发\n\n使用 threejs 开发 webGL 应用应该是几乎每个前端工程师想要做的事儿，然而虽然对比于原生 WebGL 开发来说，threejs 已经做了很多，但是相对于现代的一些前端框架。threejs 还稍显不足。针对这些不足，微软开发了[Babylon.js](https://www.babylonjs.com/)，给 threejs 量身定制了一个节点编辑器，如果做过 blender 或者 unity 的同学，对于节点编辑器肯定不会陌生，但对我本人来说还是没有触碰到 G 点。\n\n## 描述组件关系的重要性\n\n本人觉得，对于前端开发来说，提供一个能够准确描述组件和组件结构关系的语言（DSL）是至关重要的，如 HTML 之于 web 开发，xml 之于安卓开发。这些 DSL 能够以最直观的方式表达页面将会展示什么，就从开发的角度上来说，或许入门不是很方便，毕竟要处理很多文件。但是维护起来却异常的轻松，就是前面提到的原因，直观。当然因为 JavaScript 跟 HTML 的交互有很大的性能缺陷。所以给很多模板语言提供了机会。比如 mustache 还有 react 的 JSX。在安卓也能看到 anko 在 kotlin 社区兴起，但是仅仅一年就没有更多人使用了，个人体验，在 Android studio 中使用 xml 和 anko 开发体验差距并不大，有时候 xml 甚至占优，也许这就是原因之一了吧。\n\n几年前我翻查了很多框架，老实说可能更多人并没有把结构描述放在如我想的位置上，哪怕连个 JSON 的方案都没有。但是的确有[aframejs](https://aframe.io/)这种直接用 HTML 管理 canvas 中元素关系的库，可惜它更关注于 VR 开发，而我更希望 WebGL 能够成为诸如图书注解一样的工具，当然这种专注于一个方面的做法或许是正确的，毕竟能够汇聚一个小圈的开发者，也不会有很多流失。\n\n## 用 JSX 开发 WebGL\n\n今年运气就好多了，react-reconciler 使得我们能够直接接管组件的 render 函数，而 react-hooks 在开发体验上完美超出现有框架，[react-babylonjs](https://github.com/brianzinn/react-babylonJS) 和 [react-three-fiber](https://github.com/react-spring/react-three-fiber) 应运而生。我同时试用了这两个框架，简单来说，react-three-fiber 更加成熟些，对 tTypeScript 的支持更好，而 react-babylonjs 开发的时候往往会因为处理类型而费心，最后又不得不使用 JavaScript 开发。\n\n## 怎么使用 react-three-fiber\n\nreact-three-fiber 的[官方文档链接](https://inspiring-wiles-b4ffe0.netlify.com/)描述很详细，建议详读。另外 threejs 官方来链接的[threejs fundamentals](https://threejsfundamentals.org/)有时间也可以拿来读读。\n\n如果想把原来的 threejs 模块迁移到 react 模块，只需要使用一层 primitive 包装即可。每个拥有 set 和 get 的参数都可以作为 props 的成员，构造器参数则是`props.args: any[]`类型。\n\n```JavaScript\nconst grid = new GridHelper(2000, 20, 0x000000, 0x0000000);\n(grid.material as Material).opacity = 0.2;\n(grid.material as Material).transparent = true;\n\nconst Grid = () => {\n  useFrame(({ scene }) => {\n    if (!scene.fog) {\n      const fog = new Fog(0xa0a0a0, 200, 800);\n      scene.fog = fog;\n    }\n  });\n\n  return <primitive object={grid}></primitive>;\n};\n\n```\n\n## 调试工具\n\n这点 babylonjs 要好得多，一个节点编辑器秒杀一切，但是 threejs 还有一个「够用」的[threejs inspector](https://chrome.google.com/webstore/detail/threejs-inspector/dnhjfclbfhcbcdfpjaeacomhbdfjbebi?hl=en)。\n\n使用时需要把你的 scene 和 THREE 模块暴露给 window 作用域。\n\n```JavaScript\nwindow.scene = scene;\nwindow.THREE = THREE;\n```\n\n然后刷新浏览器就可以在场景添加光源，查看节点等操作了。\n\n## 提示\n\n因为 threejs 及其模块本身不是编译好的 ES5，在 nextjs 中一定记得使用`next-transpile-modules`编译，当然即使已经完美适配 ES5，在 IE11 的展示也不是很乐观 😅。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["threejs","webGL","react"],"series":{"slug":"threejs-howto","name":"细品threejs"}}},{"id":"2020/03/26/Tailwind-CSS.md","slug":"2020/03/26/tailwind-css","body":"\n# [Tailwind](https://tailwindcss.com/) 一个像宏语言的 CSS 解决方案\n\n先把刀放下，我知道，现在已经有 n 种 CSS 的解决方案，而且基本上没有一个用着顺心的。\n\n我记得曾有一段时间，好像是使用 YUI 那会儿，CSS 的 class 往往会命名成布局规则，比如希望一个 div 有 10 像素的留白，就给他添加一个 class，`.margin-10px`，然后对这个 class 的描述为。\n\n```CSS\n.margin-10px {\n    margin: 10px;\n}\n```\n\n当然，这种方式在我入职一段时间后马上消失了，大家都更倾向于使用组件语义化的 class，如显示头像，则把 class 命名为`.avatar`而不是`.margin-10px.padding-5px.radius-50`这种怎么看都不知道是干什么的命名。\n\n于是 CSS 开始和组件越来越近，自从有了 scope CSS， React 和 Vue 的组件库逐渐成形，更多的方案逐渐青睐[CSS in JS](https://cssinjs.org/?v=v10.1.1)，单纯的 CSS 解决方案除了 [bulma](https://bulma.io/) 剩下的就不多了。设计的时候往往要先考虑使用的这个组件库的设计语言能给改造预留出多大的空间，然后再设计。\n\n## 回头想一想\n\n其实把几个 CSS 语句合起来作为一个集合使用并不是错的，现有的 SASS 框架也会用 utils 库专门存储封装好的`@mixins`。想到以前使用[Yo](https://github.com/doyoe/Yo)做前端样式时常会用`@yo-flex('.box'){}`这样的函数，这个函数其实就是将 flex 布局的以及它的降级 box 布局，甚至是优雅降级到不支持 box 布局的样式集合到一起。\n\n如果你认同上面这段话，那么 tailwind 一定是个适合你的工具，个人比较喜欢的是这个工具仅仅基于 postcss，这意味着你不需要使用 SASS（并不是 SASS 不好，只是国内用起来太悲剧，即使已经有 sass dart，但是因为普遍还没支持，每次使用的时候神经都要紧绷一下），它和 SASS 也不冲突。你还可以使用 config 文件来自定义样式（这很像很多 CSS in JS 的样式库，这应该是我喜欢那些库的唯一一点了）。\n\n## 操练起来\n\n[官网安装方式](https://tailwindcss.com/docs/installation)很详细，基本上能提到的工具都提过了。\n\n就拿前面的`.avatar`来举例，使用 tailwind 的代码应如下（注意 tailwind 单位不是 px 而是 rem，这里假定 html 的字体大小为 10px）。\n\n```CSS\n.avatar {\n    @apply m-4;\n    @apply p-2;\n    @apply rounded-full;\n}\n```\n\n这样既满足了，类名的语义化，还能使用 config 文件来统一自己的设计语言，最重要的，如果你拿 houdini 写个什么奇葩的 polyfill，就算预编译器读不懂，他也会容错，毕竟这就是原生 CSS。\n\n至于官网的示例，我个人很不支持，感觉是一种开倒车的方式，但萝卜白菜各有所爱，如果有公司会因为我写那样的代码而给我钱的话，我当然无所谓。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["css","tailwind","postcss"]}},{"id":"2020/03/27/svelte.md","slug":"2020/03/27/svelte","body":"\n# Svelte 让人眼前一亮的前端框架\n\n我觉得必须要介绍一下 [svelte](https://svelte.dev/) 这个框架，确切的说是 svelte v3，这应该是继 [riotjs](http://riot.js.org/)、[typescript](https://www.typescriptlang.org/) 和 [rust](https://www.rust-lang.org/) 之后又一个能给我眼前一亮的感觉的产品了。\n\n## 关于 Svelte\n\n不得不提到他的作者 [Rich Harris](https://github.com/Rich-Harris)，提到他的另一个作品就是大名鼎鼎的 [rollup](http://rollupjs.org/)，这可是第一个提出 tree-shaking 的前端打包器（说实话，这导致我有更多的担忧，svelte 可能会变成像 rollup 一样的小众狂欢）。\n\n回到 svelte，他从 v1 的时候目标就是简单，只不过 v1 版本看起来太像 zepto 了（那我为什么不用原生 JavaScript）。不过 v3 版本这个框架换了个方向，从框架变成了编译器，类似于 riotjs 和 vuejs，组件的 html、css 和 js 可以写在一起，其实我并不是特别推崇这种做法，往往有时候我更倾向于 angularJS 的做法，但是 svelte 的处理真的太完美。\n\n```html\n<script>\n  const hello = \"world\";\n</script>\n\n<h1>{hello}</h1>\n\n<style>\n  h1 {\n    color: black;\n  }\n</style>\n```\n\n看到了吗？没有多出来的 `Vue.extend()`，HTML 和 JavaScript 部分的交互竟然这儿么完美！要是 CSS 再加把力就更好了（不过如果是 CSS in JS 的话...那还是用某个 preprocessor 勉强一下好了）。HTML 模板类似比较简单的 handlebars 语法，甚至支持异步模板。\n\n另外 svelte 没有虚拟 DOM，这一点我有一些相见恨晚，我之前就写过[文章](/fe/2016/03/31/VUE&Riot&React实力比较.html)质疑虚拟 DOM 是不是真的能带来性能提高（结果是性能很差），但是最终被人喷了，导致一年后不得不[弃坑 riotjs 改用 preact](/fe/2017/05/15/弃坑Riot转向Preact.html)。但我始终认为虚拟 DOM 更是一个范式而不是能带来性能提升的神器。所以你代码差，换什么范式，性能都差，喷别人之前先称称自己几斤几两好么？\n\nsvelte 符合响应式模式，这一点和 riotjs 很类似，借助 svelte 这个编译器，写好的组件会被编译成响应式函数。也许拿 riotjs 做比方会比较难，这里拿 react 做比方，在 react 中实现响应式需要使用`setState()`。\n\n```JavaScript\nconst Com = () => {\n    const [state, setState] = useState(1);\n    useEffect(() => setState(state + 1), [])\n    const stateX2 = state*2;\n\n    return (\n    <>\n        <div>{state*2}</div>\n        <div>{stateX2}</div>\n    </>\n    );\n}\n/* 输出\n * <div>2</div>\n * <div>2</div>\n*/\n```\n\n而由于 svelte 是个编译器，svelte 里面不仅代码更少，而且正确的输出了`stateX2`的值。\n\n```HTML\n<script>\nimport { onMount } from \"svelte\";\n\nlet state = 1;\n\nonMount(() =>  state += 1);\n\n$: let stateX2 = state * 2;\n</script>\n\n<div>{state}</div>\n<div>{stateX2}</div>\n\n<!--\n    输出\n    <div>2</div>\n    <div>4</div>\n-->\n```\n\n没错，完全没有多余的代码（其实 svelte 编译器会默默地给`state`增加一个`observable`的配置，但是这都是编译器自己做的，开发者完全不需要考虑）。这里发现`stateX2`前面有一个`$`标识，表明后面的语句是响应式的。这一点真的很巧妙，因为这个语法是 JavaScript 标准里百年不遇的`goto`语句，svelte 高明的使用 JavaScript 原有的语法实现了新的功能，不像某框架愣是加了一个 JSX 语法（不是鄙视 JSX，JSX 也很牛逼的说）。\n\n在 n 多个框架都在模仿 react 的主流下，这个框架还能别出心裁，不得不赞，如果你感兴趣，我强烈推荐浏览他们的[例子](https://svelte.dev/examples#hello-world)。store 和 context 都非常有启发。\n\n最大的缺点就是目前还没有官方的 TypeScript 支持，这一点很有尴尬，因为 svelte 本身就是 TypeScript 写的。不过现在有第三方的[svelte-preprocess](https://github.com/kaisermann/svelte-preprocess)对 TypeScript 提供支持，不知道啥时候转正。\n\n## Sapper\n\nriotjs 同样没有虚拟 DOM，这使得它在 SSR 方面会[有一些问题](https://riot.js.org/documentation/#riot-dom-caveats)，但是 Svelte 提供了一套 SSR 解决方案，[sapper](https://sapper.svelte.dev/) 同时支持 node 渲染和静态发布。\n\nSapper 受 next.js 启发，使用`src/route`文件夹下的文件做路由。\n\n```\nsrc/routes\n    _layout.svelte -- 布局文件\n    _error.svelte  -- 404目录\n    index.svelte   -- /或者/index\n    posts.json.js  -- /post.json，可以使用类似express路由的方式写接口\n```\n\n想要在 index 里面实现 server 端的预加载，可以使用 sapper 的 preload API。\n\n```html\n<script context=\"module\">\n  export async function preload(page, session) {\n    const res = await this.fetch(\"posts.json\");\n    const { posts } = await res.json();\n\n    return { posts };\n  }\n</script>\n```\n\n这样会在`window`上面注入一个`__SAPPER__`变量把 server 端预加载的值赋上去。\n\n因为 sapper 还在 beta 阶段，我也不敢拿来开发什么大项目，但真心想写写 svelte，因为它在很多地方非常有新意，历史包袱也不大，暂时写个 [CSS playground](https://css.gongbushang.com/) 来做 [CSS Secrets](http://shop.oreilly.com/product/0636920031123.do) 的笔记好了。\n\n## 单元测试\n\n[testing-library](https://testing-library.com/docs/svelte-testing-library/intro) 提供单元测试支持，配置起来绝对比 react 和 vue 简单，只是因为比较新，所以没有类似的 create react app 这种官方脚手架，当然如果 sapper 出正式版了就算有了。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["svelte","sapper","JavaScript","rollup"]}},{"id":"2020/03/29/Rust-crate.io.md","slug":"2020/03/29/rust-crateio","body":"\n# Rust 开发更换 crate.io 源\n\n使用 VSCode 开发 Rust 的我，最难过的一刻就是打开编辑器时的 RLS 检查，可以看做它是一个用来检查代码语法的后台程序，在 RLS 的 issue 里面有很多人吐槽他初始化的速度实在是太慢了，然而大佬的回复都是说他们不需要使用这种辅助工具。作为使用 JavaScript 都一定要 TypeScript 编译，打字都是通过语音输入来打字的我来说（没错，这篇博文是语音转换过来的），臣妾做不到啊。\n\nRLS 检查有一个步骤是`cargo check`，这里会链接`crate.io`检查包的完整性。由于`crate.io`的包大多托管在 GitHub，所以外网的宝宝们吐槽的慢只是秒级别的，而中国的宝宝是小时级的 😭。\n\n但是尚有修补的余地，中科大爸爸给国内开发者提供国内的镜像了。修改`~/.cargo/config`增加中科大的源。\n\n```ini\n[source.crates-io]\nregistry = \"https://github.com/rust-lang/crates.io-index\"\nreplace-with = 'ustc'\n\n[source.ustc]\nregistry = \"git://mirrors.ustc.edu.cn/crates.io-index\"\n```\n\n中科大就是我的神啊！开发 Rust 终于可以和国外一样慢了 😂！\n","collection":"blog","data":{"type":"post","category":"fe","tag":["rust","crate.io","ustc","cargo"]}},{"id":"2020/03/30/CSS Secret.md","slug":"2020/03/30/css-secret","body":"\n# CSS Secret 有感\n\n虽然维多利亚的秘密没有了，但是 CSS 的秘密还是可以考虑考虑的，这本书是 2015 年出版的，相比于现在，显然里面的很多属性已经可以做到多平台兼容了，当然里面还没有涉及 grid 布局，强烈推荐 [wesbos 的 grid 课程](https://cssgrid.io/)，虽然看完也是忘 😅。\n\n要说编程算法难学，跟 CSS 比起来还是个弟弟，不仅仅要了解一些拓扑的知识，编出来的图形还得好看。\n\n书中的实现都放在[这里](http://play.csssecrets.io/)，同时我也挑了一些喜欢的[自己实现了一下](http://css.gongbushang.com/)。\n\n书里面涉及到的有\n\n- outline\n- box-shadow\n- background-image（里面提到了一个纯 CSS 实现北京图案的[网站](https://leaverou.github.io/css3patterns/)，值得拥有）\n- background-origin\n- border-image\n- path-clip\n- transform\n- filter\n- font-variable\n- keyframe\n\n目前个人比较感兴趣然而未被涉及的是\n\n- grid\n- css variables\n\n当然这些那会儿都还没有，所以闲着没事儿干的时候还要多逛逛[css-tricks](https://css-tricks.com/)。\n\n还有，在写[svelte](/fe/2020/03/27/svelte一个让人眼前一亮的的前端框架.html)曾经提过如果有一个比较好的 CSS 和 JavaScript 以及 HTML 交互的方法就好了，细想之下 css variables 或许可以。试想如下结构。\n\n```html\n// Back.svelte\n<div class=\"bg\">\n  <slot></slot>\n</div>\n\n<style>\n  .bg {\n    --color: red;\n  }\n</style>\n```\n\n```html\n// Menu.svelte\n<ul>\n  <li>Menu</li>\n</ul>\n\n<style>\n  ul > li {\n    color: var(--color, blue);\n  }\n</style>\n```\n\n```html\n// App.svelte\n<script>\n  import Back from \"Back.svelte\";\n  import Menu from \"Menu.svelte\";\n</script>\n\n<Back>\n  <menu></menu>\n</Back>\n```\n\n此时的 Menu 应该是 Back 里面设置好的红色（我自己没尝试，只是写这个博文的时候临时起意）。这最大的好处显而易见，类似于 react 里面的 theme，`<Back/>`组件给`<Menu/>`组件提供了配合的样式，而不仅仅局限于 JavaScript 传入的数据。\n\n只可惜 CSS variables 需要做向下兼容，而且就算是 postcss 的[postcss-css-variables](https://www.npmjs.com/package/postcss-css-variables)也只能兼容放到`:root`下的变量（那要你有何用囧），不过就[caniuse](https://caniuse.com/#feat=css-variables)的数据，不考虑中国用户的话，确实可以大胆使用 CSS variables，就算是降级估计也没那么难看吧。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["CSS"]}}]}