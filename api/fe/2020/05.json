{"posts":[{"id":"2020/05/04/RN-Flutter-Dart.md","slug":"2020/05/04/rn-flutter-dart","body":"\n# 从 RN 到 Flutter-从 Dart 开始\n\n这是一篇翻译，原文来自于[官方文档](https://flutter.dev/docs/get-started/flutter-for/react-native-devs)，当然，里面夹带私货，哈哈。\n\n## 从 JavaScript 到 Dart\n\n就像 React Native，Flutter 也是用响应式界面。但是 React Native 是链接原生环境，而 flutter 则是直接编译到原生环境中。Flutter 可以控制屏幕上面的每一个像素，可以避免 JavaScript 和原生环境桥的性能问题。\n\nDart 是一个简单的语言，并提供以下功能。\n\n- 提供一个开源可伸缩的开发环境并提供给网页端、服务器端、移动端使用。\n- 提供单继承面向对象的 C 语法支持，并支持 AOT 编译至原生环境。\n- 可翻译到 JavaScript\n- 支持接口和虚基类的数据结构\n\n以下是几处 JavaScript 和 Dart 的不同之处。\n\n### 入口\n\nJavaScript 没有与设定的入口函数。\n\n```js\nfunction startHere() {\n  // 可以用来做入口函数\n}\n```\n\nDart 有一个顶级`main()`函数作为入口函数使用。\n\n```Dart\nmain() {}\n```\n\n在 [DartPad](https://dartpad.dev/0df636e00f348bdec2bc1c8ebc7daeb1) 上使用。\n\n### 打印日志\n\n在 Dart 中打印日志需要使用`print()`函数。\n\n```js\nconsole.log(\"Hello JavaScript!\");\n```\n\n```Dart\nprint(\"Hello Dart!\");\n```\n\n在 [DartPad](https://dartpad.dev/cf9e652f77636224d3e37d96dcf238e5) 试用。\n\n### 变量\n\nDart 是类型安全的——它结合静态类型检查和动态类型检查确保变量总是符合它的静态类型。即使类型是强制的，但类型标识并不是必须的，因为 Dart 会预判类型。\n\n#### 声明变量并赋值\n\n在 JavaScript 中，变量是无类型的（这是原文说的，不是我说的，我不是很同意）。\n\n```js\nvar name = \"JavaScript\";\n```\n\n在 Dart 中，变量必须声明类型，或者让系统能够预判类型。\n\n```Dart\nString name = \"Dart\";\nvar otherName = \"Dart\";\n```\n\n在 [DartPad](https://dartpad.dev/3f4625c16e05eec396d6046883739612) 中试用。\n\n点[这里](https://dart.dev/guides/language/sound-dart)了解 Dart 的类型系统。\n\n#### 默认值\n\n在 Javascript 中，未初始化的变量是`undefined`（他可能指的是函数作用域变量）。\n\n```js\nvar name; // undefined\n```\n\n在 Dart 中，未初始化的变量值为`null`。因为 Dart 中的类型都是对象，所以即使定义了类型但没有赋值它的默认值依然是 null。\n\n```dart\nvar name; // null\nint x; // null\n```\n\n在 [DartPad](https://dartpad.dev/57ec21faa8b6fe2326ffd74e9781a2c7) 使用。\n\n更多关于 [Dart 变量](https://dart.dev/guides/language/language-tour#variables) 的信息。\n\n#### 空值检查和零值检查\n\n在 JavaScript 中非空对象被认为是真值。\n\n```JavaScript\nvar myNull = null;\nif (!myNull) {\n  console.log(\"null是假值\");\n}\nvar zero = 0;\nif (!zero) {\n  console.log(\"0是假值\");\n}\n```\n\nDart 中，只有布尔真值是真值。\n\n```Dart\nvar myNull = null;\nif (myNull == null) {\n  print(\"使用 == null 做空值检查\");\n}\nvar zero = 0;\nif (zero == 0) {\n  print(\"使用 == 0 做零值检查\");\n}\n```\n\n在 [DartPad](https://dart.dev/guides/language/language-tour#variables) 上使用。\n\n#### 函数\n\n两个语言的函数基本上相同。\n\n```JavaScript\nfunction fn() {\n  return true;\n}\n```\n\n不同点是他们的声明。\n\n```dart\n{\n  fn() {\n    return true;\n  }\n}\n\n{// 也能这么写\n  bool fn() {\n    return true;\n  }\n}\n```\n\n在 [DartPad](https://dartpad.dev/5454e8bfadf3000179d19b9bc6be9918) 上使用，点[这里](https://dart.dev/guides/language/language-tour#functions)查看函数细节。\n\n#### 异步开发\n\n##### Futures\n\n和 Javascript 一样，Dart 支持单线程执行。JavaScript 使用 promise 对象处理异步的成功以及失败状态，并获取它的值。\n\n```js\nconst getIp = () =>\n  fetch(\"https://httpbin.org/ip\")\n    .then((res) => res.json())\n    .then(({ origin: { ip } }) => ip);\n\ngetIp()\n  .then((ip) => console.log(ip))\n  .catch((errpr) => console.error(error));\n```\n\n而在 Dart 中，使用 [Future](https://dart.dev/tutorials/language/futures) 对象处理异步。\n\n```Dart\nimport \"dart:convert\";\nimport \"package:http/http.dart\" as http;\n\nFuture<string> getIp() {\n  return http.get(\"https://httpbin.org/ip\")\n    .then((res) {\n      String ip = jsonDecode(res.body)[\"origin\"];\n      return ip;\n    });\n}\n\nmain() {\n  getIp()\n    .then(ip => print(ip))\n    .catchError((error) ==> print(error));\n}\n```\n\n点击[这里](https://dart.dev/tutorials/language/futures)了解 Future 对象。\n\n##### `async` 和 `await`\n\n使用 `async` 标识符声明异步函数。\n\n在 JavaScript 中，`async`函数返回一个`Promise`对象，并使用`await`处理它。\n\n```js\nasync function getIp() {\n  const res = await fetch(\"http://httpbin/ip\");\n  const { origin } = await res.json();\n  return origin;\n}\n\nasync function main() {\n  try {\n    const ip = await getIp();\n    console.log(ip);\n  } catch (e) {\n    console.log(e);\n  }\n}\n```\n\n在 Dart 中，`async`函数返回`Future`类型，函数体会被安排运行，`await`运算符被用来获取`Future`的返回值。\n\n```dart\nimport \"package:http/http.dart\" as http;\nimport \"dart:convert\"\n\nFuture<string> getIp() {\n  final res = await http.get(\"http://httpbin.org/ip\");\n  String ip = jsonDecode(res.body)['origin'];\n  return ip;\n}\n\nmain() async {\n  try {\n    final ip = await getIp();\n    print(ip);\n  } catch(e) {\n    print(e);\n  }\n}\n```\n\n了解更多[async 和 await](https://dart.dev/guides/language/language-tour#asynchrony-support)的信息。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["react-native","flutter","dart"],"series":{"slug":"Flutter-for-RN-devs","name":"从RN到Flutter","number":1}}},{"id":"2020/05/05/RN-Flutter.md","slug":"2020/05/05/rn-flutter","body":"\n# 从 RN 到 Flutter-简单说说\n\n## 如何创建一个 Flutter 应用\n\n创建一个 React Native，可以在终端中使用`create-react-native-typescript-app`，或者`expo-cli`。\n\n```shell\ncreate-react-native-typescript-app <projectname>\n```\n\n使用 Flutter 创建应用，可以采用以下两种方式。\n\n- 使用 IDE 中的 Flutter 和 Dart 插件。\n- 使用`flutter create`命令，请确保 Flutter SDK 已经在 PATH 中，[Windows 用户可以参考此文](/fe/2020/02/21/Windows安装flutter开发环境.html)。\n\n```shell\nflutter create <projectname>\n```\n\n更多内容，可以参考[快速入门](https://flutter.dev/docs/get-started)，入门是一个创建单按钮的计数项目，并能够部署在 Android 和 iOS 设备中的示例应用。\n\n## 如何运行应用\n\n在 React Native 中，你可以使用`npm run`或者`yarn run`。\n\n在 Flutter 中，可以参考如下方式：\n\n- 使用 IDE 中的\"run\"选项。\n- 在项目根目录执行 `flutter run`。\n\n你的应用会在连接好的设备上执行。\n\n更多信息，请参考 Flutter 的[快速入门](https://flutter.dev/docs/get-started)。\n\n## 如何引入部件\n\n在 React Native 中，你需要引入组件。\n\n```JavaScript\nimport React from \"react\";\nimport { StyleSheet, Text, View } from \"react-native\";\n```\n\n在 Flutter 中，需要引入`material.dart`包来使用 Material Design 库中的部件。要使用 iOS 样式的部件则需要引入 Cupertino 库。想使用更多基础部件，需要引入他们的库，或者你也可以自己写一个部件库，并引入。\n\n```Dart\nimport \"package:flutter/material.dart\";\nimport \"package:flutter/cupertino.dart\";\nimport \"package:flutter/widgets.dart\";\nimport \"package:flutter/my_widgets.dart\";\n```\n\n无论你引入了什么包，Dart 只会使用你在应用中使用的部件。\n\n## 写一个和 React Native 中一样的 Hello World 应用\n\n在 React Native 中，`HelloWorldApp`是`React.Component`的一个实现，并返回如下 view 组件实现。\n\n```tsx\nimport React, { FC } from \"react\";\nimport { StyleSheet, Text, View } from \"react-native\";\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: \"#fff\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n});\n\nconst App: FC = () => (\n  <View style={styles.container}>\n    <Text>Hello world!</Text>\n  </View>\n);\n\nexport default App;\n```\n\n在 Flutter 中，创建一个 Hello World 应用需要使用`Center`和`Text`核心部件，`Center`部件在部件树的根部件，并拥有唯一子部件`Text`。\n\n```Dart\nimport \"package:flutter/material.dart\";\n\nmain() {\n  runApp(\n    Center(\n      child: Text(\n        \"Hello World!\",\n        textDirection: TextDirection.ltr,\n      )\n    )\n  );\n}\n```\n\n（卧槽，写 Hello World 还挺简短的，怕不是错觉...）\n\n| Android                                                                                                                                                                | iOS                                                                                                                                                            |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| ![Android展示样式](https://flutter.dev/assets/get-started/android/react-native/hello-world-basic-ed1ed2698fc492892552a8d719b0e124b7a50e2f8e0327f1548e2834b0aa515a.png) | ![iOS展示样式](https://flutter.dev/assets/get-started/ios/react-native/hello-world-basic-1ba3dfcb9fcbee11f5307cde947ab29dd4f52683f311b049242a28fefb37412b.png) |\n\n这就是 Flutter 中最基础的应用，下一个部分将会利用 Flutter 丰富的组件库创建现代应用。\n\n## 如何使用在部件树中增加部件\n\n在 Flutter 中，几乎一切都是部件。\n\n部件是创建用户界面的基础块。部件组成的层级结构叫做部件树。每个部件接入它的父部件，并继承它们的属性。即使应用对象本身也是个部件。并没有分离的\"application\"对象，根部件就是它。\n\n一个部件可以定义如下内容：\n\n- 一个有结构的元素 —— 如一个按钮或菜单。\n- 一个样式元素 —— 如字体或者颜色方案。\n- 一个布局或视角 —— 如边距或者对齐。\n\n如下的例子使用 Material Design 创建部件，在此例子中，部件树链接在`MaterialApp`跟部件下。\n\n```Dart\nimport \"package:flutter/material.dart\";\n\nWidget MyApp() {\n  return MaterialApp(\n    title: \"Welcome to Flutter\",\n    home: Scaffold(\n      appBar: AppBar(\n        title: Text(\"Welcome to Flutter\"),\n      ),\n      body: Center(\n        child: Text(\"Hello world\"),\n      ),\n    ),\n  );\n}\n\nmain() => runApp(MyApp());\n```\n\n如下是使用 Material Design 部件创建的 “Hello world!” 应用。\n\n| Android                                                                                                                                                                             | iOS                                                                                                                                                                          |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| ![Adroid Material Design Hello World](https://flutter.dev/assets/get-started/android/react-native/hello-world-198f4b19ca6d3dd72f6a17dd858814cc42cf2bc696f61d7f273be95818110777.png) | ![iOS Material Design Hello World](https://flutter.dev/assets/get-started/ios/react-native/hello-world-ed7cf47213953bfca5eaa74fba63a78538d782f2c63a7c575068f3c2f7298bde.png) |\n\n写应用的时候，会使用到两种部件`StatelessWidget`和`StatefulWidget`（上面我写的就是`StatelessWidget`不过没有按照面向对象的写法去写）。一个`StatelessWidget`是一个没有状态的部件，它一旦被创建就不会改变。一个`StatefulWidget`会基于数据变化或者用户输入动态改变。\n\n`StatelessWidget`和`StatefulWidget`二者的最大不同点，就是`StatefulWidget`拥有一个`State`对象来存储数据，以避免在部件树渲染的时候丢失。\n\n在简单的项目中，写部件树是容易的，但是当代码变多之后，应用会越来越复杂，你应该将很深的部件封装成函数或者简单的类。创建封装好的函数和类有利于在复杂项目中实现复用。\n\n## 如何创建可复用的组件\n\n在 React Native 中，创建一个可复用的组件，并使用`props`向它传入属性和值。在如下的例子中，`CustomCard`就是个可复用组件。\n\n```tsx\nconst CustomCard: FC<{ index?: number; onPress?: () => void }> = ({\n  index,\n  onPress,\n}) => (\n  <View>\n    <Text>Card {index}</Text>\n    <Button title=\"Press\" onPress={() => onPress()} />\n  </View>\n);\n\n// Usage\n<CustomCard onPress={() => console.log(1)} index={1} />;\n```\n\n在 Flutter 中，可以通过创建一个后浪于（怎么样，这说法阳春不？）部件的类，并实现它的`build`函数，你也可以创建一个函数并复用它。\n\n```dart\nWidget CustomCard({int index, Function onPress}) {\n  return Card(\n    child: Column(\n      children: <Widget>[\n        Text('Card $index'),\n        FlatButton(\n          child: const Text('Press'),\n          onPress: onPress,\n        ),\n      ],\n    ),\n  );\n}\n\n// Usage\nCustomCard(index = 1, onPress = () { print('Card 1'); })\n```\n\n以上`CustomCard`参数的大括号是 Dart[可选参数](https://dart.dev/guides/language/language-tour#optional-parameters)。\n\n在类的构造函数中，可以使用`@required`实现必要参数。\n\n如下截图是`CustomCard`的展示效果。\n\n| Android                                                                                                                                                              | iOS                                                                                                                                                          |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| ![Android CustomCard](https://flutter.dev/assets/get-started/android/react-native/custom-cards-6bdba4664044a9e5328c0304a51c45fc2812bb37b3d0d57b0c93b98d5bab1f42.png) | ![iOS CustomCard](https://flutter.dev/assets/get-started/ios/react-native/custom-cards-47e3e1e3e73a0ce419eacbee11dc2f15b9acac9b5877c43cd1a783a792b519dc.png) |\n","collection":"blog","data":{"type":"post","category":"fe","tag":["react-native","flutter","dart"],"series":{"slug":"Flutter-for-RN-devs","name":"从RN到Flutter","number":2}}},{"id":"2020/05/06/RN-Flutter.md","slug":"2020/05/06/rn-flutter","body":"\n# 从 RN 到 Flutter-部件\n\n在 Flutter 中，你应该使用部件去描述针对于现有状态和配置的界面。\n\n部件是由许多很小或者单一目的的部件组成。比如`Container`部件就包括几个相关布局、绘制、定位和定型组件，像是`LimitedBox`、`ConstrainedBox`、`Align`、`Padding`、`DecoratedBox`以及`Transform`部件。除了使用`Container`来实现效果，你也可以用几个组件来实现它。\n\n`Center`部件是另一个控制布局的例子。想要剧中部件，就用`Center`包住它。这些部件没有自己的展示，他们的目标就是控制内部部件的布局。想要理解部件是如何渲染，可以去查看他们的相邻部件。\n\n了解更多信息，可以查看[Flutter 技术概览](https://flutter.dev/docs/resources/technical-overview)。\n\n想要了解更多部件信息，可以查看[Flutter 基础部件](https://flutter.dev/docs/development/ui/widgets/basics)，[Flutter 部件目录](https://flutter.dev/docs/development/ui/widgets) 或者 [Flutter 部件索引](https://flutter.dev/docs/reference/widgets)。\n\n## 界面\n\n### Flutter 中的 `View` 组件\n\n在 React Native 中，`View`是支持`Flexbox`布局、样式处理、触摸处理和无障碍化的组件。\n\n在 Flutter 中，你可以使用诸如`Container`、`Column Row`和`Center`的核心布局部件。更多信息可以参考[布局部件](https://flutter.dev/docs/development/ui/widgets/layout)目录。\n\n### Flutter 中的 `FlatList` 和 `SectionList` 组件\n\n一个`List`是垂直排布的可滚动列表。\n\n在 React Native 中，`FlatList`和`SectionList`可以用来渲染简单的或者复杂内容的列表。\n\n```tsx\n<FlatList data={[]} renderItem={({ item }) => <Text>{item.key}</Text>} />\n```\n\n`ListView`是 Flutter 中最常被使用的滚动部件。默认的构造器接受一列准确定义的数据。`ListView`适合少量个数部件渲染。对于无限滚动，需要使用`ListView.builder`，它会按需渲染，并之渲染能展示出来的数据。\n\n```dart\nvar data = [];\nListView.builder(\n    itemCount: data.length,\n    itemBuilder: (context, int index) {\n        return Text(data[index]);\n    },\n);\n```\n\n| Adroid ListVIew                                                                                                                                                | iOS ListView                                                                                                                                           |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| ![Android ListView](https://flutter.dev/assets/get-started/android/react-native/flatlist-91d7c8beaadff16f52d663e94aae7b4c9959d1d811dd7f12ea2005a10e166d34.gif) | ![iOS ListView](https://flutter.dev/assets/get-started/ios/react-native/flatlist-2a18c0173248dd8bf250b29fab7e4cdbc917c27d90ac33c1c791ecb73463f3a5.gif) |\n\n阅读[你的第一个 Flutter 应用，第一部分](https://codelabs.developers.google.com/codelabs/first-flutter-app-pt1)更多了解如何实现无限滚动。\n\n### 如何使用画布\n\n在 React Native 中是没有相关组件的，需要引入类似于`react-native-canvas`的第三方组件。\n\n```tsx\nconst App = () => {\n  return (\n    <View>\n      <Canvas\n        ref={(canvas) => {\n          const ctx = canvas.getContext(\"2d\");\n          ctx.fillStyle = \"skyblue\";\n          ctx.beginPath();\n          ctx.arc(75, 75, 50, 0, 2 * Math.PI);\n          ctx.fillRect(150, 100, 300, 300);\n          ctx.stroke();\n        }}\n      />\n    </View>\n  );\n};\n```\n\n在 Flutter 中，你可以使用`CustomPaint`和`CustomPainter`类去绘制画布。\n\n下面的例子展示的是如何使用`CustomPaint`部件绘制。它实现了虚类 `CustomPainter`，并传递了 `CustomPaint` 的属性。`CustomPaint` 的子类必须实现 `paint()` 和 `shouldRepaint()` 方法。\n\n```dart\nclass MyCanvasPainter extends CustomPainter {\n    paint(Canvas anvas, Size size) {\n        {\n            Paint paint = Paint();\n            paint.color = Colors.amber;\n            canvas.drawCircle(Offset(100.0, 200.0), 40.0, paint);\n        }\n        {\n            Paint paint = Paint();\n            paint.color = Colors.lightBlue;\n            Rect rect = Rect.fromPoints(Offset(150.0, 300.0), Offset(300.0, 400.0));\n            canvas.drawRect(rect, paintRect);\n        }\n    }\n    shouldRepaint() => false;\n}\n\nWidget getCanvas() {\n    return Scaffold(\n        body: CustomPaint(\n            paint: MyCanvasPainter(),\n        ),\n    );\n}\n```\n\n| Android CustomPaint                                                                                                                                             | iOS CustomPaint                                                                                                                                         |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| ![Android CustomPaint](https://flutter.dev/assets/get-started/android/react-native/canvas-cf039fc10bae17fb60b21adb4228eb928b2bf284f95fee71c5a20033c217e333.png) | ![iOS CustomPaint](https://flutter.dev/assets/get-started/ios/react-native/canvas-2cc207759f6ab912bf73e1c3298dc2183618ef207ed989f4d83f6c08fd3a3279.png) |\n\n## 布局\n\n### 如何使用布局部件\n\n在 React Native，许多布局可以通过 props 传入。比如，你可以使用`View`的`style`属性去指定 flexbox 布局。想要让组件成列排列，可以指定样式为`flexDirection: \"column\"`。\n\n```JavaScript\n<View\n    style={{\n        flex: 1,\n        flexDirection: \"column\",\n        justifyContent: \"space-between\",\n        alignItems: \"center\"\n    }}\n/>\n```\n\n在 Flutter 中，布局主要是由既定的布局部件和他们的参数实现。\n\n举个例子，`Column`和`Row`组件接受一个数组作为参数来以列或者以行排列。一个`Container`部件既能处理样式也能处理布局，一个`Center`部件可以将组件居中。\n\n```Dart\nCenter(\n    child: Column(\n        children: <Widget> [\n            Container(\n                color: Colors.red,\n                width: 100.0,\n                height: 100.0,\n            ),\n            Container(\n                color: Colors.blue,\n                width: 100.0,\n                height: 100.0\n            ),\n            Container(\n                color: Colors.green,\n                width: 100.0,\n                height: 100.0,\n            ),\n        ],\n    ),\n)\n```\n\nFlutter 提供一堆布局部件，比方说，`Padding`、`Align`和`Stack`。\n\n了解全部的布局部件，可以查看[布局部件](https://flutter.dev/docs/development/ui/widgets/layout)。\n\n| Adroid Layout                                                                                                                                                    | iOS Layout                                                                                                                                               |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| ![Adroid Layout ](https://flutter.dev/assets/get-started/android/react-native/basic-layout-2490ba3bed87bbf579b422977dcaa34f51a5b77dab53abbd460028acda33a000.gif) | ![iOS Layout](https://flutter.dev/assets/get-started/ios/react-native/basic-layout-bb720a0054daf418b7bafb40619c490933b730f9e45bd9003254ea9d80d6c163.gif) |\n\n### 如何堆叠部件\n\n在 React Native，可以使用绝对定位`absolute`来堆叠组件。\n\nFlutter 使用`Stack`部件让部件按照图层分布。部件会部分覆盖于下面的部件。\n\n```dart\nStack(\n    alignment: cont Alignment(0.6, 0.6),\n    children: <Widget>[\n        CircleAvatar(\n            backgroundImage: NetworkImage(\n                'https://avatars3.githubusercontent.com/u/14101776?v=4'\n            )\n        ),\n        Container(\n            decoration: BoxDecoration(\n                color: Colors.black45,\n            ),\n            child: Text(\"Flutter\"),\n        ),\n    ],\n)\n```\n\n上面的例子使用`Stack`来布局一个`Container`并展示一个拥有黑色半透明背景的`Text`部件覆盖于`CircleAvatar`部件。这个部件通过对齐参数来规定文字位置。\n\n| Android Stack                                                                                                                                            | iOS Stack                                                                                                                                        |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------ |\n| ![Android Stack](https://flutter.dev/assets/get-started/android/react-native/stack-65e0c9e7fc3db73d80d3943f6e88fc788819b1ab4c1354c11e4711298e26ecd0.png) | ![iOS Stack](https://flutter.dev/assets/get-started/ios/react-native/stack-04b7bf2727e1eb71f5dfea8430ee833f24be1ced1893ae86270795b2ab76c5b9.png) |\n\n更多信息可以查看`Stack`对象[文档](https://api.flutter.dev/flutter/widgets/Stack-class.html)。\n\n## 样式\n\n### 如何处理组件样式\n\n在 React Native 中，内联样式和`stylesheets.create`是用来处理组件样式的。\n\n```tsx\nconst style = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: \"#fff\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n});\n\n<View style={styles.container}>\n  <Text style={{ fontSize: 32, color: \"cyan\", fontWeight: \"600\" }}>\n    This is a simple text\n  </Text>\n</View>;\n```\n\n在 Flutter 中，`Text`部件可以使用`TextStyle`类，这个类的对象也可以给多个部件复用。\n\n```dart\nvar textStyle = TextStyle(\n    fontSize: 32.0,\n    color: Colors.cyan,\n    fontWeight: FontWeight.w600,\n);\n\nCenter(\n    child: Column(\n        children: <Widget>[\n            Text(\n                'sample text',\n                style: textStyle,\n            ),\n            Padding(\n                padding: EdgeInsets.all(20.0),\n                child: Icon(\n                    Icons.lightbulb_outline,\n                    size: 48.0,\n                    color: Colors.redAccent,\n                ),\n            ),\n        ],\n    ),\n)\n```\n\n| Android Style                                                                                                                                                     | iOS Style                                                                                                                                                 |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| ![Android Style](https://flutter.dev/assets/get-started/android/react-native/flutterstyling-10cfb607a02859b2a1e9767237029b3cc47891fd017bd70d84536de26383b39c.gif) | ![iOS Style](https://flutter.dev/assets/get-started/ios/react-native/flutterstyling-8b812e5226435b0db6f72b4f2f03a7c72b45bf0794965a0bee882fea909fc7b8.gif) |\n\n### 如何使用图标和颜色\n\nReact Native 没有支持图标的库（这点我不是很同意）。\n\n在 Flutter 中，引入 Material 库包含一堆[Material 图标](https://api.flutter.dev/flutter/material/Icons-class.html)和[颜色](https://api.flutter.dev/flutter/material/Colors-class.html)。\n\n```dart\nIcon(Icons.lightbulb_outline, color: COlors.redAccent)\n```\n\n使用`Icons`类时，记住要把`uses-material-design: true`设置在`pubspec.yaml`中。这保证`MaterialIcons`字体会被包括在应用中。\n\n```yaml\nname: my_awesome_application\nflutter:\n  uses-material-design: true\n```\n\nFlutter 的[Cupertino](https://flutter.dev/docs/development/ui/widgets/cupertino)包，完全遵守 iOS 设计语言。要使用`CupertinoIcons`字体，在项目中增加`cupertino_icons`依赖。\n\n```yaml\nname: my_awesome_application\ndependencies:\n  cupertino_icons: ^0.1.0\n```\n\n要完全的自定义组件的色彩和样式，使用`ThemeData`来定义主题。设置`MaterialApp`的`ThemeData`对象。`Colors`类提供遵守 Material 设计语言的调色盘。\n\n```dart\nWidget build() {\n    return MaterialApp(\n        title: \"Sample App\",\n        theme: ThemeData(\n            primarySwatch: Colors.blue,\n            textSelectionColor: Colors.red,\n        ),\n        home: SampleAppPage()\n    );\n}\n```\n\n### 如何增加主题样式\n\n在 Ract Native，主题是组件定义好的。\n\n在 Flutter 中，使用`ThemeData`类为整个`MaterialApp`部件提供主题。\n\n```dart\nWidget build() {\n    return MaterialApp(\n        title: \"Sample App\",\n        theme: ThemeData(\n            primarySwatch: Colors.blue,\n            textSelectionColor: Colors.red,\n        ),\n        home: SampleAppPage()\n    );\n}\n```\n\n一个`Theme`甚至可以不依赖于`MaterialApp`部件。[Theme](https://api.flutter.dev/flutter/material/Theme-class.html)部件需要一个`ThemeData`传入它的`data`参数中，以适配它的所有子部件。\n\n```dart\nclass SampleTheme extends StatelessWidget {\n    Widget build(BuildContext context) {\n      return Theme(\n           data: ThemeData(\n               primaryColor: Colors.cyan,\n               brightness: brightness,\n           ),\n           child: Scaffold(\n               backgroundColor: Theme.of(context).primaryColor,\n           )\n       )\n    }\n}\n```\n","collection":"blog","data":{"type":"post","category":"fe","tag":["react-native","flutter","dart"],"series":{"slug":"Flutter-for-RN-devs","name":"从RN到Flutter","number":4}}},{"id":"2020/05/07/RN-Flutter.md","slug":"2020/05/07/rn-flutter","body":"\n# 从 RN 到 Flutter-路由器\n\n> 我要死了，这个系列怎么这么长。\n\n许多应用都有多个页面来展示不同信息。比方说，你可能在页面展示一个产品的图片，当用户点击时打开这个产品的详情。\n\n在 Android，新的页面叫做 Activities。在 iOS 新的页面叫 ViewControllers，在 Flutter，新的页面也是部件！包括导航至这些页面的导航器也是导航器部件。\n\n## 如何在页面中导航\n\n在 React Native 里面，有三个导航器`StackNavigator`，`TabNavigator`和`DrawerNavigator`。都提供了配置的接口。\n\n```js\n// React Native\nconst MyApp = TabNavigator(\n  { Home: { screen: HomeScreen }, Notifications: { screen: tabNavScreen } },\n  { tabBarOptions: { activeTintColor: \"#e91e63\" } }\n);\nconst SimpleApp = StackNavigator({\n  Home: { screen: MyApp },\n  stackScreen: { screen: StackScreen },\n});\nexport default MyApp1 = DrawerNavigator({\n  Home: {\n    screen: SimpleApp,\n  },\n  Screen2: {\n    screen: drawerScreen,\n  },\n});\n```\n\n在 Flutter 中，有两个部件用于处理页面路由。\n\n- `Route` 是页面的抽象。\n- `Navigator` 是管理路由的部件。\n\n`Navigator`通过将一列页面以堆的方式覆盖，并提供方法管理这个堆，像是[Navigator.push](https://api.flutter.dev/flutter/widgets/Navigator/push.html)和[Navigator.pop](https://api.flutter.dev/flutter/widgets/Navigator/pop.html)。[MaterialApp](https://api.flutter.dev/flutter/material/MaterialApp-class.html) 部件提供 routes 参数接受这些路由，这些路由可能会明确指出或者动态生成，比如标题动画。下面是一个指明路由的例子。\n\n```dart\nclass App extends StatelessWidget{\n    Widget build(BuildContext: context) {\n        return MaterialApp(\n           routes: <String, WidgetBuilder> {\n                '/a': (BuildContext: context) => usualNavscreen(),\n                '/b': (BuildContext: context) => drawerNavscreen(),\n          },\n       ),\n    }\n}\n```\n\n使用`Navigator.of()`并指定一个`BuildContext`来处理导航，比如前往某个特定页面，可以使用`pushNamed`。\n\n```dart\nNavigator.of(context).pushNamed('/a');\n```\n\n你可以使用`push`方法调用已存在的[Route](https://api.flutter.dev/flutter/widgets/Route-class.html)，这样会动画打开 Route。下面的例子中[MaterialPageRoute](https://api.flutter.dev/flutter/material/MaterialPageRoute-class.html)提供一个模态的页面，并适配系统动画。\n\n```dart\nNavigator.push(context, MaterialPageRoute(builder: (BuildContext context)\n => UsualNavscreen()));\n```\n\n## 如何使用选项卡和抽屉导航\n\n在 Material 设计语言中，为 Flutter 提供了两种导航选项，tab 和 drawer。如果空间使用 tab 很紧张，则 drawer 是个不错的替代。\n\n### 选项卡导航\n\n在 React Native 中，`createBottomTabNavigator`和`TabNavigation`被用来处理选项卡和导航。\n\n```js\nimport { createBottomTabNavigator } from \"react-navigation\";\n\nconst MyApp = TabNavigator(\n  { Home: { screen: HomeScreen }, Notifications: { screen: tabNavScreen } },\n  { tabBarOptions: { activeTintColor: \"#e91e63\" } }\n);\n```\n\nFlutter 提供特别的部件处理抽屉和选项卡导航。\n\n- [TabController](https://api.flutter.dev/flutter/material/TabController-class.html)\n\n  提供`TabBar`和`TabBarView`的控制器\n\n- [TabBar](https://api.flutter.dev/flutter/material/TabBar-class.html)\n\n  展示横向的选项卡\n\n- [Tab](https://api.flutter.dev/flutter/material/Tab-class.html)\n\n  展示 Material 设计语言的单一选项\n\n- [TabBarView](https://api.flutter.dev/flutter/material/TabBarView-class.html)\n\n  展示选中的选项卡\n\n```dart\nTabController controller = TabController(length: 2, vsync: this);\n\nTabBar(\n    tabs: <Tab>[\n        Tab(icon: Icon(Icons.person),),\n        Tab(icon: Icon(Icons.email),),\n    ],\n    controller: controller,\n),\n```\n\n一个`TabController`用于协调`TabBar`和`TabBarView`。构造参数中的`length`属性，提供选项卡的个数。一个`TickerProvider`被用来处理框架状态变化的消息的，通过`vsync`传入。`vsync:this`参数是创建`TabController`必要的。\n\n[TickerProvider](https://api.flutter.dev/flutter/scheduler/TickerProvider-class.html)是可以产生[Ticker](https://api.flutter.dev/flutter/scheduler/Ticker-class.html)对象的类的接口。Ticker 是可以用来接收框架消息的对象，但是他们基本上都是间接通过[AnimationController](https://api.flutter.dev/flutter/animation/AnimationController-class.html)。`AnimationController`需要`TickerProvider`来获取`Ticker`对象。如果你正在从 State 里面创建一个 AnimationController，你可以使用[TickerProviderStateMixin](https://api.flutter.dev/flutter/widgets/TickerProviderStateMixin-mixin.html)或者[SingleTickerProviderStateMixin](https://api.flutter.dev/flutter/widgets/SingleTickerProviderStateMixin-mixin.html)对象以得到`TrickerProvider`。如果你用的是`flutter-hooks`你可以使用`useSingleTickerProvider`获取`Ticker`对象。\n\n[Scaffold](https://api.flutter.dev/flutter/material/Scaffold-class.html)部件封装了一个新的`TabBar`部件并创建两个选项卡。`TabBarView`部件通过`body`参数传入。所有页面的`TabBar`都是`TabBarView`部件的子部件。\n\n```dart\nclass Home extends StatefulWidget {\n  Home() : super();\n  @override\n  State<StatefulWidget> createState() {\n    return _Home();\n  }\n}\n\nclass _Home extends State<Home> with SingleTickerProviderStateMixin {\n  @override\n  Widget build(BuildContext context) {\n    TabController controller = TabController(length: 2, vsync: this);\n    return Scaffold(\n        appBar: AppBar(\n          title: Text('home'),\n        ),\n        bottomNavigationBar: Material(\n          color: Colors.blue,\n          child: TabBar(\n            controller: controller,\n            tabs: <Tab>[\n              Tab(\n                icon: Icon(Icons.person),\n              ),\n              Tab(\n                icon: Icon(Icons.email),\n              )\n            ],\n          ),\n        ),\n        body: TabBarView(\n          children: <Widget>[\n            Center(\n              child: Text('person'),\n            ),\n            Center(\n              child: Text('email'),\n            )\n          ],\n          controller: controller,\n        ));\n  }\n}\n\n```\n\n当然也可以使用`flutter-hooks`，其实如果收拾一下的话都要写两个类，就看你爱怎么写了。\n\n```dart\nclass Home extends HookWidget {\n  @override\n  Widget build(BuildContext context) {\n    final vsync = useSingleTickerProvider();\n    final controller = useMemoized(() {\n      return TabController(length: 2, vsync: vsync);\n    });\n\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Home'),\n      ),\n      bottomNavigationBar: Material(\n        color: Colors.blue,\n        child: TabBar(\n          controller: controller,\n          tabs: <Widget>[\n            Tab(icon: Icon(Icons.person)),\n            Tab(icon: Icon(Icons.email))\n          ],\n        ),\n      ),\n      body: TabBarView(\n        controller: controller,\n        children: <Widget>[\n          Center(child: Text(\"person\")),\n          Center(\n            child: Text(\"email\"),\n          )\n        ],\n      ),\n    );\n  }\n}\n\n```\n\n## 抽屉导航\n\n在 React Native 中，需要引入`react-navigation`包，并使用`createDrawerNavigator`和`DrawerNavigation`。\n\n```js\nexport default MyApp = DrawerNavigator({\n  Home: {\n    screen: SimpleApp,\n  },\n  Screen2: {\n    screen: drawScreen,\n  },\n});\n```\n\n在 Flutter 中，我们可以使用`Drawer`部件结合`Scaffold`部件创建 Material 设计语言的抽屉。想要创建一个带有抽屉的应用，需要将`Drawer`封装至`Scaffold`中。`Scaffold`部件提供一套基于[Material 设计标准](https://material.io/design)的样式结构，并且还支持许多特殊的 Material 设计组件，比如`Drawer`、`AppBar`和`SnackBar`。\n\n`Drawer`部件是一个基于 Material 设计的控制台，它在`Scaffold`水平方向的边缘，展示应用的导航链接。你可以在这个部件中使用[RaisedButton](https://api.flutter.dev/flutter/material/RaisedButton-class.html)和[Text](https://api.flutter.dev/flutter/widgets/Text-class.html)组件，或者一个列表。在下面的例子中[ListTile](https://api.flutter.dev/flutter/material/ListTile-class.html)就提供了点击导航的功能。\n\n```dart\n// Flutter\nDrawer(\n  child:ListTile(\n    leading: Icon(Icons.change_history),\n    title: Text('Screen2'),\n    onTap: () {\n      Navigator.of(context).pushNamed('/b');\n    },\n  ),\n  elevation: 20.0,\n),\n```\n\n在`Scaffold`部件的`AppBar`会自动适配给`Drawer`一个图标，并且`Scaffold`能够自动处理`Drawer`的左滑手势。\n\n```dart\n// Flutter\n@override\nWidget build(BuildContext context) {\n  return Scaffold(\n    drawer: Drawer(\n      child: ListTile(\n        leading: Icon(Icons.change_history),\n        title: Text('Screen2'),\n        onTap: () {\n          Navigator.of(context).pushNamed('/b');\n        },\n      ),\n      elevation: 20.0,\n    ),\n    appBar: AppBar(\n      title: Text('Home'),\n    ),\n    body: Container(),\n  );\n}\n```\n\n另外，如果不爽页面转场动画单一，然后自己又懒得写动画，可以直接用[page_transition](https://pub.dev/packages/page_transition)包。\n\n| Android Drawer                                                                                                                                                 | iOS Drawer                                                                                                                                             |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| ![Android Drawer](https://flutter.dev/assets/get-started/android/react-native/navigation-98906732ed22d9aa8e0ce0eb846dbcc7d24c123ad026c359f9f7fcc44ba99230.gif) | ![iOS Drawer](https://flutter.dev/assets/get-started/ios/react-native/navigation-1939f60628bec820bad0fe88d58c562984c1c00d8cfd755a4135f4321a37417e.gif) |\n","collection":"blog","data":{"type":"post","category":"fe","tag":["React-Native","flutter"],"series":{"slug":"Flutter-for-RN-devs","name":"从RN到Flutter","number":6}}},{"id":"2020/05/08/RN-Flutter.md","slug":"2020/05/08/rn-flutter","body":"\n# 从 RN 到 Flutter-动画\n\n好的动画会使 UI 更加直观，是应用更加精致，并提高用户体验。Flutter 的动画使简单动画和复杂动画的实现变得容易。Flutter SDK 所遵守的 Material 设计语言包含了标准的动态效果，你可以简单地自定义它们并应用于你的应用。\n\n在 React Native 中，Animated API 被应用于创建动画。\n\n在 Flutter 中，使用[Animation](https://api.flutter.dev/flutter/animation/Animation-class.html)类和[AnimationController](https://api.flutter.dev/flutter/animation/AnimationController-class.html)类。`Animation`是包括一个动画初始状态到它终态（完成或者取消）状态的抽象类。`AnimationController`类控制动画的执行、反转或者停止动画，乃至于设置动画为某一个值以做到自定义的目的。\n\n## 实现一个淡入动画\n\n下面的 React Native 例子是利用 Animated API 创建的`FadeInView`组件。初始状态、终止状态已经过程都需要定义。该组件包裹需要动画的组件，透明值`fadeAnim`向下继承到`Text`组件中，使得执行`start()`后，动画就开始了。\n\n```js\n// React Native\nclass FadeInView extends React.Component {\n  state = {\n    fadeAnim: new Animated.Value(0) // Initial value for opacity: 0\n  };\n  componentDidMount() {\n    Animated.timing(this.state.fadeAnim, {\n      toValue: 1,\n      duration: 10000\n    }).start();\n  }\n  render() {\n    return (\n      <Animated.View style={{...this.props.style, opacity: this.state.fadeAnim }} >\n        {this.props.children}\n      </Animated.View>\n    );\n  }\n}\n    ...\n<FadeInView>\n  <Text> Fading in </Text>\n</FadeInView>\n    ...\n```\n\n想在 Flutter 中实现相应效果，需要创建一个 [AnimationController](https://api.flutter.dev/flutter/animation/AnimationController-class.html) 对象，命名为`controller`并指明持续时间。默认`AnimationController`会在持续时间内线性执行动画。这个动画控制器在每一帧都会返回一个新值，默认是每秒 60 个值。\n\n使用`AnimationController`时，必须传入`vsync`对象。引入`vsync`的目的是避免不在屏幕上的动画浪费资源。你可以使用你的状态机作为`vsync`，只要在类定义的时候混入`TickerProviderStateMixin`。一个`AnimationController`构造时需要一个 TickerProvider 作为`vsync`参数。\n\n[Tween](https://api.flutter.dev/flutter/animation/Tween-class.html)描述初始值和结束值之间的插值。动画中使用`Tween`对象，可以将`Tween`的`animate()`返回值传给要修改的`Animation`对象。\n\n使用`controller.forward()`开始动画。其他操作如`fling()`和`repeat()`也可以开始动画。比如下面的例子，将[FlutterLogo](https://api.flutter.dev/flutter/material/FlutterLogo-class.html)部件放在`FadeTransition`部件中。\n\n```dart\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(Center(child: LogoFade()));\n}\n\nclass LogoFade extends StatefulWidget {\n  _LogoFadeState createState() => _LogoFadeState();\n}\n\nclass _LogoFadeState extends State<LogoFade> with TickerProviderStateMixin {\n  Animation animation;\n  AnimationController controller;\n\n  initState() {\n    super.initState();\n    controller = AnimationController(\n        duration: const Duration(milliseconds: 3000), vsync: this);\n    final CurvedAnimation curve =\n    CurvedAnimation(parent: controller, curve: Curves.easeIn);\n    animation = Tween(begin: 0.0, end: 1.0).animate(curve);\n    controller.forward();\n  }\n\n  Widget build(BuildContext context) {\n    return FadeTransition(\n      opacity: animation,\n      child: Container(\n        height: 300.0,\n        width: 300.0,\n        child: FlutterLogo(),\n      ),\n    );\n  }\n\n  dispose() {\n    controller.dispose();\n    super.dispose();\n  }\n}\n```\n\n也可以把动画的实现封装成 hook。\n\n```dart\nAnimation useFadeIn() {\n  final ticker = useSingleTickerProvider();\n  final controller = useMemoized(() => AnimationController(\n      duration: const Duration(milliseconds: 3000), vsync: ticker));\n  final animation = useMemoized(() => Tween(begin: 0.0, end: 1.0)\n      .animate(CurvedAnimation(parent: controller, curve: Curves.easeIn)));\n\n  useEffect(() {\n    controller.forward();\n    return () => controller.dispose();\n  });\n\n  return animation;\n}\n```\n\n| Android fadeIn                                                                                                                                                   | iOS fadeIn                                                                                                                                               |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| ![Android fadeIn](https://flutter.dev/assets/get-started/android/react-native/flutter-fade-241787290a9da1d7406516a96845a65c42c97b5a8219f4ff29f0c3412ab281ba.gif) | ![iOS fadeIn](https://flutter.dev/assets/get-started/ios/react-native/flutter-fade-2596d382757ecf7c4a2db020871d715da585db9fabed9956cbff6ef011b2786b.gif) |\n\n## 为卡片增加滑动关闭动画\n\n在 React Native 里，可以使用如`PanResponder`或者第三方库实现华东关闭。\n\n在 Flutter 中，为部件增加滑动动画可以使用[Dismissible](https://api.flutter.dev/flutter/widgets/Dismissible-class.html)部件。\n\n```dart\nchild: Dismissible(\n  key: key,\n  onDismissed: (DismissDirection dir) {\n    cards.removeLast();\n  },\n  child: Container(\n    ...\n  ),\n),\n```\n\n| Android Dismissable                                                                                                                                                 | iOS dismissable                                                                                                                                             |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| ![Android Dissmisable](https://flutter.dev/assets/get-started/android/react-native/card-swipe-20a57fe25c2e274bfbe0e9f3d4d1aebd5443fc9d2ce81bd6e9d2588e94e28b16.gif) | ![iOS Dismissible](https://flutter.dev/assets/get-started/ios/react-native/card-swipe-ed0bd70d7698b81793f2a44bea69ddf51be44ac486e8410961aabff16176e3ce.gif) |\n\n啊啊啊啊，这个系列翻译完了！！！后面还有一个 Flutter 和 React Native 组件的[对照表格](https://flutter.dev/docs/get-started/flutter-for/react-native-devs#react-native-and-flutter-widget-equivalent-components)，我就不贴上来了。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["React-Native","flutter"],"series":{"slug":"Flutter-for-RN-devs","name":"从RN到Flutter","number":8}}},{"id":"2020/05/10/Flutter.md","slug":"2020/05/10/flutter","body":"\n# Flutter 的手表应用-从入门到放弃\n\n这是一个写得一头沮丧的文章，可能是期待值比较高吧，所以任何一个想用 Flutter 写 wearOS 的朋友都要注意一点，他能写，但可能没那么好。这篇文章本来想参考[Flutter: Building Wear OS app](https://medium.com/flutter-community/flutter-building-wearos-app-fedf0f06d1b4)，因为`wear`这个包已经年久失修不支持最新的 SDK（我天，这可是 2019 年 6 月的文章），于是后来参考[Experimenting with Flutter on Wear OS](https://medium.com/@mjohnsullivan/experimenting-with-flutter-on-wear-os-f789d843f2ef)。如果不想踩坑，只是想写个应用截图发朋友圈的话，直接 clone[这个 repo](https://github.com/sbis04/flutter_os_wear)就好，热爱生命，避免折腾，哈哈。\n\n## 可以用 Flutter 来写手表应用吗\n\n答案是可以的，而且还意料之外地能用。首先要在本机安装模拟器（注意不要安装中国版，中国版真的会卡住）。然后直接运行 flutter 的官方示例就可以了。\n\n![模拟器下的Flutter示例](./2020-05-10-flutter-watch.png)\n\n## 表盘形状\n\n在 Flutter 中可以使用 MediaQuery 获取到屏幕的大小：\n\n```dart\nfinal screenSize = MediaQuery.of(content).size;\nfinal screenHeight = screenSize.height;\nfinal screenWidth = screenSize.width;\n```\n\n但是不能获取到表盘的形状，但是可以通过 kotlin 从安卓 Wear OS 的库里面获取。Flutter 为 Dart 提供了一个支持双向传输的数据通道[MethodChannels](https://flutter.io/platform-channels/)，比起 QML，这更像 JS bridge 的实现，因为这些数据是异步传输的，这些数据也可以通过流传输[EventChannels](https://docs.flutter.io/flutter/services/EventChannel-class.html)。\n\n在安卓的 MainActivity 中可以调用如下方法向 Flutter 传递表盘状态，注意因为是 Wear OS，所以在`Android/app/build.gradle`修改`minSdkVersion`为 23，并在以下依赖中增加以下项目。\n\n```gradle\ndependencies {\n    ...\n    implementation 'com.android.support:wear:27.1.1'\n    implementation 'com.google.android.support:wearable:2.3.0'\n    compileOnly 'com.google.android.wearable:wearable:2.3.0'\n    ...\n}\n```\n\n`AndroidManifest.xml`中打开权限。\n\n```xml\n<!-- Required for ambient mode support -->\n<uses-permission android:name=\"android.permission.WAKE_LOCK\" />\n\n<!-- Flags the app as a Wear app -->\n<uses-feature android:name=\"android.hardware.type.watch\" />\n\n<!-- Flags that the app doesn't require a companion phone app -->\n<application>\n<meta-data\n    android:name=\"com.google.android.wearable.standalone\"\n    android:value=\"true\" />\n</application>\n```\n\n```kotlin\nprivate fun setShapeMethodChannel() {\n  MethodChannel(flutterView, shapeChannel).setMethodCallHandler { _, result ->\n    setOnApplyWindowInsetsListener(flutterView, {_, insets: WindowInsetsCompat? ->\n      if (insets?.isRound == true) {\n        result.success(0)\n      }\n      else {\n        result.success(1)\n      }\n      WindowInsetsCompat(insets)\n    })\n    requestApplyInsets(flutterView)\n  }\n}\n```\n\n在 Dart 部分通过监听 channel 获得形状\n\n```dart\nenum Shape { square, round };\nShape shape;\ntry {\n  final int result = await platform.invokeMethod('shape');\n  shape = result == 1 ? Shape.square : Shape.round;\n} on PlatformException catch (e) {\n  // Default to round\n  print('Error detecting shape: $e');\n  shape = Shape.round;\n}\n```\n\n## 省电模式(Ambient mode)\n\n手表耗电是很棘手的，所以安卓手表的应用都会选择支持长期显示时进入省电模式（我就惊了，你说用电子纸多好，偏偏所有人都用 LED，又不是拿手表看片，要那么好的显示搞什么？）。\n\n可以在 kotlin 部分获取省电模式的事件并通过 channel 传给 dart。\n\n```kotlin\nclass MainActivity: FlutterActivity(), AmbientMode.AmbientCallbackProvider {\n    private var mAmbientController: AmbientMode.AmbientController? = null\n    override fun onCreate(savedInstanceState: Bundle?) {\n        // Set the Flutter ambient callbacks\n        mAmbientController = AmbientMode.attachAmbientSupport(this)\n    }\n    override fun getAmbientCallback(): AmbientMode.AmbientCallback {\n        return FlutterAmbientCallback(flutterView)\n    }\n}\n\nprivate class FlutterAmbientCallback(val flutterView: FlutterView): AmbientMode.AmbientCallback() {\n    override fun onEnterAmbient(ambientDetails: Bundle) {\n        MethodChannel(flutterView, ambientChannel).invokeMethod(\"enter\", null)\n        super.onEnterAmbient(ambientDetails)\n    }\n    override fun onExitAmbient() {\n        MethodChannel(flutterView, ambientChannel).invokeMethod(\"exit\", null)\n        super.onExitAmbient()\n    }\n    override fun onUpdateAmbient() {\n        MethodChannel(flutterView, ambientChannel).invokeMethod(\"update\", null)\n        super.onUpdateAmbient()\n    }\n}\n```\n\n在 Dart 部分处理事件。\n\n```dart\n@override\ninitState() {\n    super.initState();\n    platformAmbient.setMethodCallHandler((call) {\n        switch (call.method) {\n            case 'enter':\n                setState(() => ambientMode = Mode.ambient);\n            break;\n        case 'update':\n            if (widget.update != null)\n                widget.update();\n            else\n                setState(() => ambientMode = Mode.ambient);\n        break;\n        case 'exit':\n            setState(() => ambientMode = Mode.active);\n        break;\n    }\n  });\n}\n```\n\n## 总结\n\nFlutter 能写安卓应用吗？能，而且比不好用要强得多。但是如果想写出 apple watch 的应用那种，还是道阻且长。不过考虑 wear OS 本身自己的应用都不咋地，感兴趣玩一下还是可以的。\n\n另外 Flutter 没有为 wearOS 设计 Material 设计语言的部件，所以都要自己设计（虽然屏幕也就 1~2 英寸）。也没有左滑后退的能力，只能在界面增加一个后退按钮，如果用户不小心左滑了，应用就关闭了（尴尬）。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["flutter","wearOS"]}},{"id":"2020/05/12/flutter-CICD.md","slug":"2020/05/12/flutter-cicd","body":"\n# 多平台上的 flutter 以及 CICD\n\nFlutter 是一个号称面向全平台的框架，既然立了 flag，早晚要去摘的。除了 iOS 和 Android，beta 版本的 flutter 还支持 web 网页以及 mac 桌面端，alpha（master 分支）版本还提供 Windows 和 Linux 桌面端的支持，本篇除了介绍 flutter 在各端如何开发发布还会提及如何通过 CICD 发布安卓 apk，以及这段时间使用 Flutter 的感想。\n\n## Web 支持\n\nWeb 应该是 dart 语言一直想抢的蛋糕，在早期 chrome 上面就有 dart VM，甚至提供了 dart2js 这样的工具，所以 Flutter 在一炮走红之后立刻提供 web 支持是不意外的。\n\n创建 Web 端的 Flutter 应用，以下几项是必须的：\n\n- 安装 Flutter SDK\n- Chrome 浏览器\n- 一个支持开发 Flutter 的编辑器\n\n确定以上几项后执行下面命令切换 Flutter 到 beta 版本，并打开 Web 端支持。\n\n```shell\n flutter channel beta\n flutter upgrade\n flutter config --enable-web\n```\n\n以上命令执行成功后执行`flutter devices`应该能看到 Chrome 浏览器和 Web 伺服器的支持。\n\n打开任何一个 Flutter 项目的根目录，执行`flutter run -d chrome`，稍等片刻 chrome 会被自动打开并渲染项目（这个体验很割裂，真的，这个片刻其实比较久，而且你的终端会不会显示任何东西）。\n\n执行`flutter build web`就会编译项目至`/build/web`文件夹下。\n\n### Web 支持总结\n\n编译 web 应用已经相对稳定，基本上你老姑（谷歌）想要的功能也都有（比如 service-worker 什么的），但因为是 js 渲染，SEO 什么的可能没 SSR 项目号，再一个，我在使用的时候没发现有 sourcemap，估计 debug 的方法也会和普遍 web 应用不太一致。\n\n## Windows 桌面支持\n\n到 Flutter 的目录下，将它 checkout 到 master 分支，此时执行`flutter doctor`，它会检查你是否安装`Visual Studio`、`MSVC`以及`Windows10 SDK`（当然了，这是在 Windows 下面执行才有），没错，alpha 版本的 flutter 已经可以编译 Windows 桌面应用了，只需安装社区版的`Visual Studio`，在安装项里面添加`Clang`、`MSVC`和`Windows10 SDK`即可。\n\n另外还需要在项目中增加[flutter desktop embedding](https://github.com/google/flutter-desktop-embedding)，尝试到这里我有点失望，看了这个项目的 issue，目前 Windows 的桌面支持还是用 Win32 的 API，项目正在计划使用 UWP 来替换。同样 Linux 桌面也在纠结于到底使用 QT 还是 GTK 做框架，因此这两个桌面端的支持相较于 Mac 延后。\n\n## flutter-rs\n\n这是我的另一个 Flag，几个月前我在尝试用 rust 写桌面应用，几个平台都不理想，于是尝试了这个包。然而[flutter-rs](https://github.com/flutter-rs/flutter-rs)依然不太理想，不过更多原因可能是因为这个项目还在 WIP 阶段。\n\n目前 rust 推荐在 WSL 上面开发，考虑到 WSL1 对图形的支持不太好，我更新了[WSL2](https://aka.ms/wsl2kernel)的内核，并使用 Ubuntu 20.04 开发。\n\n这里注意下，WSL2 是完整的 Linux 内核，所以代理什么的都不能使用 WSL1 里面的`localhost`。\n\n```shell\nexport WSL_VERSION=$(wsl.exe -l -v | grep -a '[*]' | sed 's/[^0-9]*//g')\nexport WSL_HOST=$(tail -1 /etc/resolv.conf | cut -d' ' -f2)\nexport DISPLAY=$WSL_HOST:0\n\nexport HTTP_PROXY=http://$WSL_HOST:1080\nexport HTTPS_PROXY=http://$WSL_HOST:1080\nexport NO_PROXY=127.0.0.1,localhost,$WSL_HOST\n```\n\n同样在运行`vcXsrv`时也要加上`-ac`参数已打开远端支持。\n\n安装编译`flutter-rs`需要很多依赖，\n\n```shell\nsudo apt install build-essential libssl-dev pkg-config libxcb-util-dev libxcb-render-util0-dev libxcb-shape0-dev libxcb-xfixes0-dev libclang-dev libglfw3\n\ncargo install flutter-rs\n```\n\n尴尬的来了，执行`cargo flutter run`，打开的 flutter 窗口闪了一下就崩溃了...查了下，好像是 Skia 在 rust 上面链接的问题，哎，不跟进了。\n\n## hover\n\n那么就没有一个能稳定点的桌面端方案了么？有！go 提供了一套 API 接口[hover](https://hover.build/)也叫[go-flutter](https://github.com/go-flutter-desktop/go-flutter)，框架是 GLFW。\n\n在 MSYS 里面就可以安装 golang（太好了，WSL 下面编译 GUI 不敢恭维啊）。\n\n```shell\npacman -S mingw-w64-x86_64-go\n```\n\n初次运行提示找不到 go 命令，貌似`mingw-w64`不在 PATH 上，查了好多都没找到原因，干脆直接添加上好了。\n\n```shell\nexport PATH=/c/tools/msys64/mingw64/bin:$PATH\n```\n\n下面安装 hover\n\n```shell\nGO111MODULE=on go get -u -a github.com/go-flutter-desktop/hover\n```\n\n随便找个已有的 flutter 项目，执行`hover run`，它会询问你是否增加一段 fushia 的代码`lib/main_desktop.dart`，没错，所有的 desktop 端都叫 fushia，它也是桌面端的入口文件，直接回复 Y 即可。\n\n和 flutter 的命令类似，执行`hover build windows`就会在`/build/output/windows`下生成编译好的可执行文件。\n\nhover 相对来说是目前唯一比较成熟的 Flutter 桌面运行时了，更多内容可以查看它的[文档](https://github.com/go-flutter-desktop/hover)。但是运行结果不能说如意，比如在处理改变窗口大小时，界面不会跟着鼠标变化，直到释放之后才会改变，这对于 2020 年的人类来说，体验真是不够好，但是运行起来确实是比 electron 好些，起码笔记本风扇没有疯狂打转。\n\n### Windows 桌面支持总结\n\n在官方支持遥遥无期的情况下，桌面支持真是百花齐放，不过另一方面微软爸爸直接提供亲生的[React Native Windows](https://github.com/Microsoft/react-native-windows)可是支持 UWP 下面的 Fluent Design 哦，所以在多段支持上，起码 Windows 这里，React Native 略胜一筹。\n\n## CICD\n\n本来想写一下测试的，结果发现没啥新东西。干脆提一下利用 Github action 做 CICD 好了。（其实基本上就复制[别人](https://github.com/nabilnalakath/flutter-githubaction)的`/.github/workflows`文件夹就好，白嫖很开心）。\n\n```yaml\non: push\nname: Test, Build and Release apk\njobs:\n  build:\n    name: Build APK\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v1\n      - uses: actions/setup-java@v1\n        with:\n          java-version: \"12.x\"\n      - uses: subosito/flutter-action@v1\n        with:\n          flutter-version: \"1.7.8+hotfix.4\"\n      - run: flutter pub get\n      - run: flutter test\n      - run: flutter build apk --debug --split-per-abi\n      - name: Push APK to Releases\n        uses: ncipollo/release-action@v1\n        with:\n          artifacts: \"build/app/outputs/apk/debug/*.apk\"\n          token: ${{ secrets.TOKEN }}\n```\n\n## 总结\n\nFlutter 相对于 React Native 的确有性能上的优势，毕竟跳过了 js 和原生环境交互的沟壑，但是对比开发环境还是没有 RN 全面。\n\n- 如果只是移动端应用，两者皆可，Flutter 有对 Material Design 更原生的支持，所以如果设计上是 Material Design，开发效率会更高；但是 RN 则在可定制上更高一筹。\n- 如果是 Wear OS，必然 Flutter。\n- 如果是桌面应用，目前我站 RN，除了工具链全面，它对比 Electron 已经很好了，而 Flutter 即使理论上性能更高，但其 alpha 的不稳定也要考虑在内。\n- 如果是 Web 端，感觉 Flutter 根本打不过现有的框架，不过仅仅对比 RN 的话，Flutter 可以不做配置就直接编译 Web，也就是说如果你有一个移动应用，又不想关心 Web 是怎么回事儿，用它还是可以的。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["flutter","CICD","rust","golang","wsl2","hover","github-action","vcXsrv","MSYS"]}},{"id":"2020/05/29/WebRTC.md","slug":"2020/05/29/webrtc","body":"\n# WebRTC，谈谈我这几天对它的研究\n\nWebRTC 是一个我在大学时期就关注的技术了，然而由于时间过早，很多技术细节都还在草案上就暂时罢休。今年年初，全世界都进入在家办公状态，视频会议工具被推到风口浪尖，webRTC 技术又一次被推到小高潮，于是便有了[这个实现](https://github.com/gongbaodd/ReactRTC)以及这篇文章。\n\n## WebRTC 是什么\n\nWebRTC 是实现网络端视频会议的技术，包括实现获取客户端的媒体 API，如获取摄像头以及麦克风的 `navigator.mediaDevices.getUserMedia()` 以及录制屏幕的 `navigator.mediaDevices.getDisplayMedia()`；还有实现双端数据传输的 `RTCPeerConnection` 类。\n\n目前主流的实现方式是将用户本地视频上传到后台服务器，由服务器转发视频数据到客户端。很恐怖是吧，没错，这就是为什么疫情刚刚开始大部分视频服务都因为访问过多而宕机，但是因为技术架构相对简单，容易实现并可以迁移到多个平台上面。\n\nWebRTC 依赖的是 P2P 技术，一旦两台机器实现连接，双方直接进行数据传输而不需要第三方转发，所以相对安全，但是实现细节比较困难，强烈推荐看一下 MDN 的[介绍](https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API)。\n\n## 两台机器如何连接\n\nP2P 说起来简单，实现起来并不容易，目前互联网主流使用 IPv4 协议，这意味着在网络环境中，真正暴漏的单一 IP 对应的是后台基于 NAT（Network Address Transition）技术连接的一簇终端设备。当我们使用网络传输数据时，是有一台暴露在外网的路由将收到的数据转发给自己的端口上面，但这一层转发，很多实现是广播的，意味着端口上面的每一台设备都能收到传输数据，如果要指定某台机器接收，需要在数据包里包含设备的描述，就好像 90 年代打电话往往要胡同门口小卖铺的王大爷叫一下。实现多设备链接就需要使用 ICE 技术（你的地址描述）的 TURN 或者 STUN 服务（提供地址描述的服务）。\n\n### ICE 技术\n\nICE（Interactive Connectivity Establishment）技术，我称之为「破冰」技术，它提供一个通过 TURN 或者 STUN 服务获取的一堆关于本地地址的描述，在 webRTC 中可以[获得本地描述](https://codesandbox.io/s/reactrtc-f365m?file=/src/components/PeerConnection.tsx:2363-2403)和[添加远端描述](https://codesandbox.io/s/reactrtc-f365m?file=/src/components/PeerConnection.tsx:3078-3139)。\n\n```typescript\nuseEffect(() => {\n  // 获取本地地址\n  connection.addEventListener(\"icecandidate\", (event) => {\n    if (event.candidate) {\n      // TODO: 保存 `event.candidate.toJSON()` 到服务器\n      // ...\n    }\n  });\n}, [connection]);\n\nconst onGetRemoteCandidate = useCallback(async () => {\n  // 添加远端地址\n  await connection.addIceCandidate(new RTCIceCandidate(data));\n}, [connection]);\n```\n\n### STUN 服务和 TURN 服务\n\nSTUN（Session Traversal Utilities for NAT）是一个能够帮助获取到客户端地址描述的协议。\n\n![STUN 服务](https://mdn.mozillademos.org/files/6115/webrtc-stun.png)\n\n在 RTCPeerConnection 中可以使用 google 的 STUN 服务。\n\n```ts\nconst [connection] = useState(() => {\n  return new RTCPeerConnection({\n    iceServers: [\n      {\n        urls: [\n          \"stun:stun1.l.google.com:19302\",\n          \"stun:stun2.l.google.com:19302\",\n        ],\n      },\n    ],\n    iceCandidatePoolSize: 10,\n  });\n});\n```\n\n而 TURN（Traversal Using Relays around NAT）则针对于只能接受对称 NAT（Symmetric NAT） 的路由器，设备对应的端口可变，相对于传统的锥形 NAT（Cone NAT），需要在 STUN 协议的基础上增加 Relay 转发。\n\n![TURN 协议](https://mdn.mozillademos.org/files/6117/webrtc-turn.png)\n\n如果心情好的话，你可以使用[COTURN](https://github.com/coturn/coturn)自己搭建一个 TURN 服务，更多关于 P2P 协议的描述可以参考[这篇博文](https://www.cnblogs.com/pannengzhi/p/5048965.html)。\n\n### SDP 会话描述\n\n如果你写过 HTTP 服务的话，一定会知道，要实现一个有状态的 HTTP 请求的实现基于会话，服务器和客户端通过一个会话 ID 实现双方的认证。会话在 P2P 下一样成立，这个会话 ID 则称为 SDP（Session Description Protocol）。\n\n一个 SDP 的结构如下，m 表示会话中的媒体描述。\n\n```ini\nv=0\no=mozilla...THIS_IS_SDPARTA-76.0.1 8725109466872836540 0 IN IP4 0.0.0.0\ns=-\nt=0 0\na=fingerprint:sha-256 A9:89:58:E6:B5:E3:23:F8:F4:4C:15:13:58:F5:7B\na=group:BUNDLE 0 1\na=ice-options:trickle\na=msid-semantic:WMS *\nm=audio 9 UDP/TLS/RTP/SAVPF 109 9 0 8 101\nc=IN IP4 0.0.0.0\na=sendrecv\na=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level\na=extmap:2/recvonly urn:ietf:params:rtp-hdrext:csrc-audio-level\nm=video 9 UDP/TLS/RTP/SAVPF 120 121 126 97\nc=IN IP4 0.0.0.0\na=sendrecv\na=extmap:3 urn:ietf:params:rtp-hdrext:sdes:mid\na=extmap:4 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time\na=extmap:5 urn:ietf:params:rtp-hdrext:toffset\n```\n\n当然生成二进制 SDP 的过程是不需要人工字符串拼接的，可以使用`connection.createOffer`和`connection.createAnswer`生 SDP，并使用`connection.setLocalDescription`和`connection.setRemoteDescription`建立会话。\n\n```ts\n// 发起端生成SDP\nconst createOffer = useCallback(async () => {\n  const offer = await connection.createOffer();\n  await conn.setLocalDescription(offer);\n  // TODO: 保存发起端的SDP到服务器\n  // ...\n}, [connection]);\n```\n\n## P2P 会议室的流程\n\n### 事前准备\n\n了解了上面的部分，我们需要如下内容以完成一次 P2P 连接\n\n- 一个 STUN 服务或者一个 TURN 服务来获取地址描述\n- 一台服务器，能够实现存储一端 ICECandidate（地址描述） 和 SDP（会话描述），并使另一端通过无论是 websocket 实现还是像 firebase 一样做轮询（polling）的技术获取数据。\n- 两台终端设备，其实要的就是两个`RTCPeerConnection`，但如果需要视频会议的话，还需要两个以上摄像头（反正我有 3 台 PC~）。\n\n### 1. 设置 RTCPeerConnection\n\n注意，网上很多示例会创建一个`localConnection`和一个`remoteConnection`，因为他们是在一台终端上做演示，所以理论上如果只要两台设备联络，代码里面创建一个`RTCPeerConnection`就可以实现两台设备连接了。\n\n[这里](https://codesandbox.io/s/github/gongbaodd/ReactRTC?file=/src/components/PeerConnection.tsx:618-663)因为项目用的是 React，我把实现封装成了一个`PeerConnection`组件。\n\n```ts\nconst config = {\n  iceServers: [\n    {\n      urls: [\"stun:stun1.l.google.com:19302\", \"stun:stun2.l.google.com:19302\"],\n    },\n  ],\n  iceCandidatePoolSize: 10,\n};\n\nconst CTX = createContext<RTCPeerConnection | null>(null);\n\nexport const PeerConnection: FC = ({ children }) => {\n  const [connection] = useState(() => {\n    return new RTCPeerConnection(config);\n  });\n\n  return <CTX.Provider value={connection} children={children} />;\n};\n```\n\n### 2. 处理本地 IceCandidate\n\n建立好 RTCPeerConnection 对象后，需要收集本地的 IceCandidate 并上传至服务器。\n\n```ts\nuseEffect(() => {\n  // 获取本地地址\n  // 假设这段代码是发起端，存储数据到callerAddress\n  // 如果是接收端，则存储到calleeAddress\n  connection.addEventListener(\"icecandidate\", async (event) => {\n    if (event.candidate) {\n      const db = await firebase.firestore();\n      const caller = await db.collection(\"callerAddress\");\n      caller.add(event.candidate);\n    }\n  });\n}, [connection]);\n```\n\n### 3. 获得远端 IceCandidate\n\n从数据库中中找到远端的地址（根据黑暗森林法则，如果知道对方地址，就可以杀死对方了），知道对方地址就可以建立会话了。\n\n```ts\n// 获得远端地址\n// 同样假设这段代码是发起端\n// 如果是接收端，则需要监视callerAddress\nconst db = await firebase.firestore();\nconst caller = await db.collection(\"calleeAddress\");\ncaller.onSnapshot((snapshot) => {\n  snapshot.docChanges().forEach(async (change) => {\n    if (change.type === \"added\") {\n      const address = change.doc.data();\n      await connection.addIceCandidate(new RTCIceCandidate(address));\n    }\n  });\n});\n```\n\n至此两边已经了解对方地址，可以进行会话了。\n\n### 4. 发起方获得本地媒体数据\n\n通过`navigator.mediaDevices.getUserMedia`获得媒体数据后，可以用`addTracks`函数把数据流添加到连接里面。\n\n```ts\nconst getUserMedia = useCallback(async () => {\n  const userStream = await navigator.mediaDevices.getUserMedia({\n    video: true,\n    audio: true,\n  });\n  userStream.getTracks().forEach((t) => {\n    connection.addTrack(t, localStream);\n    console.log(\"[P2P] stream to peer\", localStream);\n  });\n}, [connection]);\n```\n\n### 5. 发起方发送 offer SDP\n\n了解对方地址之后，发起方就可以发送 SDP 来建立会话了。\n\n```ts\nconst createOffer = useCallback(async () => {\n  const offer = await connection.createOffer();\n  await connection.setLocalDescription(offer);\n\n  const db = await firebase.firestore();\n  const offer = await db.collection(\"offer\");\n  offer.add({ type: offer.type, sdp: offer.sdp });\n\n  return offer;\n}, [connection]);\n```\n\n### 6. 接收方收到 offer，并返回 answer SDP\n\n接收方通过轮询服务器得到 offer，为连接添加远端会话描述，生成自己的会话描述（answer SDP），并存储到服务器，注意，这些步骤是不能更换的。\n\n```ts\nconst db = await firebase.firestore();\nconst offerRef = await db.collection(\"offer\");\nconst answerRef = await db.collection(\"answer\");\n\nofferRef.onSnapshot((snapshot) => {\n  snapshot.docChanges().forEach(async (change) => {\n    if (change.type === \"added\") {\n      const offer = change.doc.data();\n      await connection.setRemoteDescription(offer); // 设置远端会话描述\n      const answer = await conn.createAnswer(); // 生成本地会话描述\n      await conn.setLocalDescription(answer); // 设置本地会话描述\n      await answerRef.add(answer); // 存储本地会话到云端\n    }\n  });\n});\n```\n\n### 7. 发起方收到 answer，会话建立\n\n和接收方类似，发送方也需要从服务器收到会话的应答，设置好远端会话描述后，会话开始。\n\n```ts\nconst db = await firebase.firestore();\nconst answerRef = await db.collection(\"answer\");\n\nanswerRef.onSnapshot((snapshot) => {\n  snapshot.docChanges().forEach(async (change) => {\n    if (change.type === \"added\") {\n      const answer = change.doc.data();\n      await connection.setRemoteDescription(answer); // 设置远端会话描述\n    }\n  });\n});\n```\n\n### 8. 收到远端媒体流\n\n通过监听 track 事件，就可以获取远端媒体流了。注意，track 事件返回的是多个媒体流（因为 RTCPeerConnection 的`addTrack`可以使用多个媒体流），每个媒体流包括音轨和画轨。\n\n```ts\nconst video = useRef<HTMLVideoElement>(null);\n\nuseEffect(() => {\n  connection.addEventListener(\"track\", ({ streams: [remoteStream] }) => {\n    const stream = new MediaStream();\n    remoteStream.getTracks().forEach((t) => stream.addTrack(t));\n    video.current && video.current.srcObj = stream; // 设置HTML元素使用远端媒体流\n  });\n}, [connection]);\n```\n\n### 9. 会话结束\n\n停止一个媒体流，要关闭它的轨道。\n\n```ts\nstream.getTracks().forEach((t) => t.stop());\n```\n\n关闭连接则需要调用`close`函数。\n\n```ts\nawait connection.close();\n```\n\n## 传输文字信息\n\nRTCPeerConnection 不仅仅可以传输媒体流，使用[RTCDataChannel](https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Simple_RTCDataChannel_sample)可以传递文字信息。\n\n每一个 RTCPeerConnection 建立之后会有一个\"datachannel\"事件，这个事件会返回一个 chennel 对象，用来接收发送方传来的数据。\n\n```ts\nconnection.addEventListener(\"datachannel\", ({ channel }) => {\n  channel.addEventListener(\"open\", () => {\n    console.log(\"[P2P receiver] open\");\n  });\n  channel.addEventListener(\"message\", ({ data }) => {\n    console.error(\"[P2P receiver] message\", data);\n  });\n  channel.addEventListener(\"close\", () => {\n    console.log(\"[P2P receiver] closed\");\n  });\n});\n```\n\n在发起端创建一个 datachannel 向远端发送数据了。\n\n```ts\nconst sender = connection.createDataChannel(\"xxx\");\n// ... 发送信息必须在sender收到open事件后\nsender.send(\"hello\"); // 向接收端发送\"hello\"字符串\n```\n\n## 附录\n\n### 实现多端链接\n\n目前为止，RTCPeerConnection 只能做一对一连接。不过，要想实现多端连接，可以创建多个 RTCPeerConnection。那么一个浏览器最多能使用多少个 RTCPeerConnection 呢？根据[这篇文章](https://bloggeek.me/webrtc-rtcpeerconnection-one-per-stream/)，显然这个问题比较复杂，这个文章里面提过大概是 200 个，但由于网络等原因，可能并不能顺利建立这么多连接。\n\n### 调试方法\n\n我不太清楚出了什么状况，我的 demo 只能在火狐里面跑起来，但是调试起来类似，可以参考[这篇](https://testrtc.com/webrtc-internals-parameters/)。\n\n### PWA 里面能用 P2P 吗\n\n既然 DataChannel 能够实现端对端传输文字信息，那么结合 ServiceWorker 我们是不是可以创建一个完全去中心化的网页呢？答案是目前不可以，但是方案已经写进 webtorrent，具体内容可以在[此链接](https://github.com/webtorrent/webtorrent/issues/1721)跟进。\n\n### CodeSandbox 的使用体验\n\nCodeSandbox 可以理解为一个线上 Web 前端开发编辑器。\n\n因为现在是五月末六月初，在大陆依赖于 npm 的开发到了无比艰难的一段时间，导致我开始不得不考虑在[CodeSandbox](https://codesandbox.io/)进行开发。开发体验还是很可观的，虽然写代码会出现不跟手的情况，偶尔代码会出现因为远端没同步导致丢失（好在可以通过 github 同步）。\n\n我推荐以下情况可以考虑使用 codeSandbox：\n\n- 一个全新的项目\n- 项目比较简单，浏览器不至于卡死\n","collection":"blog","data":{"type":"post","category":"fe","tag":["webRTC","p2p","codesandbox","firebase"]}}]}