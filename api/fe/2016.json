{"posts":[{"id":"2016/01/20/webpack-riot-loader.md","slug":"2016/01/20/webpack-riot-loader","body":"\n# webpack 里面使用 riot-loader\n\n```javascript\nvar webpack = require(\"webpack\");\nvar HtmlWebpackPlugin = require(\"html-webpack-plugin\");\nvar plugins = [\n  new webpack.ProvidePlugin({\n    riot: \"riot\",\n  }),\n  new webpack.HotModuleReplacementPlugin(),\n  new HtmlWebpackPlugin(),\n];\n\nmodule.exports = {\n  entry: \"./src/app\",\n  output: {\n    path: __dirname + \"/prd\",\n    filename: \"app.js\",\n  },\n  plugins: plugins,\n  module: {\n    preLoaders: [\n      {\n        test: /\\.tag$/,\n        loader: \"riotjs-loader\",\n        exclude: /node_modules/,\n        query: { type: \"none\" },\n      },\n    ],\n    loaders: [\n      {\n        test: /\\.js|\\.tag|\\.es6$/,\n        loader: \"babel-loader\",\n        exclude: /node_modules/,\n        query: {\n          presets: [\"es2015\"],\n        },\n      },\n      {\n        test: /\\.scss$/,\n        loaders: [\"style\", \"css?sourceMap\", \"sass?sourceMap\"],\n      },\n    ],\n  },\n  resolve: {\n    alias: {\n      yo: __dirname + \"/bower_components/Yo\",\n      zepto: __dirname + \"/bower_components/zepto/zepto.js\",\n      qrcode:\n        __dirname + \"/bower_components/qrcode/dist/arale-qrcode/3.0.5/index.js\",\n    },\n  },\n  devtool: \"source-map\",\n  devServer: {\n    contentBase: \"./prd\",\n    historyApiFallback: true,\n    hot: true,\n    inline: true,\n    progress: true,\n  },\n};\n```\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2016/01/22/jshint.md","slug":"2016/01/22/jshint","body":"\n# jshint 配置笔记\n\n```javascript\n{\n  \"undef\": true,\n  \"unused\": true,\n  \"curly\": true,\n  \"freeze\": true,\n  \"funcscope\": true,\n  \"nocomma\": true,\n  \"notypeof\": true,\n  \"shadow\": true,\n  \"debug\": true,\n  \"indent\": true,\n  \"predef\": [\n      \"require\",\n      \"document\",\n      \"window\",\n      \"QApp\",\n      \"module\",\n      \"setTimeout\",\n      \"setInterval\",\n      \"encodeURI\",\n      \"encodeURIComponent\"\n   ]\n}\n\n```\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2016/01/25/Fekit-es6-riot-tag.md","slug":"2016/01/25/fekit-es6-riot-tag","body":"\n# Fekit 支持 es6 和 riot 的 tag\n\n在如下目录里面添加 tag.js 和 es6.js\n\n```shell\n/usr/local/lib/node_modules/fekit/lib/compiler/plugins\n```\n\n```javascript\n// tag.js\n(function() {\n  var compiler = require(\"riot-compiler\");\n\n  exports.contentType = \"javascript\";\n\n  exports.process = function(txt, path, module, cb) {\n    try {\n      var prefix = 'var riot = require(\"riot\");\\n';\n      return cb(null, prefix + compiler.compile(txt));\n    } catch (err) {\n      return cb(err);\n    }\n  };\n})();\n```\n\n```javascript\n// es6.js\n(function() {\n  var babel;\n\n  babel = require(\"babel-core\");\n\n  exports.contentType = \"javascript\";\n\n  exports.process = function(txt, path, module, cb) {\n    try {\n      return cb(\n        null,\n        babel.transform(txt, {\n          presets: [\"es2015\"],\n        }).code\n      );\n    } catch (err) {\n      return cb(err);\n    }\n  };\n}.call(this));\n```\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2016/01/25/chrome.md","slug":"2016/01/25/chrome","body":"\n# chrome 插件开发笔记\n\n> [360 真是一个良心企业，这样不用翻墙就能看 API 了](http://open.chrome.360.cn/extension_dev/overview.html)\n\n# manifest.json\n\n```javascript\n{\n    \"name\": \"qunar schema qrcode\",\n    \"manifest_version\": 2,\n    \"version\": \"0.0.1\",\n    \"description\": \"generates qrcode\",\n    \"background\": {\n        \"scripts\": [\n            \"background.js\"\n        ]\n    },\n    \"page_action\": {\n        \"default_icon\": \"icon.png\",\n        \"default_title\": \"QunarQRCode\",\n        \"default_popup\": \"index.html\"\n    },\n    \"permissions\": [\n        \"http://*/\",\n        \"https://*/\",\n        \"tabs\"\n    ],\n    \"content_security_policy\": \"script-src 'self' 'unsafe-eval'; object-src 'self'\"\n}\n```\n\n# background.js 判断 url 并添加 page action\n\n```javascript\nfunction getDomainFromUrl(url) {\n  var a = document.createElement(\"a\");\n  a.href = url;\n  var o = a.origin;\n  setTimeout(function() {\n    a.remove();\n  }, 100);\n  return o.replace(a.protocol + \"//\", \"\");\n}\n\nfunction checkForValidUrl(tabId, changeInfo, tab) {\n  if (\n    getDomainFromUrl(tab.url)\n      .toLowerCase()\n      .indexOf(\"qunar\") > -1\n  ) {\n    chrome.pageAction.show(tabId);\n  }\n}\n\nchrome.tabs.onUpdated.addListener(checkForValidUrl);\n```\n\n# popup 里面获取本页 url\n\n```javascript\nchrome.tabs.getSelected(null, tab => {\n  callback(tab.url);\n});\n```\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2016/01/26/karma.md","slug":"2016/01/26/karma","body":"\n# 使用 karma 来做单元测试\n\n> 最近一直在搞 riot，想弄一个单测，正好官网提供了 karma 组件，搞起来吧\n\n# 安装\n\n```shell\ncnpm install --save-dev karma-riot\n```\n\n# 配置\n\n```javascript\n// karma.conf.js\nmodule.exports = function(config) {\n  config.set({\n    frameworks: [\"mocha\", \"riot\"],\n    plugins: [\n      \"karma-mocha\",\n      \"karma-mocha-reporter\",\n      \"karma-phantomjs-launcher\",\n      \"karma-riot\",\n    ],\n    files: [\"**/*.tag\", \"test/**/*.js\"],\n    preprocessors: {\n      \"**/*.tag\": [\"riot\"],\n    },\n    browsers: [\"PhantomJS\"],\n    reporters: [\"mocha\"],\n  });\n};\n```\n\n# 运行\n\n```shell\nkarma run\n```\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2016/01/27/commitment.md","slug":"2016/01/27/commitment","body":"\n# 写最正规的 commitment\n\n需要一个工具 Commitizen\n\n```shell\ncnpm install -g commitizen\n```\n\n在工程目录里面使用 angular 的 message 格式\n\n```shell\ncommitizen init cz-conventinl-changelog --save --save-exact\n```\n\n以后写 commit 的时候不用`git commit`改用`git cz`\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2016/03/31/VUE-Riot-React.md","slug":"2016/03/31/vue-riot-react","body":"\n# vue+riot+react 试用报告\n\n# 前言\n\n**_本报告不是针对哪个框架，单独说哪个框架好，撕逼的出门右拐微博谢谢_**\n\n最近迷上了组件化开发，感觉这是一种非常高效率的开发模式（说模式有点不对）。于是我第一时间找到了这仨库来做比较，下面请听我细细道来。\n\n## 本报告拢共扯了这些蛋\n\n- 三个库列表渲染性能比较\n- 三个库的学习曲线(自己体会吧)\n- 三个库静态页面动态渲染行为的方式(呵，这话说得)\n- rollup、postcss、webpack\n- 对 ES2015 使用的建议\n\n![测试结果](http://ww1.sinaimg.cn/large/89d0a2e1gw1f2u8fh7uygj20tv0n4473.jpg)\n\n# 关于项目\n\n## 工具\n\n> 1.分别使用三个库创建一个模拟 native 的无线滚动列表<br/> 2.体验一下三个库的开发效率、文件大小、学习曲线以及最终性能\n\n由于时间问题，这几个项目都没有使用 fekit 开发，并且都用了 ES6 的一部分功能\n\n- riot -> rollup\n- react -> webpack\n- vue -> vue-cli(webpack)\n\n## 组件\n\n三个项目都有基于组件化的思想，所以架构设计相同\n\n- App\n  - Scroller\n    - Card\n    - Card\n    - Card\n    - ...\n\n## 用的 ES2015 功能\n\n- 箭头函数\n- 解构\n- import\n- JSX（算是吧）\n\n## 文件大小\n\n- riot\n  - origin: 93k\n  - uglified: 40k\n  - gzip: 14k\n- react\n  - origin: 689k\n  - uglified: 356k\n  - gzip: 76k\n- vue\n  - origin: null\n  - uglified: 79.8k\n  - gzip: 27k\n\n# 性能分析\n\n1. 渲染一个富文本列表，项目数 n\n\n```javascript\nvar t1 = performance.now();\nself.items = res;\n\nsetTimeout(() => {\n  var t2 = performance.now();\n  console.log(\"[1]渲染节点数：\" + res.length + \"::lastTime:\" + (t2 - t1));\n}, 1);\n```\n\n2. 列表添加内容，项目数 n\n\n```javascript\nvar t3 = performance.now();\nself.items = self.items.concat(res);\nsetTimeout(() => {\n  var t4 = performance.now();\n  console.log(\"[2]增加节点数：\" + res.length + \"::lastTime:\" + (t4 - t3));\n}, 1);\n```\n\n3. 删除部分内容，项目数 n\n\n```javascript\nvar t5 = performance.now();\nself.items = self.items.slice(0, res.length);\nsetTimeout(() => {\n  var t6 = performance.now();\n  console.log(\"[3]部分删除：\" + res.length + \"::lastTime:\" + (t6 - t5));\n}, 1);\n```\n\n4. 列表倒置\n\n```javascript\nvar t7 = performance.now();\nself.items = self.items.reverse();\nsetTimeout(() => {\n  var t8 = performance.now();\n  console.log(\"[4]数组回转：\" + res.length + \"::lastTime:\" + (t8 - t7));\n}, 1);\n```\n\n## n===400\n\n- riot\n  1. 300ms\n  2. 38ms\n  3. 15ms\n  4. 150ms\n- react\n  1. 357ms\n  2. 478ms\n  3. 177ms\n  4. 278ms\n- vue\n  1. 480ms\n  2. 403ms\n  3. 124ms\n  4. 152ms\n\n## n===800\n\n- riot\n  1. 477ms\n  2. 287ms\n  3. 261ms\n  4. 273ms\n- react\n  1. 688ms\n  2. 1167ms\n  3. 531ms\n  4. 625ms\n- vue\n  1. 750ms\n  2. 775ms\n  3. 256ms\n  4. 270ms\n\n## n===1600\n\n- riot\n  1. 917ms\n  2. 776ms\n  3. 546ms\n  4. 641ms\n- react\n  1. 2780ms\n  2. 3109ms\n  3. 1612ms\n  4. 1067ms\n- vue\n  1. 1348ms\n  2. 1533ms\n  3. 1167ms\n  4. 712ms\n\n## n===3200\n\n- riot\n  1. 2268ms\n  2. 1816ms\n  3. 2444ms\n  4. 1474ms\n- react\n  1. 5374ms\n  2. 7411ms\n  3. 4107ms\n  4. 2316ms\n- vue\n  1. 2657ms\n  2. 2868ms\n  3. 3113ms\n  4. 1744ms\n\n# 学习曲线（在组件化方面，自己体会）\n\n## riot\n\n```html\n<parent-component class=\"parent\">\n  <child-component class=\"child\" onclick=\"{click}\"></child-component>\n  <h1>{title}</h1>\n  <script>\n    this.on('mount',()=>{\n        ...\n    });\n    this.click = e=>{\n        this.update({ title: \"clicked\" });\n    };\n  </script>\n  <style scoped>\n    :scope {\n    }\n  </style>\n</parent-component>\n```\n\n## react\n\n```javascript\nReact.createClass({\n    getInitialState(){\n        return { title: \"\" };\n    },\n    click(){\n        this.setState({title: \"clicked\"});\n    },\n    componentDidMount(){\n        ...\n    },\n    render(){\n        return (\n        <div className=\"parent\">\n            <div className=\"child\" onClick={this.click}></div>\n            <h1>{title}</h1>\n        </div>\n        );\n    }\n})\n```\n\n## vue\n\n```html\n<template>\n  <div class=\"parent\">\n    <child class=\"child\" @click=\"click\"></child>\n    <h1>{{title}}</h1>\n  </div>\n</template>\n<script>\n  export default {\n      components: { child },\n      data() { return { title: \"\" } },\n      ready() {\n          ...\n      },\n      methods: {\n          click() {\n              this.title = \"clicked\";\n          }\n      }\n  }\n</script>\n```\n\n# 三个库静态页面动态渲染行为的方式\n\n## 模板渲染(Vue,riot)\n\n两者都是模板渲染，所以你的 html 如果按照它们模板语法来写，渲染起来很简单\n\n## 数据元渲染(react，咦？html 不算数据元)\n\nreact 相当于把渲染的内容转成类似于 json 的数据元，到客户端渲染的时候还需要解析一遍数据元。。。\n说白了，你得用 redux 或者 flux 或者 relay\n\n# rollup、postcss 还是 webpack\n\n> 实际上都是些工具上的事，汗啊，还是哪天说吧\n\n# es2015 该用啥\n\nes2015 编译主要体现在\n\n- 语法糖编译\n- pollyfill\n- modules\n\n### 语法糖编译\n\n- class\n- 解构\n- 箭头符号\n- decorator（争议）\n\n### pollyfill\n\n- Promise\n- generator\n- async/await(7)\n\n### modules\n\n- import\n- export\n\n---\n\n## 个人感觉\n\n- pollyfill 实在太大了，如果能不用就别用\n- 语法糖最好用一下，代码可读性一下提高好多\n- modules 我靠你连这个都不用你还好意思说你用的是 es6，这玩意儿不仅要用还不要转译成 AMD 或者 CMD，就按照 es6 的规范做才对，给 rollup 点个赞。\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2016/08/11/MochiUI.md","slug":"2016/08/11/mochiui","body":"\nhttps://mp.weixin.qq.com/s?__biz=MzI4MzM5ODM1Nw==&mid=2247483658&idx=1&sn=33c68d3f615fab291c57213d1ee9712f&scene=1&srcid=08114XgM7exmkysfZ3vzfcvE&pass_ticket=YH0FqjfQPOhb325pmlOXJmvmdpwmYignZi4BGS8fvn4VZ0TwllTJ6QHqKJsJMAnY#rd\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2016/08/12/MochiUI-Button.md","slug":"2016/08/12/mochiui-button","body":"\n# FRAMEWORK WIDGET-Mochi\n\n## BUTTONS\n\n### DATE:2012/09/26\n\n---\n\n#### 按钮\n\n**_文字内容_**\n\n- 字号 14pt\n- 字体 PreludeWGL\n- 粗体 斜体\n- 颜色 #4b4b4b\n\n**_圆括号_**\n\n- 字号 30pt\n- 字体 PreludeWGL Bold\n- 颜色 #4b4b4b\n\n**_垂直间隔_**\n\n文字在圆括号中间居中。\n圆括号的行高要比文字低 5 点。\n文字的上下间距是 8 像素。\n\n**_水平间隔_**\n\n文字在圆括号中间。\n第一个括号后没有字符间隔，文字后有一个字符间隔。\n两边的间隔为 8 像素。\n\n![](https://mmbiz.qlogo.cn/mmbiz/aEj0pBet08t8XWyBXodZAYbVyVuyq5OktnQEwveBUqRV9ia4MGzZPoTbWNJGOmLick5G0PGBiaOeO16XZwYiavphqQ/0?wx_fmt=png)\n\n---\n\n#### 下拉按钮\n\nlist-arrow.png 8x8 像素。\n相对于按钮垂直居中。\n\n**_点击时_**\n\n圆括号要对应伸缩\n\n![](https://mmbiz.qlogo.cn/mmbiz/aEj0pBet08t8XWyBXodZAYbVyVuyq5OkJ4zUVPUoP6Ill5YBszmkQdv7tNibS4icXf5TS0oMPOZyhjxgWQ20Em5w/0?wx_fmt=png)\n\n---\n\n#### 禁用按钮&警告按钮\n\n![](https://mmbiz.qlogo.cn/mmbiz/aEj0pBet08t8XWyBXodZAYbVyVuyq5OkZRuJblZg1jKe2yRyicn2RxrP26NHQPLNBYyX9udVuMEAzG4O8Qeo8cQ/0?wx_fmt=png)\n\n---\n\n#### 按钮间隔\n\n最小水平间距 2 单元（16 像素）\n\n![](https://mmbiz.qlogo.cn/mmbiz/aEj0pBet08t8XWyBXodZAYbVyVuyq5OkufrzdI7bqOaKIT7tIGNFQ3VibXL6hjIyQxVqTSAmcb527KHDwfV0wyA/0?wx_fmt=png)\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2016/08/17/KarmaTest.md","slug":"2016/08/17/karmatest","body":"\n# 跑一下前端的单元测试\n\n## 什么是单元测试\n\n指对软件中的最小可测试单元进行检查和验证。\n\n<center><img alt=\"举个栗子\" src=\"http://i0.hdslb.com/video/05/050dcbac6717c4e1c99c6f0c0a61c4b9.jpg\"/></center>\n\n**_老代码_**\n\n```javascript\n// getProtocol.js\ngetProtocol: function() {\n    // 这里列举出了所有的scheme，导致缺失了扩展性。\n     var e = [\"scheme1\",\"scheme2\",\"scheme3\"];\n     // 获取userAgent\n     var t = navigator.userAgent;\n     for (var n = 0; n < e.length; n++) {\n         if (t.indexOf(e[n]) !== -1)\n             return e[n].toLowerCase()\n     }\n     return \"http\";\n }\n```\n\n**_新代码_**\n\n```javascript\n// getProtocol.js\ngetProtocol: function() {\n     var e = (function() {\n         var res = navigator.userAgent.toLowerCase().match(/(^|\\s)(scheme[^\\/]+)\\/([\\d\\.]+)/),\n    scheme = res && res[2],\n    version = res && res[3];\n        return [scheme];\n     })();\n     // 获取userAgent\n     var t = navigator.userAgent;\n     for (var n = 0; n < e.length; n++) {\n         if (t.indexOf(e[n]) !== -1)\n             return e[n].toLowerCase()\n     }\n     return \"http\";\n }\n```\n\n这里需要对**_输入(navigator.userAgent)_**\n进行处理来查看函数的\n**_输出(scheme1,scheme2,scheme3,schemeXX,http)_**\n是否发生改变\n\n## 什么工程要单元测试\n\n1. 存在大量调用的工程\n   **_(√)_**\n2. 代码量少的工程（每次修改后自测都能完全覆盖用例）\n   **_(X)_**\n\n> 代码可以加 jshint\n\n```javascript\n// .jshintrc\n{\n  \"undef\": true, \"unused\": true, \"curly\": true, \"freeze\": true, \"funcscope\": true, \"nocomma\": true, \"notypeof\": true, \"shadow\": true, \"debug\": true, \"indent\": true,\n  \"predef\": [\n      \"require\", \"document\", \"window\", \"QApp\", \"module\", \"setTimeout\", \"setInterval\", \"encodeURI\", \"encodeURIComponent\", \"clearTimeout\", \"clearInterval\", \"navigator\", \"describe\", \"beforeEach\", \"it\", \"jasmine\", \"____MODULES\", \"spyOn\", \"expect\"\n   ]\n}\n\n```\n\n## 什么代码可以测试\n\n不是所有代码都可以单元测试，需要测试的代码需要给 runner 留有接口。\n\n但是，因为 js 没有真的对象（多年从事找对象工作的笔者哭晕在厕所），所以大家实现私有函数的方法真是天花乱坠。\n\n可是宝宝要单测的代码都是私有方法啊！！！！！！\n\n<center><img alt=\"哭\" src=\"http://img2.imgtn.bdimg.com/it/u=2304895309,1301584123&fm=21&gp=0.jpg\" /></center>\n\n### case A\n\n```javascript\nvar _utils = function() {\n  /*do something*/\n};\n_utils.prototype.add = function(a, b) {\n  return a + b;\n};\nmodule.exports = _utils;\n```\n\n```javascript\ndescribe(\"utils\", () => {\n  it(\"add\", () => {\n    var a = new (require(\"utils.js\"))();\n    expect(a.add(1, 1)).toBe(2);\n  });\n});\n```\n\n### case B\n\n```javascript\nvar _add = function(a, b) {\n  return a + b;\n};\nmodule.exports = { add: _add };\n```\n\n```javascript\ndescribe(\"utils\", () => {\n  it(\"add\", () => {\n    var a = require(\"utils.js\").add;\n    expect(a.add(1, 1)).toBe(2);\n  });\n});\n```\n\n### case D\n\n```javascript\nvar _add = function(a, b) {\n  return a + b;\n};\nmodule.exports = function() {\n  return _add(1, 1);\n};\n```\n\n只能把用例写到代码里面了。。。\n\n所以当我们写代码的时候要留好单元测试的接口，不管你写的代码多牛逼，\n如果你的代码不可测试，那宝宝就认为你的代码是不可读的。\n\n<center><img alt=\"白眼\" src=\"http://www.people.com.cn/mediafile/pic/20150203/21/15475877261822907269.jpg\" /></center>\n\n## 拿什么测试\n\nfekit 自带测试功能，在 test 文件夹下面执行`fekit test`就可以运行，用例语法遵循 mocha.js，可惜运行时是当前的 node 环境。\n\nangular 的测试 runner 时 karma，可以拿来跑用例，并且可以指定环境，所以使用 karma 跑用例还不错。\n\n那么，用例拿什么写呢？\n\n- QUnit\n- mocha.js\n- jasmine\n- ava\n- tape\n\n实际上 ava 和 tape 是我强推的，可惜这俩 node 环境还不错，到了 browser 还是用老牌的好一点。\n\n## 怎么配置 karma\n\n需要安装的 npm modules 在下面的 devDependencies 里面\n\n```javascript\n{\n \"scripts\": {\n    \"test\": \"karma start\"\n  },\n  \"devDependencies\": {\n    \"bower\": \"^1.7.9\",\n    \"jasmine-core\": \"^2.4.1\",\n    \"karma\": \"^1.1.2\",\n    \"karma-chrome-launcher\": \"^1.0.1\",\n    \"karma-jasmine\": \"^1.0.2\"\n  }\n}\n```\n\n执行\n\n```shell\nnpm i\n```\n\n下面的代码会自动生成 karma 的配置文件\n\n```shell\nkarma init\n```\n\n工程根目录里面会多一个 karma.conf.js 文件\n\n```javascript\n// Karma configuration\n// Generated on Mon Aug 08 2016 17:25:40 GMT+0800 (CST)\n\nmodule.exports = function(config) {\n  config.set({\n    // base path that will be used to resolve all patterns (eg. files, exclude)\n    basePath: \"\",\n\n    // frameworks to use\n    // available frameworks: https://npmjs.org/browse/keyword/karma-adapter\n    frameworks: [\"jasmine\"],\n\n    hostname: \"localhost\",\n\n    // list of files / patterns to load in the browser\n    files: [\n      \"bower_components/jquery/dist/jquery.js\",\n      \"bower_components/jasmine-jquery/lib/jasmine-jquery.js\",\n      \"bower_components/jasmine-ajax/lib/mock-ajax.js\",\n    ],\n\n    // list of files to exclude\n    exclude: [],\n\n    // preprocess matching files before serving them to the browser\n    // available preprocessors: https://npmjs.org/browse/keyword/karma-preprocessor\n    preprocessors: {},\n\n    // test results reporter to use\n    // possible values: 'dots', 'progress'\n    // available reporters: https://npmjs.org/browse/keyword/karma-reporter\n    reporters: [\"progress\"],\n\n    // web server port\n    port: 9876,\n\n    // enable / disable colors in the output (reporters and logs)\n    colors: true,\n\n    // level of logging\n    // possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG\n    logLevel: config.LOG_INFO,\n\n    // enable / disable watching file and executing tests whenever any file changes\n    autoWatch: true,\n\n    // start these browsers\n    // available browser launchers: https://npmjs.org/browse/keyword/karma-launcher\n    browsers: [\"Chrome\", \"Chrome_without_security\"],\n    customLaunchers: {\n      Chrome_without_security: {\n        base: \"Chrome\",\n        flags: [\"--disable-web-security\", \"--args\"],\n      },\n    },\n\n    // Continuous Integration mode\n    // if true, Karma captures browsers, runs the tests and exits\n    singleRun: false,\n\n    // Concurrency level\n    // how many browser should be started simultaneous\n    concurrency: Infinity,\n  });\n};\n```\n\n可以看到 files 里面我又加上了一些文件，那些还不是测试用例，因为要测试一些 dom 以及 ajax 的情况，加了一些代码。\n\n```javascript\n// bower.json\n{\n  \"dependencies\": {\n    \"jquery\": \"^3.1.0\",\n    \"jasmine-ajax\": \"^3.2.0\",\n    \"jasmine-jquery\": \"^2.1.1\"\n  }\n}\n```\n\n## 说说这些 karma 的原理吧\n\n用过 QUnit 和 mocha 的人都知道，如果写测试用例要把 js 和用例放在一个 html 环境下，再引进来 QUnit.js 和 mocha.js 就行了，\n其实 Karma 差不多，只不过把手工的部分换成机器了，这样你不用新建一个 html 文件，发布之前也不需要先删除测试代码了。\n\n## jasmine 的语法\n\n懒得写了，可以看一下下面的文章\n\n> [JavaScript 单元测试框架——Jasmine 入门](http://ued.fanxing.com/javascriptdan-yuan-ce-shi-kuang-jia-jasmine/)<br/> >[jasmine-ajax - Faking Ajax responses in your Jasmine suite.](https://github.com/jasmine/jasmine-ajax/blob/master/README.markdown)<br/> >[jasmine-jquery](https://github.com/velesin/jasmine-jquery/blob/master/README.md)\n\n<center>![举个栗子](http://i0.hdslb.com/video/05/050dcbac6717c4e1c99c6f0c0a61c4b9.jpg)</center>\n\n如果你有一个 Dialog 对象，你想看看它的 show 函数执行后页面是否有类名`.dialog`的 dom 节点。\n\n```JavaScript\ndescribe('Dialog', ()=>{\n    var _d = new Dialog();\n    it('show', ()=>{\n        _d.show();\n        expect($('.dialog')[0]).toBeInDOM();\n    });\n})\n```\n\n再如，Dialog 有一个 sendVcode 函数，执行的时候会发起 Ajax 请求，你要 Mock 一个 Ajax 请求\n\n```JavaScript\ndescribe('Mock AJAX', ()=>{\n    var mock = JSON.stringify({\n        status: 200,\n        data: {\n            message: \"blahblah\"\n        }\n    }),_d = new Dialog(),request;\n\n    beforeEach(()=>{\n        jasmine.Ajax.install();\n        _d.sendVcode();\n        request = jasmine.Ajax.requests.mostRecent();\n        request.respondWith({ status: 200, responseText: mock});\n    });\n\n    it('sendVcode', ()=>{\n        expect(request.url).toBe(\"xxx.htm\");\n        expect(request.method).toBe(\"POST\");\n        expect(request.data()).toEqual({\"source\":\"xxxx\"});\n    });\n});\n```\n\n另外，Dialog 执行 sendVcode 的时候，会执行`Dialog.timer`的 start 函数\n\n```javascript\ndescribe(\"Timer\", () => {\n  var _d = new Dialog();\n\n  beforeEach(() => {\n    spyOn(_d.timer, \"start\");\n    _d.sendVcode();\n  });\n\n  it(\"timer.start\", () => {\n    expect(_d.timer).toHaveBeenCalled();\n  });\n});\n```\n\n如果说要做接口测试\n\n```javascript\ndescribe(\"interface\", () => {\n  var _d = new Dialog(),\n    onSuccess,\n    onFailure;\n\n  beforeEach(() => {\n    jasmine.Ajax.install();\n    (onSuccess = jasmine.createSpy(\"onSuccess\")),\n      (onFailure = jasmine.createSpy(\"onFailure\"));\n    _d.init({\n      success: res => {\n        onSuccess(res);\n      },\n      error: () => {\n        onFailure(res);\n      },\n    });\n    request = jasmine.Ajax.requests.mostRecent();\n  });\n\n  it(\"init\", () => {\n    expect(onSuccess).toHaveBeenCalledWith(\"{xxxx}\");\n  });\n});\n```\n\n说下 Cookie 和 UA 的 hack，用[karma-phantomjs-launcher](https://github.com/karma-runner/karma-phantomjs-launcher/blob/master/README.md)可以改配置\n\n```javascript\ndocument.__defineGetter__(\"cookie\", function() {\n  return \"BlahBlah\";\n});\n\nnavigator.__defineGetter__(\"userAgent\", function() {\n  return \"Schema1\";\n});\n```\n\nCSS 的测试\n\n```javascript\ndescribe(\"addStyle:\", function() {\n  it(\"body{background:red;}\", function() {\n    main.addStyle(\"body{background:red;}\");\n    expect(window.getComputedStyle(document.body).backgroundColor).toEqual(\n      \"rgb(255, 0, 0)\"\n    );\n  });\n});\n```\n\n最后说一下，如果 karma 要支持 commonJS 需要加入 preCompiler，如 webpack 或者 browserfy，否则不支持 require。\n好在 fekit 是在 window 下注入\\_\\_\\_\\_MODULES 解决模块化，所以只需要知道模块的 md5 值就好。\n如刚才的 Dialog 的引入\n\n```javascript\nvar Dialog = ____MODULES[\"babf80335465996414cd682baf25de10\"];\n```\n\n## 关于自动生成测试用例\n\n写安卓的时候，AS 会自动生成用例，所以想让 Atom 也支持这一功能，找了一下 plugin，基本上没有。。。<br/>\n如果我写一个的话。。。我得估一下它的必要性。。。\n\n<center><img alt=\"来打我呀\" src=\"http://img2.imgtn.bdimg.com/it/u=3823151670,1751373648&fm=21&gp=0.jpg\" /></center>\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2016/09/06/sonic.js-loading.md","slug":"2016/09/06/sonicjs-loading","body":"\n# sonic.js制作盾牌形状loading\n\n## 如图\n\n<img src=\"http://ww1.sinaimg.cn/thumb300/89d0a2e1jw1f7k2y2x1h7j20qo0qowha.jpg\" style=\"background:#000;\">\n\n---\n\n```javascript\nvar circle = new Sonic({\n\n    width: 50,\n    height: 50,\n    padding: 50,\n    strokeColor: 'white',\n\n    pointDistance: .01,\n    stepsPerFrame: 7,\n    trailLength: .95,\n    fps: 30,\n\n    step: 'fader',\n    fillColor: 'white',\n\n    setup: function() {\n        this._.lineWidth = 3;\n        this._.lineCap = 'round';\n        this._.lineJoin = 'round';\n    },\n\n    path: [\n        ['bezier', 0, 0, 30, -10, 0, 5, 30, -5],\n        ['bezier', 30, -10, 60, 0, 30, -5, 45, 0],\n        ['line', 60, 0, 60, 45],\n        ['bezier', 60, 45, 0, 45, 30, 70, 30, 70],\n        ['line', 0, 45, 0, 0]\n    ]\n\n});\n\ncircle.play();\n```\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2016/10/24/Efficient-your-component-development.md","slug":"2016/10/24/efficient-your-component-development","body":"\n# 高效你的组件化开发\n\n组件化开发算是老生常谈了，最早听说这个理论，我还在大学，写着那些被后端称为模板的东西。所以当时的开发就是写成一堆\\*p（php、jsp 等）片段然后 include 到一起。\n\n## 为什么要做组件化\n\n为什么要做组件化呢？因为它是什么神奇的算法，能提高代码的运行效率？不会，因为组件化会对代码进行封装，封装就会稍稍拖累运行效率。\n那为什么还要组件化呢？\n\n![理想的更新迭代](http://ww4.sinaimg.cn/mw690/89d0a2e1gw1f93dxsw0zyj215n0qvtcf.jpg)\n\n首先，在做软件的时候，我们更希望能最开始制作一套原型，并在后期的迭代中不断地对这一套原型填充。\n但是现实中，我们更有可能遇到某一工程的部分可以在以后的项目中使用，这时就可以把共有的部分封装成组建公用。\n\n![现实中的迭代](http://ww3.sinaimg.cn/mw690/89d0a2e1gw1f93ea4gcqtj219s0js0vz.jpg)\n然后，在设计一个较大的前端项目的时候，我们要对项目进行分拆，定义接口，实现多人协同开发，自然也需要组件化。\n\n最后，如果项目产生了 bug，或者要对项目进行更新，我们可以对其进行局部的更改和回归。就像制造业，如果一辆车爆胎了，\n只需要更换轮胎就好，不必更换整辆车。\n\n## WEB 组件化的昨天今天和明天\n\n那么既然组件化有这么多好处，聪明的程序员们自然早就在使用了\n\n### Web 1.0 时代\n\n![Web1.0时代的组件化](http://ww3.sinaimg.cn/mw690/89d0a2e1gw1f93ea4vx7sj21480nn44a.jpg)\n\n在 Web1.0 的时代，前端的确还只是所谓的模板，CSS 基本上还是 inline，js 也除了基础框架也基本上写在页面里面。那会儿的组件化依靠 web server\n把页面内多个碎片拼装在一起，然后一并传到客户端，当时组件化的特点是：\n\n- 客户端必须通过刷新页面实现和服务端的交互，而页面一旦刷新，页面内的所有组件刷新。\n- 每次刷新，服务端几乎每个组件都要重新计算一下，会拖累性能。\n- HTML 担任组件化的主体，页面基本上由 HTML 碎片组合而成。\n\n### Web 2.0 时代\n\n![Web2.0时代的组件化](http://ww3.sinaimg.cn/mw690/89d0a2e1gw1f93ea5eq1oj21d90rudmu.jpg)\n\nWeb 2.0 因为 AJAX 的出现，用户可以实现不刷新页面与服务端交互。为了不拖累服务端，CSS 和 JS 都各自写在一起，作为静态资源存放在 CDN 上加速。\n这时的 CSS，因为 LESS、SASS 等预编译工具的出现实现了工程文件的组件化。\n而 HTML 因为其结构依然保持着 1.0 时代的组件化，只不过这回是在前端拼接了。\njs 依靠选择器更新页面实现不刷新更新，这时组件化的特点是：\n\n- JS 逐渐替代 HTML，担负起页面组件的拼接工作。\n- HTML、JS 和 CSS 都各自逐渐实现组件化，但三者耦合不多。\n- 有完全放弃 CSS 和 HTML，只用 JS 完成页面的方案，然而可定制性不高。\n\n### SPA 时代\n\n![厉害了我大JS](http://ww2.sinaimg.cn/mw690/89d0a2e1gw1f93ea62d3bj21770jbq65.jpg)\n\n后来，为了应付更复杂的交互，前端出现了很多如 Angular、React 之类的框架，这些框架基本上就是以服务端返回的数据作为 Model，\n用 Cotroller 的处理产生 View 并渲染到页面上。\n\n![SPA时代开始](http://ww1.sinaimg.cn/mw690/89d0a2e1gw1f93ea6msqgj21670oetdw.jpg)\n\n有了这种框架，页面就可以处理更多逻辑，以前后端的路由功能也复制到了前端。\n这时 JS 已经完全接管了组件化的工作，可惜问题是，\n随着页面逻辑的复杂程度，单一 Controller 下要处理的绑定也变多了，\n工程也逐渐复杂难懂。\n\n### Web Components\n\n![Web Components](http://ww4.sinaimg.cn/mw690/89d0a2e1gw1f93ea7hxopj21d80ld11e.jpg)\n\n> 天下大事，分久必合，合久必分。\n\nWeb Components 的出现，一定程度把 HTML、CSS 和 JS 又耦合在一起，\n只不过都有了一个作用域的概念，完整的组件化已经形成，然而这一方案\n还在试验中，变数还有很多。好在现在很多框架都已经相对模仿并实现了这一方案。\n\n## 设计组件的思想\n\n用了能实现组件化思维的框架并不代表已经用组件化开发了，\n还需要一套思想，那么如何设计组件呢？\n\n> 任何一个组件都是一个有限状态机。 ——沃·滋基硕德\n\n![有限状态机](http://ww1.sinaimg.cn/mw690/89d0a2e1gw1f93ea7muo1j20u6054q38.jpg)\n\n组件的状态是有限的，状态转变是因为受到了某一个事件。\n\n![举个例子](http://ww2.sinaimg.cn/mw690/89d0a2e1gw1f93ewntvqsj20ci0a13yp.jpg)\n\n比如一个输入框，初始状态为无光标、值为空。\n\n![输入框](http://ww3.sinaimg.cn/mw690/89d0a2e1gw1f93ea82j7kj20ca02ra9y.jpg)\n\n```javascript\nM.state = {\n  curser: false,\n  value: \"\",\n};\n```\n\n输入框被聚焦之后，显示光标，值为之前的值。\n\n![输入框被聚焦](http://ww1.sinaimg.cn/mw690/89d0a2e1gw1f93ea8dlpbj20ca02r3yf.jpg)\n\n```javascript\nM.state = M.on('focus', ()=>{\n    curser: true,\n    value: M.state.value\n})\n```\n\n输入值之后，每一个字符都触发一次 input 事件。\n\n![输入框被输入值](http://ww2.sinaimg.cn/mw690/89d0a2e1gw1f93ea8qr4pj20ca02rdft.jpg)\n\n```javascript\nM.state = M.on('input', (c)=>{\n    curser: true,\n    value: M.state.value + c\n})\n```\n\n![输入框状态变化图](http://ww1.sinaimg.cn/mw690/89d0a2e1gw1f93ea929zzj20x50d3dh7.jpg)\n\n由此可以得出，组件的新状态都要由旧状态和受到的事件产生，\n再经过渲染成 View 层展示\n\n![公式](http://ww4.sinaimg.cn/mw690/89d0a2e1gw1f93eaa6y5hj20rb06gjs5.jpg)\n\n## 构造和使用组件\n\n### 原子化你的组件\n\n![一个组件要是什么样的](http://ww4.sinaimg.cn/mw690/89d0a2e1gw1f93ea9et4cj21220ebjsl.jpg)\n\n一个组件应该做成什么样的？是一个页面还是一个弹窗还是什么样子？\n比如下面这个页面，就说输入框吧，每个输入框有三个状态，\n那么整个页面就有了 12 种状态，维护起来真是复杂；\n如果这些输入框用一个迭代器处理，的确就只有三个状态了，\n可是这些迭代的输入框对事件的处理又不同\n（比如手机号要加掩码），又会把每个事件弄复杂了。\n\n![示例页面](http://ww3.sinaimg.cn/mw690/89d0a2e1gw1f93ea9uu5qj20ol0w3dil.jpg)\n\n其实，如果一个组件的状态很多，管理起来也很麻烦，\n莫不如把这个组件拆开，比如一个输入框可以由\n普通输入框混淆掩码实现，则上图输入框的处理可以变成如下\n\n![组件化后](http://ww1.sinaimg.cn/mw690/89d0a2e1gw1f93eaavbbkj21gi0vyn28.jpg)\n\n### 组件怎样交互\n\n通过原子化组件能够很好解决复杂的状态管理，\n但是需要组件间进行交互。\n\n其实很简单，页面和用户交互是监控人的事件，\n和后端交互是监控 XMLHttpRequest 的事件，\n那么组件间的交互自然是监控组件的事件，\n而组件内部交互是监控自己的事件。\n\n![组件交互](http://ww1.sinaimg.cn/mw690/89d0a2e1gw1f93eix7uspj20rb0gsjtg.jpg)\n\n比如下图的输入框，输入框可以找到清除按钮并监控其点击事件来\n判断自己是否需要清空，按钮监控输入框的输入事件来判断自己是否可点。\n\nhttp://ww1.sinaimg.cn/mw690/89d0a2e1gw1f93eix7uspj20rb0gsjtg.jpg\n![又是输入框](http://ww3.sinaimg.cn/mw690/89d0a2e1gw1f93eabffgxj219x0he0yg.jpg)\n这样组件化的又一难题就解决了。\n\n## 写在最后\n\nweb 前端的组件化还在一个发展中的状态，\n本文对组件化的想法可以刚好适应移动端页面的需求。\n技术在日新月异地发展中，\n也许今天看似高效的做法明天就不是了，\n写本文为的是能够分享一下我的想法，希望能够给人一定启发。\n\n## 参考\n\n[Web 应用的组件化开发（一）——基本思路](http://www.ituring.com.cn/article/63549)\n\n[The Sam Pattern](http://sam.js.org)\n\n[Shadow DOM 201](https://www.html5rocks.com/en/tutorials/webcomponents/shadowdom-201/)\n","collection":"blog","data":{"type":"post","category":"fe"}}]}