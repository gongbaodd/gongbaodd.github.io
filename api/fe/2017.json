{"posts":[{"id":"2017/05/02/Qxf-Qconfig.md","slug":"2017/05/02/qxf-qconfig","body":"# 结合Qxf和Qconfig解决前端热发布\n\n或许篇文章写得有些晚了，如果这篇文章是写koa的话，估计受欢迎程度会很高。\n\n最近正巧有一个前后同构的项目，其实是利用node作渲染层。至于为什么用node作渲染层就不做详述了，节约后端资源，释放前端约束，可能方案并不是通用的，正好我的项目需要。\n\n## Qxf 介绍\n\nQxf是基于express的node服务方案，也就是说很多express的API可以直接使用。确切说并不完全是这样，response.write就被改写了，但并不影响使用。\n\n其实Qxf的出现是给node做了一层兼容于原有去哪儿前后端分离模式的node后端。同时为开发者做了一层脚手架封装，集成包括cluster、logger、handlebars等开源的中间件以及去哪儿私有的异常处理、日志处理、埋点统计以及静态资源版本号的管理中间件。\n\n## QConfig\n\nQConfig是去哪儿内部解决后端热发的方案，简单地说它会依照版本存储```*.properties```或者```*.json```文件，并按需将这些配置文件推送到各个机器，推送之后也可以回滚。\n\n## 解决的问题\n\n前端有很多需求是文案修改、图标修改，相对来说算是比较安全，但每次修改的时候还要测试回归上线，这样流程拖得太长，如果前端也可以利用QConfig实现热发，那自然是很受欢迎的。\n\n## Qxf怎么用\n\n针对Qxf怎么去创建一个工程在此就不多余介绍了，讲一下工作原理吧。\n\n    qxf dev\n\n这个命令会启动Qxf的测试环境，其实就是执行了以下代码\n\n    NODE_ENV=development node ./bin/start.js --l .logs\n\n也就是说，包括server的启动配置都写在这里面了。整个服务都会在```multiprocess.listen(app, opts)```之后执行（注意一个坑点，multiprocess没有暴露server对象，所以用不了reload.js，开发的时候只能手动刷新页面了）。\n\n## QConfig怎么用\n\n讲完Qxf说说QConfig，按照qConfig的文档在Qxf的config.js里面配置好要取的配置，QConfig要在Qxf启动之前执行，也就是还要修改start.js里面的\n\n    multiprocess.listen(app, opts);\n\n为\n\n    qConfigClient.init().then(()=> multiprocess.listen(app, opts));\n\n之后如果需要获取某一个属性文件，则需要执行\n\n    const configs = qConfigClient.getConfig('*.json');\n    const value = configs.get('key');\n\n如果你的配置是json的，获取到的值会直接parse成对象。\n\n***需要注意一点,Qconfig是异步的，也就是说getConfig的执行必须放到某个可抵达的回调里面***\n\n## 结束\n\n执行一下```qxf dev```，服务器访问```localhost:3000```到对应的router下面就可以看到效果了。\n\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/05/03/QxfComponents.md","slug":"2017/05/03/qxfcomponents","body":"# 写啥题目呢\n\n## 回顾一下\n\n去年三月，我分享了一个用riotjs开发前端的方案，既然已经有一年的时间了，就先回顾一下。\n\n这套方案出自2015年，之前一直使用的是公司的QApp解决方案，后来发现使用上存在问题，\n并在试图寻找一套可行的替代方案。\n\n### 组件化方案\n\nQApp的最小单位是View(大概可以理解为页面)，\nView里面大到一个轮播图小到一个按钮的操作逻辑都和view耦合，\n假设我想使用某一个View里面的某一个组件，想直接拆出来是不太可能的。\n\n* 以前的写法\n\n        QApp.defineView({\n            html: `\n            <div node-type=\"vcode\">\n                <input action-type=\"input\">\n                <button action-type=\"vcode\">发送短信</button>\n            </div>\n            <button action-type=\"submit\">提交</button>\n           `\n            actions: {\n                // 这里的this指向整个view\n                \"input:input\": () => this.doInput(),\n                \"submit\": () => this.doSubmit(),\n                \"vcode\": () => this.doVcode(),\n            },\n            init: {\n                doInput() {},\n                doSubmit() {},\n                doVcode() {},\n            }\n        });\n        QApp.config({...});\n\n* 新的写法\n\n        riot.tag('pay-input',`\n            <input oninput=\"oninput\">\n        `, ()=> {\n            // 这里的this指向整个pay-input\n        });\n        riot.tag('pay-submit', `\n            <submit ontap=\"onsubmit\">\n                <yield/>\n            </submit>\n        `, ()=> {\n            // 这里的this指向整个pay-submit\n        });\n        riot.tag('pay-vcode', `\n            <pay-input></pay-input>\n            <pay-submit>发送短信</pay-submit>\n        `, ()=> {\n            // 这里的this指向整个pay-vcode\n        });\n        riot.tag('pay-view',`\n            <pay-vcode></pay-vcode>\n            <pay-submit>提交</pay-submit>\n        `, ()=>{\n            // 这里的this指向整个pay-view\n        });\n        riot.mount('pay-view');\n\n### 基于发布订阅的统一事件管理模式\n\n有很多时候，我们要处以理一些“这些东西，我们不要了”之类的需求，\n当我们回头去翻代码的时候，惊奇的发现它被封装了，\n那么后面的故事就是要和“xxx function is undefined”做长期斗争了。\n\n* 之前的调用方式\n\n        QApp.defineView({\n            init: {\n                doSomething: ()=> {}// 删我貌似很困难\n                doSomethingElse: ()=>this.doSomething()\n            },\n            ready() {\n                this.doSomething();\n            }\n        });\n\n* 之后的调用方式\n\n        riot.tag('pay-view',`...`, ()=>{\n            this.on('doSomething', ()=> doSomething()); // 不要就删掉吧\n\n            this.doSomethingElse = () => this.trigger('doSomething');\n            this.on('mount', () => {\n                this.trigger('doSomething')\n            });\n        });\n\n### 基于状态基的异步流程处理\n\n其实2015年，是异步流程处理比较混乱的一年，Promise刚出来，没多少人敢用，\n更别提generator还有async之类的东西了，\n这套方案正好利用了发布订阅的优点，\n只要在异步事件触发之前订阅上就没问题了\n\n* 之前\n\n        QApp.defineView({\n            ...,\n            ready() {\n                this.ajax({\n                    ...,\n                    success() {\n                        foo(..., () => {\n                            bar( ..., () => {\n                                ...\n                            });\n                        })\n                    }\n                });\n            }\n        });\n\n* 之后\n\n        riot.tag('pay-view', '...', () => {\n            this.on('ajaxDone', () => {\n                ...\n                this.trigger('foo');\n            });\n\n            this.on('fooDone', () => {\n               ...\n               this.trigger('bar');\n            });\n\n            this.on('barDone', () => {\n               ...\n            });\n\n            this.on('mount', () => this.trigger('ajax'));\n        });\n\n### 利用组件树检索组件\n\n项目组件化（Component）+ 事件化（Reactive）之后，\n一个页面的运行方式就成为某一个组件监控某一个组件的某一事件并对其造成的处理。\n那么需要利用祖组件树解决一下检索问题。\n\n    require(\"pay-input\");\n    require(\"pay-submit\");\n\n    riot.tag('pay-vcode', `\n        <pay-input></pay-input>\n        <pay-submit>发送短信</pay-submit>\n    `, ()=> this.tags[\"pay-submit\"].on('subimit', () => {\n        this.trigger('vcodeSent');\n    }) );\n\n    riot.tag('pay-view', `\n        <pay-vcode></pay-vcode>\n        <pay-submit></pay-submit>\n    `, () => this.tags['pay-vcode'].on('vcodeSent', ()=> {\n        this.tags['pay-submit'].trigger('enabled');\n    }));\n\n\n* pay-view\n  * parent: null\n  * tags\n    * pay-vcode\n      * parent: pay-view\n      * tags\n        * pay-input\n        * pay-submit\n        * parent: pay-vcode\n      * pay-submit\n        * parent: pay-view\n\n\n### 利用mixin实现继承\n\necmascript2015之前，js一直都没有一个像样的类的表达方式，\n所以我们其实也没有一个像样的继承方式，\n混淆是目前用的最多的一种继承，大概是源自$.extend吧。\n\n* ajaxApi1\n\n        module.exports = {\n            init: {\n                this.on('ajaxApi1', () => ajax(...) );\n                this.on('ajaxApi1Done', ()　=> ... );\n            }\n        };\n\n* ajaxApi2\n\n        module.exports = {\n            init: {\n                this.on('ajaxApi2', () => ajax(...) );\n                this.on('ajaxApi2Done', () => ... );\n            }\n        };\n\n* pay-view\n\n        riot.tag('pay-view', '...', () => {\n            this.mixin(require('ajaxApi1.js'));\n            this.mixin(require('ajaxApi2.js'));\n\n            this.on('mount', () => this.trigger('ajaxApi1 ajaxApi2') );\n        });\n\n### 结合velocity和yield实现首屏渲染\n\n首屏渲染，SPA一直有这个问题。\n因为在html加载到js加载完成（甚至是一些ajax返回）之前，\n页面都是白屏，其实vm可以完成一部分后端的渲染，并替代第一个ajax。\n\n* vm之中\n\n        #set($description = \"这里会代替<yield/>\")\n        <pay-view>\n            <span if=\"$!description\">$description</span>\n        </pay-view>\n        <script>\n            window.vmData = \"$!vmData\";\n        </script>\n\n* js里面\n\n        riot.tag('pay-view', `\n            <pay-vcode></pay-vcode>\n            <pay-submit></pay-submit>\n            <yield/>\n        `, () => {\n            const vmData = window.vmData;\n        });\n\n### SPA的路由（这部分本文不涉及，忽略）\n\n## 希望优化的点\n\n### 发布订阅解决函数调用问题是存在缺陷的\n\n这套方案会产生冗余代码，其实最好使用typescript编写代码，\n这样在编译环境下就能查出哪个函数调用了删除的方法。\n\n* util.ts\n\n            export const a = {\n                    // foo() { 假设我删除了foo }\n                    ...\n            };\n\n* xxx.ts\n\n            import { a } from \"util\"\n\n            class xxx {\n                constructor() {\n                    a.foo(); // 编译时会报错foo这个方法不存在，终止编译\n                }\n            }\n\n### 使用面向对象的语法\n\n* html\n\n        <body>\n            <pay-view></pay-view>\n        </body>\n\n* ES5\n\n        require(\"pay-input\");\n        require(\"pay-submit\");\n        require(\"pay-vcode);\n\n        riot.tag(\"pay-view\", '<span>{ title }</span><pay-vcode></pay-vcode><pay-submit>提交</pay-submit>', function(opts) {\n            this.title = opts.title;\n        });\n\n        riot.mount(\"pay-view\", {});\n\n* TypeScript\n\n        import {PaySubmit} from \"pay-submit\";\n        import {PayVcode} from \"pay-vcode\";\n\n        @tag({\n            name: \"pay-view\",\n            tmpl: `\n            <span>{ title }</span>\n            <pay-vcode></pay-vcode>\n            <pay-submit>提交</pay-submit>\n            `\n        })\n        class PayView extends TagCore {\n            onCreate(tag) {\n                tag.title = opts.title;\n            }\n            constructor() {\n                this.submit = new PaySubmit();\n                this.vcode = new PayVcode();\n            }\n            submit: PaySubmit;\n            vcode: PayVcode;\n        }\n\n        PayView.mount({});\n\n### 利用发布订阅模式控制流程并不是最好的流程控制\n\n目前来说原生的Promise支持已经很不错了，\nasync虽然是个实验特性，\n但发明C#的微软明显推荐用这个特性。\n\n* 发布订阅\n\n        riot.tag('pay-view', '...', () => {\n            this.on('fooDone', ()=> this.bar());\n            this.on('barDone', ()=> this.blah());\n            this.bar = () => {\n                ...\n                this.trigger('barDone');\n            };\n            this.blah = () => xxx;\n            this.on('mount', () => this.trigger('fooDone'));\n        });\n\n* Promise\n\n        @tag({\n            name: \"pay-view\",\n            tmpl: \"...\",\n        });\n        class PayView extends TagCore {\n            onCreate(tag, opts) {\n                tag.on('mount', () => this.foo.then(()=> {\n                    return this.bar()\n                }).then(()=> {\n                    this.blah();\n                }));\n            }\n            foo = ()=> new Promise(resolve => resolve());\n            bar = ()=> new Promise (resolve => resolve())\n            blah = () => {...}\n            ...\n        }\n\n* async & await\n\n        @tag({\n            name: \"pay-view\",\n            tmpl: \"...\",\n        });\n        class PayView extends TagCore {\n            onCreate(tag, opts) {\n                tag.on('mount', async () => {\n                    await this.foo();\n                    await this.bar();\n                    this.blah();\n                });\n            }\n            foo = ()=> new Promise(resolve => resolve());\n            bar = ()=> new Promise (resolve => resolve())\n            blah = () => {...}\n            ...\n        }\n\n### 没有完善的广播机制\n\n其实之前的方案是可以广播的，但需要选中需要的组件，如\n\n    [tagA,tagB,tagC].forEach(tag => tag.trigger('foobar'));\n\n但是我希望的广播是每一个页面里面的tag无需选中就可以接收到。\n其实在每个tag加载之后都会传进一个opts对象，\n这个对象或者是执行mount函数传入的值，或者是模板标签上的变量\n\n    XXX.mount({ aaa: 1 });\n    // opts == {aaa: 1}\n\n    <xxx aaa=1 ></xxx>\n    // opts == {aaa：１}\n\n所以只要把一个obersable的对象传到opts里面就行了.\n\n### 需要一个更好的mixin\n\ntypescript对mixin支持很好，\n配合vscode的输入提醒代码体验十分完美，\n所以几乎可以放弃riot的mixin了\n\n* riot.mixin\n\n        // ajaxApi.js\n        {\n            init() {\n                this.on('ajaxApi', ()=> ...);\n            }\n        }\n        // xxxtag\n        riot.tag('xxx', '...', ()=> {\n            this.mixin(require('ajaxApi.js'));\n            this.trigger(\"ajaxApi\");\n        });\n\n* @mixin(any[])\n\n        class AjaxApi {\n            ajaxApi() {\n                ...\n            }\n        }\n\n        @tag({ name: \"xxx\", tmpl: \"...\" });\n        @mixin([AjaxApi])\n        class XxxTag extends TagCore implement AjaxApi {\n            onCreate( tag, opts ) {\n                this.ajaxApi();\n            }\n            ajaxApi: () => void;\n        }\n\n### velocity模板语法太次了\n\n改用node渲染，Qxf使用的是handlebars，riot自身也支持后端渲染。\n\n## 介绍点儿常识\n\n### typescript的语法\n\n#### 类型化声明\n\n        const a:string = \"这是一个不可变的字符串\";\n        let b:string; // b只能赋字符串\n        let c:any; // c可以赋任一值\n        let d: () => void; // d只能赋空参数且返回为空的函数\n\n#### class语法糖\n\n        class a extends b {\n            constructor() {\n                super();//执行b的构造函数\n            }\n            public foo() {\n                super.foo();//执行b的原型上的foo函数\n                console.log(`\n                    我在ａ的prototype上\n                    this指向context\n                `);\n            }\n            public bar =　() => {\n                cosnole.log(`\n                    我在a的实例里,\n                    this指向a的实例\n                `)\n            }\n            public blaha = function() {\n                cosnole.log(`\n                    tslint默认禁止使用\n                    我在a的实例里,\n                    this指向context\n                `)\n            }\n        }\n\n#### async await 上面提过了\n\n#### Object解构\n\n        const obj = { a: 1 };\n        const name = \"name\";\n        const data = { ...obj, b: 2, name }; // { a: 1, b : 2, name: \"name\" }\n        const { a:xxx } = obj; // xxx===1\n        const data1 = {[xxx]: 'data1'}; // {1: 'data1'}\n\n#### 接口\n\n        interface Ia { foo: () => void; }\n        interface Ib { bar: () => string; }\n        interface Ic { name: string; }\n        class D { doSomeThing() { .... } }\n        class E implements Ia,Ib,D {\n            doSomeThing: () => any;// 如果实现的是类内元素，可以只声明，不实现\n            foo = () => {...} // 如果实现的是接口内元素，必须按照类型定义\n            bar = () => {...} // 必须把要实现的所有接口内的元素声明\n            constructor(param: Ic) {\n                const { name } = param;// param 必须是只含有name的对象\n            }\n        }\n\n### 装饰器\n\n就是前面类似于@tag,@mixin的东西，\n这个有点复杂，只说在class前面的装饰器吧,\n是用来处理对象原型的函数，\n会在构造函数执行结束后执行\n\n### Qxf router的使用(其实是express4 router的使用)\n\n#### 三种获取请求参数的方式\n\n假设一个接口是 'api/default/index?a=1'\n\n        router.param('solution', (req, res, next, value) => {\n            console.log(value); => 'default'\n            next();\n        })\n\n        router.get('api/:solution/:page', (req, res, next) => {\n            console.log(req.params) => { solution: 'default', page: 'index' }\n            console.log(req.query.a) => 1\n\n            res.write('111');// 返回111但是请求并不结束\n            res.end();　// 返回结束\n        });\n\n        router.post('api/:solution/:page', (req, res, next) => {\n            console.log(req.params) => { solution: 'default', page: 'index' }\n            console.log(req.body.a) => 1\n            res.json({aaa: 1}); //　返回　{aaa: 1}\n        });\n\n#### 中间件\n\n        router.use(`api`, (req, res, next) => {\n            req.xxx = 'xxx';\n            next();\n        });\n\n### 核心的几个类和接口\n\n#### 状态机存储器：　Store\n\n```new Store()```可以订阅```on```或者触发```trigger```几种事件，\n没错```riot.tag```函数里面的```this```就继承自```Store```;\n\n    const a = new Store();\n    a.on('sayHi', () => console.log('hello'));\n    a.trigger('sayHi'); // hello\n\n#### 广播控制器：　Control\n\n是一个状态机的集合，方法```addStore```可以添加状态机存储器，\n```trigger```可以广播触发存储器的事件。\n\n    const store1 = new Store();\n    store1.on('sayHi', () => console.log('hello,I'm store1'));\n    const store2 = new Store();\n    store2.on('sayHi', () => console.log('hello,I'm store2'));\n    const ctrl = new Control();\n    ctrl.addStore(store1);\n    ctrl.addStore(store2);\n    ctrl.trigger('sayHi');//hello,I'm store1hello,I'm store2\n\n#### 标签生成器：TagCore虚基类\n\n必须搭配@tag装饰器，```new```一个TagCore的子类（构造函数必须传一个Control），\n跟执行了一下```riot.tag```是一样的。\n执行```mount```方法就能在页面空标签里挂在上标签的实现，相当于执行了```riot.mount```。\n\n    @tag({\n        name: 'x-tag',\n        tmpl: `<span>{content}</span>`\n    })\n    class XTag extends TagCore {\n        onCreate(tag: IriotTag, opts: IriotOpts) {\n            this.on('mount', () => opts.ctrl.trigger('xTag_Mounted') );\n            tag.content = opts.content;\n        }\n        mount: (opt: { content: string }) => void;\n    }\n\n    const store = new Store();\n    store.on('xTag_Mounted', () => console.log('prodCasted') );\n\n    const ctrl = new Control();\n    ctrl.addStore(store);\n\n    const xTag = new XTag(ctrl);\n    xTag.mount({ content: '我就是content' });\n\n    // 页面里面的<x-tag></x-tag> 变成　<x-tag><span>我就是content</span></x-tag>\n    // 控制台打印出 prodCasted\n\n### node-fetch\n\n一个开源的项目，可以让node端使用fetch，使用方法和whatwg里面的API是一样的，在此就不多嘴了。\n\n### 前后端同构初阶\n\n如果看网上的一些前后端同构的资料，他们会给你如下的方案。\n\n    if (isServer) {\n        doNodeThings();\n    } else {\n        doClientThings();\n    }\n\n我可以告诉你，他们都抄自同一个骗纸。。。\n\n原因是很多前端的modules会操作window对象，\nnode端的module更牛，有一些都是二进制的，\n如果用webpack1的话，如何bundle到一个js里面?\n\n#### TreeShaking\n\n树摇（字面翻译）是个es6对module的定义，\n简单地说js代码编译的时候会解析成AST语法树，\n通过分析这个语法树可以知道某一个js里面的某一个函数是多余的，\n打包的时候就可以把它剔除。","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/05/04/0-riotjs.md","slug":"2017/05/04/0-riotjs","body":"# 回顾一下以前的Riot.js方案\n\n2015年我开始从事前端工作，开始公司正在用QApp作为前端SPA框架，\n可是在我看来QApp比较笨重(130+KB)，另外还需要引入kami做组件(100+KB)，一直想找一个轻一点的框架代替，最后选择了riot.js(76KB)来代替这两个，主要基于以下几个需求。\n\n## 大量组件化的需求\n\nQApp的最小单位是View，也就是单一页面，而我接到的需求，要么是对某个按钮做改动，要么是连做几个页面，里面的某个输入框逻辑相同。QApp中的this指向View使得这些部分既不能从View里解构出来，对部分的修改也会造成挣个View的影响。\n\n* 以前的写法\n\n        QApp.defineView({\n            html: `\n            <div node-type=\"vcode\">\n                <input action-type=\"input\">\n                <button action-type=\"vcode\">发送短信</button>\n            </div>\n            <button action-type=\"submit\">提交</button>\n           `\n            actions: {\n                // 这里的this指向整个view\n                \"input:input\": () => this.doInput(),\n                \"submit\": () => this.doSubmit(),\n                \"vcode\": () => this.doVcode(),\n            },\n            init: {\n                doInput() {},\n                doSubmit() {},\n                doVcode() {},\n            }\n        });\n        QApp.config({...});\n\n* 新的写法\n\n        riot.tag('pay-input',`\n            <input oninput=\"oninput\">\n        `, ()=> {\n            // 这里的this指向整个pay-input\n        });\n        riot.tag('pay-submit', `\n            <submit ontap=\"onsubmit\">\n                <yield/>\n            </submit>\n        `, ()=> {\n            // 这里的this指向整个pay-submit\n        });\n        riot.tag('pay-vcode', `\n            <pay-input></pay-input>\n            <pay-submit>发送短信</pay-submit>\n        `, ()=> {\n            // 这里的this指向整个pay-vcode\n        });\n        riot.tag('pay-view',`\n            <pay-vcode></pay-vcode>\n            <pay-submit>提交</pay-submit>\n        `, ()=>{\n            // 这里的this指向整个pay-view\n        });\n        riot.mount('pay-view');\n\n## XX function is undefined\n\n报错邮件以前经常会有这样的报错，究其原因，很多是由“xxx功能”我不要了这种需求造成。\n\n* 之前的调用方式\n\n        QApp.defineView({\n            init: {\n                doSomething: ()=> {}// 删我貌似很困难\n                doSomethingElse: ()=>this.doSomething()\n            },\n            ready() {\n                this.doSomething();\n            }\n        });\n\n* 之后的调用方式\n\n        riot.tag('pay-view',`...`, ()=>{\n            this.on('doSomething', ()=> doSomething()); // 不要就删掉吧\n\n            this.doSomethingElse = () => this.trigger('doSomething');\n            this.on('mount', () => {\n                this.trigger('doSomething')\n            });\n        });\n\n## 基于状态基的异步流程处理\n\n其实2015年，是异步流程处理比较混乱的一年，Promise刚出来，没多少人敢用，\n更别提generator还有async之类的东西了，\n这套方案正好利用了发布订阅的优点，\n只要在异步事件触发之前订阅上就没问题了\n\n* 之前\n\n        QApp.defineView({\n            ...,\n            ready() {\n                this.ajax({\n                    ...,\n                    success() {\n                        foo(..., () => {\n                            bar( ..., () => {\n                                ...\n                            });\n                        })\n                    }\n                });\n            }\n        });\n\n* 之后\n\n        riot.tag('pay-view', '...', () => {\n            this.on('ajaxDone', () => {\n                ...\n                this.trigger('foo');\n            });\n\n            this.on('fooDone', () => {\n               ...\n               this.trigger('bar');\n            });\n\n            this.on('barDone', () => {\n               ...\n            });\n\n            this.on('mount', () => this.trigger('ajax'));\n        });\n\n## 利用组件树检索组件\n\n项目组件化（Component）+ 事件化（Reactive）之后，\n一个页面的运行方式就成为某一个组件监控某一个组件的某一事件并对其造成的处理。\n那么需要利用祖组件树解决一下检索问题。\n\n    require(\"pay-input\");\n    require(\"pay-submit\");\n\n    riot.tag('pay-vcode', `\n        <pay-input></pay-input>\n        <pay-submit>发送短信</pay-submit>\n    `, ()=> this.tags[\"pay-submit\"].on('subimit', () => {\n        this.trigger('vcodeSent');\n    }) );\n\n    riot.tag('pay-view', `\n        <pay-vcode></pay-vcode>\n        <pay-submit></pay-submit>\n    `, () => this.tags['pay-vcode'].on('vcodeSent', ()=> {\n        this.tags['pay-submit'].trigger('enabled');\n    }));\n\n\n* pay-view\n  * parent: null\n  * tags\n    * pay-vcode\n      * parent: pay-view\n      * tags\n        * pay-input\n        * pay-submit\n        * parent: pay-vcode\n      * pay-submit\n        * parent: pay-view\n\n## 利用mixin实现继承\n\necmascript2015之前，js一直都没有一个像样的类的表达方式，\n所以我们其实也没有一个像样的继承方式，\n混淆是目前用的最多的一种继承，大概是源自$.extend吧。\n\n* ajaxApi1\n\n        module.exports = {\n            init: {\n                this.on('ajaxApi1', () => ajax(...) );\n                this.on('ajaxApi1Done', ()　=> ... );\n            }\n        };\n\n* ajaxApi2\n\n        module.exports = {\n            init: {\n                this.on('ajaxApi2', () => ajax(...) );\n                this.on('ajaxApi2Done', () => ... );\n            }\n        };\n\n* pay-view\n\n        riot.tag('pay-view', '...', () => {\n            this.mixin(require('ajaxApi1.js'));\n            this.mixin(require('ajaxApi2.js'));\n\n            this.on('mount', () => this.trigger('ajaxApi1 ajaxApi2') );\n        });\n\n## 结合velocity和yield实现首屏渲染\n\n首屏渲染，SPA一直有这个问题。\n因为在html加载到js加载完成（甚至是一些ajax返回）之前，\n页面都是白屏，其实vm可以完成一部分后端的渲染，并替代第一个ajax。\n\n* vm之中\n\n        #set($description = \"这里会代替<yield/>\")\n        <pay-view>\n            <span if=\"$!description\">$description</span>\n        </pay-view>\n        <script>\n            window.vmData = \"$!vmData\";\n        </script>\n\n* js里面\n\n        riot.tag('pay-view', `\n            <pay-vcode></pay-vcode>\n            <pay-submit></pay-submit>\n            <yield/>\n        `, () => {\n            const vmData = window.vmData;\n        });\n\n## SPA的路由（忽略）\n\n## 视频地址\n\nhttp://v.youku.com/v_show/id_XMTUxMjMyMzM0OA==.html?from=s1.8-1-1.2&spm=a2h0k.8191407.0.0","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/05/04/1TypeScript.md","slug":"2017/05/04/1typescript","body":"# TypeScript干货\n\n## 类型化声明\n\n        const a:string = \"这是一个不可变的字符串\";\n        let b:string; // b只能赋字符串\n        let c:any; // c可以赋任一值\n        let d: () => void; // d只能赋空参数且返回为空的函数\n\n## 接口\n\n        interface Ia { foo: () => void; }\n        interface Ib { bar: () => string; }\n        interface Ic { name: string; }\n        class D { doSomeThing() { .... } }\n        class E implements Ia,Ib,D {\n            doSomeThing: () => any;// 如果实现的是类内元素，可以只声明，不实现\n            foo = () => {...} // 如果实现的是接口内元素，必须按照类型定义\n            bar = () => {...} // 必须把要实现的所有接口内的元素声明\n            constructor(param: Ic) {\n                const { name } = param;// param 必须是只含有name的对象\n            }\n        }\n\n## class语法糖\n\n        class a extends b {\n            constructor() {\n                super();//执行b的构造函数\n            }\n            public foo() {\n                super.foo();//执行b的原型上的foo函数\n                console.log(`\n                    我在ａ的prototype上\n                    this指向context\n                `);\n            }\n            public bar =　() => {\n                cosnole.log(`\n                    我在a的实例里,\n                    this指向a的实例\n                `)\n            }\n            public blaha = function() {\n                cosnole.log(`\n                    tslint默认禁止使用\n                    我在a的实例里,\n                    this指向context\n                `)\n            }\n        }\n\n## 装饰器\n\n类似于@tag,@mixin的东西，\n这个有点复杂，只说在class前面的装饰器吧,\n是用来处理对象原型的函数，\n会在构造函数执行结束后执行\n\n## Object解构\n\n        const obj = { a: 1 };\n        const name = \"name\";\n        const data = { ...obj, b: 2, name }; // { a: 1, b : 2, name: \"name\" }\n        const { a:xxx } = obj; // xxx===1\n        const data1 = {[xxx]: 'data1'}; // {1: 'data1'}\n\n## 一个更好的mixin\n\ntypescript对mixin支持很好，\n配合vscode的输入提醒代码体验十分完美，\n所以几乎可以放弃riot的mixin了\n\n* riot.mixin\n\n        // ajaxApi.js\n        {\n            init() {\n                this.on('ajaxApi', ()=> ...);\n            }\n        }\n        // xxxtag\n        riot.tag('xxx', '...', ()=> {\n            this.mixin(require('ajaxApi.js'));\n            this.trigger(\"ajaxApi\");\n        });\n\n* @mixin(any[])\n\n        class AjaxApi {\n            ajaxApi() {\n                ...\n            }\n        }\n\n        @tag({ name: \"xxx\", tmpl: \"...\" });\n        @mixin([AjaxApi])\n        class XxxTag extends TagCore implement AjaxApi {\n            onCreate( tag, opts ) {\n                this.ajaxApi();\n            }\n            ajaxApi: () => void;\n        }\n\n\n## async await 处理异步流程\n\n目前来说原生的Promise支持已经很不错了，\nasync虽然是个实验特性，\n但发明C#的微软明显推荐用这个特性。\n\n* 发布订阅\n\n        riot.tag('pay-view', '...', () => {\n            this.on('fooDone', ()=> this.bar());\n            this.on('barDone', ()=> this.blah());\n            this.bar = () => {\n                ...\n                this.trigger('barDone');\n            };\n            this.blah = () => xxx;\n            this.on('mount', () => this.trigger('fooDone'));\n        });\n\n* Promise\n\n        @tag({\n            name: \"pay-view\",\n            tmpl: \"...\",\n        });\n        class PayView extends TagCore {\n            onCreate(tag, opts) {\n                tag.on('mount', () => this.foo.then(()=> {\n                    return this.bar()\n                }).then(()=> {\n                    this.blah();\n                }));\n            }\n            foo = ()=> new Promise(resolve => resolve());\n            bar = ()=> new Promise (resolve => resolve())\n            blah = () => {...}\n            ...\n        }\n\n* async & await\n\n        @tag({\n            name: \"pay-view\",\n            tmpl: \"...\",\n        });\n        class PayView extends TagCore {\n            onCreate(tag, opts) {\n                tag.on('mount', async () => {\n                    await this.foo();\n                    await this.bar();\n                    this.blah();\n                });\n            }\n            foo = ()=> new Promise(resolve => resolve());\n            bar = ()=> new Promise (resolve => resolve())\n            blah = () => {...}\n            ...\n        }\n\n## 用TypeScript写一个Riot组件\n\n* html\n\n        <body>\n            <pay-view></pay-view>\n        </body>\n\n* ES5\n\n        require(\"pay-input\");\n        require(\"pay-submit\");\n        require(\"pay-vcode);\n\n        riot.tag(\"pay-view\", '<span>{ title }</span><pay-vcode></pay-vcode><pay-submit>提交</pay-submit>', function(opts) {\n            this.title = opts.title;\n            this.mixn(require('ajax1.js'));\n\n            this.trigger('ajax1');\n        });\n\n        riot.mount(\"pay-view\", {});\n\n* TypeScript\n\n        import {PaySubmit} from \"pay-submit\";\n        import {PayVcode} from \"pay-vcode\";\n\n        @tag({\n            name: \"pay-view\",\n            tmpl: `\n            <span>{ title }</span>\n            <pay-vcode></pay-vcode>\n            <pay-submit>提交</pay-submit>\n            `\n        })\n        @mixin([Ajax1])\n        class PayView extends TagCore implement Ajax1 {\n            onCreate(tag) {\n                tag.title = opts.title;\n                this.ajax1();\n            }\n            constructor() {\n                this.submit = new PaySubmit();\n                this.vcode = new PayVcode();\n            }\n            submit: PaySubmit;\n            vcode: PayVcode;\n            ajax1: () => void;\n        }\n\n        PayView.mount({});","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/05/04/2WebPack2-treeShaking-extTextPlugin.md","slug":"2017/05/04/2webpack2-treeshaking-exttextplugin","body":"# webpack2\n\n## tree-shaking（树摇）\n\nes6 module里面详述了树摇的的实现，但是webpack1始终没能实现，后来rollup实现了，于是大量框架转用rollup，去年webpack2发布，带来的就是这个tree-shaking功能。\n\n### AST树\n\n所有的代码，编译或者执行之前都会被转义成AST树，\n那么AST树是啥\n\n    let a;\n    let b = 1 + 1;\n\n* 代码\n    + 声明表达式\n        - let 声明\n        - 变量名 a\n    + 赋值表达式\n        - 加法运算\n            * 常量1\n            * 常量1\n        - 声明表达式\n            - let 声明\n            - 变量名 b\n\n### module的解析\n\n    // module a\n\n    export function foo() {...}\n    export function bar() {...}\n\n    // js\n\n    import { foo, bar } from a;\n\n    foo();\n\nwebpack会将代码解析成AST树，并发现bar并没有用过，就不会被打包进去。\n\n## extTextPlugin\n\n这是webpack的一个插件，可以解析出代码里面的css单独打包。这样css可以和组件放在一起了。\n\n    declare const require;\n    require(\"./style.scss\");\n\n    @tag({\n        name: \"pay-toast\",\n        tmpl: `\n        <div class=\"pay-toast\">{content}</div>\n        `,\n    })\n    export class PayToast extends TagCore {\n        public name: string = payToastConsts.name;\n        public onCreate(tag: ItoastTag, opts: ItoastRiotOpts) {\n            tag.update(opts);\n        }\n       public appendTag() {\n           const document = window.document;\n           const elem = document.createElement(this.name);\n           document.body.appendChild(elem);\n       }\n    }\n\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/05/04/3postcss-cssnext-cssnano.md","slug":"2017/05/04/3postcss-cssnext-cssnano","body":"# postcss干货\n\n上文说过，借助extTextPlugin可以把多个组件的css抽取成一个css，但webpack做的只是简单的文件拼接。处理css的地方要交给postcss。\n\n## cssnext\n\ncssnext使用caniuse.com的数据判断css需要支持到哪些浏览器，并自动做出可行的css解决方案（当然让ie6支持flex还是不行的）。\n\n    browsers: [\"> 0.1% in CN\", \"last 2 versions\"]\n\n登入 http://browserl.ist/ 可以查看上面的语句能支持的浏览器\n\n## cssnano\n\npostcss也是把css代码解析成ast树，解析之后可以看到冗余代码并对它进行压缩。\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/05/04/4Qxf-bigPipe.md","slug":"2017/05/04/4qxf-bigpipe","body":"# Qxf上的BigPipe的实现和优化原理\n\n![](http://i2.muimg.com/588926/2400354de719507f.jpg)\n\nQxf其实是express下的一堆中间件的集合，所以其实我在介绍express的BigPipe实现。\n\n简单的来说，当一个html开始下载的同时浏览器就开始渲染html了（而不是等html下载完成再渲染）。\n所以，返回给用户的页面可以一上一行地写出来（用我们学生时代老师的话来说就是挤牙膏）。\n\n## server => client (以前)\n\n1. 接到用户请求 => 白屏\n2. 请求接口，或者查数据库，处理数据，不拉不拉不拉 => 白屏\n3. 渲染出数据为state => 白屏\n4. 渲染模板为html => 白屏\n5. 返回html并结束请求 => 收到html并渲染，可能会下载css\n6. 空闲 => 下载js\n7. 空闲 => 渲染js，如果有ajax请求就请求\n\n## server => client (BigPipe)\n\n1. 接到用户请求 => 白屏\n2. 返回html的head => 收到head，下载css，核心js\n3. 请求接口，或者查数据库，处理数据 => 等待返回，如果有与UI无关的逻辑可以在下载完js后先执行\n4. 页面首部分的数据返回，生成state（组合成script标签） => 等待返回，如果有与UI无关的逻辑可以在下载完js后先执行\n5. 按照state生成模板一并返回，如果后面的接口也返回了数据重复3-5 => 渲染收到的html碎片\n6. 全部页面加载完成，结束请求 => 页面加载完成\n\n但是实际上按照BigPipe的做法，屏幕上面依赖的请求会阻塞，所以我对这一方案做了修改\n\n## server => client (BigPipe+)\n\n1. 接到用户请求 => 白屏\n2. 返回html的head + 按照默认state渲染的页面 + 默认state拼成的script标签 => 渲染出页面，下载css、js，js下载完成后可以操作了\n3. 请求接口，或者查数据库，处理数据 => 等待返回，或者直接操作页面\n4. 如果有接口返回，渲染出state并以script标签返回 => 根据收到的state二次渲染已经在dom树的组件\n5. 全部接口返回，结束请求 => 页面加载完成\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/05/04/5IsomophicApp.md","slug":"2017/05/04/5isomophicapp","body":"# Isomophic App\n\n如果你已经了解过前后端同构的话，你一定知道如下的方案\n\n    if (isServer) {\n        doServer();\n    } else {\n        doClient();\n    }\n\n那你看的文档应该都转发自同一个人。\n\n这种做法很有局限性\n\n* 你引用的module必须是umd打包的\n* 你引用的module必须不存在二进制包\n\n这回你知道为啥react要用全家桶了吧？\n\n## 换一种想法\n\n首先看一下node层和client层的不同点\n\n* node\n\n    接到用户Get请求 =>\n    node-fetch异步获取后端数据 =>\n    初始化Riot标签 =>\n    渲染页面为html =>\n    返回给用户 =>\n    收到接口元数据 =>\n    将元数据处理成state =>\n    以script标签形式返回用户 =>\n    res.end\n\n* client\n\n    收到渲染好的html并进行渲染 =>\n    加载js代码 =>\n    初始化Riot标签 =>\n    收到并运行script标签 =>\n    更新state =>\n    页面渲染完成\n\n可见，涉及到node像后端取数据并处理成state这部分逻辑是没必要加到client里面的，\n那么可以做两个文件实现node和client不同状态的处理。\n\n## 之前先介绍几个名词\n\n* 状态机存储器：　Store\n\n    ```new Store()```可以订阅```on```或者触发```trigger```几种事件，\n    没错```riot.tag```函数里面的```this```就继承自```Store```;\n\n* 广播控制器：　Control\n\n    是一个状态机的集合，方法```addStore```可以添加状态机存储器，\n    ```trigger```可以广播触发存储器的事件。\n\n* 标签生成器：TagCore虚基类\n\n* server.js\n\n        class RouteStore extends Store {\n            constructor(control) {\n                super()\n                this.on('apiFetched', () => ...)\n                this.on('serverStarted', () => ...)\n                ...\n            }\n        }\n\n        const control = new Control();\n        const routeStore = new RouteStroe(control);// 前后端不同的状态机\n        const someStore = new SomeStore(control);// 前后端一样的状态机\n\n        control.addStore(routeStore);\n        control.addStore(someStore);\n\n        const app = new App(control);\n\n* client.js\n\n        class ClientStore extends Store {\n            constructor(control) {\n                super()\n                this.on('DOMonLoad', () => ...)\n                ...\n            }\n        }\n\n        const control = new Control();\n        const clientStore = new ClientStore(control);// 前后端不同的状态机\n        const someStore = new SomeStore(control);// 前后端一样的状态机\n\n        control.addStore(clientStore);\n        control.addStore(someStore);\n\n        const app = new App(control);\n\n这样App、someStore这部分可以同构，clientStore和routeStore分别针对运行环境处理就可以了","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/05/04/6.md","slug":"2017/05/04/6","body":"# 项目完成情况\n\n## 封装完成但还没有上传npm\n\n1. QunarSniff中间件\n2. QunarLogin中间件\n3. TagCore，Control，Store\n4. fetch（用于合并请求，基于node-fetch）\n5. hysdk、QConfig-client-node， Qxf, PayGa 等的TypeScript封装\n6. 完成公用组件： yo-header, yo-logo, pay-toast\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/05/15/Riot-Preact.md","slug":"2017/05/15/riot-preact","body":"# 弃坑Riot转投Preact\n\n![换个坑继续趟](http://i4.buimg.com/588926/431151959544ded0.jpg)\n\n## 回顾一下为什么用Riot\n\n### 1. 对ES5最友好的组件化MVP框架\n\n> 吐槽一下现在的前端，gulp + webpack + rollup +　babel + ... 用gcc的同学都看哭了好么\n\nriot.js虽然官网上给出的语法是ES6的，但是可以直接使用ES5的语法，虽然react也可以，但是没人会想用ES5写JSX吧。\n\n相比于其它框架，使用ES5的riot.js不用写gulpfile，不用谢webpack.config.js，不用写babelrc，想想，直接上去就开始写逻辑还是件挺爽的事情哈。\n\n当时公司大量使用Fekit作为发布工具，因为Fekit只是简单地commonjs实现，所以使用Riot.js就是件理所当然的事情了。\n\n### 2. 十分轻量的框架\n\nriot.js的源码70+KB，混淆之后是10+KB，大概一个handlebars或者是大一点的arctemplate的大小，里面包括组件化、observable的事件机制、路由器、SSR这些功能。\n\n用riot.js开发之后的逻辑代码（移动端）大小也没有比vue的核心代码库大。\n\n所以如果有一个项目想要快速开发，代码量又不想太大，riot.js会是我推荐的，而且不必担心性能问题（可以参考我之前vue、react和riot的对比，分明react是性能最差的）。\n\n之前写过riot.js的最佳实践，没在公众号里面推，后面补上哈～\n\n----\n<center>\n    <h3>蛋是</h3>\n    <h2>你还是一个好<s>人</s>框架</h2>\n    <h3>而我已经不是那个骚年了</h3>\n</center>\n\n---\n\n## Preact的出现\n\n去年我录制了一个Riot.js的分享视频（在youku可以搜到哦），Preact大概在那时出现在了hackernews的首页，我记得当时hackernews下面的回复都是很轻蔑的“呵呵，又一个“。\n\n等了大概一年，这个项目居然没死，要知道这一年很多类react的项目过得可不是那么好啊。这个项目的Twitter帐号都发会议邀请函了。\n\n## 那么引入Preact是为什么\n\n### 1. Typescript对JSX的支持好过template\n\ntypescript能够做静态类型检查，简单地说，如果我的代码里面有什么拼写错误或者什么包没引入，编译器都能查出来。\n\n蛋是，如果我写的代码在模板里面，编译器就无能为力了，毕竟模板就只是字符串啊。而jsx不同，它是一种DSL，编译器自然会检查里面的代码。\n\n### 2. Preact真的太TM小了\n\n当时使用riotjs的原因很大的比重在减负，在我的哲学里面，一个框架只需要完成我需要它完成的东西，其他的不要多。preact相比riot减负了大概50k（源代码），当然功能上也少了（observable，router）。\n\n### 3. 真的能堵住很多人的嘴\n\nPreact和React用的是同一套API，JSX语法又一样，用这套框架估计没有人吐槽难用了吧？（这一条真的很无力，好多人连react都没用过，就说我用一冷门框架不好维护，就像我用了react你就能来维护一样）\n\n## 所以我会用Preact吗？\n\n我会在最近的一次优化把我的项目进行优化改造，最后我在根据它的性能（ssr+browser）、最终的业务代码大小、是否可以多人合作开发等多方面分析考虑是否切换。\n\n当然，也有别的可能，毕竟当初说好用vim的我现在竟用着vscode。\n\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/06/04/riotjs-typed.md","slug":"2017/06/04/riotjs-typed","body":"# 我把riotjs-typed开源了\n\n都来看啊，都来看啊\n\n关键字：\n\nriotjs, riotcontrol, SSR, 组件化开发, 前后端同构","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/06/15/nock-node-mock.md","slug":"2017/06/15/nock-node-mock","body":"# nock做node的mock数据\n\n懒得写了，mark一下","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/08/01/archifactory.md","slug":"2017/08/01/archifactory","body":"# Achifactory私有源的坑\n\n公司的私有源从CNPM改成AchiFactory了，为的是更好的管理docker、maven、PyPI和npm，结果我在迁移的时候出现了问题。\n\nnpm install的时候一直报 module achifactory not found\n\n结果是公司的私有库没有完全同步，我的一个私有包404了，但是报achifactory not found还真是。。。","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/08/15/Er-pt.md","slug":"2017/08/15/er-pt","body":"# 【Erʌpt】一个前后端同构的设计思想\n\n<img src=\"http://ww1.sinaimg.cn/large/89d0a2e1ly1fikrpw68t9j208c08cdfx.jpg\" alt=\"logo\" width=\"150px\">\n\n> 最近一直没有更新博客，其实脑子里面已经装了很多东西了，略微分享一下。\n\n[精美PPT~（花了十多分钟呢](http://gongbushang.com/ng/ERUPT/)\n\n## 前提\n\n2017年前端看起来是风平浪静的，其实不然，今年WASM终于定稿了，那意味着用任何语言编译web应用得到了官方支持。由于采纳的是Mozilla的asm.js方案，兼容性上面要好得多。很多人关注的是性能上的提升，而我觉得最先活起来的应该是前后端同构。因为大批的后端程序员可以避开javascript的各种坑去使用自己的开发语言开发前端应用了。\n\n### 最近出现了很多诸如RustWeb和Golymer的框架\n\n<table>\n<tr>\n<td>\n<img src=\"http://ww1.sinaimg.cn/mw690/89d0a2e1ly1fir7gp7j3ej20r40k6abz.jpg\"/>\n</td>\n<td>\n<img src=\"http://ww1.sinaimg.cn/mw690/89d0a2e1ly1fir7nz5t8qj21040qcabg.jpg\"/>\n</td>\n</tr>\n</table>\n\n### CS架构解决的问题\n\n![现有的CS架构](http://ww1.sinaimg.cn/thumbnail/89d0a2e1ly1fir7ta8jaij20a90a9437.jpg)\n\n* 我是谁\n* 我从哪里来\n* 要到哪里去\n\n### 照以前前后端分离的方案\n\n| server | client |\n|--------|--------|\n| 返回html | 发出请求 |\n| 空闲  | 获取css、js等资源 |\n| 空闲  | 发出ajax请求 |\n| 返回数据 | 空闲 |\n| 空闲 | 渲染数据 |\n\n### 前后端同构的做法\n\n| server | client |\n|--------|--------|\n| 返回html头部 | 发出请求 |\n| 返回html碎片 | 获取css、js |\n| 返回html碎片 | 渲染碎片 |\n| 返回end | 结束页面渲染 |\n\n### 小结一\n\n前后端同构是在“我是谁？”这一部分做了优化。\n\n### 前后端同构的优势\n\n1. SEO，不多说了；\n2. 减少http请求数；\n3. 减少用户初次访问页面的白页时间；\n4. 减少因前后端分离造成的技术障碍。\n\n### 前后端同构的策略\n\n1. 精确渲染\n2. 结构渲染\n3. 模板渲染\n\n#### 精确渲染\n\n把页面首屏的内容都渲染出来。\n\n![精确渲染](http://ww1.sinaimg.cn/mw690/89d0a2e1ly1fiylzsf71jj20hs0b4mxf.jpg)\n\n#### 精确渲染的评价\n\n优点\n\n* 渲染出来的页面就是用户看到的\n\n缺点\n\n* 部分后端请求会阻塞页面的渲染\n\n#### 结构渲染\n\n把初始状态的首屏渲染出来然后在同一请求中把应该展示的状态展示出来。\n\n![结构渲染](http://ww1.sinaimg.cn/mw690/89d0a2e1ly1fiym4385dfj20hs0b4jro.jpg)\n\n#### 框架渲染的评价\n\n优点\n\n* 解决了精确渲染会阻塞的问题\n\n缺点\n\n* 对于新闻类型的页面，框架渲染不利于SEO\n\n#### 模板渲染\n\n把模板直接作为html传到客户端。\n\n![模板渲染](http://ww1.sinaimg.cn/mw690/89d0a2e1ly1fiynhe7jenj20hs0b43ys.jpg)\n\n#### 模板渲染的评价\n\n优点\n\n* 字符串渲染，计算开销最小\n\n缺点\n\n* 用户会看到未渲染的模板变量\n\n### 小结二\n\n应该结合精确渲染和框架渲染\n\n## 介绍Erʌpt\n\n| | Erʌpt |  |\n|--|---|---|\n| E | Express | 这都不知道？退下吧  |\n| R | React | 这也不知道？别看了 |\n| ʌ | Values | 基于Redux的异步数据管理 |\n| P | Pipe | HTML渲染器 |\n| T | Tunnel | 同步数据管理 |\n\n## Values异步数据管理\n\n### 单向数据流\n\nreact的render函数是会不断轮询页面上绑定的数据来进行页面更新的。\n\n| value===\"bud\" | value===\"bloom\" |\n|--|--|\n|![](http://ww1.sinaimg.cn/mw690/89d0a2e1ly1fiyoot1ss4j20m80gojsi.jpg)|![](http://ww1.sinaimg.cn/mw690/89d0a2e1ly1fiyotbnajvj20m80godgz.jpg)|\n\n### Values的写法\n\n```typescript\nclass TestValues extends Values {\n    public getReducer() {\n        return combineReducers({\n            flower: TestValues.FlowerValue(),\n        });\n    }\n    public static FlowerValue = () => {\n        return ( value = \"bud\", action ) => {\n            if ( action.type === \"开花\" ) return \"bloom\";\n            if ( action.type === \"被狗踩了\" ) return \"baiduLogo\";\n            return value;\n        }\n    }\n}\n```\n\n### 怎么使用Values\n\n```typescript\nconst v = new TestValues();\nconst store = createStore(v.getReducer());\nstore.getState(); // { flower: \"bud\" }\n```\n\n### Pipe HTML渲染器\n\n用于利用React renderToString 生成HTML。\n\n### Pipe的写法\n\n```typescript\nclass TestPipe extends Pipe<Request, Response> {\n    constructor(request, response) {\n        super( request, response, minifyParams);\n    }\n    public renderPage(tunnel) {\n        this.html(`\n        <!doctype html>\n        <html>\n            <body>\n            ${this.JSX2HTML(\n                <Provider store={store}>\n                    <Page></Page>\n                </Provider>\n            )}\n            </body>\n        </html>\n        `);\n        this.response.end();\n    }\n}\n```\n\n### Tunnel同步数据管理\n\n#### Tunnel的设计\n\n前后端同构的意思是要在后端完成一部分工作，当前端getState的时候，获取的是后端生成并注入到前端作用域的state，也就是说这个对象在后端完成set工作，而在前端完成get工作。\n\n![Tunnel设计](http://ww1.sinaimg.cn/mw690/89d0a2e1ly1fiypthxr4jj20m80goq4f.jpg)\n\n#### Tunnel的使用\n\nServer\n\n```typescript\nconst t = new Tunnel(\"QNR_GLOBAL\", {}, value);\nPipe.renderPage(t)\n```\n\nClient\n\n```typescript\nconst t = new Tunnel();\nt.$state // { flower: \"bud\" }\nwindow.QNR_GLOBAL // { $state: { flower: \"bud\" } }\n```\n\n## 结论\n\nErvpt是VPT在react+express上面的实现，能够很好地实现前后端同构中的精确渲染和结构渲染，基于这套思想我相信它能带来一场新的前后端分离的革命，也就是前端能够主导全部的页面逻辑，后端专注于接口的优化。","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/09/18/Typescript sucks but long live the types.md","slug":"2017/09/18/typescript-sucks-but-long-live-the-types","body":"# TypeScript Sucks but Long Live the Types\n\n[查看PPT](http://gongbushang.com/ng/types-slide/)\n\n## Part I : Type System\n\n### JavaScript 是一种很爽的语言\n\n作为一款动态语言，比如你可以执行以下代码而不用担心报错。\n\n```javascript\nvar num = \"3\" - \"2\";　// num = 1\n```\n\n---\n\n但是，如果遇到了下面这种情况，就算是灾难了。\n\n```javascript\nisGreater(\"1000\", \"233\"); // false\n\nfunction isGreater(ａ, b) {\n    return a > b;\n}\n```\n\n---\n\n所以我们写代码的时候，都会加注释\n\n```javascript\n/**\n* 是否为最大\n* 参数传数字啊\n* 谁不传谁是小狗\n* @constructor\n* @param {number} ａ\n* @param {number} b\n* @returns {boolean}\n**/\nfunction isGreater(ａ, b) {\n    return a > b;\n}\n```\n\n---\n\n可是总有人不看注释，所以这个函数变成了\n\n```javascript\nfunction isGreater(a, b) {\n    const T_NUM = \"number\";\n    if (\n        T_NUM === typeof a &&\n        T_NUM === typeof b\n    ) {\n        return a > b;\n    } else {\n        throw(\"参数传数字啊，扎心了，老铁！\");\n    }\n}\n```\n\n---\n\n这还没完呢，假设这次改动出现在某次重构中，此前这个isGreater方法已经遍布你的项目了。\n\n```javascript\nbtn.onclick = () =>\n    isGreater(\"x\", \"y\") ? ... : ...;\n```\n\n而正好，这个 onClick 在自测的时候被忽略了。上线之后就是灾难了。\n\n---\n\n### 动态一时爽，重构火葬场\n\n### 举个 TS 的栗子\n\n```javascript\nfunction isGreater(ａ: number, b: number): boolean {\n    return a > b;\n}\n```\n\n### 类型系统的优势\n\n* 代码可读性高\n* 更有利于重构\n* IDE能更好地支持\n* 预防某些类型相关的错误\n\n### 比较流行的JS类型系统\n\n![](http://ww1.sinaimg.cn/mw690/89d0a2e1ly1fjow3fyxzbj20fy0baq4k.jpg)\n\n## Part II : TS vs Flow\n\n众多类型系统里面，typescript 和 flowtyped 的比较类似，目标都是为了 JS 的工程化，而且语法上除了细节几处根本没区别。\n\n### 对照\n\n| | TypeScript    | Flow-typed    |\n|--|---------------|---------------|\n| by   | Microsoft  | Facebook   |\n| in   | TypeScript | OCamel     |\n| is A | Compiler   | Checker    |\n| VSCode | 原生支持  | 安装插件 |\n| webpack | ts-loader | babel |\n| config | json | config |\n| version | 2.3.2 | 0.54.1 |\n\n### 简单比对\n\n#### TypeScript\n\n```javascript\nfunction isGreater(a: number, b: number): boolean {\n    return a > b;\n}\n\nisGreater(\"1\", \"2\");\n      // ^^^^\n      // Argument of type \"1\" is not assignable to parameter of type 'number'.\n```\n\n### Flow-typed\n\n```javascript\n//@flow\nfunction isGreater(a: number, b: number): boolean {\n    return a > b;\n}\n\nisGreater(\"1\", \"2\");\n        // ^^^  ^^^\n        // string (This type is incompatible with the expected param type of number)\n```\n\n### 空值检查\n\nTypeScript(strict) 和 Flow 都能指出 nullCheck 函数应该指明返回值为 string | void 类型。\n\n```javascript\nfunction nullCheck(num: number): string {\n                                // ^^^\n                                // [ts] Function lacks ending return statement and return type does not include 'undefined'.\n                                // [flow] This type is incompatible with an implicitly-returned undefined.\n    if (num > 10) {\n        return \"it's ok\"\n    }\n}\n```\n\n### 泛型\n\nTypeScript 和 Flow 都指出狗的数组不能加入猫的实例。\n\n```javascript\nclass Animal { }\nclass Dog extends Animal { woff = true }\nclass Cat extends Animal { meow = true }\n\nlet animals: Animal[] = [];\nlet dogs: Dog[] = [];\nlet cat: Cat[] = [];\n\nanimals.push(new Animal);\nanimals.push(new Dog);\nanimals.push(new Cat);\n\ndogs.push(new Cat);\n      // ^^^^^^^^\n      // 'Argument of type 'Cat' is not assignable to parameter of type 'Dog'.\n      // ^^^^^^^ Cat. This type is incompatible with\n```\n\n---\n\n此处 TS 和 Flow 都能查出错误，但是报错位置不同。\n\n```javascript\n//@flow\nclass Animal {}\nclass Dog extends Animal { woff = true }\nclass Cat extends Animal { meow = true }\n\nlet animals: Animal[] = [];\n            // ^^^^^^\n            // [flow] Animal (This type is incompatible with Cat)'\nlet cats: Cat[] = animals;\n// ^^^\n// [ts] Type 'Animal[]' is not assignable to type 'Cat[]'.\n```\n\n#### Wait for IT\n\n震惊，TypeScript 在这种情况下不报错！！！\n\n```javascript\n//@flow\nclass Animal {}\nclass Dog extends Animal { woff = true }\nclass Cat extends Animal { meow = true }\n\nlet cats: Cat[] = [];\nlet animals: Animal[] = cat;\n        // ^^^^^^^^^\n        // [flow] Animal (This type is incompatible with Cat)\n\nanimals.push(new Dog);\nanimals.push(new Cat);\nanimals.push(new Animal);\n\nJSON.stringify(cats); // [{\"woff\":true},{\"meow\":true},{}]\n```\n\n***TS 只做了类型检查，而 JS 数组是引用赋值的，因此引起了错误***\n\n#### Nominal & Structural (property-based) Typing\n\nFlow 是标称类型而 TS 是结构类型。\n\n```javascript\nclass Animal { }\nclass Dog extends Animal { name = \"dog\" }\nclass Cat extends Animal { name = \"cat\" }\n\nlet dog: Dog = new Dog;\ndog = new Cat;\n      // ^^^^^^^ [Flow] Cat. This type is incompatible with Dog\ndog = { name: \"dog\" };\n      // ^^^^^^^^^^^^^^^ [Flow] object literal. This type is incompatible with\n```\n\n#### 对比总结\n\n|    |　TypeScript | Flow-typed |\n|----|-------------|------------|\n| 工具支持　| 有亲爸做编辑器　| 目前体验存在迟钝，但可以做 linting 前的最后工序 |\n| 第三方库定义支持　| npm @types 私有库　| flow-typed 可以安装定义，但明显少于 TS |\n| 质量检查　| tslint　| eslint　(jshint 不行) |\n| 编译　|　可以直接编译为各版本的 JS | 借助babel |\n| 迁移成本　| 可以把原来的 JS 作为类库使用，但整体依然要用 TS 写 | 可以指定要检查的文件 |\n| 其他　| 支持很多es7/8的功能　| 只是检查器，但是类型检查强于 TS |\n\n## Part III Types in use (TypeScript)\n\n### Library\n\nJavaScript 的类库一直是良莠不齐，所以当你有两个以上的类库可选的话，究竟选哪个可能是个问题。\n\n好在如果一个 JS 类库存在类型声明的话，可以说明这两个问题。\n\n* 官方声明：作者写这一类库的时候不是玩票地试一下\n* 第三方声明：已经有人在使用这一类库了\n\n![](http://ww1.sinaimg.cn/mw690/89d0a2e1ly1fjq8ttqtxhj20w20i4abt.jpg)\n\n那么在使用这些类库的时候起码不会有太多的坑。\n\n#### NPM declarations\n\n假如你是一个类库的作者，你已经用 typescript 写完了一个库，正准备把它发布到 npm 上面，如果你想给这个类库加上类型声明，只需在 typescript 的编译配置　(tsconfig.json)　上添加如下字段。\n\n```javascript\n\"declaration\": true\n```\n\n再次编译，你会看到很多```*.d.ts```文件，这就是类库的声明文件。\n\n```javascript\nfunction isGreater(ａ: number, b: number): boolean;\n```\n\n接下来，在```package.json```添加 type 字段，再发布的 npm 包就已经带有声明了。\n\n```javascript\n\"types\": \"./lib/main.d.ts\",\n```\n\n另外，通过在　@types 下搜索也能找到第三方的类库声明。\n\n#### 3rd party declaration\n\n有的时候，你的类库并没有声明文件，同时 @types 也没有其他人上传，你需要自己写声明文件。\n\n比如 HySDK, 只需要在项目目录里添加　.d.ts　文件\n\n```javascript\ndeclare module \"@qnpm/hysdk\" {\n    export = {\n        openWebView: (param: {\n            url: string;\n            name?: string;\n            data?: any;\n        }) => void,\n    }\n}\n\nimport { openWebView } from \"@qnpm/hysdk\";\nopenWebView({ url: \"\" });\n```\n\n### Types in Redux\n\n前端交互逻辑用得最多的就是发布订阅模式了，\n在发布订阅模式里面需要一个约定值来确定订阅的是哪一个事件。\n那么类型系统就派上用场了，这里拿 Redux 举例。\n\n---\n\nRedux 的问题在于，订阅和发布的约定值可以随便写。\n\n```javascript\nconst store = createStore((state,{type, data}) => {\n    if (type === \"action1\") return ...\n    if (type === \"action2\") return ...\n    return state;\n})\nfunction doAction(action) {store.dispatch(action);}\ndoAction({ type: \"action1\", data }); // OK\ndoAction({ type: \"actionX\", data }); // OK\n```\n\n---\n\n我们给 action 写一个约束 IAction，这样，\n在 reducer 里面不能多写一个 actionY 事件，\ndispatch 的时候也不能指定 actionX 事件。\n\n```javascript\ninterface IAction { type: \"action1\" | \"action2\", data: any }\nconst store = createStore((state,{type, data}: IAction) => {\n    if (type === \"action1\") return ...\n    if (type === \"action2\") return ...\n    if (type === \"actionY\") return ... // Err\n    return state;\n})\nfunction doAction(action: IAction) {store.dispatch(action);}\ndoAction({ type: \"action1\", data }); // OK\ndoAction({ type: \"actionX\", data }); // Err\n```\n\n## Part IV Epilogue\n\n### 应该使用类型系统吗？\n\n|   |   |\n|---|---|\n| 页面只用于接下来的十一活动营销　| No |\n| 页面很简单就是展示文案 | No |\n| 新项目,并以后很有可能会频繁重构　| TypeScript |\n| 老项目,老文件不再改,只增加文件 | Flow |\n\n其实，前端的类型系统到目前为止依然还有很多瑕疵，因此我说 TypeScript sucks，但是就目前的版本来说，可比它刚发布那会儿要好用的多了，起码已经到了能用的地步。\n\n随着 TS 和 Flow 的发展和互相影响，前端类型系统将会逐步完善，但那都是以后的事了。就目前来说，如果你手上有一个大工程，还没有用上类型系统，那为何不尝试一下呢？","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/11/22/Building.Isomorphic.JavaScript.Apps.md","slug":"2017/11/22/buildingisomorphicjavascriptapps","body":"# Building Isomorphic JavaScript Applications\n\n## 读<构建同构的JavaScript应用>有感\n\n![](https://covers.oreillystatic.com/images/0636920042846/cat.gif)\n\n这本书简单介绍了并实现了前后端js应用方案(Hapj.js)\n\n我更喜欢书后半部分各个公司对前后端同构的优化.\n\n### React\n\nReact的后端渲染存在性能瓶颈(这个我在现实使用时也考虑过,虽然我用的是Preact), 书中通过修改 mountComponent 方法缓存最近渲染的模板, 这种 LRU 算法很大的加快了后端渲染效率. 貌似 Vue 也用的这种方案.\n\n我的做法可能更粗暴点,我直接在服务启动的时候把不会变化的组件渲染出来在内存里使用了,囧. 但这是最快的做法呀(原谅~).\n\n### Angular\n\n其实是 Angular1, 由于过于依赖浏览器, 开发者抽象了很多的浏览器 API. 作者介绍了 Angular2 Universal. 我比较喜欢的是 Preboot 功能, 这个功能能够缓存用户在未渲染完成的页面的操作,并在客户端渲染完成进行操作, 这样能够解决用户过早提交表单的问题.\n\n我的确碰到表单问题了, 但我是直接把表单删了, 依赖 JS 处理 submit 按钮, 这样用户在未渲染之前是不能提交的, 遗憾的是这样就失去了表单的功能了.\n\n### Backbone\n\n没有过多了解, 书里提到后悔使用jQuery, jQuery的确是一个前后同构的 js 库, 刚有 node 的时候我也在用, 然而现在我也不用了.\n\n### C#.Net\n\n有趣的是, 前后端同构并不是 node 独享的, 书里的最后一个例子是 C# 的, 作者找到了 js 和 C# 共有的模板引擎解决了跨语言前后端同构的问题.\n\n## 注意\n\n需要注意的是，做单页面应用的时候，或许不需要考虑太多内存泄漏，毕竟页面关了资源就释放了。而做 server 端并不会。\n\n\n## 总结\n\n这本书很薄, 英文版209页而已, 后面的例子的确有很多可采纳的地方.\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/12/20/plantUML.md","slug":"2017/12/20/plantuml","body":"# plantUML的使用\n\n参考自 [轻松从Js文件生成UML类图](https://github.com/imfly/bitcoin-on-nodejs/blob/master/4-%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/7-%E6%96%B9%E6%B3%95%E8%AE%BA/6-%E8%BD%BB%E6%9D%BE%E4%BB%8EJs%E6%96%87%E4%BB%B6%E7%94%9F%E6%88%90UML%E7%B1%BB%E5%9B%BE.md)\n\n## 使用说明\n\nvscode 安装 plantUML 插件, 编写 *.puml 文件的时候执行 Alt + D 可以预览绘制的流程图.\n\n## *.puml 文件格式说明\n\nplantUML的解析以 @startuml 开始 以 @enduml 结束\n\n## 时序图\n\n```plantuml\n@startuml\nactor Foo1\nboundary Foo2\ncontrol Foo3\nentity Foo4\ndatabase Foo5\ncollections Foo6\nFoo1 -> Foo2 : To boundary\nFoo1 -> Foo3 : To control\nFoo1 -> Foo4 : To entity\nFoo1 -> Foo5 : To database\nFoo1 -> Foo6 : To collections\n@enduml\n```\n\n![](http://ww1.sinaimg.cn/large/89d0a2e1ly1fn3ikg2r9fj20pe0m6433.jpg)\n\n\n```plantuml\n@startuml\nactor Bob\nactor Alice\nactor AVertyVeryLongName as L\nAlice->Bob: Authentication Request\nBob->Alice: Authentication Response\nBob->L: Log transaction\n@enduml\n```\n\n![](http://ww1.sinaimg.cn/large/89d0a2e1ly1fn3ikg1c86j20q60ietc5.jpg)\n\n## 活动图\n\n```plantuml\n@startuml\nstart\nif (condition A) then (yes)\n  :Text 1;\nelseif (condition B) then (yes)\n  :Text 2;\n  stop\nelseif (condition C) then (yes)\n  :Text 3;\nelseif (condition D) then (yes)\n  :Text 4;\nelse (nothing)\n  :Text else;\nendif\nstop\n@enduml\n```\n\n![](http://ww1.sinaimg.cn/large/89d0a2e1ly1fn3ikfxoemj20ug0f4juf.jpg)\n\n```plantuml\n@startuml\n\nstart\n\nrepeat\n  :read data;\n  :generate diagrams;\nrepeat while (more data?)\n\nstop\n\n@enduml\n```\n\n![](http://ww1.sinaimg.cn/large/89d0a2e1ly1fn3ikfyu6cj20c80ikjt1.jpg)\n\n## 类图\n\n```plantuml\n@startuml\nclass Dummy {\n  String data\n  void methods()\n}\n\nclass Flight {\n   flightNumber : Integer\n   departureTime : Date\n}\n@enduml\n```\n\n![](http://ww1.sinaimg.cn/large/89d0a2e1ly1fn3ikftv49j20iw060jsm.jpg)","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/12/25/WebAR.md","slug":"2017/12/25/webar","body":"\r\nhttps://github.com/jeromeetienne/AR.js/\r\n","collection":"blog","data":{"type":"post","category":"fe"}}]}