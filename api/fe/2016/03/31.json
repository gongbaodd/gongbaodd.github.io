{"posts":[{"id":"2016/03/31/VUE-Riot-React.md","slug":"2016/03/31/vue-riot-react","body":"\n# vue+riot+react 试用报告\n\n# 前言\n\n**_本报告不是针对哪个框架，单独说哪个框架好，撕逼的出门右拐微博谢谢_**\n\n最近迷上了组件化开发，感觉这是一种非常高效率的开发模式（说模式有点不对）。于是我第一时间找到了这仨库来做比较，下面请听我细细道来。\n\n## 本报告拢共扯了这些蛋\n\n- 三个库列表渲染性能比较\n- 三个库的学习曲线(自己体会吧)\n- 三个库静态页面动态渲染行为的方式(呵，这话说得)\n- rollup、postcss、webpack\n- 对 ES2015 使用的建议\n\n![测试结果](http://ww1.sinaimg.cn/large/89d0a2e1gw1f2u8fh7uygj20tv0n4473.jpg)\n\n# 关于项目\n\n## 工具\n\n> 1.分别使用三个库创建一个模拟 native 的无线滚动列表<br/> 2.体验一下三个库的开发效率、文件大小、学习曲线以及最终性能\n\n由于时间问题，这几个项目都没有使用 fekit 开发，并且都用了 ES6 的一部分功能\n\n- riot -> rollup\n- react -> webpack\n- vue -> vue-cli(webpack)\n\n## 组件\n\n三个项目都有基于组件化的思想，所以架构设计相同\n\n- App\n  - Scroller\n    - Card\n    - Card\n    - Card\n    - ...\n\n## 用的 ES2015 功能\n\n- 箭头函数\n- 解构\n- import\n- JSX（算是吧）\n\n## 文件大小\n\n- riot\n  - origin: 93k\n  - uglified: 40k\n  - gzip: 14k\n- react\n  - origin: 689k\n  - uglified: 356k\n  - gzip: 76k\n- vue\n  - origin: null\n  - uglified: 79.8k\n  - gzip: 27k\n\n# 性能分析\n\n1. 渲染一个富文本列表，项目数 n\n\n```javascript\nvar t1 = performance.now();\nself.items = res;\n\nsetTimeout(() => {\n  var t2 = performance.now();\n  console.log(\"[1]渲染节点数：\" + res.length + \"::lastTime:\" + (t2 - t1));\n}, 1);\n```\n\n2. 列表添加内容，项目数 n\n\n```javascript\nvar t3 = performance.now();\nself.items = self.items.concat(res);\nsetTimeout(() => {\n  var t4 = performance.now();\n  console.log(\"[2]增加节点数：\" + res.length + \"::lastTime:\" + (t4 - t3));\n}, 1);\n```\n\n3. 删除部分内容，项目数 n\n\n```javascript\nvar t5 = performance.now();\nself.items = self.items.slice(0, res.length);\nsetTimeout(() => {\n  var t6 = performance.now();\n  console.log(\"[3]部分删除：\" + res.length + \"::lastTime:\" + (t6 - t5));\n}, 1);\n```\n\n4. 列表倒置\n\n```javascript\nvar t7 = performance.now();\nself.items = self.items.reverse();\nsetTimeout(() => {\n  var t8 = performance.now();\n  console.log(\"[4]数组回转：\" + res.length + \"::lastTime:\" + (t8 - t7));\n}, 1);\n```\n\n## n===400\n\n- riot\n  1. 300ms\n  2. 38ms\n  3. 15ms\n  4. 150ms\n- react\n  1. 357ms\n  2. 478ms\n  3. 177ms\n  4. 278ms\n- vue\n  1. 480ms\n  2. 403ms\n  3. 124ms\n  4. 152ms\n\n## n===800\n\n- riot\n  1. 477ms\n  2. 287ms\n  3. 261ms\n  4. 273ms\n- react\n  1. 688ms\n  2. 1167ms\n  3. 531ms\n  4. 625ms\n- vue\n  1. 750ms\n  2. 775ms\n  3. 256ms\n  4. 270ms\n\n## n===1600\n\n- riot\n  1. 917ms\n  2. 776ms\n  3. 546ms\n  4. 641ms\n- react\n  1. 2780ms\n  2. 3109ms\n  3. 1612ms\n  4. 1067ms\n- vue\n  1. 1348ms\n  2. 1533ms\n  3. 1167ms\n  4. 712ms\n\n## n===3200\n\n- riot\n  1. 2268ms\n  2. 1816ms\n  3. 2444ms\n  4. 1474ms\n- react\n  1. 5374ms\n  2. 7411ms\n  3. 4107ms\n  4. 2316ms\n- vue\n  1. 2657ms\n  2. 2868ms\n  3. 3113ms\n  4. 1744ms\n\n# 学习曲线（在组件化方面，自己体会）\n\n## riot\n\n```html\n<parent-component class=\"parent\">\n  <child-component class=\"child\" onclick=\"{click}\"></child-component>\n  <h1>{title}</h1>\n  <script>\n    this.on('mount',()=>{\n        ...\n    });\n    this.click = e=>{\n        this.update({ title: \"clicked\" });\n    };\n  </script>\n  <style scoped>\n    :scope {\n    }\n  </style>\n</parent-component>\n```\n\n## react\n\n```javascript\nReact.createClass({\n    getInitialState(){\n        return { title: \"\" };\n    },\n    click(){\n        this.setState({title: \"clicked\"});\n    },\n    componentDidMount(){\n        ...\n    },\n    render(){\n        return (\n        <div className=\"parent\">\n            <div className=\"child\" onClick={this.click}></div>\n            <h1>{title}</h1>\n        </div>\n        );\n    }\n})\n```\n\n## vue\n\n```html\n<template>\n  <div class=\"parent\">\n    <child class=\"child\" @click=\"click\"></child>\n    <h1>{{title}}</h1>\n  </div>\n</template>\n<script>\n  export default {\n      components: { child },\n      data() { return { title: \"\" } },\n      ready() {\n          ...\n      },\n      methods: {\n          click() {\n              this.title = \"clicked\";\n          }\n      }\n  }\n</script>\n```\n\n# 三个库静态页面动态渲染行为的方式\n\n## 模板渲染(Vue,riot)\n\n两者都是模板渲染，所以你的 html 如果按照它们模板语法来写，渲染起来很简单\n\n## 数据元渲染(react，咦？html 不算数据元)\n\nreact 相当于把渲染的内容转成类似于 json 的数据元，到客户端渲染的时候还需要解析一遍数据元。。。\n说白了，你得用 redux 或者 flux 或者 relay\n\n# rollup、postcss 还是 webpack\n\n> 实际上都是些工具上的事，汗啊，还是哪天说吧\n\n# es2015 该用啥\n\nes2015 编译主要体现在\n\n- 语法糖编译\n- pollyfill\n- modules\n\n### 语法糖编译\n\n- class\n- 解构\n- 箭头符号\n- decorator（争议）\n\n### pollyfill\n\n- Promise\n- generator\n- async/await(7)\n\n### modules\n\n- import\n- export\n\n---\n\n## 个人感觉\n\n- pollyfill 实在太大了，如果能不用就别用\n- 语法糖最好用一下，代码可读性一下提高好多\n- modules 我靠你连这个都不用你还好意思说你用的是 es6，这玩意儿不仅要用还不要转译成 AMD 或者 CMD，就按照 es6 的规范做才对，给 rollup 点个赞。\n","collection":"blog","data":{"type":"post","category":"fe"}}]}