{"posts":[{"id":"2017/09/18/Typescript sucks but long live the types.md","slug":"2017/09/18/typescript-sucks-but-long-live-the-types","body":"# TypeScript Sucks but Long Live the Types\n\n[查看PPT](http://gongbushang.com/ng/types-slide/)\n\n## Part I : Type System\n\n### JavaScript 是一种很爽的语言\n\n作为一款动态语言，比如你可以执行以下代码而不用担心报错。\n\n```javascript\nvar num = \"3\" - \"2\";　// num = 1\n```\n\n---\n\n但是，如果遇到了下面这种情况，就算是灾难了。\n\n```javascript\nisGreater(\"1000\", \"233\"); // false\n\nfunction isGreater(ａ, b) {\n    return a > b;\n}\n```\n\n---\n\n所以我们写代码的时候，都会加注释\n\n```javascript\n/**\n* 是否为最大\n* 参数传数字啊\n* 谁不传谁是小狗\n* @constructor\n* @param {number} ａ\n* @param {number} b\n* @returns {boolean}\n**/\nfunction isGreater(ａ, b) {\n    return a > b;\n}\n```\n\n---\n\n可是总有人不看注释，所以这个函数变成了\n\n```javascript\nfunction isGreater(a, b) {\n    const T_NUM = \"number\";\n    if (\n        T_NUM === typeof a &&\n        T_NUM === typeof b\n    ) {\n        return a > b;\n    } else {\n        throw(\"参数传数字啊，扎心了，老铁！\");\n    }\n}\n```\n\n---\n\n这还没完呢，假设这次改动出现在某次重构中，此前这个isGreater方法已经遍布你的项目了。\n\n```javascript\nbtn.onclick = () =>\n    isGreater(\"x\", \"y\") ? ... : ...;\n```\n\n而正好，这个 onClick 在自测的时候被忽略了。上线之后就是灾难了。\n\n---\n\n### 动态一时爽，重构火葬场\n\n### 举个 TS 的栗子\n\n```javascript\nfunction isGreater(ａ: number, b: number): boolean {\n    return a > b;\n}\n```\n\n### 类型系统的优势\n\n* 代码可读性高\n* 更有利于重构\n* IDE能更好地支持\n* 预防某些类型相关的错误\n\n### 比较流行的JS类型系统\n\n![](http://ww1.sinaimg.cn/mw690/89d0a2e1ly1fjow3fyxzbj20fy0baq4k.jpg)\n\n## Part II : TS vs Flow\n\n众多类型系统里面，typescript 和 flowtyped 的比较类似，目标都是为了 JS 的工程化，而且语法上除了细节几处根本没区别。\n\n### 对照\n\n| | TypeScript    | Flow-typed    |\n|--|---------------|---------------|\n| by   | Microsoft  | Facebook   |\n| in   | TypeScript | OCamel     |\n| is A | Compiler   | Checker    |\n| VSCode | 原生支持  | 安装插件 |\n| webpack | ts-loader | babel |\n| config | json | config |\n| version | 2.3.2 | 0.54.1 |\n\n### 简单比对\n\n#### TypeScript\n\n```javascript\nfunction isGreater(a: number, b: number): boolean {\n    return a > b;\n}\n\nisGreater(\"1\", \"2\");\n      // ^^^^\n      // Argument of type \"1\" is not assignable to parameter of type 'number'.\n```\n\n### Flow-typed\n\n```javascript\n//@flow\nfunction isGreater(a: number, b: number): boolean {\n    return a > b;\n}\n\nisGreater(\"1\", \"2\");\n        // ^^^  ^^^\n        // string (This type is incompatible with the expected param type of number)\n```\n\n### 空值检查\n\nTypeScript(strict) 和 Flow 都能指出 nullCheck 函数应该指明返回值为 string | void 类型。\n\n```javascript\nfunction nullCheck(num: number): string {\n                                // ^^^\n                                // [ts] Function lacks ending return statement and return type does not include 'undefined'.\n                                // [flow] This type is incompatible with an implicitly-returned undefined.\n    if (num > 10) {\n        return \"it's ok\"\n    }\n}\n```\n\n### 泛型\n\nTypeScript 和 Flow 都指出狗的数组不能加入猫的实例。\n\n```javascript\nclass Animal { }\nclass Dog extends Animal { woff = true }\nclass Cat extends Animal { meow = true }\n\nlet animals: Animal[] = [];\nlet dogs: Dog[] = [];\nlet cat: Cat[] = [];\n\nanimals.push(new Animal);\nanimals.push(new Dog);\nanimals.push(new Cat);\n\ndogs.push(new Cat);\n      // ^^^^^^^^\n      // 'Argument of type 'Cat' is not assignable to parameter of type 'Dog'.\n      // ^^^^^^^ Cat. This type is incompatible with\n```\n\n---\n\n此处 TS 和 Flow 都能查出错误，但是报错位置不同。\n\n```javascript\n//@flow\nclass Animal {}\nclass Dog extends Animal { woff = true }\nclass Cat extends Animal { meow = true }\n\nlet animals: Animal[] = [];\n            // ^^^^^^\n            // [flow] Animal (This type is incompatible with Cat)'\nlet cats: Cat[] = animals;\n// ^^^\n// [ts] Type 'Animal[]' is not assignable to type 'Cat[]'.\n```\n\n#### Wait for IT\n\n震惊，TypeScript 在这种情况下不报错！！！\n\n```javascript\n//@flow\nclass Animal {}\nclass Dog extends Animal { woff = true }\nclass Cat extends Animal { meow = true }\n\nlet cats: Cat[] = [];\nlet animals: Animal[] = cat;\n        // ^^^^^^^^^\n        // [flow] Animal (This type is incompatible with Cat)\n\nanimals.push(new Dog);\nanimals.push(new Cat);\nanimals.push(new Animal);\n\nJSON.stringify(cats); // [{\"woff\":true},{\"meow\":true},{}]\n```\n\n***TS 只做了类型检查，而 JS 数组是引用赋值的，因此引起了错误***\n\n#### Nominal & Structural (property-based) Typing\n\nFlow 是标称类型而 TS 是结构类型。\n\n```javascript\nclass Animal { }\nclass Dog extends Animal { name = \"dog\" }\nclass Cat extends Animal { name = \"cat\" }\n\nlet dog: Dog = new Dog;\ndog = new Cat;\n      // ^^^^^^^ [Flow] Cat. This type is incompatible with Dog\ndog = { name: \"dog\" };\n      // ^^^^^^^^^^^^^^^ [Flow] object literal. This type is incompatible with\n```\n\n#### 对比总结\n\n|    |　TypeScript | Flow-typed |\n|----|-------------|------------|\n| 工具支持　| 有亲爸做编辑器　| 目前体验存在迟钝，但可以做 linting 前的最后工序 |\n| 第三方库定义支持　| npm @types 私有库　| flow-typed 可以安装定义，但明显少于 TS |\n| 质量检查　| tslint　| eslint　(jshint 不行) |\n| 编译　|　可以直接编译为各版本的 JS | 借助babel |\n| 迁移成本　| 可以把原来的 JS 作为类库使用，但整体依然要用 TS 写 | 可以指定要检查的文件 |\n| 其他　| 支持很多es7/8的功能　| 只是检查器，但是类型检查强于 TS |\n\n## Part III Types in use (TypeScript)\n\n### Library\n\nJavaScript 的类库一直是良莠不齐，所以当你有两个以上的类库可选的话，究竟选哪个可能是个问题。\n\n好在如果一个 JS 类库存在类型声明的话，可以说明这两个问题。\n\n* 官方声明：作者写这一类库的时候不是玩票地试一下\n* 第三方声明：已经有人在使用这一类库了\n\n![](http://ww1.sinaimg.cn/mw690/89d0a2e1ly1fjq8ttqtxhj20w20i4abt.jpg)\n\n那么在使用这些类库的时候起码不会有太多的坑。\n\n#### NPM declarations\n\n假如你是一个类库的作者，你已经用 typescript 写完了一个库，正准备把它发布到 npm 上面，如果你想给这个类库加上类型声明，只需在 typescript 的编译配置　(tsconfig.json)　上添加如下字段。\n\n```javascript\n\"declaration\": true\n```\n\n再次编译，你会看到很多```*.d.ts```文件，这就是类库的声明文件。\n\n```javascript\nfunction isGreater(ａ: number, b: number): boolean;\n```\n\n接下来，在```package.json```添加 type 字段，再发布的 npm 包就已经带有声明了。\n\n```javascript\n\"types\": \"./lib/main.d.ts\",\n```\n\n另外，通过在　@types 下搜索也能找到第三方的类库声明。\n\n#### 3rd party declaration\n\n有的时候，你的类库并没有声明文件，同时 @types 也没有其他人上传，你需要自己写声明文件。\n\n比如 HySDK, 只需要在项目目录里添加　.d.ts　文件\n\n```javascript\ndeclare module \"@qnpm/hysdk\" {\n    export = {\n        openWebView: (param: {\n            url: string;\n            name?: string;\n            data?: any;\n        }) => void,\n    }\n}\n\nimport { openWebView } from \"@qnpm/hysdk\";\nopenWebView({ url: \"\" });\n```\n\n### Types in Redux\n\n前端交互逻辑用得最多的就是发布订阅模式了，\n在发布订阅模式里面需要一个约定值来确定订阅的是哪一个事件。\n那么类型系统就派上用场了，这里拿 Redux 举例。\n\n---\n\nRedux 的问题在于，订阅和发布的约定值可以随便写。\n\n```javascript\nconst store = createStore((state,{type, data}) => {\n    if (type === \"action1\") return ...\n    if (type === \"action2\") return ...\n    return state;\n})\nfunction doAction(action) {store.dispatch(action);}\ndoAction({ type: \"action1\", data }); // OK\ndoAction({ type: \"actionX\", data }); // OK\n```\n\n---\n\n我们给 action 写一个约束 IAction，这样，\n在 reducer 里面不能多写一个 actionY 事件，\ndispatch 的时候也不能指定 actionX 事件。\n\n```javascript\ninterface IAction { type: \"action1\" | \"action2\", data: any }\nconst store = createStore((state,{type, data}: IAction) => {\n    if (type === \"action1\") return ...\n    if (type === \"action2\") return ...\n    if (type === \"actionY\") return ... // Err\n    return state;\n})\nfunction doAction(action: IAction) {store.dispatch(action);}\ndoAction({ type: \"action1\", data }); // OK\ndoAction({ type: \"actionX\", data }); // Err\n```\n\n## Part IV Epilogue\n\n### 应该使用类型系统吗？\n\n|   |   |\n|---|---|\n| 页面只用于接下来的十一活动营销　| No |\n| 页面很简单就是展示文案 | No |\n| 新项目,并以后很有可能会频繁重构　| TypeScript |\n| 老项目,老文件不再改,只增加文件 | Flow |\n\n其实，前端的类型系统到目前为止依然还有很多瑕疵，因此我说 TypeScript sucks，但是就目前的版本来说，可比它刚发布那会儿要好用的多了，起码已经到了能用的地步。\n\n随着 TS 和 Flow 的发展和互相影响，前端类型系统将会逐步完善，但那都是以后的事了。就目前来说，如果你手上有一个大工程，还没有用上类型系统，那为何不尝试一下呢？","collection":"blog","data":{"type":"post","category":"fe"}}]}