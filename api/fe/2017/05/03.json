{"posts":[{"id":"2017/05/03/QxfComponents.md","slug":"2017/05/03/qxfcomponents","body":"# 写啥题目呢\n\n## 回顾一下\n\n去年三月，我分享了一个用riotjs开发前端的方案，既然已经有一年的时间了，就先回顾一下。\n\n这套方案出自2015年，之前一直使用的是公司的QApp解决方案，后来发现使用上存在问题，\n并在试图寻找一套可行的替代方案。\n\n### 组件化方案\n\nQApp的最小单位是View(大概可以理解为页面)，\nView里面大到一个轮播图小到一个按钮的操作逻辑都和view耦合，\n假设我想使用某一个View里面的某一个组件，想直接拆出来是不太可能的。\n\n* 以前的写法\n\n        QApp.defineView({\n            html: `\n            <div node-type=\"vcode\">\n                <input action-type=\"input\">\n                <button action-type=\"vcode\">发送短信</button>\n            </div>\n            <button action-type=\"submit\">提交</button>\n           `\n            actions: {\n                // 这里的this指向整个view\n                \"input:input\": () => this.doInput(),\n                \"submit\": () => this.doSubmit(),\n                \"vcode\": () => this.doVcode(),\n            },\n            init: {\n                doInput() {},\n                doSubmit() {},\n                doVcode() {},\n            }\n        });\n        QApp.config({...});\n\n* 新的写法\n\n        riot.tag('pay-input',`\n            <input oninput=\"oninput\">\n        `, ()=> {\n            // 这里的this指向整个pay-input\n        });\n        riot.tag('pay-submit', `\n            <submit ontap=\"onsubmit\">\n                <yield/>\n            </submit>\n        `, ()=> {\n            // 这里的this指向整个pay-submit\n        });\n        riot.tag('pay-vcode', `\n            <pay-input></pay-input>\n            <pay-submit>发送短信</pay-submit>\n        `, ()=> {\n            // 这里的this指向整个pay-vcode\n        });\n        riot.tag('pay-view',`\n            <pay-vcode></pay-vcode>\n            <pay-submit>提交</pay-submit>\n        `, ()=>{\n            // 这里的this指向整个pay-view\n        });\n        riot.mount('pay-view');\n\n### 基于发布订阅的统一事件管理模式\n\n有很多时候，我们要处以理一些“这些东西，我们不要了”之类的需求，\n当我们回头去翻代码的时候，惊奇的发现它被封装了，\n那么后面的故事就是要和“xxx function is undefined”做长期斗争了。\n\n* 之前的调用方式\n\n        QApp.defineView({\n            init: {\n                doSomething: ()=> {}// 删我貌似很困难\n                doSomethingElse: ()=>this.doSomething()\n            },\n            ready() {\n                this.doSomething();\n            }\n        });\n\n* 之后的调用方式\n\n        riot.tag('pay-view',`...`, ()=>{\n            this.on('doSomething', ()=> doSomething()); // 不要就删掉吧\n\n            this.doSomethingElse = () => this.trigger('doSomething');\n            this.on('mount', () => {\n                this.trigger('doSomething')\n            });\n        });\n\n### 基于状态基的异步流程处理\n\n其实2015年，是异步流程处理比较混乱的一年，Promise刚出来，没多少人敢用，\n更别提generator还有async之类的东西了，\n这套方案正好利用了发布订阅的优点，\n只要在异步事件触发之前订阅上就没问题了\n\n* 之前\n\n        QApp.defineView({\n            ...,\n            ready() {\n                this.ajax({\n                    ...,\n                    success() {\n                        foo(..., () => {\n                            bar( ..., () => {\n                                ...\n                            });\n                        })\n                    }\n                });\n            }\n        });\n\n* 之后\n\n        riot.tag('pay-view', '...', () => {\n            this.on('ajaxDone', () => {\n                ...\n                this.trigger('foo');\n            });\n\n            this.on('fooDone', () => {\n               ...\n               this.trigger('bar');\n            });\n\n            this.on('barDone', () => {\n               ...\n            });\n\n            this.on('mount', () => this.trigger('ajax'));\n        });\n\n### 利用组件树检索组件\n\n项目组件化（Component）+ 事件化（Reactive）之后，\n一个页面的运行方式就成为某一个组件监控某一个组件的某一事件并对其造成的处理。\n那么需要利用祖组件树解决一下检索问题。\n\n    require(\"pay-input\");\n    require(\"pay-submit\");\n\n    riot.tag('pay-vcode', `\n        <pay-input></pay-input>\n        <pay-submit>发送短信</pay-submit>\n    `, ()=> this.tags[\"pay-submit\"].on('subimit', () => {\n        this.trigger('vcodeSent');\n    }) );\n\n    riot.tag('pay-view', `\n        <pay-vcode></pay-vcode>\n        <pay-submit></pay-submit>\n    `, () => this.tags['pay-vcode'].on('vcodeSent', ()=> {\n        this.tags['pay-submit'].trigger('enabled');\n    }));\n\n\n* pay-view\n  * parent: null\n  * tags\n    * pay-vcode\n      * parent: pay-view\n      * tags\n        * pay-input\n        * pay-submit\n        * parent: pay-vcode\n      * pay-submit\n        * parent: pay-view\n\n\n### 利用mixin实现继承\n\necmascript2015之前，js一直都没有一个像样的类的表达方式，\n所以我们其实也没有一个像样的继承方式，\n混淆是目前用的最多的一种继承，大概是源自$.extend吧。\n\n* ajaxApi1\n\n        module.exports = {\n            init: {\n                this.on('ajaxApi1', () => ajax(...) );\n                this.on('ajaxApi1Done', ()　=> ... );\n            }\n        };\n\n* ajaxApi2\n\n        module.exports = {\n            init: {\n                this.on('ajaxApi2', () => ajax(...) );\n                this.on('ajaxApi2Done', () => ... );\n            }\n        };\n\n* pay-view\n\n        riot.tag('pay-view', '...', () => {\n            this.mixin(require('ajaxApi1.js'));\n            this.mixin(require('ajaxApi2.js'));\n\n            this.on('mount', () => this.trigger('ajaxApi1 ajaxApi2') );\n        });\n\n### 结合velocity和yield实现首屏渲染\n\n首屏渲染，SPA一直有这个问题。\n因为在html加载到js加载完成（甚至是一些ajax返回）之前，\n页面都是白屏，其实vm可以完成一部分后端的渲染，并替代第一个ajax。\n\n* vm之中\n\n        #set($description = \"这里会代替<yield/>\")\n        <pay-view>\n            <span if=\"$!description\">$description</span>\n        </pay-view>\n        <script>\n            window.vmData = \"$!vmData\";\n        </script>\n\n* js里面\n\n        riot.tag('pay-view', `\n            <pay-vcode></pay-vcode>\n            <pay-submit></pay-submit>\n            <yield/>\n        `, () => {\n            const vmData = window.vmData;\n        });\n\n### SPA的路由（这部分本文不涉及，忽略）\n\n## 希望优化的点\n\n### 发布订阅解决函数调用问题是存在缺陷的\n\n这套方案会产生冗余代码，其实最好使用typescript编写代码，\n这样在编译环境下就能查出哪个函数调用了删除的方法。\n\n* util.ts\n\n            export const a = {\n                    // foo() { 假设我删除了foo }\n                    ...\n            };\n\n* xxx.ts\n\n            import { a } from \"util\"\n\n            class xxx {\n                constructor() {\n                    a.foo(); // 编译时会报错foo这个方法不存在，终止编译\n                }\n            }\n\n### 使用面向对象的语法\n\n* html\n\n        <body>\n            <pay-view></pay-view>\n        </body>\n\n* ES5\n\n        require(\"pay-input\");\n        require(\"pay-submit\");\n        require(\"pay-vcode);\n\n        riot.tag(\"pay-view\", '<span>{ title }</span><pay-vcode></pay-vcode><pay-submit>提交</pay-submit>', function(opts) {\n            this.title = opts.title;\n        });\n\n        riot.mount(\"pay-view\", {});\n\n* TypeScript\n\n        import {PaySubmit} from \"pay-submit\";\n        import {PayVcode} from \"pay-vcode\";\n\n        @tag({\n            name: \"pay-view\",\n            tmpl: `\n            <span>{ title }</span>\n            <pay-vcode></pay-vcode>\n            <pay-submit>提交</pay-submit>\n            `\n        })\n        class PayView extends TagCore {\n            onCreate(tag) {\n                tag.title = opts.title;\n            }\n            constructor() {\n                this.submit = new PaySubmit();\n                this.vcode = new PayVcode();\n            }\n            submit: PaySubmit;\n            vcode: PayVcode;\n        }\n\n        PayView.mount({});\n\n### 利用发布订阅模式控制流程并不是最好的流程控制\n\n目前来说原生的Promise支持已经很不错了，\nasync虽然是个实验特性，\n但发明C#的微软明显推荐用这个特性。\n\n* 发布订阅\n\n        riot.tag('pay-view', '...', () => {\n            this.on('fooDone', ()=> this.bar());\n            this.on('barDone', ()=> this.blah());\n            this.bar = () => {\n                ...\n                this.trigger('barDone');\n            };\n            this.blah = () => xxx;\n            this.on('mount', () => this.trigger('fooDone'));\n        });\n\n* Promise\n\n        @tag({\n            name: \"pay-view\",\n            tmpl: \"...\",\n        });\n        class PayView extends TagCore {\n            onCreate(tag, opts) {\n                tag.on('mount', () => this.foo.then(()=> {\n                    return this.bar()\n                }).then(()=> {\n                    this.blah();\n                }));\n            }\n            foo = ()=> new Promise(resolve => resolve());\n            bar = ()=> new Promise (resolve => resolve())\n            blah = () => {...}\n            ...\n        }\n\n* async & await\n\n        @tag({\n            name: \"pay-view\",\n            tmpl: \"...\",\n        });\n        class PayView extends TagCore {\n            onCreate(tag, opts) {\n                tag.on('mount', async () => {\n                    await this.foo();\n                    await this.bar();\n                    this.blah();\n                });\n            }\n            foo = ()=> new Promise(resolve => resolve());\n            bar = ()=> new Promise (resolve => resolve())\n            blah = () => {...}\n            ...\n        }\n\n### 没有完善的广播机制\n\n其实之前的方案是可以广播的，但需要选中需要的组件，如\n\n    [tagA,tagB,tagC].forEach(tag => tag.trigger('foobar'));\n\n但是我希望的广播是每一个页面里面的tag无需选中就可以接收到。\n其实在每个tag加载之后都会传进一个opts对象，\n这个对象或者是执行mount函数传入的值，或者是模板标签上的变量\n\n    XXX.mount({ aaa: 1 });\n    // opts == {aaa: 1}\n\n    <xxx aaa=1 ></xxx>\n    // opts == {aaa：１}\n\n所以只要把一个obersable的对象传到opts里面就行了.\n\n### 需要一个更好的mixin\n\ntypescript对mixin支持很好，\n配合vscode的输入提醒代码体验十分完美，\n所以几乎可以放弃riot的mixin了\n\n* riot.mixin\n\n        // ajaxApi.js\n        {\n            init() {\n                this.on('ajaxApi', ()=> ...);\n            }\n        }\n        // xxxtag\n        riot.tag('xxx', '...', ()=> {\n            this.mixin(require('ajaxApi.js'));\n            this.trigger(\"ajaxApi\");\n        });\n\n* @mixin(any[])\n\n        class AjaxApi {\n            ajaxApi() {\n                ...\n            }\n        }\n\n        @tag({ name: \"xxx\", tmpl: \"...\" });\n        @mixin([AjaxApi])\n        class XxxTag extends TagCore implement AjaxApi {\n            onCreate( tag, opts ) {\n                this.ajaxApi();\n            }\n            ajaxApi: () => void;\n        }\n\n### velocity模板语法太次了\n\n改用node渲染，Qxf使用的是handlebars，riot自身也支持后端渲染。\n\n## 介绍点儿常识\n\n### typescript的语法\n\n#### 类型化声明\n\n        const a:string = \"这是一个不可变的字符串\";\n        let b:string; // b只能赋字符串\n        let c:any; // c可以赋任一值\n        let d: () => void; // d只能赋空参数且返回为空的函数\n\n#### class语法糖\n\n        class a extends b {\n            constructor() {\n                super();//执行b的构造函数\n            }\n            public foo() {\n                super.foo();//执行b的原型上的foo函数\n                console.log(`\n                    我在ａ的prototype上\n                    this指向context\n                `);\n            }\n            public bar =　() => {\n                cosnole.log(`\n                    我在a的实例里,\n                    this指向a的实例\n                `)\n            }\n            public blaha = function() {\n                cosnole.log(`\n                    tslint默认禁止使用\n                    我在a的实例里,\n                    this指向context\n                `)\n            }\n        }\n\n#### async await 上面提过了\n\n#### Object解构\n\n        const obj = { a: 1 };\n        const name = \"name\";\n        const data = { ...obj, b: 2, name }; // { a: 1, b : 2, name: \"name\" }\n        const { a:xxx } = obj; // xxx===1\n        const data1 = {[xxx]: 'data1'}; // {1: 'data1'}\n\n#### 接口\n\n        interface Ia { foo: () => void; }\n        interface Ib { bar: () => string; }\n        interface Ic { name: string; }\n        class D { doSomeThing() { .... } }\n        class E implements Ia,Ib,D {\n            doSomeThing: () => any;// 如果实现的是类内元素，可以只声明，不实现\n            foo = () => {...} // 如果实现的是接口内元素，必须按照类型定义\n            bar = () => {...} // 必须把要实现的所有接口内的元素声明\n            constructor(param: Ic) {\n                const { name } = param;// param 必须是只含有name的对象\n            }\n        }\n\n### 装饰器\n\n就是前面类似于@tag,@mixin的东西，\n这个有点复杂，只说在class前面的装饰器吧,\n是用来处理对象原型的函数，\n会在构造函数执行结束后执行\n\n### Qxf router的使用(其实是express4 router的使用)\n\n#### 三种获取请求参数的方式\n\n假设一个接口是 'api/default/index?a=1'\n\n        router.param('solution', (req, res, next, value) => {\n            console.log(value); => 'default'\n            next();\n        })\n\n        router.get('api/:solution/:page', (req, res, next) => {\n            console.log(req.params) => { solution: 'default', page: 'index' }\n            console.log(req.query.a) => 1\n\n            res.write('111');// 返回111但是请求并不结束\n            res.end();　// 返回结束\n        });\n\n        router.post('api/:solution/:page', (req, res, next) => {\n            console.log(req.params) => { solution: 'default', page: 'index' }\n            console.log(req.body.a) => 1\n            res.json({aaa: 1}); //　返回　{aaa: 1}\n        });\n\n#### 中间件\n\n        router.use(`api`, (req, res, next) => {\n            req.xxx = 'xxx';\n            next();\n        });\n\n### 核心的几个类和接口\n\n#### 状态机存储器：　Store\n\n```new Store()```可以订阅```on```或者触发```trigger```几种事件，\n没错```riot.tag```函数里面的```this```就继承自```Store```;\n\n    const a = new Store();\n    a.on('sayHi', () => console.log('hello'));\n    a.trigger('sayHi'); // hello\n\n#### 广播控制器：　Control\n\n是一个状态机的集合，方法```addStore```可以添加状态机存储器，\n```trigger```可以广播触发存储器的事件。\n\n    const store1 = new Store();\n    store1.on('sayHi', () => console.log('hello,I'm store1'));\n    const store2 = new Store();\n    store2.on('sayHi', () => console.log('hello,I'm store2'));\n    const ctrl = new Control();\n    ctrl.addStore(store1);\n    ctrl.addStore(store2);\n    ctrl.trigger('sayHi');//hello,I'm store1hello,I'm store2\n\n#### 标签生成器：TagCore虚基类\n\n必须搭配@tag装饰器，```new```一个TagCore的子类（构造函数必须传一个Control），\n跟执行了一下```riot.tag```是一样的。\n执行```mount```方法就能在页面空标签里挂在上标签的实现，相当于执行了```riot.mount```。\n\n    @tag({\n        name: 'x-tag',\n        tmpl: `<span>{content}</span>`\n    })\n    class XTag extends TagCore {\n        onCreate(tag: IriotTag, opts: IriotOpts) {\n            this.on('mount', () => opts.ctrl.trigger('xTag_Mounted') );\n            tag.content = opts.content;\n        }\n        mount: (opt: { content: string }) => void;\n    }\n\n    const store = new Store();\n    store.on('xTag_Mounted', () => console.log('prodCasted') );\n\n    const ctrl = new Control();\n    ctrl.addStore(store);\n\n    const xTag = new XTag(ctrl);\n    xTag.mount({ content: '我就是content' });\n\n    // 页面里面的<x-tag></x-tag> 变成　<x-tag><span>我就是content</span></x-tag>\n    // 控制台打印出 prodCasted\n\n### node-fetch\n\n一个开源的项目，可以让node端使用fetch，使用方法和whatwg里面的API是一样的，在此就不多嘴了。\n\n### 前后端同构初阶\n\n如果看网上的一些前后端同构的资料，他们会给你如下的方案。\n\n    if (isServer) {\n        doNodeThings();\n    } else {\n        doClientThings();\n    }\n\n我可以告诉你，他们都抄自同一个骗纸。。。\n\n原因是很多前端的modules会操作window对象，\nnode端的module更牛，有一些都是二进制的，\n如果用webpack1的话，如何bundle到一个js里面?\n\n#### TreeShaking\n\n树摇（字面翻译）是个es6对module的定义，\n简单地说js代码编译的时候会解析成AST语法树，\n通过分析这个语法树可以知道某一个js里面的某一个函数是多余的，\n打包的时候就可以把它剔除。","collection":"blog","data":{"type":"post","category":"fe"}}]}