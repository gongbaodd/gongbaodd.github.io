{"posts":[{"id":"2017/05/02/Qxf-Qconfig.md","slug":"2017/05/02/qxf-qconfig","body":"# 结合Qxf和Qconfig解决前端热发布\n\n或许篇文章写得有些晚了，如果这篇文章是写koa的话，估计受欢迎程度会很高。\n\n最近正巧有一个前后同构的项目，其实是利用node作渲染层。至于为什么用node作渲染层就不做详述了，节约后端资源，释放前端约束，可能方案并不是通用的，正好我的项目需要。\n\n## Qxf 介绍\n\nQxf是基于express的node服务方案，也就是说很多express的API可以直接使用。确切说并不完全是这样，response.write就被改写了，但并不影响使用。\n\n其实Qxf的出现是给node做了一层兼容于原有去哪儿前后端分离模式的node后端。同时为开发者做了一层脚手架封装，集成包括cluster、logger、handlebars等开源的中间件以及去哪儿私有的异常处理、日志处理、埋点统计以及静态资源版本号的管理中间件。\n\n## QConfig\n\nQConfig是去哪儿内部解决后端热发的方案，简单地说它会依照版本存储```*.properties```或者```*.json```文件，并按需将这些配置文件推送到各个机器，推送之后也可以回滚。\n\n## 解决的问题\n\n前端有很多需求是文案修改、图标修改，相对来说算是比较安全，但每次修改的时候还要测试回归上线，这样流程拖得太长，如果前端也可以利用QConfig实现热发，那自然是很受欢迎的。\n\n## Qxf怎么用\n\n针对Qxf怎么去创建一个工程在此就不多余介绍了，讲一下工作原理吧。\n\n    qxf dev\n\n这个命令会启动Qxf的测试环境，其实就是执行了以下代码\n\n    NODE_ENV=development node ./bin/start.js --l .logs\n\n也就是说，包括server的启动配置都写在这里面了。整个服务都会在```multiprocess.listen(app, opts)```之后执行（注意一个坑点，multiprocess没有暴露server对象，所以用不了reload.js，开发的时候只能手动刷新页面了）。\n\n## QConfig怎么用\n\n讲完Qxf说说QConfig，按照qConfig的文档在Qxf的config.js里面配置好要取的配置，QConfig要在Qxf启动之前执行，也就是还要修改start.js里面的\n\n    multiprocess.listen(app, opts);\n\n为\n\n    qConfigClient.init().then(()=> multiprocess.listen(app, opts));\n\n之后如果需要获取某一个属性文件，则需要执行\n\n    const configs = qConfigClient.getConfig('*.json');\n    const value = configs.get('key');\n\n如果你的配置是json的，获取到的值会直接parse成对象。\n\n***需要注意一点,Qconfig是异步的，也就是说getConfig的执行必须放到某个可抵达的回调里面***\n\n## 结束\n\n执行一下```qxf dev```，服务器访问```localhost:3000```到对应的router下面就可以看到效果了。\n\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/05/03/QxfComponents.md","slug":"2017/05/03/qxfcomponents","body":"# 写啥题目呢\n\n## 回顾一下\n\n去年三月，我分享了一个用riotjs开发前端的方案，既然已经有一年的时间了，就先回顾一下。\n\n这套方案出自2015年，之前一直使用的是公司的QApp解决方案，后来发现使用上存在问题，\n并在试图寻找一套可行的替代方案。\n\n### 组件化方案\n\nQApp的最小单位是View(大概可以理解为页面)，\nView里面大到一个轮播图小到一个按钮的操作逻辑都和view耦合，\n假设我想使用某一个View里面的某一个组件，想直接拆出来是不太可能的。\n\n* 以前的写法\n\n        QApp.defineView({\n            html: `\n            <div node-type=\"vcode\">\n                <input action-type=\"input\">\n                <button action-type=\"vcode\">发送短信</button>\n            </div>\n            <button action-type=\"submit\">提交</button>\n           `\n            actions: {\n                // 这里的this指向整个view\n                \"input:input\": () => this.doInput(),\n                \"submit\": () => this.doSubmit(),\n                \"vcode\": () => this.doVcode(),\n            },\n            init: {\n                doInput() {},\n                doSubmit() {},\n                doVcode() {},\n            }\n        });\n        QApp.config({...});\n\n* 新的写法\n\n        riot.tag('pay-input',`\n            <input oninput=\"oninput\">\n        `, ()=> {\n            // 这里的this指向整个pay-input\n        });\n        riot.tag('pay-submit', `\n            <submit ontap=\"onsubmit\">\n                <yield/>\n            </submit>\n        `, ()=> {\n            // 这里的this指向整个pay-submit\n        });\n        riot.tag('pay-vcode', `\n            <pay-input></pay-input>\n            <pay-submit>发送短信</pay-submit>\n        `, ()=> {\n            // 这里的this指向整个pay-vcode\n        });\n        riot.tag('pay-view',`\n            <pay-vcode></pay-vcode>\n            <pay-submit>提交</pay-submit>\n        `, ()=>{\n            // 这里的this指向整个pay-view\n        });\n        riot.mount('pay-view');\n\n### 基于发布订阅的统一事件管理模式\n\n有很多时候，我们要处以理一些“这些东西，我们不要了”之类的需求，\n当我们回头去翻代码的时候，惊奇的发现它被封装了，\n那么后面的故事就是要和“xxx function is undefined”做长期斗争了。\n\n* 之前的调用方式\n\n        QApp.defineView({\n            init: {\n                doSomething: ()=> {}// 删我貌似很困难\n                doSomethingElse: ()=>this.doSomething()\n            },\n            ready() {\n                this.doSomething();\n            }\n        });\n\n* 之后的调用方式\n\n        riot.tag('pay-view',`...`, ()=>{\n            this.on('doSomething', ()=> doSomething()); // 不要就删掉吧\n\n            this.doSomethingElse = () => this.trigger('doSomething');\n            this.on('mount', () => {\n                this.trigger('doSomething')\n            });\n        });\n\n### 基于状态基的异步流程处理\n\n其实2015年，是异步流程处理比较混乱的一年，Promise刚出来，没多少人敢用，\n更别提generator还有async之类的东西了，\n这套方案正好利用了发布订阅的优点，\n只要在异步事件触发之前订阅上就没问题了\n\n* 之前\n\n        QApp.defineView({\n            ...,\n            ready() {\n                this.ajax({\n                    ...,\n                    success() {\n                        foo(..., () => {\n                            bar( ..., () => {\n                                ...\n                            });\n                        })\n                    }\n                });\n            }\n        });\n\n* 之后\n\n        riot.tag('pay-view', '...', () => {\n            this.on('ajaxDone', () => {\n                ...\n                this.trigger('foo');\n            });\n\n            this.on('fooDone', () => {\n               ...\n               this.trigger('bar');\n            });\n\n            this.on('barDone', () => {\n               ...\n            });\n\n            this.on('mount', () => this.trigger('ajax'));\n        });\n\n### 利用组件树检索组件\n\n项目组件化（Component）+ 事件化（Reactive）之后，\n一个页面的运行方式就成为某一个组件监控某一个组件的某一事件并对其造成的处理。\n那么需要利用祖组件树解决一下检索问题。\n\n    require(\"pay-input\");\n    require(\"pay-submit\");\n\n    riot.tag('pay-vcode', `\n        <pay-input></pay-input>\n        <pay-submit>发送短信</pay-submit>\n    `, ()=> this.tags[\"pay-submit\"].on('subimit', () => {\n        this.trigger('vcodeSent');\n    }) );\n\n    riot.tag('pay-view', `\n        <pay-vcode></pay-vcode>\n        <pay-submit></pay-submit>\n    `, () => this.tags['pay-vcode'].on('vcodeSent', ()=> {\n        this.tags['pay-submit'].trigger('enabled');\n    }));\n\n\n* pay-view\n  * parent: null\n  * tags\n    * pay-vcode\n      * parent: pay-view\n      * tags\n        * pay-input\n        * pay-submit\n        * parent: pay-vcode\n      * pay-submit\n        * parent: pay-view\n\n\n### 利用mixin实现继承\n\necmascript2015之前，js一直都没有一个像样的类的表达方式，\n所以我们其实也没有一个像样的继承方式，\n混淆是目前用的最多的一种继承，大概是源自$.extend吧。\n\n* ajaxApi1\n\n        module.exports = {\n            init: {\n                this.on('ajaxApi1', () => ajax(...) );\n                this.on('ajaxApi1Done', ()　=> ... );\n            }\n        };\n\n* ajaxApi2\n\n        module.exports = {\n            init: {\n                this.on('ajaxApi2', () => ajax(...) );\n                this.on('ajaxApi2Done', () => ... );\n            }\n        };\n\n* pay-view\n\n        riot.tag('pay-view', '...', () => {\n            this.mixin(require('ajaxApi1.js'));\n            this.mixin(require('ajaxApi2.js'));\n\n            this.on('mount', () => this.trigger('ajaxApi1 ajaxApi2') );\n        });\n\n### 结合velocity和yield实现首屏渲染\n\n首屏渲染，SPA一直有这个问题。\n因为在html加载到js加载完成（甚至是一些ajax返回）之前，\n页面都是白屏，其实vm可以完成一部分后端的渲染，并替代第一个ajax。\n\n* vm之中\n\n        #set($description = \"这里会代替<yield/>\")\n        <pay-view>\n            <span if=\"$!description\">$description</span>\n        </pay-view>\n        <script>\n            window.vmData = \"$!vmData\";\n        </script>\n\n* js里面\n\n        riot.tag('pay-view', `\n            <pay-vcode></pay-vcode>\n            <pay-submit></pay-submit>\n            <yield/>\n        `, () => {\n            const vmData = window.vmData;\n        });\n\n### SPA的路由（这部分本文不涉及，忽略）\n\n## 希望优化的点\n\n### 发布订阅解决函数调用问题是存在缺陷的\n\n这套方案会产生冗余代码，其实最好使用typescript编写代码，\n这样在编译环境下就能查出哪个函数调用了删除的方法。\n\n* util.ts\n\n            export const a = {\n                    // foo() { 假设我删除了foo }\n                    ...\n            };\n\n* xxx.ts\n\n            import { a } from \"util\"\n\n            class xxx {\n                constructor() {\n                    a.foo(); // 编译时会报错foo这个方法不存在，终止编译\n                }\n            }\n\n### 使用面向对象的语法\n\n* html\n\n        <body>\n            <pay-view></pay-view>\n        </body>\n\n* ES5\n\n        require(\"pay-input\");\n        require(\"pay-submit\");\n        require(\"pay-vcode);\n\n        riot.tag(\"pay-view\", '<span>{ title }</span><pay-vcode></pay-vcode><pay-submit>提交</pay-submit>', function(opts) {\n            this.title = opts.title;\n        });\n\n        riot.mount(\"pay-view\", {});\n\n* TypeScript\n\n        import {PaySubmit} from \"pay-submit\";\n        import {PayVcode} from \"pay-vcode\";\n\n        @tag({\n            name: \"pay-view\",\n            tmpl: `\n            <span>{ title }</span>\n            <pay-vcode></pay-vcode>\n            <pay-submit>提交</pay-submit>\n            `\n        })\n        class PayView extends TagCore {\n            onCreate(tag) {\n                tag.title = opts.title;\n            }\n            constructor() {\n                this.submit = new PaySubmit();\n                this.vcode = new PayVcode();\n            }\n            submit: PaySubmit;\n            vcode: PayVcode;\n        }\n\n        PayView.mount({});\n\n### 利用发布订阅模式控制流程并不是最好的流程控制\n\n目前来说原生的Promise支持已经很不错了，\nasync虽然是个实验特性，\n但发明C#的微软明显推荐用这个特性。\n\n* 发布订阅\n\n        riot.tag('pay-view', '...', () => {\n            this.on('fooDone', ()=> this.bar());\n            this.on('barDone', ()=> this.blah());\n            this.bar = () => {\n                ...\n                this.trigger('barDone');\n            };\n            this.blah = () => xxx;\n            this.on('mount', () => this.trigger('fooDone'));\n        });\n\n* Promise\n\n        @tag({\n            name: \"pay-view\",\n            tmpl: \"...\",\n        });\n        class PayView extends TagCore {\n            onCreate(tag, opts) {\n                tag.on('mount', () => this.foo.then(()=> {\n                    return this.bar()\n                }).then(()=> {\n                    this.blah();\n                }));\n            }\n            foo = ()=> new Promise(resolve => resolve());\n            bar = ()=> new Promise (resolve => resolve())\n            blah = () => {...}\n            ...\n        }\n\n* async & await\n\n        @tag({\n            name: \"pay-view\",\n            tmpl: \"...\",\n        });\n        class PayView extends TagCore {\n            onCreate(tag, opts) {\n                tag.on('mount', async () => {\n                    await this.foo();\n                    await this.bar();\n                    this.blah();\n                });\n            }\n            foo = ()=> new Promise(resolve => resolve());\n            bar = ()=> new Promise (resolve => resolve())\n            blah = () => {...}\n            ...\n        }\n\n### 没有完善的广播机制\n\n其实之前的方案是可以广播的，但需要选中需要的组件，如\n\n    [tagA,tagB,tagC].forEach(tag => tag.trigger('foobar'));\n\n但是我希望的广播是每一个页面里面的tag无需选中就可以接收到。\n其实在每个tag加载之后都会传进一个opts对象，\n这个对象或者是执行mount函数传入的值，或者是模板标签上的变量\n\n    XXX.mount({ aaa: 1 });\n    // opts == {aaa: 1}\n\n    <xxx aaa=1 ></xxx>\n    // opts == {aaa：１}\n\n所以只要把一个obersable的对象传到opts里面就行了.\n\n### 需要一个更好的mixin\n\ntypescript对mixin支持很好，\n配合vscode的输入提醒代码体验十分完美，\n所以几乎可以放弃riot的mixin了\n\n* riot.mixin\n\n        // ajaxApi.js\n        {\n            init() {\n                this.on('ajaxApi', ()=> ...);\n            }\n        }\n        // xxxtag\n        riot.tag('xxx', '...', ()=> {\n            this.mixin(require('ajaxApi.js'));\n            this.trigger(\"ajaxApi\");\n        });\n\n* @mixin(any[])\n\n        class AjaxApi {\n            ajaxApi() {\n                ...\n            }\n        }\n\n        @tag({ name: \"xxx\", tmpl: \"...\" });\n        @mixin([AjaxApi])\n        class XxxTag extends TagCore implement AjaxApi {\n            onCreate( tag, opts ) {\n                this.ajaxApi();\n            }\n            ajaxApi: () => void;\n        }\n\n### velocity模板语法太次了\n\n改用node渲染，Qxf使用的是handlebars，riot自身也支持后端渲染。\n\n## 介绍点儿常识\n\n### typescript的语法\n\n#### 类型化声明\n\n        const a:string = \"这是一个不可变的字符串\";\n        let b:string; // b只能赋字符串\n        let c:any; // c可以赋任一值\n        let d: () => void; // d只能赋空参数且返回为空的函数\n\n#### class语法糖\n\n        class a extends b {\n            constructor() {\n                super();//执行b的构造函数\n            }\n            public foo() {\n                super.foo();//执行b的原型上的foo函数\n                console.log(`\n                    我在ａ的prototype上\n                    this指向context\n                `);\n            }\n            public bar =　() => {\n                cosnole.log(`\n                    我在a的实例里,\n                    this指向a的实例\n                `)\n            }\n            public blaha = function() {\n                cosnole.log(`\n                    tslint默认禁止使用\n                    我在a的实例里,\n                    this指向context\n                `)\n            }\n        }\n\n#### async await 上面提过了\n\n#### Object解构\n\n        const obj = { a: 1 };\n        const name = \"name\";\n        const data = { ...obj, b: 2, name }; // { a: 1, b : 2, name: \"name\" }\n        const { a:xxx } = obj; // xxx===1\n        const data1 = {[xxx]: 'data1'}; // {1: 'data1'}\n\n#### 接口\n\n        interface Ia { foo: () => void; }\n        interface Ib { bar: () => string; }\n        interface Ic { name: string; }\n        class D { doSomeThing() { .... } }\n        class E implements Ia,Ib,D {\n            doSomeThing: () => any;// 如果实现的是类内元素，可以只声明，不实现\n            foo = () => {...} // 如果实现的是接口内元素，必须按照类型定义\n            bar = () => {...} // 必须把要实现的所有接口内的元素声明\n            constructor(param: Ic) {\n                const { name } = param;// param 必须是只含有name的对象\n            }\n        }\n\n### 装饰器\n\n就是前面类似于@tag,@mixin的东西，\n这个有点复杂，只说在class前面的装饰器吧,\n是用来处理对象原型的函数，\n会在构造函数执行结束后执行\n\n### Qxf router的使用(其实是express4 router的使用)\n\n#### 三种获取请求参数的方式\n\n假设一个接口是 'api/default/index?a=1'\n\n        router.param('solution', (req, res, next, value) => {\n            console.log(value); => 'default'\n            next();\n        })\n\n        router.get('api/:solution/:page', (req, res, next) => {\n            console.log(req.params) => { solution: 'default', page: 'index' }\n            console.log(req.query.a) => 1\n\n            res.write('111');// 返回111但是请求并不结束\n            res.end();　// 返回结束\n        });\n\n        router.post('api/:solution/:page', (req, res, next) => {\n            console.log(req.params) => { solution: 'default', page: 'index' }\n            console.log(req.body.a) => 1\n            res.json({aaa: 1}); //　返回　{aaa: 1}\n        });\n\n#### 中间件\n\n        router.use(`api`, (req, res, next) => {\n            req.xxx = 'xxx';\n            next();\n        });\n\n### 核心的几个类和接口\n\n#### 状态机存储器：　Store\n\n```new Store()```可以订阅```on```或者触发```trigger```几种事件，\n没错```riot.tag```函数里面的```this```就继承自```Store```;\n\n    const a = new Store();\n    a.on('sayHi', () => console.log('hello'));\n    a.trigger('sayHi'); // hello\n\n#### 广播控制器：　Control\n\n是一个状态机的集合，方法```addStore```可以添加状态机存储器，\n```trigger```可以广播触发存储器的事件。\n\n    const store1 = new Store();\n    store1.on('sayHi', () => console.log('hello,I'm store1'));\n    const store2 = new Store();\n    store2.on('sayHi', () => console.log('hello,I'm store2'));\n    const ctrl = new Control();\n    ctrl.addStore(store1);\n    ctrl.addStore(store2);\n    ctrl.trigger('sayHi');//hello,I'm store1hello,I'm store2\n\n#### 标签生成器：TagCore虚基类\n\n必须搭配@tag装饰器，```new```一个TagCore的子类（构造函数必须传一个Control），\n跟执行了一下```riot.tag```是一样的。\n执行```mount```方法就能在页面空标签里挂在上标签的实现，相当于执行了```riot.mount```。\n\n    @tag({\n        name: 'x-tag',\n        tmpl: `<span>{content}</span>`\n    })\n    class XTag extends TagCore {\n        onCreate(tag: IriotTag, opts: IriotOpts) {\n            this.on('mount', () => opts.ctrl.trigger('xTag_Mounted') );\n            tag.content = opts.content;\n        }\n        mount: (opt: { content: string }) => void;\n    }\n\n    const store = new Store();\n    store.on('xTag_Mounted', () => console.log('prodCasted') );\n\n    const ctrl = new Control();\n    ctrl.addStore(store);\n\n    const xTag = new XTag(ctrl);\n    xTag.mount({ content: '我就是content' });\n\n    // 页面里面的<x-tag></x-tag> 变成　<x-tag><span>我就是content</span></x-tag>\n    // 控制台打印出 prodCasted\n\n### node-fetch\n\n一个开源的项目，可以让node端使用fetch，使用方法和whatwg里面的API是一样的，在此就不多嘴了。\n\n### 前后端同构初阶\n\n如果看网上的一些前后端同构的资料，他们会给你如下的方案。\n\n    if (isServer) {\n        doNodeThings();\n    } else {\n        doClientThings();\n    }\n\n我可以告诉你，他们都抄自同一个骗纸。。。\n\n原因是很多前端的modules会操作window对象，\nnode端的module更牛，有一些都是二进制的，\n如果用webpack1的话，如何bundle到一个js里面?\n\n#### TreeShaking\n\n树摇（字面翻译）是个es6对module的定义，\n简单地说js代码编译的时候会解析成AST语法树，\n通过分析这个语法树可以知道某一个js里面的某一个函数是多余的，\n打包的时候就可以把它剔除。","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/05/04/0-riotjs.md","slug":"2017/05/04/0-riotjs","body":"# 回顾一下以前的Riot.js方案\n\n2015年我开始从事前端工作，开始公司正在用QApp作为前端SPA框架，\n可是在我看来QApp比较笨重(130+KB)，另外还需要引入kami做组件(100+KB)，一直想找一个轻一点的框架代替，最后选择了riot.js(76KB)来代替这两个，主要基于以下几个需求。\n\n## 大量组件化的需求\n\nQApp的最小单位是View，也就是单一页面，而我接到的需求，要么是对某个按钮做改动，要么是连做几个页面，里面的某个输入框逻辑相同。QApp中的this指向View使得这些部分既不能从View里解构出来，对部分的修改也会造成挣个View的影响。\n\n* 以前的写法\n\n        QApp.defineView({\n            html: `\n            <div node-type=\"vcode\">\n                <input action-type=\"input\">\n                <button action-type=\"vcode\">发送短信</button>\n            </div>\n            <button action-type=\"submit\">提交</button>\n           `\n            actions: {\n                // 这里的this指向整个view\n                \"input:input\": () => this.doInput(),\n                \"submit\": () => this.doSubmit(),\n                \"vcode\": () => this.doVcode(),\n            },\n            init: {\n                doInput() {},\n                doSubmit() {},\n                doVcode() {},\n            }\n        });\n        QApp.config({...});\n\n* 新的写法\n\n        riot.tag('pay-input',`\n            <input oninput=\"oninput\">\n        `, ()=> {\n            // 这里的this指向整个pay-input\n        });\n        riot.tag('pay-submit', `\n            <submit ontap=\"onsubmit\">\n                <yield/>\n            </submit>\n        `, ()=> {\n            // 这里的this指向整个pay-submit\n        });\n        riot.tag('pay-vcode', `\n            <pay-input></pay-input>\n            <pay-submit>发送短信</pay-submit>\n        `, ()=> {\n            // 这里的this指向整个pay-vcode\n        });\n        riot.tag('pay-view',`\n            <pay-vcode></pay-vcode>\n            <pay-submit>提交</pay-submit>\n        `, ()=>{\n            // 这里的this指向整个pay-view\n        });\n        riot.mount('pay-view');\n\n## XX function is undefined\n\n报错邮件以前经常会有这样的报错，究其原因，很多是由“xxx功能”我不要了这种需求造成。\n\n* 之前的调用方式\n\n        QApp.defineView({\n            init: {\n                doSomething: ()=> {}// 删我貌似很困难\n                doSomethingElse: ()=>this.doSomething()\n            },\n            ready() {\n                this.doSomething();\n            }\n        });\n\n* 之后的调用方式\n\n        riot.tag('pay-view',`...`, ()=>{\n            this.on('doSomething', ()=> doSomething()); // 不要就删掉吧\n\n            this.doSomethingElse = () => this.trigger('doSomething');\n            this.on('mount', () => {\n                this.trigger('doSomething')\n            });\n        });\n\n## 基于状态基的异步流程处理\n\n其实2015年，是异步流程处理比较混乱的一年，Promise刚出来，没多少人敢用，\n更别提generator还有async之类的东西了，\n这套方案正好利用了发布订阅的优点，\n只要在异步事件触发之前订阅上就没问题了\n\n* 之前\n\n        QApp.defineView({\n            ...,\n            ready() {\n                this.ajax({\n                    ...,\n                    success() {\n                        foo(..., () => {\n                            bar( ..., () => {\n                                ...\n                            });\n                        })\n                    }\n                });\n            }\n        });\n\n* 之后\n\n        riot.tag('pay-view', '...', () => {\n            this.on('ajaxDone', () => {\n                ...\n                this.trigger('foo');\n            });\n\n            this.on('fooDone', () => {\n               ...\n               this.trigger('bar');\n            });\n\n            this.on('barDone', () => {\n               ...\n            });\n\n            this.on('mount', () => this.trigger('ajax'));\n        });\n\n## 利用组件树检索组件\n\n项目组件化（Component）+ 事件化（Reactive）之后，\n一个页面的运行方式就成为某一个组件监控某一个组件的某一事件并对其造成的处理。\n那么需要利用祖组件树解决一下检索问题。\n\n    require(\"pay-input\");\n    require(\"pay-submit\");\n\n    riot.tag('pay-vcode', `\n        <pay-input></pay-input>\n        <pay-submit>发送短信</pay-submit>\n    `, ()=> this.tags[\"pay-submit\"].on('subimit', () => {\n        this.trigger('vcodeSent');\n    }) );\n\n    riot.tag('pay-view', `\n        <pay-vcode></pay-vcode>\n        <pay-submit></pay-submit>\n    `, () => this.tags['pay-vcode'].on('vcodeSent', ()=> {\n        this.tags['pay-submit'].trigger('enabled');\n    }));\n\n\n* pay-view\n  * parent: null\n  * tags\n    * pay-vcode\n      * parent: pay-view\n      * tags\n        * pay-input\n        * pay-submit\n        * parent: pay-vcode\n      * pay-submit\n        * parent: pay-view\n\n## 利用mixin实现继承\n\necmascript2015之前，js一直都没有一个像样的类的表达方式，\n所以我们其实也没有一个像样的继承方式，\n混淆是目前用的最多的一种继承，大概是源自$.extend吧。\n\n* ajaxApi1\n\n        module.exports = {\n            init: {\n                this.on('ajaxApi1', () => ajax(...) );\n                this.on('ajaxApi1Done', ()　=> ... );\n            }\n        };\n\n* ajaxApi2\n\n        module.exports = {\n            init: {\n                this.on('ajaxApi2', () => ajax(...) );\n                this.on('ajaxApi2Done', () => ... );\n            }\n        };\n\n* pay-view\n\n        riot.tag('pay-view', '...', () => {\n            this.mixin(require('ajaxApi1.js'));\n            this.mixin(require('ajaxApi2.js'));\n\n            this.on('mount', () => this.trigger('ajaxApi1 ajaxApi2') );\n        });\n\n## 结合velocity和yield实现首屏渲染\n\n首屏渲染，SPA一直有这个问题。\n因为在html加载到js加载完成（甚至是一些ajax返回）之前，\n页面都是白屏，其实vm可以完成一部分后端的渲染，并替代第一个ajax。\n\n* vm之中\n\n        #set($description = \"这里会代替<yield/>\")\n        <pay-view>\n            <span if=\"$!description\">$description</span>\n        </pay-view>\n        <script>\n            window.vmData = \"$!vmData\";\n        </script>\n\n* js里面\n\n        riot.tag('pay-view', `\n            <pay-vcode></pay-vcode>\n            <pay-submit></pay-submit>\n            <yield/>\n        `, () => {\n            const vmData = window.vmData;\n        });\n\n## SPA的路由（忽略）\n\n## 视频地址\n\nhttp://v.youku.com/v_show/id_XMTUxMjMyMzM0OA==.html?from=s1.8-1-1.2&spm=a2h0k.8191407.0.0","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/05/04/1TypeScript.md","slug":"2017/05/04/1typescript","body":"# TypeScript干货\n\n## 类型化声明\n\n        const a:string = \"这是一个不可变的字符串\";\n        let b:string; // b只能赋字符串\n        let c:any; // c可以赋任一值\n        let d: () => void; // d只能赋空参数且返回为空的函数\n\n## 接口\n\n        interface Ia { foo: () => void; }\n        interface Ib { bar: () => string; }\n        interface Ic { name: string; }\n        class D { doSomeThing() { .... } }\n        class E implements Ia,Ib,D {\n            doSomeThing: () => any;// 如果实现的是类内元素，可以只声明，不实现\n            foo = () => {...} // 如果实现的是接口内元素，必须按照类型定义\n            bar = () => {...} // 必须把要实现的所有接口内的元素声明\n            constructor(param: Ic) {\n                const { name } = param;// param 必须是只含有name的对象\n            }\n        }\n\n## class语法糖\n\n        class a extends b {\n            constructor() {\n                super();//执行b的构造函数\n            }\n            public foo() {\n                super.foo();//执行b的原型上的foo函数\n                console.log(`\n                    我在ａ的prototype上\n                    this指向context\n                `);\n            }\n            public bar =　() => {\n                cosnole.log(`\n                    我在a的实例里,\n                    this指向a的实例\n                `)\n            }\n            public blaha = function() {\n                cosnole.log(`\n                    tslint默认禁止使用\n                    我在a的实例里,\n                    this指向context\n                `)\n            }\n        }\n\n## 装饰器\n\n类似于@tag,@mixin的东西，\n这个有点复杂，只说在class前面的装饰器吧,\n是用来处理对象原型的函数，\n会在构造函数执行结束后执行\n\n## Object解构\n\n        const obj = { a: 1 };\n        const name = \"name\";\n        const data = { ...obj, b: 2, name }; // { a: 1, b : 2, name: \"name\" }\n        const { a:xxx } = obj; // xxx===1\n        const data1 = {[xxx]: 'data1'}; // {1: 'data1'}\n\n## 一个更好的mixin\n\ntypescript对mixin支持很好，\n配合vscode的输入提醒代码体验十分完美，\n所以几乎可以放弃riot的mixin了\n\n* riot.mixin\n\n        // ajaxApi.js\n        {\n            init() {\n                this.on('ajaxApi', ()=> ...);\n            }\n        }\n        // xxxtag\n        riot.tag('xxx', '...', ()=> {\n            this.mixin(require('ajaxApi.js'));\n            this.trigger(\"ajaxApi\");\n        });\n\n* @mixin(any[])\n\n        class AjaxApi {\n            ajaxApi() {\n                ...\n            }\n        }\n\n        @tag({ name: \"xxx\", tmpl: \"...\" });\n        @mixin([AjaxApi])\n        class XxxTag extends TagCore implement AjaxApi {\n            onCreate( tag, opts ) {\n                this.ajaxApi();\n            }\n            ajaxApi: () => void;\n        }\n\n\n## async await 处理异步流程\n\n目前来说原生的Promise支持已经很不错了，\nasync虽然是个实验特性，\n但发明C#的微软明显推荐用这个特性。\n\n* 发布订阅\n\n        riot.tag('pay-view', '...', () => {\n            this.on('fooDone', ()=> this.bar());\n            this.on('barDone', ()=> this.blah());\n            this.bar = () => {\n                ...\n                this.trigger('barDone');\n            };\n            this.blah = () => xxx;\n            this.on('mount', () => this.trigger('fooDone'));\n        });\n\n* Promise\n\n        @tag({\n            name: \"pay-view\",\n            tmpl: \"...\",\n        });\n        class PayView extends TagCore {\n            onCreate(tag, opts) {\n                tag.on('mount', () => this.foo.then(()=> {\n                    return this.bar()\n                }).then(()=> {\n                    this.blah();\n                }));\n            }\n            foo = ()=> new Promise(resolve => resolve());\n            bar = ()=> new Promise (resolve => resolve())\n            blah = () => {...}\n            ...\n        }\n\n* async & await\n\n        @tag({\n            name: \"pay-view\",\n            tmpl: \"...\",\n        });\n        class PayView extends TagCore {\n            onCreate(tag, opts) {\n                tag.on('mount', async () => {\n                    await this.foo();\n                    await this.bar();\n                    this.blah();\n                });\n            }\n            foo = ()=> new Promise(resolve => resolve());\n            bar = ()=> new Promise (resolve => resolve())\n            blah = () => {...}\n            ...\n        }\n\n## 用TypeScript写一个Riot组件\n\n* html\n\n        <body>\n            <pay-view></pay-view>\n        </body>\n\n* ES5\n\n        require(\"pay-input\");\n        require(\"pay-submit\");\n        require(\"pay-vcode);\n\n        riot.tag(\"pay-view\", '<span>{ title }</span><pay-vcode></pay-vcode><pay-submit>提交</pay-submit>', function(opts) {\n            this.title = opts.title;\n            this.mixn(require('ajax1.js'));\n\n            this.trigger('ajax1');\n        });\n\n        riot.mount(\"pay-view\", {});\n\n* TypeScript\n\n        import {PaySubmit} from \"pay-submit\";\n        import {PayVcode} from \"pay-vcode\";\n\n        @tag({\n            name: \"pay-view\",\n            tmpl: `\n            <span>{ title }</span>\n            <pay-vcode></pay-vcode>\n            <pay-submit>提交</pay-submit>\n            `\n        })\n        @mixin([Ajax1])\n        class PayView extends TagCore implement Ajax1 {\n            onCreate(tag) {\n                tag.title = opts.title;\n                this.ajax1();\n            }\n            constructor() {\n                this.submit = new PaySubmit();\n                this.vcode = new PayVcode();\n            }\n            submit: PaySubmit;\n            vcode: PayVcode;\n            ajax1: () => void;\n        }\n\n        PayView.mount({});","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/05/04/2WebPack2-treeShaking-extTextPlugin.md","slug":"2017/05/04/2webpack2-treeshaking-exttextplugin","body":"# webpack2\n\n## tree-shaking（树摇）\n\nes6 module里面详述了树摇的的实现，但是webpack1始终没能实现，后来rollup实现了，于是大量框架转用rollup，去年webpack2发布，带来的就是这个tree-shaking功能。\n\n### AST树\n\n所有的代码，编译或者执行之前都会被转义成AST树，\n那么AST树是啥\n\n    let a;\n    let b = 1 + 1;\n\n* 代码\n    + 声明表达式\n        - let 声明\n        - 变量名 a\n    + 赋值表达式\n        - 加法运算\n            * 常量1\n            * 常量1\n        - 声明表达式\n            - let 声明\n            - 变量名 b\n\n### module的解析\n\n    // module a\n\n    export function foo() {...}\n    export function bar() {...}\n\n    // js\n\n    import { foo, bar } from a;\n\n    foo();\n\nwebpack会将代码解析成AST树，并发现bar并没有用过，就不会被打包进去。\n\n## extTextPlugin\n\n这是webpack的一个插件，可以解析出代码里面的css单独打包。这样css可以和组件放在一起了。\n\n    declare const require;\n    require(\"./style.scss\");\n\n    @tag({\n        name: \"pay-toast\",\n        tmpl: `\n        <div class=\"pay-toast\">{content}</div>\n        `,\n    })\n    export class PayToast extends TagCore {\n        public name: string = payToastConsts.name;\n        public onCreate(tag: ItoastTag, opts: ItoastRiotOpts) {\n            tag.update(opts);\n        }\n       public appendTag() {\n           const document = window.document;\n           const elem = document.createElement(this.name);\n           document.body.appendChild(elem);\n       }\n    }\n\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/05/04/3postcss-cssnext-cssnano.md","slug":"2017/05/04/3postcss-cssnext-cssnano","body":"# postcss干货\n\n上文说过，借助extTextPlugin可以把多个组件的css抽取成一个css，但webpack做的只是简单的文件拼接。处理css的地方要交给postcss。\n\n## cssnext\n\ncssnext使用caniuse.com的数据判断css需要支持到哪些浏览器，并自动做出可行的css解决方案（当然让ie6支持flex还是不行的）。\n\n    browsers: [\"> 0.1% in CN\", \"last 2 versions\"]\n\n登入 http://browserl.ist/ 可以查看上面的语句能支持的浏览器\n\n## cssnano\n\npostcss也是把css代码解析成ast树，解析之后可以看到冗余代码并对它进行压缩。\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/05/04/4Qxf-bigPipe.md","slug":"2017/05/04/4qxf-bigpipe","body":"# Qxf上的BigPipe的实现和优化原理\n\n![](http://i2.muimg.com/588926/2400354de719507f.jpg)\n\nQxf其实是express下的一堆中间件的集合，所以其实我在介绍express的BigPipe实现。\n\n简单的来说，当一个html开始下载的同时浏览器就开始渲染html了（而不是等html下载完成再渲染）。\n所以，返回给用户的页面可以一上一行地写出来（用我们学生时代老师的话来说就是挤牙膏）。\n\n## server => client (以前)\n\n1. 接到用户请求 => 白屏\n2. 请求接口，或者查数据库，处理数据，不拉不拉不拉 => 白屏\n3. 渲染出数据为state => 白屏\n4. 渲染模板为html => 白屏\n5. 返回html并结束请求 => 收到html并渲染，可能会下载css\n6. 空闲 => 下载js\n7. 空闲 => 渲染js，如果有ajax请求就请求\n\n## server => client (BigPipe)\n\n1. 接到用户请求 => 白屏\n2. 返回html的head => 收到head，下载css，核心js\n3. 请求接口，或者查数据库，处理数据 => 等待返回，如果有与UI无关的逻辑可以在下载完js后先执行\n4. 页面首部分的数据返回，生成state（组合成script标签） => 等待返回，如果有与UI无关的逻辑可以在下载完js后先执行\n5. 按照state生成模板一并返回，如果后面的接口也返回了数据重复3-5 => 渲染收到的html碎片\n6. 全部页面加载完成，结束请求 => 页面加载完成\n\n但是实际上按照BigPipe的做法，屏幕上面依赖的请求会阻塞，所以我对这一方案做了修改\n\n## server => client (BigPipe+)\n\n1. 接到用户请求 => 白屏\n2. 返回html的head + 按照默认state渲染的页面 + 默认state拼成的script标签 => 渲染出页面，下载css、js，js下载完成后可以操作了\n3. 请求接口，或者查数据库，处理数据 => 等待返回，或者直接操作页面\n4. 如果有接口返回，渲染出state并以script标签返回 => 根据收到的state二次渲染已经在dom树的组件\n5. 全部接口返回，结束请求 => 页面加载完成\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/05/04/5IsomophicApp.md","slug":"2017/05/04/5isomophicapp","body":"# Isomophic App\n\n如果你已经了解过前后端同构的话，你一定知道如下的方案\n\n    if (isServer) {\n        doServer();\n    } else {\n        doClient();\n    }\n\n那你看的文档应该都转发自同一个人。\n\n这种做法很有局限性\n\n* 你引用的module必须是umd打包的\n* 你引用的module必须不存在二进制包\n\n这回你知道为啥react要用全家桶了吧？\n\n## 换一种想法\n\n首先看一下node层和client层的不同点\n\n* node\n\n    接到用户Get请求 =>\n    node-fetch异步获取后端数据 =>\n    初始化Riot标签 =>\n    渲染页面为html =>\n    返回给用户 =>\n    收到接口元数据 =>\n    将元数据处理成state =>\n    以script标签形式返回用户 =>\n    res.end\n\n* client\n\n    收到渲染好的html并进行渲染 =>\n    加载js代码 =>\n    初始化Riot标签 =>\n    收到并运行script标签 =>\n    更新state =>\n    页面渲染完成\n\n可见，涉及到node像后端取数据并处理成state这部分逻辑是没必要加到client里面的，\n那么可以做两个文件实现node和client不同状态的处理。\n\n## 之前先介绍几个名词\n\n* 状态机存储器：　Store\n\n    ```new Store()```可以订阅```on```或者触发```trigger```几种事件，\n    没错```riot.tag```函数里面的```this```就继承自```Store```;\n\n* 广播控制器：　Control\n\n    是一个状态机的集合，方法```addStore```可以添加状态机存储器，\n    ```trigger```可以广播触发存储器的事件。\n\n* 标签生成器：TagCore虚基类\n\n* server.js\n\n        class RouteStore extends Store {\n            constructor(control) {\n                super()\n                this.on('apiFetched', () => ...)\n                this.on('serverStarted', () => ...)\n                ...\n            }\n        }\n\n        const control = new Control();\n        const routeStore = new RouteStroe(control);// 前后端不同的状态机\n        const someStore = new SomeStore(control);// 前后端一样的状态机\n\n        control.addStore(routeStore);\n        control.addStore(someStore);\n\n        const app = new App(control);\n\n* client.js\n\n        class ClientStore extends Store {\n            constructor(control) {\n                super()\n                this.on('DOMonLoad', () => ...)\n                ...\n            }\n        }\n\n        const control = new Control();\n        const clientStore = new ClientStore(control);// 前后端不同的状态机\n        const someStore = new SomeStore(control);// 前后端一样的状态机\n\n        control.addStore(clientStore);\n        control.addStore(someStore);\n\n        const app = new App(control);\n\n这样App、someStore这部分可以同构，clientStore和routeStore分别针对运行环境处理就可以了","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/05/04/6.md","slug":"2017/05/04/6","body":"# 项目完成情况\n\n## 封装完成但还没有上传npm\n\n1. QunarSniff中间件\n2. QunarLogin中间件\n3. TagCore，Control，Store\n4. fetch（用于合并请求，基于node-fetch）\n5. hysdk、QConfig-client-node， Qxf, PayGa 等的TypeScript封装\n6. 完成公用组件： yo-header, yo-logo, pay-toast\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/05/15/Riot-Preact.md","slug":"2017/05/15/riot-preact","body":"# 弃坑Riot转投Preact\n\n![换个坑继续趟](http://i4.buimg.com/588926/431151959544ded0.jpg)\n\n## 回顾一下为什么用Riot\n\n### 1. 对ES5最友好的组件化MVP框架\n\n> 吐槽一下现在的前端，gulp + webpack + rollup +　babel + ... 用gcc的同学都看哭了好么\n\nriot.js虽然官网上给出的语法是ES6的，但是可以直接使用ES5的语法，虽然react也可以，但是没人会想用ES5写JSX吧。\n\n相比于其它框架，使用ES5的riot.js不用写gulpfile，不用谢webpack.config.js，不用写babelrc，想想，直接上去就开始写逻辑还是件挺爽的事情哈。\n\n当时公司大量使用Fekit作为发布工具，因为Fekit只是简单地commonjs实现，所以使用Riot.js就是件理所当然的事情了。\n\n### 2. 十分轻量的框架\n\nriot.js的源码70+KB，混淆之后是10+KB，大概一个handlebars或者是大一点的arctemplate的大小，里面包括组件化、observable的事件机制、路由器、SSR这些功能。\n\n用riot.js开发之后的逻辑代码（移动端）大小也没有比vue的核心代码库大。\n\n所以如果有一个项目想要快速开发，代码量又不想太大，riot.js会是我推荐的，而且不必担心性能问题（可以参考我之前vue、react和riot的对比，分明react是性能最差的）。\n\n之前写过riot.js的最佳实践，没在公众号里面推，后面补上哈～\n\n----\n<center>\n    <h3>蛋是</h3>\n    <h2>你还是一个好<s>人</s>框架</h2>\n    <h3>而我已经不是那个骚年了</h3>\n</center>\n\n---\n\n## Preact的出现\n\n去年我录制了一个Riot.js的分享视频（在youku可以搜到哦），Preact大概在那时出现在了hackernews的首页，我记得当时hackernews下面的回复都是很轻蔑的“呵呵，又一个“。\n\n等了大概一年，这个项目居然没死，要知道这一年很多类react的项目过得可不是那么好啊。这个项目的Twitter帐号都发会议邀请函了。\n\n## 那么引入Preact是为什么\n\n### 1. Typescript对JSX的支持好过template\n\ntypescript能够做静态类型检查，简单地说，如果我的代码里面有什么拼写错误或者什么包没引入，编译器都能查出来。\n\n蛋是，如果我写的代码在模板里面，编译器就无能为力了，毕竟模板就只是字符串啊。而jsx不同，它是一种DSL，编译器自然会检查里面的代码。\n\n### 2. Preact真的太TM小了\n\n当时使用riotjs的原因很大的比重在减负，在我的哲学里面，一个框架只需要完成我需要它完成的东西，其他的不要多。preact相比riot减负了大概50k（源代码），当然功能上也少了（observable，router）。\n\n### 3. 真的能堵住很多人的嘴\n\nPreact和React用的是同一套API，JSX语法又一样，用这套框架估计没有人吐槽难用了吧？（这一条真的很无力，好多人连react都没用过，就说我用一冷门框架不好维护，就像我用了react你就能来维护一样）\n\n## 所以我会用Preact吗？\n\n我会在最近的一次优化把我的项目进行优化改造，最后我在根据它的性能（ssr+browser）、最终的业务代码大小、是否可以多人合作开发等多方面分析考虑是否切换。\n\n当然，也有别的可能，毕竟当初说好用vim的我现在竟用着vscode。\n\n","collection":"blog","data":{"type":"post","category":"fe"}}]}