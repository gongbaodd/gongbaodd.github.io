{"posts":[{"id":"2022/01/02/Amdahl.md","slug":"2022/01/02/amdahl","body":"\n# 再次聊 Amdahl 定律和 Gustafson 定律\n\n因为考研，这个专题耽搁了，[之前](/book/2021/07/27/Amdahl定律.html)提过这个定律但是不深。本来想继续之前的位置读，不过考虑到很久没看了，就来重读一遍，没想到能获得新的理解\n\n## Amdahl 定律\n\nAmdahl 这个名字还真难记，查了一下，老爷子生平经历还是值得一看的，本人也是瑞典和挪威混血，15 年因为肺癌去世 RIP。\n\n其实 Amdahl 定律$S=\\frac{1}{(1-\\alpha)+\\alpha/k}$是一个解决一定数据集下并行处理在整体的占比和整体运算速度影响的一种定律（$\\alpha$为占比，$k$为芯片数）。\n\n这个公式比较好理解，假设整体串行处理的时间为 1，则优化之后的时间就是串行部分$1-\\alpha$和并行部分$\\alpha/k$的和。\n\n如果 k 是无限多个，则整体速度比则无限趋近于$\\frac{1}{1-\\alpha}$，即整个系统串行和加上并行之后串行时间之比。\n\n## Gustafson 定律\n\nGustafson 则是另一个角度，假定串行时间是 a，单一线程处理并行数据时间是 b，则完全串行运行的时间为 a+nb，实际运行时间为 a+b，那么速度比为$S=\\frac{a+nb}{a+b}$\n\n令$F=\\frac{a}{a+b}$即串行在整体项目中的占比，经过化简得$S=(1-n)F+n$也就是串行占比足够小的时候，加速比就是芯片数。\n\nGustafson 定律解决了 Amdohl 定律必须要求数据集一定的前提。但是也有许多争议，比如处理非线性问题时可能不会有理想的结果。\n","collection":"blog","data":{"type":"post","category":"book","tag":["CSAPP"],"series":{"slug":"CSAPP","name":"深入理解计算机系统"}}},{"id":"2022/01/08/Soul.md","slug":"2022/01/08/soul","body":"\n# Soul\n\n皮克斯每年的固有泪目电影，这回的主题竟不是要坚持梦想，用一句俗话说，就是哥们别把掳走窄了。","collection":"blog","data":{"type":"post","category":"movie"}},{"id":"2022/01/09/Fixed-point-number.md","slug":"2022/01/09/fixed-point-number","body":"\n# 定点数\n\n## 二进制、十进制和十六进制的转化\n\n对于$2^n$的 16 进制转化,最高位是$2^{(n \\mod 4)}$，低位用$n/4$个零补齐\n\n| $n$ | $2^n(decimal)$ | $2^n(hexadecimal)$ |\n| --- | -------------- | ------------------ |\n| 5   | 32             | 0x20               |\n| 23  | 8388608        | 0x800000(3+4x5)    |\n\n这个用的还比较多，比如一个 32 位的计算机，它可以寻址 0x0000~0xffff(0x10000-1)，总共$2^{32}$字节（4GB）。\n\n显然 16 位中 A-F 和二进制、十进制的对应关系也需要熟记。\n\n- 0x605c + 0x5 = 0x6061\n- 0x605c - 0x20 = 0x603c\n- 0x605c + 32 = 0x607c\n- 0x60fa - 0x605c = 0x9e\n\n## 字节序\n\n字节序 endian 这个词源于「格列佛游记」里面一个国家因为吃鸡蛋要敲大端还是小端引发争议。这里面指老的计算机普遍以大端存储数据即主观方式存储，而现有的主流机器都以小端存储，即反向存储。\n\n如`int a=0x12345678;`在大端上 a 的第一个字节是 12 而小端则是 78。历史上也出现过大小端机器互通导致 Unix 打成 nUxi 的故障。\n","collection":"blog","data":{"type":"post","category":"book","tag":["CSAPP"],"series":{"slug":"CSAPP","name":"深入理解计算机系统"}}},{"id":"2022/02/25/Johnathan Agassi Saved my Life.md","slug":"2022/02/25/johnathan-agassi-saved-my-life","body":"\n# Johnathan Agassi Saved My Life\n\n这是一部纪录片，讲的是一个以色列 Gay 星从出道到最后吸毒退出的 8 年故事。\n\n大开眼界，可以说，按理说看纪录片我都会困的，但是这部不一样，可能因为它讲的是一个绝对灰色产业的故事吧。\n\n开始是这个 Johnathan Agassi 在柏林跳脱衣舞，和同事讨论自己因为梦想从事色情业（就跟「全裸监督」一样），同事则是因为妹妹得了癌症。\n\nJohnathan 在纽约混的大红大紫，因为父母离异，他和母亲特别亲密，甚至和母亲一起看自己的片，母亲也时常鼓励他。\n\n他的堕落从一次评奖开始（没错，gay 片还有奖），他连感谢词都想好了，但并没拿上奖。一气之下，他揪了个人就在厕所干起来，还叫那个人喊他第一名，这段真的，全程跟拍！全程跟拍！\n\n后来他担心肌肉不够，开始注射类固醇。表演的时候担心硬不起来，也会注射药物。但是效果不理想，并怪罪其它演员。最后因为吸毒上瘾不得不退出。\n","collection":"blog","data":{"type":"post","category":"tv"}},{"id":"2022/03/21/Barrier-DeskDroid-Universal Control.md","slug":"2022/03/21/barrier-deskdroid-universal-control","body":"\n# Barrier 和 DeskDroid 实现苹果的 Universal Control\n\n今天被人显摆了苹果的 Universal Control 了，作为跨屏协同用了这么久的我，为啥不显摆一下我现有的桌面配置呢？\n\nDeskDroid 的最新版本是可以和 Barrier 集成的，需要在设置中选择集成到 barrier，会有提示提醒如何把现有机器配置到 barrier 的设置里。\n\n由于 DeskDroid 基于 adb，可以很简单实现 adb 的无线连接\n\n```shell\nadb devices # 展示现在有线连接的设备\nadb tcpip 5555 # 打开设备无线的5555端口，成功后可以断开有线了（如果有多台设备连接，需要用-s指定设备）\nadb connect ${DeviceIP}:5555\n```\n\n现在就可以实现全局操控了。\n","collection":"blog","data":{"type":"post","category":"tech","tag":["windows"],"series":{"slug":"windows-howto","name":"Windows舒适指南"}}},{"id":"2022/05/14/QWERT Learner.md","slug":"2022/05/14/qwert-learner","body":"\n# QWERT Learner 练打字\n\nkeybr 被墙之后，我就琢磨换一个打字网站，最近使用了[QWERT Learner](https://qwerty.kaiyi.cool/)，很不错，还可以顺便背单词。\n\n后期我可能会 fork 这个项目加入 anki 的功能\n\n现在暂时 dict2anki 成单词卡\n","collection":"blog","data":{"type":"post","category":"tech"}},{"id":"2022/05/30/WSL2.md","slug":"2022/05/30/wsl2","body":"\n# WSL2加载虚拟硬盘\n\n在最新版的Windows11中，WSL2新增了[mount参数](https://docs.microsoft.com/zh-cn/windows/wsl/wsl2-mount-disk\n)可以加载虚拟硬盘了。\n\n依过去的经验WSL经常会更新崩溃，所以开发的时候我会把代码仓库和系统放在两个分区里，然而在Linux中操作NTFS是非常慢的，最好是新建一个Ext4的虚拟硬盘，再挂载到Linux中。\n\n在Windows的磁盘管理可以新建`.vhdx`文件（默认新建好会自动挂载，以后双击文件也可加载硬盘），然后使用Diskgen将这个磁盘分区并格式化成Ext4格式。\n\n接着在Powershell执行`GET-CimInstance -query \"SELECT * from Win32_DiskDrive\"`查看挂载的硬盘DiskPath，紧接着管理员执行`sudo wsl --mount <DiskPath> --bare`将硬盘挂载到WSL中。\n\n进入Linux里面，执行`lsblk`查看新加载的分区如sda3，新建文件夹`work`，并把这个分区挂在上去`sudo mount /dev/sda3 work`，完成。\n\nExt4的磁盘格式比NTFS快得不是一星半点，只可惜这些都只能在Windows11中实现，而且目前还没有更好的自动化实现方案。","collection":"blog","data":{"type":"post","category":"tech","tag":["windows"],"series":{"slug":"windows-howto","name":"Windows舒适指南"}}},{"id":"2022/06/14/VSCode-NeoVim.md","slug":"2022/06/14/vscode-neovim","body":"\n# 从VSCode到NeoVim\n\n最近Github的Atom宣布暂停更新了，这让我想起来现在的VSCode就如它的老对手一样卡...\n没错，换成Ext4分区之后WSL的开发速度快了很多，但还是能够感觉到卡顿，所以最近几天就折腾起来NeoVim了。\n\n具体的配置我就不多说了，因为网上的内容实在太多，学习的话可以参考[Neovim 配置实战：从 0 到 1 打造自己的 IDE](https://github.com/nshen/learn-neovim-lua)，入门足够了。\n\n目前我的配置是[nvim-config](https://github.com/gongbaodd/nvim-config)是从别人那里fork出来的。\n\n现在的NeoVim已经all in lua了，这让我怀念起来玩饥荒的美好时光，哈哈\n","collection":"blog","data":{"type":"post","category":"tech","tag":["vim"]}},{"id":"2022/06/20/Makefile.md","slug":"2022/06/20/makefile","body":"\n# 学习使用 makefile\n\nMakefile其实一直都用过，只是没有系统学习一下，也从未遇到过要从头写一个的机会。\n\n这个[链接](https://makefiletutorial.com/)很详细了，抽出一点时间看了下。\n\n","collection":"blog","data":{"type":"post","category":"tech","tag":["makefile"]}},{"id":"2022/06/29/kindle.md","slug":"2022/06/29/kindle","body":"\n# 破解 kindle\n\n据说手上的 kindle 还有两年就不能服役了，果断选择把它破解掉，破解的方式是主要参照[书伴](https://bookfere.com/post/970.html)。\n\n越狱成功后可以参考[此文](https://bookfere.com/post/311.html)安装插件，试用了 Koreader，比 kindle 原生的浏览器好用太多了，File Browser 可以搭建了本地 http 服务实现局域网传文件。\n","collection":"blog","data":{"type":"post","category":"tech","tag":["kindle"]}},{"id":"2022/07/05/CMake.md","slug":"2022/07/05/cmake","body":"\n# 学习 CMake\n\n学习了 Makefile 之后自然开始学习 CMake，网上找到了一个[例子](https://github.com/ttroy50/cmake-examples)有一些老了，但是还是挺有用的。\n\n里面包括使用 boost 和 catch2 以及 GoogleTest 做单元测试，还有包装 deb 以及使用 conan 进行包管理的例子。\n","collection":"blog","data":{"type":"post","category":"tech","tag":["CMakeFile"]}},{"id":"2022/07/27/wxWidgets.md","slug":"2022/07/27/wxwidgets","body":"\n# 在学习大概一周的 wxWidgets 之后，我决定放弃了\n\n之前我冲浪的时候看到了[这篇博客](https://zetcode.com/gui/wxwidgets)，一下子勾起了我关于古早味的 UI 开发的兴趣，照着里面的教程，在 Linux 下面学习很顺利，唯一小坑就是 Ubuntu-22.04 里面的`libwxgtk3.0-dev`改名为`libwxgtk3.0-gtk3-dev`，另外还需要设置环境变量`export wxWidgets_ROOT_DIR=/usr/lib/x86_64-linux-gnu/wx`。\n\n然而到了 Windows 下面就没有那么顺利了，当然，我个人反思一下，如果使用 MSYS2 或者 mingw，虽然慢点，但应该和 Ubuntu 下面差不多，然而，想要尝试顺滑编程体验的我最先选择 VSCode + CMake + conan + ninja 作为技术栈。\n\n第一个坑，conan 的官方仓库没有 wxWidgets，小问题我马上找到了 bincrafters 仓库 https://bincrafters.jfrog.io/artifactory/api/conan/public-conan。配置好发现没有支持VS2019的x64二进制文件......好说，执行`conan install --build-missing`，后面发现编译不成功，少一堆依赖。\n\n算了，编译那么大的项目比较麻烦，官网给了直接下载二进制包的方法啊，配置好`wxWidgets_ROOT_DIR`，执行 cmake 一直提醒 find_package(wxWidgets)不成功，我几乎把[文档](https://docs.wxwidgets.org/trunk/overview_cmake.html)里面的所有变量都处理了个遍，就是不行。\n\n好吧，可能是技术栈的问题，我看大部分用 Windows 的都是 VS2019 开发，于是把技术栈改成 VS2019+vcpkg，别说各种帮助方法，如 wxPuts 都能使用了，可 GUI 编译不过。\n\n寻思这既然 vcpkg 都能编译过去了，那我直接把源文件当成 subdirectory，用之前的技术栈不是也能成？果然也是 GUI 编译不通过。\n\n太难过了，古早味的跨平台 GUI 开发真辛苦...\n","collection":"blog","data":{"type":"post","category":"tech","tag":["WxWidgets"]}},{"id":"2022/07/31/SwiftUI.md","slug":"2022/07/31/swiftui","body":"\n# 短暂尝试 SwiftUI\n\n周围吹 SwiftUI 的人太多了，而且手上刚好有台黑苹果就一直想试一试。\n\n其实受伤的黑苹果挺卡的，所以更希望不使用 XCode，而是 vscode 远程编程，也确实有人尝试了，[这里是他的 demo](https://www.alwaysrightinstitute.com/tows-ios/)。\n\n尝试过这段代码，很遗憾要求至少 MacOS 11，不能编译成功，算了以后有机会再事先吧。\n","collection":"blog","data":{"type":"post","category":"tech","tag":["SwiftUI"]}},{"id":"2022/08/11/OpenGL-tutorial.md","slug":"2022/08/11/opengl-tutorial","body":"\n# 几个 OpenGL 的 tutorial\n\nOpenGL 和 Rust 算是我一直在学习，但一直没办法实际使用的技术了。\n\n[Rust and OpenGL from scratch](http://nercury.github.io/rust/opengl/tutorial/2018/02/08/opengl-in-rust-from-scratch-00-setup.html) 这是一篇讲 Rust 结合 OpenGL 的博客，照着操作下去，主要的感觉就是 unsafe 太多了，网上几乎所有的 OpenGL 教程都基于[LearnOpenGL](https://learnopengl-cn.github.io/)来做，这是一篇中文译本，非常值得细看。\n\n今天我还会再看一下 Vulkan，希望里面的 unsafe 的部分不要太多。\n","collection":"blog","data":{"type":"post","category":"tech","tag":["OpenGL"]}},{"id":"2022/08/17/Rust.md","slug":"2022/08/17/rust","body":"\n# Rust 实现的几个排序算法\n\n## 冒泡排序\n\n$O(n^2)$ 稳定排序\n\n选择每个元素和后面的作比较，如果前面的元素比后面的大，就交换两个元素的位置。\n\n```rust\nfn bubble_sort<T: Ord>(arr: &mut [T]) {\n    for i in 0..arr.len() {\n        for j in i..arr.len() {\n            if arr[i] > arr[j] {\n                arr.swap(i, j);\n            }\n        }\n    }\n}\n```\n\n## 插入排序\n\n$O(n^2)$ 稳定排序\n\n假定只有两个元素并排好序，每次再插入新的元素，直到全部元素都插入。\n\n```rust\nfn insert<T: Ord>(arr: &mut [T]) {\n    for i in 1..arr.len() {\n        let mut j = i;\n        while j > 0 && arr[j] < arr[j-1] {\n            arr.swap(j, j-1);\n            j -= 1;\n        }\n    }\n}\n```\n\n## 快速排序\n\n期望$O(n\\log{n})$，最坏情况$O(n^2)$，不稳定排序\n\n选中一个元素，把小于它的元素放到左边，再把大于它的放到右边，再继续处理两边数据。\n\n```rust\nfn quick<T:Ord>(arr: &mut [T]) {\n    _quick(arr, 0, (arr.len() - 1) as isize);\n}\n\nfn _quick<T:Ord>(arr: &mut [T], start: usize, end: isize) {\n    if start > end {\n        return;\n    }\n\n    let pivot = partition(arr, start, end as isize);\n    _quick(arr, start, (pivot) as isize - 1);\n    _quick(arr, pivot + 1, end);\n}\n\nfn partition<T:Ord>(arr: &mut [T], mut low: usize, mut high: usize) -> usize {\n    let pivot = 0;\n\n    loop {\n        if low < high && data[low] < pivot {\n            low += 1;\n        }\n        data.swap(low, high);\n\n        if low < high && data[high] > pivot {\n            high -= 1;\n        }\n        data.swap(low, high);\n\n        if low == high {\n            break;\n        }\n    }\n\n    low\n}\n```\n\n## 归并排序\n\n$O(n\\log{n})$ 稳定排序\n\n将两个有序数组合并为一个有序数组\n\n```rust\nfn merge<Ord:T>(arr: &mut [T]) {\n    let length = arr.len();\n    let middle = length / 2;\n\n    if length > 1 {\n        let a = arr[0..middle];\n        let b = arr[middle..length];\n        merge(a);\n        merge(b);\n\n\n    }\n}\n\nfn sort<Ord: T>(a: &[T], b: &[T], arr: &mut[T]) {\n    let mut ia = 0;\n    let mut ib = 0;\n    let mut i = 0;\n\n    while ia < arr.len() && ib < arr.len() {\n        if a[ia] < b[ib] {\n            data[i] = a[ia];\n            ia += 1;\n        } else {\n            data[i] = b[ib];\n            ib += 1;\n        }\n        i += 1;\n    }\n\n    if ia < arr.len() {\n        data[..i].copy_from_slice(&a[ia..]);\n    }\n\n    if ib < arr.len() {\n        data[..i].copy_from_slice(&b[ib..]);\n    }\n}\n```\n\n## 希尔排序\n\n$O(n\\log^2{n})$不稳定排序\n\n升级版的插入排序，每隔一个 gap 进行一次排序，直到 gap 缩到 1。\n\n```Rust\nfn shell<T: Ord>(arr: &mut [T]) {\n    let length = arr.len();\n    let mut gap = length / 2;\n\n    while gap > 0 {\n        for i in gap..length {\n            let mut j = i;\n            while j > gap & data[j] < data[j-gap] {\n                data.swap(j, j-gap);\n                j -= gap;\n            }\n        }\n        gap /= 2;\n    }\n}\n```\n\n## 堆排序\n\n$O(n\\log{n})$不稳定排序\n\n将数组转换成大顶堆，把作为根的最大值排到数组最后，再去除最大值重新排序。\n\n```Rust\nfn heap(data: &mut Vec<i32>) {\n    if data.len() < 2 {\n        return ;\n    }\n\n    // build one max heap\n    let last_root = (data.len() + 2) / 2;\n    for root in (0..=last_root).rev() {\n        to_max_heap(data, root, data.len() - 1);\n    }\n\n    // replace the first element(max element) to the last\n    // make max heap using the other elements\n    for last in (1..data.len()).rev() {\n        data.swap(0, last);\n        to_max_heap(data, 0, last-1);\n    }\n}\n\nfn to_max_heap(data: &mut Vec<i32>, mut root: usize, last: usize) {\n    loop {\n        let left = root * 2 + 1;\n        let right = left + 1;\n        let max_child;\n\n        if left > last {\n            break;\n        }\n\n        if right > last {\n            max_child = left;\n        } else {\n            max_child = if data[right] > data[left] {\n                right\n            } else {\n                left\n            }\n        }\n\n        if data[max_child] > data[root] {\n            data.swap(max_child, root);\n        }\n\n        root = max_child;\n    }\n}\n```\n\n另外还有很多排序算法参考[https://github.com/TheAlgorithms/Rust/tree/master/src/sorting](https://github.com/TheAlgorithms/Rust/tree/master/src/sorting)\n\n## bogo 排序\n\n$O(n\\times n!)$\n\n随机排列直到排序完成\n\n## 桶排序(Bucket Sort)\n\n$O(n)$ 稳定排序\n\n先对元素分类，如 0-10，10-20...然后在每个桶中进行排序\n\n## 鸡尾酒排序(cocktail Sort)\n\n$O(n^2)$ 稳定排序\n\n冒泡排序的变形，先向上冒泡，再进行一次下沉，是两个方向的冒泡排序。\n\n## 梳排序(Comb sort)\n\n$O(n\\log{n})$ 不稳定排序\n\n用希尔排序的方法进化冒泡排序，衰减值默认选 1.3 效率最高\n\n## 计数排序\n\n$O(n+k)$ 稳定排序\n\n新建一个 k 元素的计数数组，k 为排序数组的取值空间，有值的计数数组键值就是排序结果。\n\n## 基数排序(Radix sort)\n\n$O(k\\cdot n)$\n\n按照个位、十位、百位...排序\n\n## Tim sort\n\n长度小于 64 的数组进行二分插入排序，大于 64 的数组进行归并排序，归并排序在比较大于 minrun 时直接对接数组。\n","collection":"blog","data":{"type":"post","category":"tech","tag":["algorithm","Rust"]}},{"id":"2022/08/24/Astro.md","slug":"2022/08/24/astro","body":"\n# Astro 算是比较终极状态的前端框架了\n\n这几天刷油管发现都在推荐一个 Astro 的框架，这算是一个比 React、Vue 更高一维度的框架，\n它可以使用目前已知的主流前端框架作为渲染器生成静态页面，同时可以把页面中需要交互的部分以「岛」的形式添加到页面里。\n\n更有趣的，同一个项目可以接受不同的框架，相比于 Next、Gatsby 等，它看起来是更加简单易用的。\n","collection":"blog","data":{"type":"post","category":"tech","tag":["astro","js"]}},{"id":"2022/08/27/Ziglang.md","slug":"2022/08/27/ziglang","body":"\n# 试用 Zig\n\n最近 bun 大火，带动一个语法看起来很像 JS 的语言 Zig 受到关注。听了 Devtools 播客里面的推荐，我觉得可以试用一下。\n\nZig 官网两个学习链接[ziglearn](https://ziglearn.org/)和[ziglings](https://github.com/ratfactor/ziglings)很有帮助，这个语言的学习曲线远没有 Rust 那么陡，甚至可以说，比 C 简单。可以说 Zig 就是披着高级语言语法外衣的 C 语言，而根据官方文档的说法，Zig 的编译器确实可以直接编译 C。\n\n提到语言安全，比较多提的是类型安全和内存安全。类型在 Zig 中只有编译环境使用，官方介绍 Zig 没有宏语言，实际使用中其实是有的，只不过宏语言用的也是 Zig 语法，前面加上了 comptime 关键字，它的泛型写法也利用了编译时可编程的特点。个人觉得使用的时候会混淆，但是教程里面表示用习惯了就不会...\n\n对比 Golang 的垃圾回收和 Rust 的借用机制，Zig 是完全不管内存安全的，跟 C 类似，想要操作堆内存，要新建 allocator，好在利用 defer 关键词能让回收工作在代码里面看起来不是那么难懂。\n\nasync 几乎和 JS 一模一样，用起来感觉是 JS 里面 generator 和 async 的合体版（但它不是迭代器），感觉 JS 用户体验是无缝的。\n\n个人很推荐 Zig，是一个完全新味道的语言。\n","collection":"blog","data":{"type":"post","category":"tech","tag":["zig"]}},{"id":"2022/09/08/Traversing-a-binary-tree.md","slug":"2022/09/08/traversing-a-binary-tree","body":"\n# 遍历二叉树\n\n遍历二叉树其实也不难，就是利用栈的思维实现遍历挺有意思的，另外在写迭代器的时候还会用的 Rust 的生命周期，刚好能够对 Rust 的生命周期有更多的理解。\n\n## 遍历方法\n\n- 先序遍历，根左右\n- 中序遍历，左根右\n- 后序遍历，左右根\n- 按层遍历\n\n先序遍历，先把跟压入栈，执行 next 出栈取值，并将右子树和左子树压入栈，直到栈空，返回 None。\n\n```Rust\nstruct TreeIter<'tree> {\n    order: Order,\n    stack: Vec<&'tree Tree>,\n}\n\nimpl<'tree> TreeIter<'tree> {\n    pub fn new(tree: &Tree) -> TreeIter {\n            TreeIter {\n                stack: vec![tree],\n                order,\n            }\n    }\n}\n\nimpl<'tree> Iterator for TreeIter<'tree> {\n    type Item = String;\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.stack.is_empty() {\n            return None;\n        }\n\n        let item = self.stack.pop().unwrap();\n\n        if item.right.is_some() {\n            self.stack.push(item.right.as_ref().unwrap());\n        }\n\n        if item.left.is_some() {\n            self.stack.push(item.left.as_ref().unwrap());\n        }\n\n        Some(item.value.to_owned())\n    }\n}\n```\n\n中序遍历，先把根的左手边按节点拆成几棵没有左子树的树压入栈，执行 next 的时候逐一弹出，如果弹出的子树有右子树，把右子树也拆成没有左子树的子树压入栈。\n\n```Rust\nstruct TreeIter<'tree> {\n    order: Order,\n    stack: Vec<&'tree Tree>,\n}\n\nimpl<'tree> TreeIter<'tree> {\n    pub fn new(tree: &Tree) -> TreeIter {\n        let mut iter = TreeIter {\n            stack: vec![tree],\n            order,\n        };\n\n        while let Some(node) = &iter.stack.last().unwrap().left {\n            iter.stack.push(node);\n        }\n\n        iter\n    }\n}\n\nimpl<'tree> Iterator for TreeIter<'tree> {\n    type Item = String;\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.stack.is_empty() {\n            return None;\n        }\n        let item = self.stack.pop().unwrap();\n        if item.right.is_some() {\n           self.stack.push(item.right.as_ref().unwrap());\n              while let Some(node) = &self.stack.last().unwrap().left {\n                  self.stack.push(node);\n              }\n        }\n\n        Some(item.value.to_owned())\n    }\n}\n```\n\n后序遍历，相比于前两个准备工作多一些，需要两个栈，第一个栈按照先序遍历一样压栈，不同的是，先序遍历为了先出栈左子树（根左右）而先压栈右子树，这里要先压栈左子树。第一个栈的出栈元素直接压入第二个栈。执行 next 时，直接从第二个栈出栈即可。\n\n```Rust\nstruct TreeIter<'tree> {\n    order: Order,\n    stack: Vec<&'tree Tree>,\n}\n\nimpl<'tree> TreeIter<'tree> {\n    pub fn new(tree: &Tree) -> TreeIter {\n            let mut iter = TreeIter {\n                stack: vec![],\n                order,\n            };\n            let mut stack = vec![tree];\n            while !stack.is_empty() {\n                let node = stack.pop().unwrap();\n                iter.stack.push(node);\n                if node.left.is_some() {\n                    stack.push(node.left.as_ref().unwrap());\n                }\n                if node.right.is_some() {\n                    stack.push(node.right.as_ref().unwrap());\n                }\n            }\n            iter\n    }\n}\n\nimpl<'tree> Iterator for TreeIter<'tree> {\n    type Item = String;\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.stack.is_empty() {\n            return None;\n        }\n\n        let item = self.stack.pop().unwrap();\n        Some(item.value.to_owned())\n    }\n}\n```\n\n按层遍历，就是把每一层的节点按层压入栈\n\n```Rust\nstruct LevelIter<'tree> {\n    stack: Vec<Vec<&'tree Tree>>,\n}\nimpl<'tree> LevelIter<'tree> {\n    pub fn new(tree: &'tree Tree) -> LevelIter {\n        let mut iter = LevelIter {\n            stack: vec![vec![tree]],\n        };\n\n        loop {\n            let last_row = iter.stack.last().unwrap();\n            let mut row: Vec<&'tree Tree> = vec![];\n            last_row.iter().for_each(|&node| {\n                if node.left.is_some() {\n                    row.push(node.left.as_ref().unwrap());\n                }\n\n                if node.right.is_some() {\n                    row.push(node.right.as_ref().unwrap());\n                }\n            });\n\n            if row.is_empty() {\n                break;\n            }\n\n            iter.stack.push(row);\n        }\n\n        iter.stack.reverse();\n\n        iter\n    }\n}\n\nimpl<'tree> Iterator for LevelIter<'tree> {\n    type Item = Vec<String>;\n    fn next(&mut self) -> Option<Self::Item> {\n        self.stack\n            .pop()\n            .map(|row| row.iter().map(|&tree| tree.value.to_owned()).collect())\n    }\n}\n```\n\n所有的迭代器语法里面都有个类似于泛型的`<'tree>`，这里就是 Rust 的生命周期，每一个迭代器都有一个自身的生命周期和对应的二叉树的生命周期，这里需要向编译器指明这个对象有两个生命周期，以及哪些变量的生命周期不同。\n","collection":"blog","data":{"type":"post","category":"tech","tag":["algorithm","Rust"]}},{"id":"2022/09/08/kmp.md","slug":"2022/09/08/kmp","body":"\n# KMP 匹配算法\n\n要从一个字符串 ababcabcacbababcac 中查中一个片段如 abcac 可以使用 KMP 算法。\n\nKMP 算法，简单来说就是先从要匹配的字符串中找到重复的字缀，并将这些字缀标记跳过的字数以做到匹配时剪掉不许匹配的次数。\n\n- a，首位和末尾没有重复即为 0\n- ab，首位和末尾没有重复即为 0\n- abc，首位和末尾没有重复即为 0\n- abca，首位和末尾有一位重复 a，记为 1\n- abcac，首位和末尾没有重复即为 0\n\n```js\nvar next = ArrayList(usize).init(allocator);\ndefer next.deinit();\n\nfor (word) |_, inext| {\n     if (inext == 0) {\n         try next.append(0);\n         continue;\n    }\n\n     var imatched = next.items[inext - 1];\n     while (imatched > 0 and word[imatched] != word[inext]) {\n            imatched = next.items[imatched - 1];\n     }\n\n     if (word[imatched] == word[inext]) {\n        try next.append(imatched + 1);\n     } else {\n         try next.append(imatched);\n     }\n}\n```\n\n得到匹配列表为 00010，这里的数字对应每个字母的序号 01234，假设匹配长字符串的时候刚好匹配到 abcac 的时候（第五位）没有匹配上，就看`c`前面的字符`a`对应的匹配值，这里是 1，指的可以从字符串中序号为 1 的字符，这里是`b`，继续匹配。\n\n```js\n    var iword: usize = 0;\n    for (str) |c, istr| {\n        while (c != word[iword] and iword > 0) {\n            iword = next.items[iword - 1];\n        }\n\n        if (c == word[iword]) {\n            iword += 1;\n        }\n\n        if (iword == word.len) {\n            try res.append(istr - iword + 1);\n            iword = next.items[iword - 1];\n        }\n    }\n```\n","collection":"blog","data":{"type":"post","category":"tech","tag":["algorithm","zig"]}},{"id":"2022/09/09/OpenGL.md","slug":"2022/09/09/opengl","body":"\n# OpenGL 画个三角\n\n这是上个月打算看的教程[learnopengl-cn.github.io](https://learnopengl-cn.github.io/)，真的是非常良心，完全搬运的话感觉没意义，这里做一下笔记好了。\n\n三个主要的对象\n\n- 顶点数组对象 VAO\n- 顶点缓冲对象 VBO\n- 元素缓冲对象 EBO\n\n这三个对象都是用来描述显存的，每一个 VAO 对应一个图形，VBO 是这个图形的点的数组，因为图形按照三角形拼接的，如果只使用 VBO 会多出许多重复的点，EBO 就是为这些重复的点做索引。\n\n```C++\n// ..:: 初始化代码 :: ..\n// 1. 绑定顶点数组对象\nglBindVertexArray(VAO);\n// 2. 把我们的顶点数组复制到一个顶点缓冲中，供OpenGL使用\nglBindBuffer(GL_ARRAY_BUFFER, VBO);\nglBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\n// 3. 复制我们的索引数组到一个索引缓冲中，供OpenGL使用\nglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);\nglBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);\n// 4. 设定顶点属性指针\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);\nglEnableVertexAttribArray(0);\n\n[...]\n\n// ..:: 绘制代码（渲染循环中） :: ..\nglUseProgram(shaderProgram);\nglBindVertexArray(VAO);\nglDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);\nglBindVertexArray(0);\n```\n","collection":"blog","data":{"type":"post","category":"tech","tag":["OpenGL"]}}]}