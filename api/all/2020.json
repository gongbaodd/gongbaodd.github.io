{"posts":[{"id":"2020/01/03/2019-Node.md","slug":"2020/01/03/2019-node","body":"\n# 2019 年的 Node 测试最佳实践\n\n这其实不是一篇总结文档，而是一个笔记，基于[NodeJs && JS testing best practise](https://medium.com/@me_37286/yoni-goldberg-javascript-nodejs-testing-best-practices-2b98924c9347)。\n\n比较有趣的是，[Stryker Mutator](https://stryker-mutator.io/)这个工具，可以用来做 mutation testing，简单说，一般测试工具只能保证代码经过了分支，这个工具可以通过修改部分代码逻辑（比如把 true 改成 false）来判断代码是否还会经过这个逻辑。\n\n再一个就是[License Checker](https://www.npmjs.com/package/license-checker)和[plagiarism check](https://www.npmjs.com/package/plagiarism-checker)，就是避免自己养肥了被别人割韭菜。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["test"]}},{"id":"2020/01/04/gitBash.md","slug":"2020/01/04/gitbash","body":"\n# GitBash 增加环境变量\n\nWSL 的运行速度比较慢，所以我在 windows 下面的开发很大一部分还是在 GitBash 下面，GitBash 基于 mingw 开发，所以直接修改.bashrc 即可\n\n```\nPATH=$PATH:/c/Program\\ Files/nodejs\nalias python='winpty python.exe'\nalias ubuntu='winpty ubuntu.exe'\n```\n\n这里注意下，因为 python 和 Ubuntu 是从应用商店安装的，直接修改 PATH 变量会有权限问题，只能利用 winpty 调用。\n","collection":"blog","data":{"type":"post","category":"tech","tag":["git"]}},{"id":"2020/01/04/kindle-pdf.md","slug":"2020/01/04/kindle-pdf","body":"\n# 转换 kindle 书籍到 pdf\n\n自从习惯用讯飞听书之后，我就很少看书了。如果是 pdf 的话，就在 Windows 上面拿 edge 读给我听，可问题是 kindle 上面很多书加了设备锁，只能在 kindle 上面看，而 kindle 的 TTS 功能实在太差，查了一下，Calibre 是有[DeDRM 插件](https://github.com/apprenticeharper/DeDRM_tools)的。\n\n解压缩插件，在 Calibre 中点击首选项->插件->从文件加载插件，选中解压好的 zip 文件。\n\n之后在插件中找到 DeDRM，把自己的产品序列号输入进去（在亚马逊我的设备中可以找到），之后转换 azw 文件就不会有问题了。\n","collection":"blog","data":{"type":"post","category":"tech","tag":["kindle"]}},{"id":"2020/01/05/CloudFlare-https.md","slug":"2020/01/05/cloudflare-https","body":"# 利用CloudFlare实现网站https访问\n\n## 配置DNS指向CloudFlare\n\n首先登入CloudFlare的时候，会被要求更改网站的DNS为cloudflare中。需要登入到自己网站的域名配置中修改DNS到CloudFlare下。\n\n配置成功后，收到CloudFlare的确认邮件，打开DNS，将Proxy status都打开。\n\n## 配置https-only\n\n打开CloudFlare的TLS选项，选择encryption mode为flexible，就是服务器到cloudflare不加密（只要cloudflare不作恶，我就OK），在Edge Certificates里面选择Always use https即可。\n\n## 配置防火墙只允许cloudflare的IP\n\n这里没配置成功，留个坑以后补全。\n\n安装firewalld\n\n```\nsudo apt install firewalld\nsudo systemctl start firewalld\nsudo systemctl enable firewalld\n```\n\n接下来执行以下脚本为cloudflare增加至白名单\n\n```shell\n!#/bin/bash\n\nfor i in $(curl \"https://www.cloudflare.com/ips-v4\");\ndo\nsudo firewall-cmd --permanent --zone=public --add-rich-rule='rule family=\"ipv4\" source address=\"'$i'\" port port=80 protocol=tcp accept';\nsudo firewall-cmd --permanent --zone=public --add-source=$i;\ndone\n\nfor i in $(curl \"https://www.cloudflare.com/ips-v6\");\ndo\nsudo firewall-cmd --permanent --zone=public --add-rich-rule='rule family=\"ipv6\" source address=\"'$i'\" port port=80 protocol=tcp accept';\nsudo firewall-cmd --permanent --zone=public --add-source=$i;\ndone\n\nsudo firewall-cmd --permanent --change-zone=eth0 --zone=public\n\nsudo firewall-cmd --reload\n\nfirewall-cmd --zone=public --list-all\n```","collection":"blog","data":{"type":"post","category":"tech"}},{"id":"2020/01/06/Windows-Jupyter-NotImplementError.md","slug":"2020/01/06/windows-jupyter-notimplementerror","body":"\n# 修复 Windows 下打开 Jupyter 报 NotImplementError\n\n打开`/c/Users/{USER_NAME}/AppData/Local/Programs/Python/Python38/Lib/asyncio/__init__/py`.\n\n修改\n\n```python\nif sys.platform == 'win32':\n    from .windows_event import *\n    __all__ += windows_events.__all__\n```\n\n改为如下\n\n```python\nimport asyncio\n\nif sys.platform == 'win32':\n    from .windows_event import *\n    asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())\n    __all__ += windows_events.__all__\n```\n","collection":"blog","data":{"type":"post","category":"tech","tag":["jupyter"]}},{"id":"2020/01/12/Opera-Dance-Dance-Notre-Dame.md","slug":"2020/01/12/opera-dance-dance-notre-dame","body":"# 歌舞剧「巴黎圣母院」\n\n因为朋友过年要出国年会，赶不上这场歌舞剧，我就直接接手了。\n\n故事就是巴黎圣母院，吉普赛人女主在举行于巴黎圣母院外的选丑盛会上跳舞，被愚人王卡西莫多、教堂的主教、护卫队队长看到。女主和护卫队长一见钟情，却不知道护卫队长已经结婚。主教明面安排敲钟人卡西莫多去抓女主，实则为了假装英雄救美把拘捕卡西莫多。\n\n女主本性善良，看到诗人因为传唱嘲讽主教的诗被抓捕，对外宣称诗人是自己的丈夫。卡西莫多被拘捕示众，女主为其送水，卡西莫多因此爱上女主。主教为了得到女主，借助女主和护卫队长幽会的机会暗杀护卫队长。受伤的护卫队长认为这是因为女主的巫术迷惑了她才导致自己受伤。主教趁机抓捕了女主和吉普赛人。\n\n主教威胁女主，女主宁死不从，依然爱着护卫队长。卡西莫多放出吉普赛人救出女主。女主只能白天躲在教堂里，晚上溜出来。主教杀死女主哥哥引她出来，并审判以绞刑。施刑当天，卡西莫多终于搞清主教阴谋，将主教推下教堂摔死。然而为时已晚，女主已死，卡西莫多自杀死在女主身边。\n\n美女与野兽的成人版，护卫队长那个渣男...\n\n全程法语，最后还要法语合唱大教堂啊，好在提前在B站上面预习了一下。","collection":"blog","data":{"type":"post","category":"life"}},{"id":"2020/01/13/Website Scraping with Python.md","slug":"2020/01/13/website-scraping-with-python","body":"\n# Website Scraping with Python\n\n## Parsing robots.txt\n\npage 28\n\n## Using Beautiful Soup\n\n用来解析 HTML\n\n- page 56 - 使用\n- page 101 - 利用 strainer 只解析想要的数据\n\n## Exporting the Data\n\n- page 80 - CSV\n- page 87 - JSON\n- page 90 - SQLite\n- page 97 - MongoDB\n\n## Using Scrapy\n\n- page 111\n\n## Handling JavaScript\n\n- page 186 - Splash\n- page 196 - Selenium\n\n## Cloud\n\n- page 206 - [Scrapy Cloud](https://scrapinghub.com/scrapy-cloud)\n  - page 211 - [mlab](https://mlab.com/)\n- page 216 - [PythonAnywhere](https://www.pythonanywhere.com/)\n","collection":"blog","data":{"type":"post","category":"book"}},{"id":"2020/01/15/Static-phylical-scope.md","slug":"2020/01/15/static-phylical-scope","body":"\n# 静态词法作用域\n\n最近在看 rust，里面提到静态词法作用域，一个神奇的 deja-vu，于是我急忙查了下它是啥。\n\nrust 和 js 都是静态词法作用域，简单说，作用域中的变量在编译时已经确定，不会随着运行时变化而变化。\n\n```javascript\nvar a = 1;\n\nfunction foo() {\n  var a = 2;\n\n  bar();\n}\n\nfunction bar() {\n  console.log(a);\n}\n\nfoo(); // print 1\n```\n\n而相对的 shell 就是动态作用域。\n\n```shell\nvalue=1\n\nfunction foo() {\n    local value=2;\n    bar;\n}\n\nfunction bar() {\n    echo $value;\n}\n\nfoo;# print 2\n```\n\n动态作用域被广泛应用于早期动态语言，猜测是早期运行环境内存比较少不能装拿这么多东西吧。\n","collection":"blog","data":{"type":"post","category":"tech","tag":["compilers"]}},{"id":"2020/01/16/rust.md","slug":"2020/01/16/rust","body":"# rust编程之道\n\n这是一本大概是我18年买的书，当初是打算紧随Mozilla的脚步学习使用Rust，然而这本书显然不太适合那个时代的我学习。当时我只是个完全的前端，过了第3章类型管理的时候基本上就是一脸懵逼。\n\n可以说经过19年一年的后端工程师工作，我是更加了解关于线程、内存管理之类的概念。而且由于过去一年读了RxJS，对函数编程范式更加了解。另外在18年中旬，我是完全的面向对象范式追随者，对于Rust里面的一些范式显然不是很理解。\n\n这本书讲得很全面，可以说，如果拿里面的某些章节详细写出来就可以做大学教材了。但是弊端肯定是有的，比如Rust的应用，这里基本上没提，不过也可以谅解，毕竟就是在这本书出版后两年的今天，要说Rust的存在感依然很低；另外，很多作者用的很习惯的词汇往往会漏注释，毕竟我不是专门抽出一段时间来看这本书的，乍一看某个缩写还真难回忆它对应语境里面应该是什么。\n\n## 笔记\n\nrust虽然使用类C语法，但是很多地方真的和C语言及其它语言大相径庭。\n\n比如用来代替interface的trait系统\n\n```typescript\n// typescript\ninterface A {\n    bar()\n}\n\nclass B implements A {\n    bar() {\n\n    }\n}\n```\n\n在Rust中\n\n```rust\nstruct B {\n\n}\n\nimpl A for B {\n    fn bar() -> () {\n\n    }\n}\n```\n\n第182页提供了trait系统的不足，当时没看懂，以后回来看好了。\n\n另外259页生命周期参数，比较复杂，个人感觉等用到的时候再看吧。\n\n322页和361页，关于原生闭包和迭代器语法糖的第三方实现。\n\n435页RAII模式，以后抽时间看把。\n\n727页，无状态协程async/await语法糖实现。\n\n","collection":"blog","data":{"type":"post","category":"tech"}},{"id":"2020/01/22/Movie-supplementary-plan-Confession.md","slug":"2020/01/22/movie-supplementary-plan-confession","body":"\n# 电影补档计划： 告白\n\n![告白](https://img9.doubanio.com/view/photo/l/public/p689520756.webp)\n\n松隆子饰演的女教师女儿被两个学生残忍虐杀，然而两个男生却因为少年保护而幸免于责罚。教师离职前向全班宣布她在男生的牛奶里加入艾滋病血液。\n\n很快男生 B 精神错乱，女教师联系到新一任教师不断刺激男生 B 以至于最终男生 B 杀死生母被捕。男生 A 有强烈恋母情结，得知生母嫁人，新生恨意，打算炸死全校学生。女教师偷走炸弹安装到男生 A 母亲办公室里，最终男生 A 炸死了自己的亲生母亲。\n\n除了情节安排震惊，因为导演是中岛哲也（之前提过，被嫌弃的松子的一生也是他的），电影画面极具视觉感，很值得推荐。\n","collection":"blog","data":{"type":"post","category":"movie"}},{"id":"2020/01/28/spotify.md","slug":"2020/01/28/spotify","body":"\n# 白嫖 spotify 的方式\n\n今年开始，我不再在家办公，这使得我的网络环境不是很稳定，无法一直在线听 spotify。最好的办法，自然是把要听的音乐缓存下来。\n\nGitHub 里面有一个 python 项目[spotify-downloader](https://github.com/ritiek/spotify-downloader)可以下载 spotify 的音频。\n\n利用 pip 安装\n\n```shell\npip install spotdl\n```\n\n因为是国内使用，需要代理\n\n```shell\nenv https_proxy=http://127.0.0.1:1080 spotdl --song http://open.spotify.com/xxx\n```\n\n另外，spotdl 支持列表下载\n\n```shell\nspotdl --playlist [listUrl] # to get all songs' url\nspotdl --list list.txt # to download the songs\n```\n","collection":"blog","data":{"type":"post","category":"tech","tag":["spotify"],"series":{"slug":"windows-howto","name":"Windows舒适指南"}}},{"id":"2020/01/31/monect.md","slug":"2020/01/31/monect","body":"\n# Monect 让手机变成鼠标\n\n自从我的 XPS 键盘坏了，我就打算使用 K380 键盘替代我的笔记本键盘，然而这样使用触摸板就很困难。\n\n很久之前我就想让手机成为我的远程键盘，以前用 Linux 的时候有一个 KDE connect 可以实验通过 wifi 链接。但是因为我住的公寓 wifi 貌似会阻拦互相发现，最好的办法还是用蓝牙链接。去年稍稍了解了一些 blueman 的相关知识，其实蛮有意思的，可惜拖延症没有继续下去（确实比较有意思，苹果曾开发过一个协议，通过商场蓝牙派发广告）。\n\n回到正题，可以通过 Monenct 官网下载 PC 的 host，在 play store 下载 client，monect 支持 wifi、蓝牙以及 usb 链接。这样即使有一种连接方式暂时不可用其他方式能够立马替换。\n","collection":"blog","data":{"type":"post","category":"tech","series":{"slug":"windows-howto","name":"Windows舒适指南"}}},{"id":"2020/02/01/Summary-and-February-Plan-in-January.md","slug":"2020/02/01/summary-and-february-plan-in-january","body":"\n# 一月总结和二月计划\n\n话说这个月吃瓜不少。\n\n1. 长江白鳍豚灭绝\n2. 澳洲大火\n3. 戈恩逃离日本\n4. 川普一炮炸了伊朗二号人物\n5. 湾湾大选\n6. 伊朗炸加拿大飞机，伊朗道歉\n7. 患者家属砍死医生，医院道歉\n8. 木兰编程语言抄袭，实验室道歉\n9. 警方诬告 8 名医生造谣 SARS 传播，没有道歉\n10. 中美贸易协议签订\n11. 冠状病毒爆发\n12. 英国正式脱欧\n13. 人民网半夜带货双黄连\n\n不说气人的了，谈谈自己的事情。\n\n## 一月总结\n\n这个月我的生活也很充分\n\n1. 个人网站域名通过 Cloudflare 转发，但是备案没通过，算了，以后放点实验性的东西好了。\n2. 看了巴黎圣母院歌剧。\n3. 完成三本书「Website Scraping with Python」「rust 编程之道」「Unity 游戏设计与实现」\n4. 完成美剧爬虫上线 scrapinghub\n\n一月发现的新事物\n\n1. YouTube 栏目，老高&小茉，将一些奇闻异事很有趣，晚上烦的时候看一看很轻松。\n2. YouTube 栏目，自说自话的总裁，很有个人观点的历史频道。\n3. 网站[田间小站](https://www.tianfateng.cn/)，英语资源站。\n4. monect 键盘鼠标模拟器。\n\n## 二月计划\n\n1. 我的蛋白粉没了。\n2. 要整理出来一篇 Windows 下面开发 scrapy 爬虫（并单元测试）\n3. 使用 rust 开发前端页面\n4. 写第一个 flutter 应用\n5. 空闲时间整理一下旅游计划\n6. 报名 4-5 月雅思考试\n","collection":"blog","data":{"type":"post","category":"plan"}},{"id":"2020/02/04/Powershell-Windows.md","slug":"2020/02/04/powershell-windows","body":"\n# 用 Powershell 更新 Windows\n\n发现已经半个月没有被 Windows 更新打扰了，原来是一个累积更新挂了，我发现在图形界面下面怎么更新都失败，于是寻思在命令行执行。\n\n在 powershell 中有一个包 PSUpdateWindows 可以派上用场。\n\n```powershell\nInstall-Module PSUpdateWindow\n\nGet-WindowsUpdate #下载更新\n\nInstall-WindowsUpdate #安装更新\n```\n","collection":"blog","data":{"type":"post","category":"tech","tag":["powershell"],"series":{"slug":"windows-howto","name":"Windows舒适指南"}}},{"id":"2020/02/04/Windows-scrapy.md","slug":"2020/02/04/windows-scrapy","body":"\n# Windows 上使用 scrapy 抓取网页\n\n过去一周，我在尝试在 Windows 上面使用 python，我会在这一篇文章中总结一下这一次体验的经验，代码已经发布到[GitHub](https://github.com/gongbaodd/webScrapingStudy)上面。\n\n## 安装 python\n\n本身 python 的版本就比较混乱，Windows 又提供了商店版，而且 WSL 下面也可以安装 Linux 的 python，我都体验了一下。\n\n- Windows 商店版，这个貌似就是为了教学使用，因为 Windows 目前比较尴尬，全局安装的包可能会有兼容性问题，但是因为商店版都运行在沙盒之下，基本上就没多少修改的可能了。\n- WSL 版本，这个版本体验的是纯正的 Linux，但是一定要注意，如果没安装 Xserver 就相当于没有图形界面。\n- x64 版本，这个问题在于安装文件的地址都跟了个 x64。\n- win32 版本，这个版本的问题比较小，除了 pyenv 需要单独下载 Windows 版和[jupyter 报错](https://gongbaodd.github.io/tech/2020/01/06/%E4%BF%AE%E5%A4%8DWindows%E4%B8%8B%E6%89%93%E5%BC%80Jupyter%E6%97%B6%E6%8A%A5NotImplementError.html)，还没碰到其他问题。\n\n## pyenv\n\n介于 python 大版本兼容性，个人认为要安装一个版本管理器。因为习惯于 JavaScript 工作环境，我肯定会寻找类似于 nvm 的映射就是 pyenv，在 Windows 下面可以通过 chocolatey 安装。\n\n```shell\nsudo choco install pyenv-win\n```\n\n下面几个命令是最常用的。\n\n- `pyenv install -l`查看可以安装的 python 版本号。\n- `pyenv local install 3.8.0`在项目中安装 3.8.0 版本（会在项目目录增加.python-version 文件）。\n- `pyenv version`查看现在的 python 版本。\n- `pyenv versions`查看安装过的 python 版本。\n\nwin10 上了一个新功能，控制台会引导 python 到应用商店，在“设置>应用和功能>应用执行名”中可以勾掉这个功能\n\n## virtualenv\n\npython 的包管理其实很差，都是放到 global 下面，这就导致多个项目可能都用同一个依赖。那么如何实现每个项目都有自己的依赖呢？这就靠 virtualenv。\n\n```shell\npip install virtualenv\n```\n\n如下命令最常用\n\n- `virtualenv [venv folder name]`新建虚拟环境文件夹。\n- `source [venv folder name]/Scripts/activate`启动虚拟环境（在 Linux 下面是 bin/activate）。\n- `deactivate`关闭虚拟环境（这个在 Linux 会比较常用）。\n\n## scrapy\n\nscrapy 是一个 python 的爬虫框架，使用 pip 可以安装 scrapy。\n\n```shell\npip install scrapy\n```\n\n下面是 scrapy 用的比较多的几个命令\n\n- `scrapy startproject [project name]`新建项目。\n- `scrapy crawl [spider name] -o [output file]`爬取页面并输出结果到文件。\n\nscrapy 的概念比较多，包括 spider、pipeline、middleware 等等，但个人看来基本上看完[tutorial](https://docs.scrapy.org/en/latest/intro/tutorial.html#our-first-spider)就可以上手了。\n\n### scrapy shell\n\n执行`scrapy shell [url]`可以以命令形式使用 scrapy。\n\n- `fetch('http://xxx.com')`爬取页面\n- `view(response)`浏览爬取的页面\n- `response.css('a::text').extract()`析取页面中链接的文字列表\n- `response.css('a::attr(href)')`析取页面中链接列表\n\n### 发起 Xmlhttp 请求\n\n使用[Scrapy.FormRequest](https://docs.scrapy.org/en/latest/topics/request-response.html#scrapy.http.FormRequest)发起请求，接收到结果可以使用[response.body_as_unicode()]解析 JSON 为字典。\n\n### splash\n\n截至目前，scrapy 都只能渲染非 JavaScript 运行的页面，但是借助 splash 就可以解析 JavaScript 了。我们使用 docker 可以尝试一下 splash。\n\n```shell\ndocker pull scrapinghub/splash\ndocker run -p 8050:8050 scrapinghub/splash\n```\n\n访问 localhost:8050 即可访问 splash。通过安装`scrapy-splash`可以在 scrapy 中使用 splash，具体安装步骤[官网](https://github.com/scrapy-plugins/scrapy-splash)已经很详细在此不做赘述。\n\n## Scrapinghub\n\nScrapinghub 是一个基于 scrapy 的云服务，可以将自己的爬虫部署到该平台。[这里](https://support.scrapinghub.com/support/solutions/articles/22000200667-running-a-scrapy-spider)有个工具可以帮助部署（当然通过链接 GitHub 可以做到 master 部署）。\n\n```shell\npip install shub\n```\n\n### 解决依赖\n\n爬虫上传到 Scrapinghub 之后，会部署失败，可能源于以下两点。\n\n- scrapinghub 使用的是 python2\n- 部份依赖没有安装\n\n以上两点可以通过修改 scrapinghub.yml 完成\n\n```yaml\nprojects:\n  default: 427692\nstacks:\n  default: scrapy:1.8-py3\nrequirements:\n  file: requirements.txt\n```\n\n通过`pip freeze`能够列举出目前环境下的所有包，需要挑出可能缺少的依赖写在 requirements.txt 里面（没错这一步只能人工完成，不要妄想把所有包都写进去）。\n\n```\nbeautifulsoup4==4.8.2\nfeedparser===5.2.1\nscrapy-splash==0.7.2\n```\n\n## 单元测试\n\n使用 python 自带的 unittest 模块以及 pytest 可以对代码进行单元测试。可以参考我代码中的[测试](https://github.com/gongbaodd/webScrapingStudy/tree/master/test/test_spider)。\n\n执行 pytest 的时候会出现找不到模块的问题，可以按照如下方式重置根地址位置。\n\n```\npython -m pytest [file path]\n```\n\n## 代码优化和格式化\n\n这里比较爽了，如果用的是 vscode，在第一次格式化代码的时候，vscode 就会安装格式化工具。\n\n## pre-commit\n\npre-commit 是一个 git 钩子工具，简单说，当本地代码不满足要求的时候，利用这个工具自动格式化代码或者阻止用户提交代码。可以参考[官网配置](https://pre-commit.com/)。\n\n## 包健康检查\n\n目前没在 python 找到一个类似于 yarn audit 的东西，到那时找到了一个[SNYK](https://snyk.io)是一个跨语言的包健康检查工具，但是貌似还有 bug，暂时先裸奔好了。\n\n## 持续集成\n\n目前我是用 Travis 做集成，配置文件可参考[此文件](https://github.com/gongbaodd/webScrapingStudy/blob/master/.travis.yml)。\n\n## 兼容性处理\n\n另外还找到一个 python 版本兼容测试工具，考虑到使用 python 命令的人自己的 python 版本并不确定，[tox](https://pypi.org/project/tox/)则是用来测试 py 是否兼容某些 python 的版本。\n","collection":"blog","data":{"type":"post","category":"tech","tag":["scrapy","python"]}},{"id":"2020/02/06/git-CRLF-LF.md","slug":"2020/02/06/git-crlf-lf","body":"\n# Git 中的 CRLF 和 LF\n\n跨平台开发的时候，如果是在 Windows 下面上传代码，git 会提醒部分文本文件的 CRLF 会改为 LF。\n\n原因是在 Windows 下面，文本文件会以 CRLF（回车换行）结尾，而 Linux 和 Mac 会以 LF（换行）结尾。其实想想打字机，回车换行是一个正确的做法，但是为了保持兼容性，git 会把 Windows 上传的 CRLF 都改成 LF。\n\n如果只在 Windows 下面开发，可以关掉这个功能。\n\n```shell\ngit config --global core.autocrlf false\n```\n","collection":"blog","data":{"type":"post","category":"tech","tag":["git"]}},{"id":"2020/02/09/1917.md","slug":"2020/02/09/1917","body":"\n# 电影补档计划：1917\n\n![1917](https://img1.doubanio.com/view/photo/l/public/p2570243317.webp)\n\n一战时期英国两名士兵接到命令去前线停止一场冲进圈套的进攻的故事。\n\n故事肯定是比较感人了，长镜头的运用说实话，如果没有对比，完全没意识出来...\n","collection":"blog","data":{"type":"post","category":"movie"}},{"id":"2020/02/10/actix-web-rust-web.md","slug":"2020/02/10/actix-web-rust-web","body":"\n# 利用 actix_web 使用 rust 编写 web 应用\n\n最近我一直在实践 rust 相关的内容，本来想写一篇类似于[scrapy 的文章](http://gongbaodd.github.io/tech/2020/02/04/Windows%E4%B8%8A%E4%BD%BF%E7%94%A8scrapy%E7%88%AC%E7%BD%91%E9%A1%B5.html)，后来发现内容有点多，仅仅一篇文章兜不住，干脆写一个系列好了。\n\n## 使用 Rust 的工具\n\n### rustup\n\n使用 chocolatey 安装，安装好以后只是处理好了 rustup，后面的工具链还要用再次处理。\n\n```shell\nchoco install rust\n```\n\n关于 rustup 的使用，可以查看[文档](https://github.com/rust-lang/rustup/blob/master/README.md)，包括如何做交叉编译都可以使用这个工具完成。\n\n```shell\nrustup toolchain install stable-msvc\n```\n\n### crates.io\n\n[crates.io](https://crates.io/) 是 rust 的模块库，没啥可说的。\n\n### cargo\n\ncargo 是 rust 的包管理工具。以下是几个 cargo 经常使用的命令。\n\n- `cargo new [project name]`，新建一个项目。\n- `cargo init`，初始化一个项目。\n- `cargo clean`，清理编译文件（相信我，这个会经常用）。\n- `cargo run`，编译并运行 main 文件。\n- `cargo run --bin [helper file name]`，直接执行 bin 文件夹下的文件。\n- `cargo build`，编译文件。\n- `cargo install [tools name]`，安装工具。\n\n### cargo-edit\n\n执行`cargo init`之后，项目根目录会生成一个`Cargo.toml`文件本项目的依赖模块都会放到这里，然而手动编写这个文件对于像我这样的懒人显然是无法接受的。因此可以借助`cargo-edit`完成。\n\n```shell\ncargo install cargo-edit\n```\n\n记住`cargo-edit`如下命令即可。\n\n- `cargo add [module name]` 安装一个模块。\n- `cargo rm [module name]` 删除一个模块。\n\n## rust 项目结构\n\n```shell\n- Cargo.toml\n- Cargo.lock\n- src\n-- main.rs # 项目入口文件\n-- lib.rs # 如果作为封装成一个crate，这里配置可以暴露的模块\n-- bin/ # 项目工具文件\n--- helper.rs\n```\n\n## 语法速记\n\n### 函数\n\nrust 的函数还比较有趣，它的`return`关键字是默认省略的，如果这个函数没有中断，这个函数的最后一行就是返回值，且这一行不带分号。\n\n```rust\npub async fn index() -> impl Responder {\n    format!(\"hello\")\n}\n```\n\n如果这个函数没写返回值，其实编译器还会让这个函数返回一个`()`。\n\n```rust\nfn main() {\n    println!(\"hello world\");\n    () // 此处不加()编译器还是会默认理解为返回()。\n}\n```\n\n这么做确实比较符合函数编程的概念，但是一般 rust 库里面的函数都会返回 Result 或者 Option 类型，就用 Result 类型做例子，一般会有四种处理方式。\n\n```rust\nlet bar = foo().expect(\"Panic!\"); // 直接中断程序\nlet bar = match foo() {\n    Ok(value) => Some(value),\n    Err(_) => Some(someError)\n}; // 通过match判断处理错误， 类似于其他语言的switch-case\nlet bar = foo()?; // 把错误处理交给bar\nlet bar = foo().unwrap_or(); // 成功返回成功值，失败返回unwrap_or的值\n```\n\n### 模块\n\n通常想要使用一个模块，只需要使用`use`关键字。\n\n```rust\nuse std::env;\n\nfn main() {\n    let db_url = match env::var(\"DB_URL\") {\n        Ok(_) => { \"OK\".to_owned() }\n        Err(_) => { \"Err\".to_owned() }\n    };\n\n    println!(\"{}\", db_url);\n}\n```\n\n如果引用的这个包是个非 rust 标准包（一个 crate，这里说的是我的理解，如果有个官方中文说法，以它为准），需要在添加`extern crate`关键字，如果还引用了宏，还要加上`#[macro_use]`（这就比较坑了，我哪知道到底用没用上宏，所以一般我都靠编辑器帮我编译一下...）。\n\n```rust\n#[macro_use]\nextern crate log;\n\nfn main() {\n    info!(\"debug\")\n}\n```\n\n如果只是引用本项目相对地址的文件，使用`mod`关键字就好，可以看我的[actix_log](https://github.com/gongbaodd/rust_webAssembly_study/tree/master/actix_log)。\n\n#### 为啥 rust 的模块这么复杂\n\n我猜测毕竟 rust 是对标 C 语言的，相比于很多高级语言的链接工作是在虚拟机里面做的，rust 则全部下放到语言里面，所以一起用起来就会比较复杂。\n\n## trait\n\ntrait 是 rust 上面的一个新概念，类似于 JS 的 mixin 和 Java 的接口，后面我会按例子来讲。\n\n很多库的 trait 需要单独引用，否则会编译失败，这些库往往会封装成一个 prelude 使用。\n\n```rust\nuse gtk::prelude::*;\n```\n\n## rust command\n\nrust 是个系统级语言，可以互相访问其他程序语言分享的堆内存空间，FFI 依靠的是 Box，但是本篇暂时不提及，这个[代码](https://github.com/gongbaodd/rust_webAssembly_study/tree/master/command)实现的是读取并处理其它语言的 std 输出。\n\n## Actix_web\n\n[actix-web](https://actix.rs/)是 Rust 的 web 框架之一，试用了一下，很好上手，有一点 Express 的味道。\n\n```shell\ncargo add actix-web\ncargo add actix_rt\n```\n\n官网首页的例子即是一个简单的应用。\n\n```rust\nuse actix::{\n    web,\n    App,\n    HttpServer,\n    Responder,\n    HttpRequest,\n};\n\nasync fn greet(req: HttpRequest) -> impl Responder {\n    let name = req.match_info()\n        .get(\"name\")\n        .unwrap_or(\"World\");\n\n    format!(\"Hello {}!\", name)\n}\n\n#[actix_rt]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new(\n        || {\n            App::new()\n                .route(\"/\", web::get().to(greet))\n                .route(\"/{name}\", web::get().to(greet))\n        }\n    )\n    .bind(\"127.0.0.1:8080\")?\n    .run()\n    .await\n}\n\n```\n\n当然，如果觉得路由的部分比较难写，还可以使用宏来修改。\n\n```rust\n#[get(\"/\")]\nasync fn greet(req: HttpRequest) -> impl Responder {\n    let name = req.match_info()\n        .get(\"name\")\n        .unwrap_or(\"World\");\n\n    format!(\"Hello {}!\", name)\n}\n\nApp::new().route(greet);\n```\n\n### 利用中间件处理日志和错误\n\nlog 和 env_logger 是 rust 的日志工具，基本上都是宏。\n\n```\ncargo add log\ncargo add env_logger\n```\n\nactix-web 使用 wrap 方法添加中间件，如添加 Logger 打出标准访问日志。\n\n```rust\nuse actix_web::middleware::Logger;\nasync fn main() -> std::io::Result<()> {\n    std::env::set_var(\"RUST_LOG\", \"actix_web=info,info\");\n    env_logger::init();\n\n    let url = \"127.0.0.1:8080\";\n    let app = || {\n        App::new()\n            .wrap(Logger::default())\n            .wrap(Logger::new(\"%a %{User-Agent}i\"))\n            .wrap(middleware::DefaultHeaders::new().header(\"X-Version\", \"0.2\"))\n            .wrap(ErrorHandlers::new().handler(http::StatusCode::INTERNAL_SERVER_ERROR, render_500))\n            .service(routes::index::index)\n    };\n\n    let server = HttpServer::new(app).bind(url);\n    let wait_server = server?.run();\n\n    info!(\"Running Server on {}\", url);\n    wait_server.await\n}\n```\n\n错误处理，详细代码可以查看[actix-log](https://github.com/gongbaodd/rust_webAssembly_study/tree/master/actix_log)。\n\n```rust\nfn render_500<B>(mut res: dev::ServiceResponse<B>) -> Result<ErrorHandlerResponse<B>> {\n    res.response_mut().headers_mut().insert(\n        http::header::CONTENT_TYPE,\n        http::HeaderValue::from_static(\"Error\"),\n    );\n    Ok(ErrorHandlerResponse::Response(res))\n}\n```\n\n### 使用 serde 返回 JSON\n\n想要制作 Restful API，JSON 支持是少不了的。\n\n```shell\ncargo add serde\n```\n\n由于 actix-web 对路由回应格式的支持，一个 json 文件可以这么写。\n\n```rust\nuse acrix_web:{\n    HttpResponse,\n    Responder,\n    get,\n};\nuse serde::{\n    Serialize,\n    Deserialize,\n};\n\n#[derive(Serialize, Deserialize)]\nstruct MyObj {\n    message: String,\n}\n\n#[get(\"/hello\")]\nasync fn hello() -> impl Responder {\n    HttpResponse::Ok().json(MyObj {\n        message: \"SUCCESS\"\n    })\n}\n\n```\n\n更多详细的代码可以查看我的[github](https://github.com/gongbaodd/rust_webAssembly_study/tree/master/actixweb)。\n\n## diesel 处理 ORM(sqlite)\n\n强烈安利大家去看一下 diesel 的[Get Start](http://diesel.rs/guides/getting-started/)，确实是一种下一代 ORM 的感觉。\n\n```shell\ncargo add diesel\n```\n\n### diesel_cli\n\ndiesel_cli 是 diesel 的命令行工具，提供数据部署和 schema 生成的功能，如果不指定 feature 的话，安装时会同时编译 sqlite、postgreSQL 以及 MySQL。\n\n```shell\ncargo install diesel_cli --no-default-features --features sqlite\n```\n\n第一次编译的时候，在 Windows 下面失败了，翻了一下[issue](https://github.com/diesel-rs/diesel/issues/487)找到了解决方案。\n\n首先安装 Visual Studio（反正现在免费安），使用 VS 的终端打开 sqlite 文件夹。\n\n```batch\ncd C:\\ProgramData\\chocolatey\\lib\\SQLite\\tools\nlib /def:sqlite3.def /out:sqlite3.lib\n```\n\n然后记得把`C:\\ProgramData\\chocolatey\\lib\\SQLite\\tools`放到环境变量 PATH 里面。\n\n再次编译即可，具体如何使用 diesel 的 get start 已经足够了，在此不做赘述，可以查看[源码](https://github.com/gongbaodd/rust_webAssembly_study/tree/master/diesel_demo)。\n\n这里列举一下经常用的命令\n\n- `diesel setup` 初始化。\n- `diesel migration generate [step name]` 生成 down.sql 和 up.sql。\n- `diesel migration run` 按照 SQL 文件部署数据库和 schema 文件（目前发现一个 bug，生成的 schema 不完全，没能完全复现）。\n- `diesel migration revert` 撤回数据库操作。\n\n### 补充一下 rust 语法里面的生命周期\n\ndemo 里面的 lib 文件 create_post 语法很奇怪。\n\n```rust\npub fn create_post<'a>(conn: &SqliteConnection, title: &'a str, body: &'a str) -> usize {\n    use schema::posts;\n\n    let new_post = NewPost {\n        title: title,\n        body: body,\n    };\n\n    diesel::insert_into(posts::table)\n        .values(&new_post)\n        .execute(conn)\n        .expect(\"Error saving new post\")\n}\n```\n\n`<'a>`的写法是指明函数的生命周期标注，因为 rust 没有垃圾回收机制，所有申请的堆内存在一个函数执行结束后就会回收。所以当一个函数的输入值是堆内存的变量，就发生「借用」，如这个函数里面的三个参数，借用都用`&`来标注。\n\n假设一个变量借出给另一个函数，而在借用变量的函数执行阶段借出函数就结束并销毁变量，程序就会出错，因此生命周期就是用来确定一个借出的变量必须还回后才能被销毁。默认 rust 都会给一个生命周期，然而当出现两个以上生命周期时，如`create_post`则需要程序员指定参数必须在一个生命周期内。\n\n## juniper 实现 graphql\n\n写一个 Query 的方法\n\n```rust\n#[derive(juniper::GraphQLObject)]\nstruct MyObj {\n    name: String,\n}\n\nstruct QueryRoot;\n#[derive(juniper::object)]\nimpl QueryRoot {\n    fn myObj() -> juniper::FieldResult {\n        Ok(MyObj {\n            name: \"World\"\n        })\n    }\n}\n```\n\nMutation 也类似，基本很简单，可以查看[代码](https://github.com/gongbaodd/rust_webAssembly_study/blob/master/graphql_only)了解。\n\n### rust 语法里面闭包里面 move 的使用\n\n前面说过，如果一个函数想调用另一个函数的堆内存，可以借用。但是还有另一种函数，闭包，理论上闭包可以处理闭包所在词法作用域下的所有变量。在动态执行时如果闭包中依赖的一个变量已经销毁也是很危险的事儿，所以这里可以用 move 关键字将变量所有权交给闭包，在闭包外则无权再次处理已经 move 的变量。\n\n```rust\nasync fn main() -> io::Result<()> {\n    let schema = std::sync::Arc::new(create_schema());\n\n    let app = move || {\n        App::new()\n            .data(schema.clone())\n            .wrap(middleware::Logger::default())\n            .service(graphql)\n            .service(graphiql)\n    };\n\n    HttpServer::new(app)\n        .bind(\"127.0.0.1:8080\")?\n        .run()\n        .await\n}\n```\n\n当然 graphql 的代码里面还有 RC 和 ARC 的概念，现在暂时了解他们时 Rust 下面的引用计数的一种实现，RC 用于单线程，ARC 用于多线程。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["rust","actix_web"]}},{"id":"2020/02/11/Movie-supplementary-plan-Hollywood-past.md","slug":"2020/02/11/movie-supplementary-plan-hollywood-past","body":"\n# 电影补档计划：好莱坞往事\n\n![Once upon a time in Hollywood](https://img1.doubanio.com/view/photo/l/public/p2571312408.webp)\n\n全片只看最后面半个小时，就是一部完美的电影。然而必须要看完前面两个小时冗长而又莫名其妙的故事（毕竟我对好莱坞的历史一无所知，所有格梗都看不出来）。\n\n大概故事是一个刚有起色的电视演员带着他的替身去好莱坞找电影工作，却发现西部电影已经不再受欢迎，演员住在很多著名演员附近，想借他们一步登天。\n\n有制片人看到演员的戏感到有趣，邀请他去意大利拍西部电影。在意大利抱得美人的演员在回程时提出因为西部电影不再受欢迎，以后不会在和替身合作。\n\n当天晚上，演员在泳池游泳，替身在客厅吸毒，演员妻子还在我是倒时差。一群嬉皮士闯入，造成一片混乱。\n\n混乱引起演员邻居注意，演员因此结实各种名流。\n","collection":"blog","data":{"type":"post","category":"movie"}},{"id":"2020/02/12/Windows-Rust-GTK.md","slug":"2020/02/12/windows-rust-gtk","body":"\n# Windows 下为 Rust 提供 GTK 环境\n\nWindows 下面安装 GTK 环境有两种方法，借助 msys2 的 linux 环境，或者借助 VCPKG 安装 Windows 的 GTK 依赖。\n\n尝试了一下，msys2 并没有成功，只能使用 VCPKG，参考[gnome 编译指南](https://www.gtk.org/download/windows.php)。\n\n```batch\ngit clone https://github.com/Microsoft/vcpkg\ncd vcpkg\n.\\bootstrap-vcpkg.bat\nvcpkg install gtk:x64-windows\n```\n\n安装的时候发现不能编译成功，此时需要祭出 Visual Studio 大法，找到 Visual Studio Installer，安装 C 工具链，再重新执行上面的代码即可。\n\n然后再环境变量中增加`GTK_LIB_BASE`值为`c:\\MyWorks\\github\\vcpkg\\installed\\x64-windows\\lib`(就是 vcpkg 下载依赖包的位置)\n\n环境变量中的 PATH 的第一个值也要配上`c:\\MyWorks\\github\\vcpkg\\installed\\x64-windows\\bin`。\n\n如果 rust 项目还编译不成功，尝试将 vcpkg 里面的/lib/gdk-3.lib 和/lib/gtk-3.lib 连接到/lib/gdk-3.0.lib 和/lib/gtk-3.0.lib，bin 文件夹下的 dll 文件也一样处理。\n\n再次运行`cargo run`即可，[相关代码](https://github.com/gongbaodd/rust_webAssembly_study/tree/master/rust_gtk)。\n\n最初想试一下 rust-gtk 的原因是，想试试这个跨平台框架如何，但是在 Windows 下面效果并不怎么样，而且还有 HIDPI 的问题，Reddit 里面讨论感觉 gtk 这边也没有很着力于 rust，所以对 GTK 的探究就暂时到此为止了。\n","collection":"blog","data":{"type":"post","category":"tech","tag":["rust","gtk"]}},{"id":"2020/02/13/Windows-Rust-QT.md","slug":"2020/02/13/windows-rust-qt","body":"\n# Windows 下为 Rust 提供 QT 环境（弃）\n\nQT 的部署要比 GTK 容易一些，然而由于最近我的机场流量用尽，所以最大的困难就是网络。\n\n参考[Rust-qt](https://github.com/rust-qt/examples)，有比较详细的环境配置。需要下载完整的[Qt 安装包](https://www.qt.io/download)和[Visual Studio 2017](https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15)（最好用 2017，能少踩不少坑）。\n\n安装成功后，在环境变量 PATH 里面增加`C:\\Qt\\Qt5.14.1\\5.14.1\\msvc2017_64\\bin`然后找到 VS2017 的命令行，只有这个命令行能准确编译 QT5。\n\n虽然按照 Rust-qt 的做法，C++的 QT 可以完美运行，但是编译的时候要使用 gcc，所以还是要安装 msys2，而且对 QT 要求的版本也比较苛刻，因此我决定就此放弃 QT（即使 QT 已经能跑在 web-assembly 上面了）。\n\n## Rust 相关的 UI 框架\n\n其实还有一篇文章关于 Rust 的 UI 编程的，可以查看[这篇文章](https://gitlab.com/bloom42/research/rust_gui_ecosystem)。\n","collection":"blog","data":{"type":"post","category":"tech","tag":["rust","qt"]}},{"id":"2020/02/14/Movie-supplementary-plan-Qiao-Qiao-Rabbit.md","slug":"2020/02/14/movie-supplementary-plan-qiao-qiao-rabbit","body":"\n# 电影补档计划：乔乔兔\n\n![jojo rabbit](https://img3.doubanio.com/view/photo/l/public/p2567973073.webp)\n\n乔乔是个小纳粹热爱者，参加童子兵的时候因为不忍心杀死兔子被同伴嘲笑为乔乔兔，因为不小心被炸伤而不能参加二战。\n\n在家休养的乔乔发现家里躲着一个犹太女孩，担心自己和母亲被连累，他没有告发这个女孩。随着互相了解，乔乔逐渐喜欢上这个女孩。乔乔发现母亲其实暗中参与阻止纳粹活动，并被杀害。随着德军战败，乔乔重回家里找到躲着的犹太女孩，并战胜心中臆想的希特勒。\n\n很温暖的喜剧，适合一家看，特适合在家隔离的时候看。\n","collection":"blog","data":{"type":"post","category":"movie"}},{"id":"2020/02/14/Movie-supplementary-program-marriage-story.md","slug":"2020/02/14/movie-supplementary-program-marriage-story","body":"\n# 电影补档计划：婚姻故事\n\n![Marriage Story](https://img1.doubanio.com/view/photo/l/public/p2571760178.webp)\n\n开罗人和寡姐的离婚故事。\n\n开罗人和寡姐和儿子住在纽约，寡姐发现开罗人有外遇，要离婚，带孩子去 LA，开罗人去索要抚养权。\n\n一个开始让人惧怕离婚，后来让人惧怕婚姻的剧。\n","collection":"blog","data":{"type":"post","category":"movie"}},{"id":"2020/02/15/Github.md","slug":"2020/02/15/github","body":"\n# Github 项目徽章地址\n\n在https://shields.io/可以为Github项目添加徽章。\n","collection":"blog","data":{"type":"post","category":"tech","tag":["github"]}},{"id":"2020/02/15/Movie-supplement-plan-sharp-blade-out-of-the-sheath.md","slug":"2020/02/15/movie-supplement-plan-sharp-blade-out-of-the-sheath","body":"\n# 电影补档计划：利刃出鞘\n\n![Knives out](https://img9.doubanio.com/view/photo/l/public/p2575381156.webp)\n\n双男主海报一出来就知道谁是凶手了。\n\n一个富豪老爷生日晚上，护士误将吗啡打错剂量，却找不到解药，老爷通过制造自杀现场保护护士。宣读遗书时众人得知老爷将财产全部转交给护士。但其实护士并没有打错药，老爷的孙子偷偷的把药物对调，并将罪行陷害给护士。最终在侦探观察下，真相大白。\n\n基本上看的是演员的演技，画面也很精致。\n","collection":"blog","data":{"type":"post","category":"movie"}},{"id":"2020/02/17/Movie-supplementary-program-time-and-space-love-traveler.md","slug":"2020/02/17/movie-supplementary-program-time-and-space-love-traveler","body":"\n# 电影补档计划：时空恋旅人\n\n![about time](https://img9.doubanio.com/view/photo/l/public/p2070153774.webp)\n\n男主 21 岁的时候从父亲那里得知家族的男性有回到过去的能力，男主利用这个能力去追初恋，却没能成功。男主又利用这个能力挽救了一场演出的灾难以帮助他的朋友，却错失自己的真爱。经过努力，男主又找回真爱，结婚生子。\n\n男主妹妹婚姻不幸福，吵架后发生车祸。男主为了拯救妹妹的婚姻回到过去，妹妹的婚姻被拯救了，可是也影响到自己的孩子。男主只能回到妹妹车祸后，教会妹妹放弃这场婚姻重新开始。\n\n男主父亲癌症去世，父亲告诉男主，可以尝试平凡度过一天，然后利用这个能力再重新来过一次。\n","collection":"blog","data":{"type":"post","category":"movie"}},{"id":"2020/02/21/Windows-flutter.md","slug":"2020/02/21/windows-flutter","body":"\n# Windows 安装 flutter 开发环境\n\n从 chocolatey 可以直接安装 flutter。\n\n```shell\nsudo choco install flutter\n```\n\n运行成功后可以运行`flutter doctor`检查环境是否完备，比如我会有`X Android license status unknown.`报错，可以运行以下命令检查详情。\n\n```shell\nflutter doctor --android-licenses\n```\n\n发现 SDK 管理的问题，进而发现要把 JDK 降级到 8.0，好在有 chocolatey，很快就解决了。\n\n```shell\nsudo choco install ojdkbuild8\n```\n\n然后修改.bashrc 设置代理\n\n```shell\nexport HTTP_PROXY=127.0.0.1:1080\nexport HTTPS_PROXY=127.0.0.1:1080\nexport NO_PROXY=127.0.0.1,localhost\n```\n\n打开 VScode，安装 flutter，打开命令面板输入`flutter new`，就可以创建工程了（然后下载了巨多文件，感觉如果写个 hello world 都要加载这么多文件真是比较坑）。\n\n打开模拟器，在 VSCode 里面按 F5 就能实时 debug 了。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["flutter","dart"]}},{"id":"2020/02/22/Windows-strokesPlus.md","slug":"2020/02/22/windows-strokesplus","body":"\n# 分享一个 Windows 下面的鼠标手势工具 StrokesPlus\n\n我终于还是妥协了，在使用 windows 的情况下最好还是配备一个鼠标。尤其是当你在编程的时候。并不是说触摸屏不好，在很多时候，触摸屏可以在可以帮你记录一些东西。比如让你写一些算法的时候，你可以在旁边画一画。\n\n但是不得不说，编辑器就像 VS code。他对触摸屏的交互其实是很反人类的。另外由于我现在是三台设备。所以我的键盘是同时连着三台设备。。这说明当我要操作我的笔记本的时候，身体要跨过两个键盘的距离。这个动作幅度是比较大的。\n\n所以我在网上买了这个科大讯飞的鼠标，他有一个最大的好处就是，我可以说话打字。这样我就不需要操作键盘了。但是 windows 上面还有另外一个问题，就是鼠标，还有触摸屏和触摸板，三者都没有统一的交互体验。所以我又安装了这个鼠标手势工具。\n\nStrokesPlus 安装很简单，依然使用的是 chocolatey。\n\n```shell\nsudo choco install strokesplus\n```\n\n其实我的需求很简单，就是需要鼠标手势来操作切换桌面。安装好 strokePlus，打开 action 菜单即可添加手势。\n\n- @：代表\"Win\"键\n- +：代表“Shift”键\n- ^：代表“Ctrl”键\n- %：代表“Alt”键\n\n如进入右边桌面的命令为`acSendKeys(\"^@{RIGHT}\")`。\n\n添加\n\n- `acSendKeys(\"^@{RIGHT}\")` 进入右桌面\n- `acSendKeys(\"^@{LEFT}\")` 进入左桌面\n- `acSendKeys(\"@{TAB}\")` 全部桌面\n\n配合 GestureSign，终于触摸屏，触摸板和鼠标手势统一了。\n","collection":"blog","data":{"type":"post","category":"tech","tag":["windows"],"series":{"slug":"windows-howto","name":"Windows舒适指南"}}},{"id":"2020/02/22/hoisting.md","slug":"2020/02/22/hoisting","body":"\n# 我也谈谈 hoisting\n\n最近在看 getify 的[You-Dont-Know-JS](https://github.com/getify/You-Dont-Know-JS)，第二版里面相对于第一版增加了很多个人认为比较硬核的东西。第二版貌似对 var 关键字进行了洗白，就目前来看还是比较争议的，毕竟这几年来我基本上已经用 let 完全替代 var 了。\n\n最近我正好是在学习 Rust，首先说明一下 Rust 的确是一个不太好学习的语言，但是学会了之后就会对编译原理有更高更深一层次的认识（同样学会了 typescript，也会有类似的感觉）。\n\n那也许是时代的问题。人们发现面向对象并不是万能的，面向函数逐渐的从原来不受人注意，变的受人理解。尤其是最近我还跟一些人在讨论到一些面向对象的继承属性。以后的以后的继承，将逐渐被组合所替代。甚至是 rust，里面已经没有了继承关系。而最受欢迎的前端框架 react 框架也逐渐的使用函数来替代对象。\n\n那么我们现在回顾一下，2015 年，那年 TC39 发布了 ECMA2015，包括块级作用域，let，class 等关键字。当时 JavaScript 的作者，Brendan Eich 就说他不赞成这个对象的设计，但是显然很多人没有理解，当然后来还发生了关于 class 成员是否跟分号的 bug。\n\n那么现在我们把当年的事情再拿出来看一看。Hoisting 这个 JavaScript 独有的特性，是不是一个鸡肋的 bug。\n\n参考 BrendanEich 老爷子自己的[话](https://twitter.com/brendaneich/status/562313394431078400)\n\n> function declaration hoisting is for mutual recursion & generally to avoid painful bottom-up ML-like order\n\n> `var` hoisting was an implementation artifact. `function` hoisting was better motivated.\n\n首先是 ML 这个语言呢也是一个基于函数的语言。但是跟 js 不太一样的是，这个语言就没有 hoisting，所以呢，看代码就只能是一行一行的看下去，比较麻烦。\n\n至于 var 的提升，则是实现 function 带来的人工产物。\n\n想一想 2015 年之前我们写前端 js 代码的时候，往往会把依赖的 function 放到最底下。\n\n```javascript\nfunction foo() {\n  bar1();\n  bar2();\n  bar3();\n\n  return;\n\n  function bar1() {}\n\n  function bar2() {}\n\n  function bar3() {}\n}\n```\n\n其实就像你现在这个角度来观察这个代码，也会觉得。这个语言的确有它的独到之处。这样的写法，直接通过 return 关键字，把一个函数分成了构造函数部分和他的私有成员。如果想要了解这个函数的功能的话，大可不必把所有的函数都看一遍。\n\n自从有了块级作用域，JavaScript 就必须要考虑，同时存在块级作用域和函数作用域的情况，就出现了 TDZ 的情况。简单讲就是说，就是块级作用域，变量不能被重复声明，即使是使用函数声明，而以前的 var 关键字是可以重新定义的（当然重新定义的时候没有重新赋值，因为提升的关系重新定义，并不存在）。\n\n```javascript\n{\n  let foo = \"foo\";\n  var foo; // wrong\n}\n```\n\n```javascript\n{\n  var foo = \"foo\";\n  let foo; // wrong\n}\n```\n\n那么块级作用域有没有提升呢？那肯定是有的，因为如果你想判断这个作用域下面的变量是不是被重新定义了，还是要预先申请内存的。只不过在他声明之前被使用的话，相比于函数变量返回未定义的值，块级作用域会报错。\n\n所以我们一般会把块级作用域变量定义放在这个块儿的最上面，来消除 TDZ。\n\n但是把定义放在最上面的话，就如之前所说的失去了 JavaScript 初衷的优雅。所以 function 和 var 关键字并不一定被宣判死刑，而是在特定的情况下还能被拿出来使用。\n\n不过，话说回来，优雅的东西不一定就是所有人喜欢的。块级作用域对 C 语言使用者来说没有学习障碍，工程上还是少数服从多数，选择最简单的而不是选择最对也存在合理性，所以即使现在面向对象逐渐失宠也不一定将来也会被摒弃。\n\n另外，Eich 和 Crockford 还有一篇访谈，可以看一下。\n\n[Eich and Crockford on the Future of JavaScript: Insight from the Creators of JavaScript and JSON](https://www.infoq.com/news/2018/07/eich-crockford-js-future/)\n","collection":"blog","data":{"type":"post","category":"fe","tag":["JavaScript"]}},{"id":"2020/02/23/Mouse-without-borders.md","slug":"2020/02/23/mouse-without-borders","body":"\n# Mouse without borders 让鼠标同时连接 4 台 PC\n\n既然已经给我的 PC 买上了鼠标，那我肯定希望，三台 PC 能够共用这一个鼠标。在网上查询了一下，发现需要这个需求的人不止我一个。所以微软有一个项目叫做[mouse without border](https://www.microsoft.com/en-us/download/details.aspx?id=35460)。\n\n只要三台设备在同一个域下，我就可以通过这一个软件，让三台设备共享鼠标。\n\n今天忙活了半天这个软件，主要是自如的 wifi 5GHz 设置了防火墙，但是 2.4GHz 没有...所以只要有一台设备连接的是 2.4G 赫兹的网络。就可以进入内网，跟其他的设备交互共享鼠标了。\n","collection":"blog","data":{"type":"post","category":"tech","tag":["windows"],"series":{"slug":"windows-howto","name":"Windows舒适指南"}}},{"id":"2020/02/25/stryker-mutation test.md","slug":"2020/02/25/stryker-mutation-test","body":"\n# 使用 stryker 做 mutation test\n\n今年年初的时候，我整理了一下前端测试现状，有一项就是 mutation test。本文将会讲一下如何给 typescript 项目添加 mutation test。\n\n## Stryker-mutator\n\n首先，为项目安装 stryker 全家桶。\n\n```shell\nyarn add -D stryker-typescript stryker-jest-runner stryker-html-reporter stryker-api stryker\n```\n\n你可能会接到升级的警告，我发现最新版本（以@stryker-mutator 做域）会有 bug，而且 github 上面显示 CI 编译失败，保守起见，还是使用老版本比较好。\n\n执行`yarn stryker init`初始化项目，修改 stryker.conf.js，详细的参数说明可以参考[这里](https://github.com/stryker-mutator/stryker/tree/master/packages/core)。\n\n```javascript\nmodule.exports = function stryker(config) {\n  config.set({\n    mutator: \"typescript\",\n    mutate: [\"src/linked_node/**/*.ts\", \"!src/**/*.spec.ts\"],\n    packageManager: \"yarn\",\n    reporters: [\"clear-text\", \"dashboard\", \"progress\", \"html\"],\n    testRunner: \"jest\",\n    coverageAnalysis: \"off\",\n    tsconfigFile: \"tsconfig.json\",\n    dashboard: {\n      reportType: \"full\",\n    },\n  });\n};\n```\n\n注意，官网的 tutorial 会要求添加 transpilor 为 typescript，这里因为我们的测试 runner 是已经配置好的 jest，所以不能再添加一次编译。\n\n执行`yarn stryker run`就能执行测试，这个测试很占用性能，我这 10 代 i7 的本都要跑 8 分钟左右，执行成功会生成报告存储在 reports 文件夹下。\n\n## 配置 travis\n\nstryker 官方提供[dashboard](https://dashboard.stryker-mutator.io)，登入配置好环境变量即可生成 stryker 的徽章，可以把它贴到 github 的 readme 中。这样，每次 travis 执行好 mutation test 后都能更新徽章分数。\n\n关于 dashboard 如何配置可以参考[handbook](https://github.com/stryker-mutator/stryker-handbook/blob/master/dashboard.md)。\n\n但是我没能成功上传 report，只能显示出分数，并不确定哪里出了问题，还是看官方如何更新吧。\n\n## 原理\n\n如果我有以下函数，并配合 100%测试覆盖的单元测试。\n\n```typescript\nfunction isGe18(num: number) {\n  return num >= 18;\n}\n\ndescribe(\"the input is 1\", () => {\n  it(\"should return false\", () => {\n    expect(isGe18(1)).toBe(false);\n  });\n});\n```\n\n显然以上的测试是不完备的，那么 stryker 如何找到它不完备的地方？首先修改函数的返回值，如生成如下四个函数。\n\n```typescript\nfunction isGe18_1(num: number) {\n  return num > 18;\n}\nfunction isGe18_2(num: number) {\n  return num < 18;\n}\nfunction isGe18_3(num: number) {\n  return true;\n}\nfunction isGe18_3(num: number) {\n  return false;\n}\n```\n\n分别用他们重新跑测试，只要有一个测试失败，就称这个 mutate 被 killed，如果测试全部通过，则称 mutate 被 survived。\n则对应上面例子：\n\n- isGe18_1 => survived\n- isGe18_2 => killed\n- isGe18_3 => killed\n- isGe18_3 => survived\n\n则此时需要增加测试\n\n```typescript\ndescribe(\"the input is 19\", () => {\n  it(\"should return true\", () => {\n    expect(isGe18(19)).toBe(true);\n  });\n});\n\ndescribe(\"the input is 18\", () => {\n  it(\"should return true\", () => {\n    expect(isGe18(18)).toBe(true);\n  });\n});\n```\n\n重新跑测试\n\n- isGe18_1 => killed（最后一个测试未通过）\n- isGe18_2 => killed\n- isGe18_3 => killed\n- isGe18_3 => killed（新增加的 2 个测试未通过）\n\n此时测试才是完备的。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["test","stryker","javascript"]}},{"id":"2020/02/26/WSL-ruby.md","slug":"2020/02/26/wsl-ruby","body":"\n# WSL 安装 ruby 环境\n\n虽然我这个博客是基于 jekyll 的，但是因为国内整 ruby 的环境实在痛苦，但是最近不得不又重新搞起来了，只能在这里记录一下。\n\n首先安装环境\n\n```shell\nsudo apt install ruby ruby-dev build-essential\n```\n\n然后修改 gem 的环境变量\n\n```shell\nexport GEM_HOME=$HOME/gems\nexport PATH=$HOME/gems/bin:$PATH\n```\n\n修改 source 为 ruby-china\n\n```shell\ngem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/\n```\n\n接着安装 jekyll 即可\n\n```shell\ngem install jekyll bundler\n```\n","collection":"blog","data":{"type":"post","category":"tech","tag":["ruby"]}},{"id":"2020/02/27/rust-webassembly-game-of-life.md","slug":"2020/02/27/rust-webassembly-game-of-life","body":"\n# 使用 rust 和 webassembly 开发 game of life\n\n这是一篇翻译，[原文](https://github.com/rustwasm/book.git)，这可能是第一篇系统讲解 rustwasm 的文章了。\n\n## 这本书适合谁？\n\n这本书适合任何对快速编译 Rust 和 Webassembly 感兴趣的人，相关的代码已经发布在网上。你应该已经了解一些 Rust 的知识，对 JavaScript HTML 和 css 很熟悉，但你不需要是在这些方面的专家。\n\n还不了解 rust？请先参阅[开始使用 rust 语言](https://doc.rust-lang.org/book/)。\n不了解 JavaScript 的 html 或者是 css？请参阅[MDN](https://developer.mozilla.org/en-US/docs/Learn)\n\n## 为什么用 rust 和 webAssembly\n\n### 底层支持和高效(Low-Level Control with Hign-Level Ergonomics)\n\nJavascript 的应用，纠结于如何保持高效运作。但是 JavaScript 的动态类型系统和垃圾回收机制，使他们不能高效。看起来很小的修改，如果不小心走出了 JIT 的舒适区，看起来很小的修改都会导致很严重的错误。\n\n### .wasm 文件大小\n\n因为要通过网络下载，代码的大小就变得异常重要。Rust 不需要运行环境，使得编译文件不需要包括垃圾回收器。这些文件包括的只有真正需要的函数。\n\n### 不要重写所有的东西\n\n现有的代码不需要被扔走，你可以把性能最严重的 JavaScript 函数，交给 rust 去执行。\n\n### 和其他工具交互融洽\n\nRust 和 WebAssembly 支持现有的工具链，它支持 ecmascript 模块，并且你依然可以使用现有的工具链如 NPM，webpack 和 greenkeeper。\n\n## 背景和相关概念\n\n### 什么是 WebAssembly\n\nWebAssembly（wasm）是一个简单的机器模块拥有大量的[定义](https://webassembly.github.io/spec/)。它被设计得以相近于原生的速度便携紧密地执行。\n\n作为一个开发语言，尽管是以两种方式展示的格式，wasm 依然表示于同样的结构。\n\n- `.wat`文本格式（叫做 WebAssembly Text），使用[S-expression](https://en.wikipedia.org/wiki/S-expression)，有点类似于 Lisp 家族，像是 Scheme 和 Clojure。\n- `.wasm`二机制格式，是一个底层的目标是让 wasm 虚拟机使用的格式，有些类似于 ELF 和 Mach-O。\n\n以`.wat`书写的斐波那契数列如下：\n\n```wasm\n(module\n  (func $fac (param f64) (result f64)\n    get_local 0\n    f64.const 1\n    f64.lt\n    if (result f64)\n      f64.const 1\n    else\n      get_local 0\n      get_local 0\n      f64.const 1\n      f64.sub\n      call $fac\n      f64.mul\n    end)\n  (export \"fac\" (func $fac)))\n```\n\n如果感兴趣的话，可以使用[此工具](https://webassembly.github.io/wabt/demo/wat2wasm/)执行上面的代码。\n\n#### 线性内存\n\nWasm 使用的[内存模式](https://webassembly.github.io/spec/core/syntax/modules.html#syntax-mem)很简单。一个 wasm 模块，可以访问的一系列内存，被限制于一个字节数组中。这些内存会[增长](https://webassembly.github.io/spec/core/syntax/instructions.html#syntax-instr-memory)为多个页（64K）不会收缩。\n\n#### Wasm 是仅仅为 web 开发的吗？\n\n尽管在 JavaScript 和 web 社区中有很多讨论。WASM 并没有考虑过它的运用环境。所以目前只能定义它为将来可以使用的便携运行格式。但就目前而言，wasm 仍然在很多方面与 JavaScript 有关。不仅仅是浏览器，还有 Node.js。\n\n## 关于本书\n\n这一部分开始使用 Rust 和 WebAssembly 开发[Conway 的 Game of Life](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life)。\n\n本章会讲到以下内容。\n\n- 如何搭建编译 WebAssembly 的 Rust 工具链。\n- 一个支持开发多语言程序（Rust、wasm、JavaScript、HTML 和 CSS）的工作流。\n- 设计最大利用 rust 和 wasm 的优势配合 JavaScript 的优点的 API。\n- 如何调试 wasm 模块。\n- 如何查看 wasm 的时间日志（time profile）。\n- 如何减少生成的二进制文件包大小。\n\n## 安装工具\n\n本节将会介绍编译 Rust 编译 WASM 并和 JavaScript 集成的工具链。\n\n### Rust 工具链\n\n你需要安装 rust 的标准工具链，[rustup，rustc 和 cargo](https://www.rust-lang.org/tools/install)（强烈建议你们在 WSl 的环境下面工作）。\n\nWASM 已经推动 Rust 新特性进入稳定版，所以我们需要有 1.30 或更新版本。\n\n### wasm-pack\n\n`wasm-pack`是一站式的建造测试以及发布 rust 相关的 wasm 应用工具。\n\n```shell\ncargo install wasm-pack\n```\n\n### cargo-generate\n\n`cargo-generate`帮助你使用现存的 Git 仓库作为模板新建 Rust 项目。\n\n```shell\ncargo install cargo-generate\n```\n\n### NPM\n\n`npm`是 JavaScript 的包装管理器。我们将利用它，去安装和运行 JavaScript 的打包和测试部署。我们将把我们编译好的`.wasm`文件放到 npm 的包中。\n\n如果你已经安装了 NPM 可以执行以下命令，安装最新版。\n\n```shell\nnpm install npm@latest -g\n```\n\n## 你好，世界\n\n通过本部分可以创建一个 Rust+WASM 页面，并能在页面弹窗展示`\"Hello, World!\"`。\n\n### 复制项目模板\n\n这个项目的模板已经提前编译好，可以借此快速绑定、集成和打包成 Web 项目。\n\n利用模板创建项目的命令：\n\n```shell\ncargo generate --git https://github.com/rustwasm/wasm-pack-template\n```\n\n它会提醒你新建一个项目名称，这里我们先使用\"wasm-game-of-life\"。\n\n### 文件结构\n\n进入项目文件夹。\n\n```shell\ncd wasm-game-of-life\n```\n\n以下是项目文件夹：\n\n```\nwasm-game-of-life/\n├── Cargo.toml\n├── LICENSE_APACHE\n├── LICENSE_MIT\n├── README.md\n└── src\n    ├── lib.rs\n    └── utils.rs\n```\n\n接下来详细看一下：\n\n#### wasm-game-of-life/Cargo.toml\n\n`Cargo.toml`文件描述`cargo`的依赖和源文件，Rust 的包管理工具和编译工具。这个包括`wasm-bindgen`依赖，我们会稍后了解其他的依赖，还有一些用来初始化`.wasm`的`crate-type`库。\n\n#### wasm-game-of-life/src/lib.rs\n\n`src/lib`文件放在 Rust 项目的更目录下面。它使用`wasm-bindgen`去和 JavaScript 链接。它能引入`window.alert`这个 JavaScript 函数，并暴露`greet`函数，并弹出弹框。\n\n```Rust\nmod utils;\nuse wasm_bindgen::prelude::*;\n\n// 当wee_alloc特性被打开，将会使用wee_alloc作为全局分匹配器\n#[cfg(feature = \"wee_alloc\")]\n#[global_allocator]\nstatic ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;\n\n#[wasm_bindgen]\nextern {\n    fn alert(s: &str);\n}\n\n#[wasm_bindgen]\npub fn greet() {\n    alert(\"Hello, wasm-game-of-life!\");\n}\n```\n\n#### wasm-game-of-life/src/utils.rs\n\n`src/utils`模块为编译 Rust 到 WASM 提供工具函数，我们后面会在调试时提到它，现在先忽略。\n\n### 编译项目\n\n使用`wasm-pack`依赖以下工具：\n\n- 保证 Rust 版本在 1.30 以上，且已经通过`rustup`安装`wasm32-unknown-unknown`工具链。\n- 使用`cargo`编译 Rust 到 WASM。\n- 使用`wasm-bindgen`去生成 JavaScript 的 API。\n\n为了完成以上内容，需要在根目录执行以下命令：\n\n```shell\nwasm-pack build\n```\n\n编译完成后，我们可以看到`pkg`里面的结构，里面应该有如下文件。\n\n```\npkg/\n├── package.json\n├── README.md\n├── wasm_game_of_life_bg.wasm\n├── wasm_game_of_life.d.ts\n└── wasm_game_of_life.js\n```\n\n`README.md`文件是直接从根目录复制的，但是其他文件完全是新生成的。\n\n#### wasm-game-of-life/pkg/wasm_game_of_life_bg.wasm\n\n`.wasm`文件是 Rust 工具链使用 Rust 源代码生成的 WASM 的二进制文件，它包括全部的函数和数据，比方说，爆露出来的`greet`函数。\n\n#### wasm-game-of-life/pkg/wasm_game_of_life.js\n\n这个`.js`文件是`wasm-bindgen`引入 DOM 和 JavaScript 方法到 Rust 中，并油耗地暴露 WASM 的 API 到 JavaScript 中。举个例子，这里个`greet`函数包裹了 WASM 中的`greet`函数，目前，这个粘合还没做任何功能，当我们逐渐从 WASM 和 JavaScript 中传输数据，他会提供帮助。\n\n```javascript\nimport * as wasm from \"./wasm_game_of_life_bg\";\n\nexport function greet() {\n  return wasm.greet();\n}\n```\n\n#### wasm-game-of-life/pkg/wasm_game_of_life.d.ts\n\n这个`.d.ts`是 TypeScript 链接 JavaScript 的文件。如果你的项目中使用了 TypeScript，你可以让你的 WebAssembly 项目被类型检查，并且你的 IDE 会提供代码提醒和自动完成功能。\n\n```TypeScript\nexport function greet(): void;\n```\n\n#### wasm-game-of-life/pkg/package.json\n\n这个文件包括了所有生成的文件描述，并使得这个项目能够作为一个使用 WebAssembly 的 NPM 包，能够集成到 JavaScript 工具链并发布至 NPM。\n\n```json\n{\n  \"name\": \"wasm-game-of-life\",\n  \"collaborators\": [\"Your Name <your.email@example.com>\"],\n  \"description\": null,\n  \"version\": \"0.1.0\",\n  \"license\": null,\n  \"repository\": null,\n  \"files\": [\"wasm_game_of_life_bg.wasm\", \"wasm_game_of_life.d.ts\"],\n  \"main\": \"wasm_game_of_life.js\",\n  \"types\": \"wasm_game_of_life.d.ts\"\n}\n```\n\n### 开始加入页面\n\n想要`wasm-game-of-life`能够展示到页面中，需要使用[`create-wasm-app` JavaScript 模板](https://github.com/rustwasm/create-wasm-app)。\n\n在项目根目录执行以下命令：\n\n```shell\nnpm init wasm-app www\n```\n\n这是`wasm-game-of-life/www`文件夹包括的文件。\n\n```\nwasm-game-of-life/www/\n├── bootstrap.js\n├── index.html\n├── index.js\n├── LICENSE-APACHE\n├── LICENSE-MIT\n├── package.json\n├── README.md\n└── webpack.config.js\n```\n\n#### wasm-game-of-life/www/package.json\n\n这个文件包括已经配置好的`webpack`和`webpack-dev-server`依赖，和`hello-wasm-pack`，版本号为已经发布到 NPM 上面的版本号。\n\n#### wasm-game-of-life/www/webpack.conf.js\n\n这个是用来配置 webpack 和开发服务器的文件。该文件已经提前布置好，如果只是开发则无需过多关心这个文件。\n\n#### wasm-game-of-life/www/index.html\n\n这是页面的 HTML 文件，它是来调用`bootstrap.js`的。\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\" />\n    <title>Hello wasm-pack!</title>\n  </head>\n  <body>\n    <script src=\"./bootstrap.js\"></script>\n  </body>\n</html>\n```\n\n#### wasm-game-of-life/www/index.js\n\n这是 JavaScript 的入口文件，他引入了`hello-wasm-pack`，并带哦用了 greet 函数。\n\n```JavaScript\nimport * as wasm from \"hello-wasm-pack\";\n\nwasm.greet();\n```\n\n#### 安装 NPM 依赖\n\n首先保证已经在`www`文件夹下面执行过`npm i`，这个命令会安装好现有依赖包括 webpack 和开发服务器。\n\n> 注意 webpack 并不是必须的，他只是个打包器并提供了开发服务器，这是我们选择它的原因。Parcel 和 Rollup 一样支持 WebAssembly 模块。你也可以选择[不使用打包器](https://rustwasm.github.io/docs/wasm-bindgen/examples/without-a-bundler.html)。\n\n#### 在 www 文件夹中使用本地 wasm-game-of-life 包\n\n相比于使用 NPM 线上的`hello-wasm-pack`，使用本地文件会提高我们的开发舒适度。\n\n打开`www/package.json`，找到`devDependencies`，在兄弟节点增加`dependencies`字段，并在里面增加`\"wasm-game-of-life\": \"file:../pkg\"`。\n\n```JSON\n{\n  // ...\n  \"dependencies\": {                     // Add this three lines block!\n    \"wasm-game-of-life\": \"file:../pkg\"\n  },\n  \"devDependencies\": {\n    //...\n  }\n}\n```\n\n接下来修改`www/index.js`引入 greet 函数。\n\n```JavaScript\nimport * as wasm from \"wasm-game-of-life\";\n\nwasm.greet();\n```\n\n既然修改了 package.json，则需要重新安装他。\n\n```shell\nnpm install\n```\n\n好了，现在服务器可以成功运行了。\n\n#### 启动本地服务\n\n接下来，打开一个新终端来在后台运行服务器，请在`www`文件夹下执行如下命令。\n\n```shell\nnpm run start\n```\n\n打开http://localhost:8080，应当会弹出如下弹窗。\n\n![弹窗](https://rustwasm.github.io/book/images/game-of-life/hello-world.png)\n\n### 练习\n\n修改 greet 函数，引入参数`name: &str`，重新执行`wasm-pack build`，并刷新页面使得弹窗中能够显示\"Hello, {name}\"。\n\n**_答案，不许看！_**\n\n修改`src/lib.rs`\n\n```Rust\n#[wasm_bindgen]\npub fn greet(name: &str) {\n    alert(&format!(\"Hello, {}!\", name));\n}\n```\n\n再修改 JavaScript 绑定`www/index.js`\n\n```JavaScript\nwasm.greet(\"Your name\");\n```\n\n## Conway 的生命游戏的游戏规则\n\n如果你已经了解[Conway 的生命游戏](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life)，可以跳过这部分。\n\n整个 Conway 的生命游戏是在一个无限的二维的正交格子宇宙中，每一个细胞拥有两种生命状态，生或者死。或者说可增殖或者不可增殖。每一个细胞都和它的 8 个邻居交互，它们分别是纵向的，斜向的，横向的相邻。并且每一步都会发生如下的变化。\n\n1. 任何一个活着的细胞，如果有少于两个邻居就会死亡。\n2. 任何一个活细胞拥有两个或三个活着的邻居，则会继续增殖。\n3. 任何一个活着的细胞拥有三个以上活着的的邻居，则会死亡。\n4. 任何一个死掉的细胞，如果有三个活着的邻居，则会重生。\n\n最初的图案组成了最初的世界。第 1 代是按照以上的规则生成的，每一个细胞的生成和死亡都是同时的。他们的生存和死亡这一个时间我们称之为一刻。用程序的语言来说，这一刻是上一次生成的纯函数。这个规则一直有效。\n\n考虑设置如下的初始宇宙：\n\n![初始宇宙](https://rustwasm.github.io/book/images/game-of-life/initial-universe.png)\n\n我们可以通过考虑每一个细胞来确定下一代。最左上角的细胞已经死亡，第 4 条规则是唯一一个能够处理死亡细胞的规则。所以第 1 排的所有细胞都有相同的规则。他们都没有三个活着的邻居。只能保持死亡。\n\n当我们看到最上面的活着的细胞时，这个游戏开始变得有趣了。在第 2 排第 3 列。对于活着细胞前三个规则都可以应用。对于这一个细胞，他只有一个活着的邻居，所以规则一可用。这个细胞会在下一次争执死亡。下面那几个活着的细胞也是有一样的命运。\n\n中间的活着的细胞，还有两个邻居，上面的和下面的，这就意味着它符合规则二，他可以活到下一次增值。\n\n最后一个比较有趣的例子，就是当我们看到死掉的细胞。嗯。在中间这活着的细胞的左边和右边。这三个活着的细胞都是他们的邻居。这使得他们按照规则是可以在下一轮重生。\n\n将这些规则放在一起，我们可以获得下一刻的世界。\n\n![下一刻的世界](https://rustwasm.github.io/book/images/game-of-life/next-universe.png)\n\n根据这个例子，和确定的规则。不去并精彩的事情将会发生。\n\n![Gosper's glider gun](https://upload.wikimedia.org/wikipedia/commons/e/e5/Gospers_glider_gun.gif)\n\n![Pulsar](https://upload.wikimedia.org/wikipedia/commons/0/07/Game_of_life_pulsar.gif)\n\n![Space ship](https://upload.wikimedia.org/wikipedia/commons/3/37/Game_of_life_animated_LWSS.gif)\n\n### 练习\n\n手动计算出下一刻，宇宙应该是什么样\n\n**_答案，不许看！_**\n\n![下一刻宇宙](https://rustwasm.github.io/book/images/game-of-life/initial-universe.png)\n\n你能找到一个稳定的没有变化的宇宙吗？\n\n**_答案，不许看！_**\n\n这个答案，不许看！其实有无数个，最平凡的答案，不许看！就是它是一个空宇宙。如果是一个 2×2 的方格，也可以形成一个稳定的宇宙。\n\n## 实现 Conway 的生命游戏\n\n### 设计\n\n在开始之前呢，我们要先考虑以下几种设计模式。\n\n#### 无限宇宙\n\n生命游戏是在一个无限宇宙中玩的。但是我们没有无限的内存和计算能力。在这种情况下，我们往往会有三个选项。\n\n1. 始终追踪这个宇宙的发展，并适当的扩展宇宙。这个扩张是无限的，所以这个实现实现了就会逐渐逐渐的变得越来越慢，直到把内存全部用完。\n2. 创建一个固定的宇宙，当细胞碰到宇宙的边缘的时候，将会有更少的邻居。更简单的策略就是当他们已经达到边缘的时候，直接被宇宙剪掉。\n3. 创建一个固定的宇宙，当细胞达到边缘的时候，将会从另外一边滑入这样，我的我们的应用就可以一直跑下去。\n\n我们会按照第 3 个选项来实现。\n\n#### 连接 Rust 和 JavaScript\n\n> 此部分是本人最重要的一节。\n\nJavaScript 的垃圾回收堆内存，是用来调用 Object 和 Array 还有 DOM 结点的。而 Rust 存在的 WebAssembly 线性内存和它是截然不同的。WebAssembly 目前还不能直接操作垃圾回收堆内存（在 2018 年 4 月，一个关于[接口类型（Interface Type）](https://github.com/WebAssembly/interface-types/blob/master/proposals/interface-types/Explainer.md)的提案将会改变这一局面）。JavaScript 却可以读写 WebAssembly 的线性内存，但仅限于 ArrayBuffe 支持的标量（u8, i32, f64 等等）。WebAssembly 行数一样能处理和返回这些标量。以下讲解 WebAssembly 和 JavaScript 如何链接。\n\nwasm_bindgen 定义了如何穿过这段链接计算数据结构的方法。它包括装箱 Rust 结构，并包装指针成为一个 JavaScript 类以供使用，或者提供 JavaScript 对象给 Rust 使用。wasm_bindgen 非常便利，但并不是无需考虑怎样在这个链接上传输数据结构。你应该把它当作一个实现接口的工具。\n\n当设计 WebAssembly 和 JavaScript 的接口时，我们需要考虑到以下内容。\n\n1. **减少复制到和移出 WebAssembly 线性内存中的值**，无效的复制会造成无用的性能损耗。\n2. **最小的序列化和解序列化**，和复制类似，序列化和解序列化一样造成性能损耗，如果想要把数据无副作用地从一端传到另一端，与其说在一端序列化，到另一端解序列化，不如使用 wasm_bindgen 帮助我们将 JavaScript 的 Object 装箱成 Rust 的 structure。\n\n一个结论，处理 JavaScript 和 WebAssembly 接口设计时，经常将大的、生命周期长的数据结构作为 Rust 类型，存储在 WebAssembly 线性内存中，并给 JavaScript 暴露一个处理方法，JavaScript 调用 WebAssembly 转换文件，处理运算，并最终得到一个小的，可复制的结果。通过只返回计算结果，我们可以躲过复制和序列化数据的过程。\n\n#### 在生命游戏中链接 Rust 和 JavaScript\n\n接下来结局几个要规避的问题。我们不想每刻都复制整个宇宙到 WebAssembly 的内存中，我们不想处理宇宙中所有的细胞，也不想在每次读写细胞的时候都穿过 WebAssembly 和 JavaScript 的分界。\n\n这是我们的 4x4 宇宙在内存中的结构。\n\n![4x4宇宙在内存中的结构](https://rustwasm.github.io/docs/book/images/game-of-life/universe.png)\n\n为了寻找细胞在内存中的位置，我们可以使用下面的公式。\n\n```\nindex(row, column, universe) = row * width(universe) + column\n```\n\n我们有很多方法来给 JavaScript 暴露宇宙中的细胞。开始我们要为宇宙实现一个`std::fmt::Display`。我们可以使用一个 Rust 的 String，每个字符代表一个细胞。这个 Rust 的 string 将会从 WebAssembly 的内存中复制到 JavaScript 的内存里，并接下来作为 textContent 展示到 HTML 里面。本节的后面，将会讲到如何把细胞展示到 canvas 中。\n\n> 另一种设计是让 Rust 返回每个细胞的生存状态列表，这样 JavaScript 就不需要在渲染时解析整个宇宙，这不过这个是先更加复杂些。\n\n#### Rust 的实现\n\n上一章，我们复制了初始化模板，我们现在要修改这个模板。\n\n从删除 greet 函数，并定义宇宙中的细胞开始。\n\n```Rust\n#[wasm_bindgen]\n#[repr(u8)]\n#[derive(Clone, Copy, Debug, PartialEq, Eq)]\npub enum Cell {\n    Dead = 0,\n    Alive = 1,\n}\n```\n\n`#[repr(u8)]`很重要，这样每个细胞都会以一个字节存储，另外 Alive 为 1，Dead 为 0 也很重要，这样我们就可以使用加法计算邻居数目。\n\n接下来定义宇宙，一个宇宙包括宽度，高度和一个向量的细胞。\n\n```Rust\n#[wasm_bindgen]\npub struct Universe {\n    width: u32,\n    height: u32,\n    cells: Vec<Cell>,\n}\n```\n\n访问并转换细胞的实现如下。\n\n```Rust\nimpl Univers {\n    fn get_index(&self, row: u32, column: u32) -> usize {\n        (row*self.width + column) as usize\n    }\n}\n```\n\n为了计算细胞接下来的状态，我们要统计某个细胞有多少个邻居存活。\n\n```Rust\nimpl Univers {\n    fn live_neighbor_count(&self, row: u32, column: u32) -> u8 {\n        let mut count = 0;\n        for delta_row in [self.height - 1, 0, 1].iter().cloned() {\n            for delta_col in [self.width - 1, 0, 1].iter().cloned() {\n                if delta_row == 0 && delta_col ==0 {\n                    continue;\n                }\n\n                let neighbor_row = (row + delta_row) % self.height;\n                let neighbor_col = (column + delta_col) % self.width;\n                let idx = self.get_index(neighbor_row, neighbor_col);\n                count += self.cells[idx] as u8\n            }\n        }\n        count\n    }\n}\n```\n\n这个函数使用取余处理边界问题。现在我们已经有所有的必须函数了，最后只需要生成下一刻的状态即可（记住，每个函数必须在`#[wasm_bindgen]`属性之下，这样 JavaScript 才能接到暴露的函数）。\n\n```Rust\n#[wasm_bindgen]\nimpl Universe {\n    pub fn tick(&mut self) {\n        let mut next = self.cells.clone();\n\n        for row in 0..self.height {\n            for col in 0..self.width {\n                let idx = self.get_index(row, col);\n                let cell = self.cells[idx];\n                let live_neighbors = self.live_neighbor_count(row, col);\n\n                let next_cell = match (cell, live_neighbors) {\n                    (Cell::Alive, x) if x < 2 => Cell::Dead,\n                    (Cell::Alive, 2) | (Cell::Alive, 3) => Cell::Alive,\n                    (Cell::Alive, x) if x > 3 => Cell::Dead,\n                    (Cell::Dead, 3) => Cell::Alive,\n                    (otherwise, _) => oterwise,\n                };\n\n                next[idx] = next_cell;\n            }\n        }\n        self.cells = next;\n    }\n}\n```\n\n目前为止，一个宇宙的状态就都被存储在 cell 这个向量里面了。为了提高它的可读性，让我们实现一个文本渲染器，目的是将整个宇宙按行输出为文字，每一个活着的细胞标注为 Unicode 符号“■”，死掉的细胞则为“□”。\n\n通过实现 Rust 标准库中的`Display`trait，我们可以将数据结构以一种用户交互方式输出，它也提供了一个`to_string`方法。\n\n```Rust\nuse std::fmt;\n\nimpl fmt::Display for Universe {\n  fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n    for line in self.cells.as_slice().chunks(self.width as usize) {\n      for &cell in line {\n        let symbol = if cell == Cell::Dead {\"□\"} else {\"■\"};\n        write!(f, \"\\n\")?;\n      }\n    }\n\n    Ok(())\n  }\n}\n```\n\n最后，我们定义一个构造器去初始化一个有趣的图案和一个渲染函数。\n\n```Rust\n#[wasm_bindgen]\nimpl Universe {\n  pub fn new() -> {\n    let width = 64;\n    let height = 64;\n\n    let cells = (0..width * height)\n      .map(|i| {\n        if i%2 == 0 || i%7 == 0 {\n          Cell::Alive\n        } else {\n          Cell::Dead\n        }\n      }).collect();\n\n    Universe {\n      width,\n      height,\n      cells,\n    }\n  }\n\n  pub fn render(&self) -> String {\n    self.to_string()\n  }\n}\n```\n\n以上，Rust 部分已经完工。\n\n#### 使用 JavaScript 渲染\n\n首先在 HTML 中插入<pre>标签用来展示整个宇宙。\n\n```html\n<body>\n  <pre id=\"game-of-life-canvas\"></pre>\n  <script src=\"./bootstrap.js\"></script>\n</body>\n```\n\n另外我们希望<pre>标签能处于页面中央。我们可以通过 CSS flex box 实现这个任务，在 html 中增加<style>标签。\n\n```css\nbody {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n}\n```\n\n修改 JavaScript 入口文件，将原来引入的 greet 函数改为 Universe。\n\n```JavaScript\nimport { Universe } from \"wasm-game-of-life\";\n```\n\n让我们在那个<pre>标签中增加新的宇宙实例吧。\n\n```JavaScript\nconst pre = document.getElementById(\"game-of-life-canvas\");\nconst universe = Universe.new();\n```\n\n使用 JavaScript 创建一个 requestAnimationFrame 循环，每一次循环，就在<pre>标签中绘制一遍宇宙，并执行一次`Universe::tick`。\n\n```JavaScript\nfunction renderLoop() {\n  pre.textContent = universe.render();\n  universe.tick();\n\n  requestAnimationFrame(renderLoop);\n}\n```\n\n想要实现渲染，只需执行`requestAnimationFrame(renderLoop)`。\n\n确保你的本地服务任然在运行，此时你的页面应该如下所示。\n\n![浏览器页面](https://rustwasm.github.io/book/images/game-of-life/initial-game-of-life-pre.png)\n\n#### 渲染到 Canvas 上\n\n在 Rust 中生成字符串并通过 wasm-bindgen 拷贝到 JavaScript 中做了很多无关的复制。既然 JavaScript 已经知道宇宙的长度和宽度，而且 JavaScript 本来可以直接读 WebAssembly 的内存，我们将要修改 render 方法，直接返回细胞向量的指针。\n\n同时，与其渲染 Unicode 字符，不如开始用 Canvas API。接下来我们会开始设计这些。\n\n在 html 中，修改<pre>为<canvas>。\n\n```html\n<body>\n  <canvas id=\"game-of-life-canvas\"></canvas>\n  <script src=\"./bootstrap.js\"></script>\n</body>\n```\n\n为了能拿到 Rust 中的相关数据结构，我们需要为宇宙增加 getter 函数，暴露宇宙的宽度、高度和细胞的向量。增加如下函数。\n\n```Rust\n#[wasm_bindgen]\nimpl Universe {\n  pub fn width(&self) -> u32 {\n    self.width\n  }\n\n  pub fn height(&self) -> u32 {\n    self.height\n  }\n\n  pub fn cells(&self) -> *const Cell {\n    self.cells.as_ptr()\n  }\n}\n```\n\n接下来，在 JavaScript 中，引入 Cell，并设置几个渲染画布的常量。\n\n```JavaScript\nimport { Universe, Cell } from \"wasm-game-of-life\";\n\nconst CELL_SIZE = 5;\nconst GRID_COLOR = \"#CCCCCC\";\nconst DEAD_COLOR = \"#FFFFFF\";\nconst LIVE_COLOR = \"#000000\";\n```\n\n接下来修改实现 canvas 的部分。\n\n```JavaScript\nconst universe = Universe.new();\nconst width = universe.width();\nconst height = universe.height();\n\nconst canvas = documnet.getElementById(\"game-of-life-canvas\");\ncanvas.height = (CELL_SIZE+1)*height + 1;\ncanvas.width = (CELL_SIZE+1)*width + 1;\n\nconst ctx = canvas.getContext(\"2d\");\n\nfunction renderLoop() {\n  universe.tick();\n\n  drawGrid();\n  drawCells();\n\n  requestAnimationFrame(renderLoop);\n}\n```\n\n世界的网格，是一系列等宽的竖线和横线。\n\n```JavaScript\nfunction drawGrid() {\n  ctx.beginPath();\n  ctx.strokeStyle = GRID_COLOR;\n\n  for(let i =0; i <= width; i+=1) {\n    ctx.moveTo(i*(CELL_SIZE+1) + 1, 0);\n    ctx.lineTo(i*(CELL_SIZE+1) + 1, (CELL_SIZE+1)*height+1);\n  }\n\n  for(let i=0; i<=height; j++) {\n    ctx.moveTo(0, i*(CELL_SIZE+1)+1);\n    ctx.lineTo((CELL_SIZE+1)*width+1, i*(CELL_SIZE+1)+1);\n  }\n\n  ctx.stroke();\n}\n```\n\n我们可以直接访问 WebAssembly 的内存，他是直接定义在`wasm_game_of_life_bg`。为了画细胞，我们先找到一个细胞的指针，并将它们转换成 Unit8Array，迭代这些细胞，并按照他们的生命状态绘制白色和黑色方块。计量避免复制所有细胞。\n\n```JavaScript\nimport { memory } from \"wasm-game-of-life/wasm_game_of_life_bg\";\n\nfunction getIndex(row, column) {\n  return row*width+column;\n}\n\nfunction drawCells() {\n  const cellsPtr = universe.cells();\n  const cells = new Unit8Array(\n    memory.buffer,\n    cellPtr,\n    width*height,\n  );\n\n  ctx.beginPath();\n\n  for(let row=0; row<height; row+=1) {\n    for (let col=0; col<width; col+=1) {\n      const idx = getIndex(row, col);\n\n      ctx.fillStyle = cells[idx] === CellDead\n        ? DEAD_COLOR\n        : LIVE_COLOR;\n\n      ctx.fillRect(\n        cell*(CELL_SIZE+1) + 1,\n        row*(CELL_SIZE+1) + 1,\n        CELL_SIZE,\n        CELL_SIZE,\n      );\n    }\n  }\n\n  ctx.stroke();\n}\n```\n\n开始渲染，需要添加以下表达式。\n\n```JavaScript\ndrawGrid();\ndrawCells();\nrequestAnimationFrame(renderLoop);\n```\n\n注意 drawGrid 和 drawCell 必须要在 requestAnimationFrame 之前执行。\n\n#### 成功了！\n\n重建 WebAssembly 绑定。\n\n```shell\nwasm-pack build\n```\n\n确定开发服务器还在运行，如果不是，需要执行以下命令。\n\n```shell\nnpm run start\n```\n\n刷新`http://localhost:8080/`，你应该能看到如下结果。\n\n![页面](https://rustwasm.github.io/docs/book/images/game-of-life/initial-game-of-life.png)\n\n结束之前，这里还有一个不错的实现生命游戏的算法，[hashlife](https://en.wikipedia.org/wiki/Hashlife)。它使用缓存，使得程序有指数级性能提升！但是为什么我们不实现它呢？它已经超出本文涉及的范围了，本文只是专注于 Rust 和 WebAssembly 集成，但是我们强烈期望你能实现这一算法。\n\n### 练习\n\n#### 实现一台宇宙飞船\n\n#### 生成一个随机的初始环境，每个细胞有 50%的生存可能\n\n**_答案，不许看！_**\n\n先增加 js-sys 依赖\n\n```toml\n[dependencies]\njs-sys=\"0.3\"\n```\n\n接下来使用 js 的随机函数\n\n```Rust\nextern crate js_sys;\n\nif js_sys::Math::random() < 0.5 {\n\n} else {\n\n}\n```\n\n#### 以 bit 形式存储每个 cell\n\n**_答案，不许看！_**\n\n在 Rust 中，使用 fixedbitset 代替`Vec<Cell>`;\n\n```Rust\nextern crate fixedbitset;\nuse fixedbitset::FixedBitSet;\n\n#[wasm_bindgen]\npub struct Universe {\n  width: u32,\n  height: u32,\n  cells: FixedBitSet,\n}\n```\n\n宇宙的构造器应该这么修改。\n\n```Rust\npub fn new() -> Universe {\n  let width = 64;\n  let height = 64;\n\n  let size = (width*height) as usize;\n  let mut cells = FixedBitSet::with_capacity(size);\n\n  for i in 0..size {\n    cells.set(i, i%2==0 || i%7==0);\n  }\n\n  Universe {\n    width,\n    height,\n    cells,\n  }\n}\n```\n\n使用 FixedBitSet 的 set 方法更新宇宙的下一刻。\n\n```Rust\nnext.set(idx, match (cell, live_neighbors) {\n  (true, x) if x<2 => false,\n  (true, 2) | (true, 3) => true,\n  (true, x) if x>3 => false,\n  (false, 3) => true,\n  (otherwise, _) => otherwise\n});\n```\n\n传输指针的时候，需要返回 slice。\n\n```Rust\n#[wasm_bindgen]\nimpl Universe {\n  pub fn cells(&self) -> *const u32 {\n    self.cells.as_slice().as_ptr()\n  }\n}\n```\n\n在 JavaScript 中，构造 Unit8Array 的时候需要除以 8，以为我们是以 bit 存储细胞的。\n\n```JavaScript\nconst cells = new Unit8Array(\n  memory.buffer,\n  cellsPtr,\n  width*height/8\n);\n```\n\n通过判断 Unit8Array 是否被赋值而判断细胞是否是活着的。\n\n```JavaScript\nfunction bitIsSet(n, arr) {\n  const byte = Math.floor(n/8);\n  const mask = 1<<(n%8);\n  return (arr[byte] & mask) == mask;\n}\n```\n\n根据以上变化，新版本的 drawCells 如下。\n\n```JavaScript\nfunction drawCells() {\n  const cellsPtr = universe.cells();\n  const cells = new Unit8Array(\n    memory.buffer,\n    cellsPtr,\n    width*height/8\n  );\n\n  ctx.beginPath();\n\n  for (let row=0; row<height; row+=1) {\n    for(let col=0; col<width; col+=1) {\n      const idx = getIndex(row, col);\n\n      ctx.fillStyle = bitIsSet(idex, cells)\n        ? LIVE_COLOR\n        : DEAD_COLOR;\n\n      ctx.fillRect(\n        col*(CELL_SIZE+1)+1,\n        row*(CELL_SIZE+1)+1,\n        CELL_SIZE,\n        CELL_SIZE,\n      );\n    }\n  }\n\n  ctx.stroke();\n}\n```\n\n## 测试\n\n现在我们已经实现了 Rust 的实现，并成功渲染在浏览器中。现在来谈谈测试 WebAssembly 中的 Rust 函数。\n\n我们将要测试 tick 函数，确保它能返回正确的值。\n\n接下来，我们将处理 Universe 的 setter 函数，让我们能构造不同大小的 universe。\n\n```Rust\n#[wasm_bindgen]\nimpl Universe {\n  pub fn set_width(&mut self, width: u32) {\n    self.width = width;\n    self.cells = (0..width * self.height).map(|_| Cell::Dead).collect()\n  }\n\n  pub fn set_height(&mut self, height: u32) {\n    self.height = height;\n    self.cells = (0..self.width * height).map(|_| Cell::Dead).collect()\n  }\n}\n```\n\n我们将会创建另一个不需要`#[wasm_bindgen]`的`impl Universe`实现，因为我们不能把所有的 WebAssembly 函数暴露给 JavaScript，Rust 生成的 WebAssembly 函数是不能返回引用的。可以尝试让 Rust 返回一个引用，查看一下编译结果中是什么错误。\n\n接下来我们要写一个 get_cells 来获得细胞，和一个 set_cells 来设置哪些细胞是活的，哪些是死的。\n\n```Rust\nimpl Universe {\n  pub fn get_cells(&self) -> &[Cell] {\n    &self.cells\n  }\n\n  pub fn set_cells(&mut self, cells: &[(u32, u32)]) {\n    for (row, col) in cells.iter().cloned() {\n      let idx = self.get_index(row, col);\n      self.cells[idx] = Cell::Alive;\n    }\n  }\n}\n```\n\n现在我们将创建测试文件`tests/web.rs`。\n\n在这之前，测试环境已经配置好，请确定`wasm-pack test --chrome --headless`能够在根目录下运行。你也可以使用`--firefox`，`--safari`和`--node`选项来在其他浏览器测试你的代码。\n\n在`test/web.rs`中，我们需要到处 Universe 类型。\n\n```Rust\nextern crate wasm_game_of_life;\nuse wasm_game_of_life:Universe;\n```\n\n在测试文件中，我们要创建一个飞船构造函数。\n\n我们要构造一个 tick 函数执行之前的飞船，和一个 tick 函数执行后的期望值。\n\n```Rust\n#[cfg(test)]\npub fn input_spaceship() -> Universe {\n  let mut universe = Universe::new();\n\n  universe.set_width(6);\n  universe_set_height(6);\n  universe_set_cells(\n    &[\n      (1,2),\n      (2,3),\n      (3,1), (3,2),(3,3)\n    ]\n  );\n\n  universe\n}\n\n#[cfg(test)]\npub fn expected_spaceship() -> Universe {\n  let mut universe = Universe::new();\n\n  universe.set_width(6);\n  universe_set_height(6);\n  universe_set_cells(\n    &[\n      (2,1), (2,3),\n      (3,2), (3,3),(4,2)\n    ]\n  );\n\n  universe\n}\n```\n\n现在我们写一个 test_tick 函数，创建以上的两个飞船。最后使用`assert_eq!`宏比较 expected_ship 来确保 tick 函数运行正确。我们添加`#[wasm_bindgen_test]`属性保证这个函数可以在 WebAssembly 环境下测试。\n\n```Rust\n#[wasm_bindgen_test]\npub fn test_tick() {\n  let mut input_universe = input_spaceship();\n  let expected_universe = expected_spaceship();\n\n  input_universe.tick();\n  assert_eq!(\n    &input_universe.get_cells(),\n    &expected_universe.get_cells(),\n  )\n}\n```\n\n测试这个测试函数使用`wasm-pack test --firefox --headless`。\n\n## 调试\n\n写这么多代码之前（虽然上面都写完了，我也不知道原作者抽什么风），先看一看 Rust 的调试工具。\n\n### 调试工具\n\n此部分将会介绍 WebAssembly 的调试工具。\n\n#### 使用 debug 标记编译\n\n如果没有打开 debug 标记，\"name\"这个部分就不会被编译到二进制程序中，错误栈也不会显示函数名，你会收到`wasm-functions[42]`而不是`wasm_game_of_file::Universe::live_neighbor_count`。\n\n调试编译，`wasm-pack build --debug`或者`cargo build`总是会默认打开 debug 标记。\n\n版本编译（release build），debug 标记是默认关闭的，要打开 debug 标记，需要声明`debug=true`。\n\n```toml\n[profile.release]\ndebug = true\n```\n\n#### 使用 console API 打印日志\n\n打印日志是最好的判断程序是否是有错的方式。在浏览器中，`console.log`函数可以将日志打印到浏览器的 dev 工具里。\n\n我们可以使用 web-sys 包去调用 console API。\n\n```Rust\nextern crate web_sys;\n\nweb_sys::console::log_1(&\"Hello, world!\".into());\n```\n\n相应的`console.error`函数用法一致，但是浏览器的调用栈还是按照`console.error`来打印。\n\n使用`console.log`：\n\n- [`web_sys::console::log`，接受一个向量的数据做参数](https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.log.html)。\n- [`web_sys::console::log_1`，接受一个数据做参数](https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.log_1.html)。\n- [`web_sys::console::log_2`，接受两个数据做参数](https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.log_2.html)。\n- ...\n\n使用`console.error`：\n\n- [`web_sys::console::error`，接受一个向量的数据做参数](https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.error.html)。\n- [`web_sys::console::error_1`，接受一个数据做参数](https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.error_1.html)。\n- [`web_sys::console::error_2`，接受两个数据做参数](https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.error_2.html)。\n- ...\n\n#### 打印崩溃日志\n\n[`console_error_panic_hook`包能通过`console.error`打印崩溃日志](https://github.com/rustwasm/console_error_panic_hook)。他能打印出格式化的崩溃信息而不是难以理解的`RuntimeError: unreachable executed`。\n\n你只需要增加调用这个钩子函数。\n\n```Rust\n#[wasm_bindgen]\npub fn init_panic_hook() {\n  console_error_panic_hook::set_once();\n}\n```\n\n#### 使用调试器\n\n不幸的，WebAssembly 的调试器依然不成熟，在很多 unix 系统中，DWARF 是用来解析调试程序需要的数据的工具。虽然，Windows 上面也有一个类似的工具。但还没有相当的工具提供给 WebAssembly。所以，调试器目前能给予的功能有限，我们只能收到 WebAssembly 的错误而不是 Rust 源代码的错误。\n\n> 这里有一个故事是[跟踪 WebAssembly 的调试](https://github.com/WebAssembly/debugging)的，我们希望它将来会有所改善！\n\n尽管如此，调试器还是能够给调试 JavaScript 方面提供效力。\n\n#### 一开始就规避在 WebAssembly 上面使用调试\n\n如果错误和交互 JavaScript 和 Web API 有关，则使用`wasm-bindgen-test`写测试。\n\n如果和 JavaScript 和 Web API 无关，这是用默认的`#[test]`属性。使用[`quickcheck`包](https://crates.io/crates/quickcheck)可以减少写测试上面的时间。\n\n为了避免`#[test]`编译器出现连接错误，你需要一个 rlib 依赖，在`Cargo.toml`文件按照如下修改。\n\n```toml\n[lib]\ncrate-type [\"cdylib\", \"rlib\"]\n```\n\n### 在生命游戏中打开崩溃日志\n\n如果程序崩溃，最好是能够在审查工具中看到日志。\n\n在``src/utils.rs`里面有一个可选的 console_error_panic_hook 包，可以在 Universe 初始化的时候调用它。\n\n```Rust\npub fn new() -> Universe {\n  utils::set_panic_hook();\n}\n```\n\n### 为生命游戏增加日志\n\n让我们在 Rust 中利用 web-sys 调用 console，打印出每一刻的细胞状态。\n\n首先在以来中增加 web-sys，修改 Cargo.toml。\n\n```toml\n[dependencies.web-sys]\nversion = \"0.3\"\nfeatures = [\n  \"console\",\n]\n```\n\n为了高效，我们把`console.log`函数封装到`println!`一样的宏中。\n\n```Rust\nextern crate web_sys;\n\nmacro_rules! log {\n  ($( $t:tt )*) => {\n    web_sys::console::log_1(&format!( $( $t )* ).into());\n  }\n}\n```\n\n现在可以通过调用 log 发送日志了。\n\n```Rust\nlog!(\n  \"cell[{}, {}] is initially {:?} and has {} live neighbors\",\n  row,\n  col,\n  cell,\n  live_neighbors,\n)\n```\n\n### 使用调试器\n\n浏览器的调试器在调试 JavaScript 和 Rust 生成的 WebAssembly 很有效。\n\n举个例子，在 renderLoop 函数中增加`debugger;`可以暂停页面执行的某一刻。\n\n者给予我们查看每一刻细胞状态的能力。\n\n![调试画面](https://rustwasm.github.io/docs/book/images/game-of-life/debugging.png)\n\n### 练习\n\n1. 给 tick 方法增加 log，查看细胞状态。\n2. 加入`panic!()`查看打印出来的崩溃日志。\n\n## 增加交互\n\n接下来我们要给这个游戏增加一些交互，我们会允许用户选择细胞的生死，并且允许暂停游戏，并使绘制初始图案更加简单。\n\n### 暂停和继续游戏\n\n首先修改 html，在画布上面增加一个<button>标签。\n\n```html\n<button id=\"play-pause\"></button>\n```\n\n在 JavaScript 中，我们要做以下几点改动。\n\n- 追踪调用 requestAnimationFrame 的标识符，这样我们就能通过调用 cancelAnimationFrame 来终止动画。\n- 当点击播放或者暂停键的时候，先检查标识符是否存在，一旦存在，则表示动画正在运行，我们需要取消动画以保证 renderLoop 不再被调用。如果标识符不存在，我们需要调用 requestAnimationFrame 以保证动画继续运行。\n\n因为是 JavaScript 控制着 Rust 和 WebAssembly，我们不需要修改 Rust 部分。\n\n我们引入 animationId 变量，保存 requestAnimationFrame 的结果。当没有排队的动画时，这个变量值为 null。\n\n```JavaScript\nlet animationId = null;\n\nfunction renderLoop() {\n  drawGrid();\n  drawCells();\n\n  universe.tick();\n\n  animationId = requestAnimationFrame(renderLoop);\n}\n```\n\n任何一个时间，我们可以通过判断 animationId 来判断这个动画是否被暂停。\n\n```JavaScript\nfunction isPaused() {\n  return animationId === null;\n}\n```\n\n现在，当播放暂停键被点击，当正在播放时，暂停动画。并把按钮的状态改为播放。\n\n```JavaScript\nconst playPauseButton = document.getElementById(\"play-pause\");\n\nfunction play() {\n  playPauseButton.textContent = \"⏸\";\n  renderLoop();\n};\n\nfunction pause() {\n  playPauseButton.textContent = \"▶\";\n  cancelAnimationFrame(animationId);\n  animationId = null;\n};\n\nplayPauseButton.addEventListener(\"click\", function playBtnListener(event) {\n  if (isPaused()) {\n    play();\n  } else {\n    pause();\n  }\n});\n```\n\n最后我们把之前的 requestAnimationFrame 函数封装成`play()`。刷新本地服务器，可以看到网页上已经有暂停按钮了。尝试点击一下它吧。\n\n### 修改一个细胞的状态\n\n现在我们能暂停这个游戏了，是时候增加一个修改细胞的功能了。\n\n想控制细胞的生死，需要给`src/lib.rs`下的 Cell 增加一个 toggle 函数。\n\n```Rust\nimpl Cell {\n    fn toggle(&mut self) {\n        *self = match *self {\n            Cell::Dead => Cell::Alive,\n            Cell::Alive => Cell::Dead,\n        };\n    }\n}\n```\n\n想要修改在宇宙中的细胞需要获得细胞的行纵值，并转换为细胞的序号。\n\n```Rust\n#[wasm_bindgen]\nimpl Universe {\n    pub fn toggle_cell(&mut self, row: u32, column: u32) {\n        let idx = self.get_index(row, column);\n        self.cells[idx].toggle();\n    }\n}\n```\n\n这个方法增加第 1 行的属性声明是为了能够在 JavaScript 环境里面直接调用。在 JavaScript 文件中，监听<canvas>标签，将页面上的点击事件转换成画布上的点击事件，并调用 toggle_cell 方法重绘场景。\n\n```Rust\ncanvas.addEventListener(\"click\", function canvasClickListener(event) {\n  const boundingRect = canvas.getBoundingClientRect();\n\n  const scaleX = canvas.width / boundingRect.width;\n  const scaleY = canvas.height / boundingRect.height;\n\n  const canvasLeft = (event.clientX - boundingRect.left) * scaleX;\n  const canvasTop = (event.clientY - boundingRect.top) * scaleY;\n\n  const row = Math.min(Math.floor(canvasTop/(CELL_SIZE + 1)), height - 1);\n  const col = Math.min(Math.floor(canvasLeft/(CELL_SIZE + 1)), width - 1);\n\n  universe.toggle_cell(row, col);\n\n  drawGrid();\n  drawCells();\n});\n```\n\n使用`wasm-pack build`重新编译，刷新网页，并更新细胞状态。\n\n### 练习\n\n- 新建一个<input>标签来处理每帧更新多少个刻。\n- 增加一个重置按钮，把宇宙恢复到初始状态；再增加一个消灭按钮，毁灭所有细胞。\n- 当使用`Ctrl+Click`的时候，增加一个[glider](<https://en.wikipedia.org/wiki/Glider_(Conway%27s_Life)>)，使用`Shift+Click`增加一个 pulsar。\n\n## 性能日志(Time Profiling)\n\n本节我们将会提高这个游戏的性能，我们将会用 time profiling 来完成。\n\n### Time Profiling\n\n此部分将会讲解如何获得页面的性能分析，目标是提高 JavaScript 和 WebAssembly 之间的吞吐。\n\n> 永远使用`wasm-pack build`编译最新的代码，以确定你的优化正确。\n\n#### windows.performance.now()\n\n这个函数会返回以毫秒为单位的时间戳来计算页面加载速度。\n\n调用`performance.now()`的性能损耗低，所以我们可以利用它创造一个简单的测算工具而不是产生很大误差值。\n\n我们可以通过`web-sys`调用时间函数。\n\n```Rust\nextern crate web_sys;\n\nfn now() -> f64 {\n  web_sys::window()\n    .expect(\"should have window\")\n    .performance()\n    .expect(\"should have a Performance\")\n    .now()\n}\n```\n\n#### 开发者工具的性能查看器\n\n所有的浏览器的开发者工具都有性能查看器。这个查看器通过火焰图展示函数调用栈来表示哪一个函数耗时更长。\n\n如果你编译的时候打开了调试，则函数名将会显示在这里（如果没打开则显示一个不透明的名字，比如`wasm-function[123]`）。\n\n注意，因为性能查看器不会显示内联函数，又因为 Rust 和 LVVM 很重地依赖于内联函数，其结果就会让人感到头疼。\n\n![性能查看器无法处理内联函数](https://rustwasm.github.io/docs/book/images/game-of-life/profiler-with-rust-names.png)\n\n#### console.time 和 console.timeEnd\n\n这两个函数是浏览器的内置函数。以调用`console.time(\"foo\")`作为开始，以`console.time(\"foo\")`作为结束，参数是可选的。\n\n你可以通过 web-sys 调用`web_sys::console::time_with_label(\"foo\")`和`web_sys::console::time_end_with_label(\"foo\")`。\n\n如下是浏览器的截图。\n\n![使用console.time的截图](https://rustwasm.github.io/docs/book/images/game-of-life/console-time.png)\n\n另外，`console.time`和`console.timeEnd`会调用性能检查器统计出瀑布图。\n\n#### 使用#[bench]调用原生代码\n\n就像我们能使用原生的测试方法`#[test]`来测试代码，我们可以使用`#[bench]`通过操作系统的工具来查看函数性能。\n\n写好标准函数并放到`benches`文件夹下。确保`crate-type`已经引入 rlib，能使测试代码能够链接。\n\n无论如何，先搞明白你知道 WebAssembly 里面的瓶颈之后再花费精力去调查原生的性能调查器！用你的浏览器的性能调查器，或者使用这些时间去优化你的代码不是更好？\n\n### 利用 window.performance.now 创建一个计时器\n\n创建一个 FPS 的计时器用来调查游戏的渲染速度不失为一个好办法。\n\n我们在 JavaScript 增加 fps 对象。\n\n```JavaScript\nconst fps = new class {\n  constructor() {\n    this.fps = document.getElementById(\"fps\");\n    this.frames = [];\n    this.lastFrameTimeStamp = performance.now();\n  }\n\n  render() {\n    // Convert the delta time since the last frame render into a measure\n    // of frames per second.\n    const now = performance.now();\n    const delta = now - this.lastFrameTimeStamp;\n    this.lastFrameTimeStamp = now;\n    const fps = 1 / delta * 1000;\n\n    // Save only the latest 100 timings.\n    this.frames.push(fps);\n    if (this.frames.length > 100) {\n      this.frames.shift();\n    }\n\n    // Find the max, min, and mean of our 100 latest timings.\n    let min = Infinity;\n    let max = -Infinity;\n    let sum = 0;\n    for (let i = 0; i < this.frames.length; i++) {\n      sum += this.frames[i];\n      min = Math.min(this.frames[i], min);\n      max = Math.max(this.frames[i], max);\n    }\n    let mean = sum / this.frames.length;\n\n    // Render the statistics.\n    this.fps.textContent = `\nFrames per Second:\n         latest = ${Math.round(fps)}\navg of last 100 = ${Math.round(mean)}\nmin of last 100 = ${Math.round(min)}\nmax of last 100 = ${Math.round(max)}\n`.trim();\n  }\n};\n```\n\n接下来再每次迭代中调用 fps render 函数。\n\n```JavaScript\nconst renderLoop = () => {\n    fps.render(); //new\n\n    universe.tick();\n    drawGrid();\n    drawCells();\n\n    animationId = requestAnimationFrame(renderLoop);\n};\n```\n\n最后在 HTML 中增加 fps 的展示。\n\n```JavaScript\n<div id=\"fps\"></div>\n```\n\n增加 CSS，让它展示得更好。\n\n```CSS\n#fps {\n  white-space: pre;\n  font-family: monospace;\n}\n```\n\n好了，现在可以在页面上看到 FPS 计数器了。\n\n### 给每一刻计算时间\n\n每一刻开始调用`console.time`，结束的时候调用`console.timeEnd`。\n\n首先，要在`Cargo.toml`里面增加 web-sys。\n\n```toml\n[dependencies.web-sys]\nversion = \"0.3\"\nfeatures = [\n  \"console\",\n]\n```\n\n因为每次执行`console.time`后总要执行`console.timeEnd`，把他们包再[RAII](https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization)类型下就会更加便利。\n\n```Rust\nextern crate web_sys;\nuse web_sys::console;\n\npub struct Timer<'a> {\n    name: &'a str,\n}\n\nimpl<'a> Timer<'a> {\n    pub fn new(name: &'a str) -> Timer<'a> {\n        console::time_with_label(name);\n        Timer { name }\n    }\n}\n\nimpl<'a> Drop for Timer<'a> {\n    fn drop(&mut self) {\n        console::time_end_with_label(self.name);\n    }\n}\n```\n\n接下来，统计每一刻用的时间是多久，只需把初始化 Timer 放到 Universe 的构造函数里。\n\n```Rust\nlet _timer = Timer::new(\"Universe::tick\");\n```\n\n如下是每一刻执行的时间。\n\n![每一刻的执行时间](https://rustwasm.github.io/book/images/game-of-life/console-time.png)\n\n另外，通过使用`console.time`和`console.timeEnd`也能获得执行性能数据。\n\n![性能数据](https://rustwasm.github.io/book/images/game-of-life/console-time-in-profiler.png)\n\n### 增加宇宙大小\n\n> 本部分是拿火狐浏览器做例子，当然还有很多浏览器有类似的功能，只是有细微的差别。这个数据是一致的，但是部分命名和标量可能不一样。\n\n如果我们把宇宙修改的大一些，会发生什么？把 64x64 改成 128x128，结果会把 fps 从 60 降到 40。\n\n如果我们打开性能监控器，并看到它的瀑布图，我们可以看到动画帧用了 20 毫秒，回顾 60fps 时渲染一页则需要 16 毫秒，这不仅仅是 JavaScript 和 WebAssembly，还包括重绘的部分。\n\n![性能监视](https://rustwasm.github.io/book/images/game-of-life/drawCells-before-waterfall.png)\n\n如果仔细查看，可以看到`CanvasRenderingContext2D.fillStyle`的 setter 是很耗费时间的。\n\n> 再火狐，你可能看到的是\"DOM\"而不是\"CanvasRenderingContext2D.fillStyle\"，你需要打开\"展示 Gecko 平台数据\"。\n\n![火狐的性能监视器](https://rustwasm.github.io/book/images/game-of-life/profiler-firefox-show-gecko-platform.png)\n\n当然，这并不稀奇，40%的的时间都浪费在这个 setter 上面。\n\n> 我们可能期望性能瓶颈再 tik 函数上，但并不是。永远选择性能监视器观察，因为你可能浪费很多时间在无关的地方上面。\n\n在 drawCell 上面，fillStyle 在每次动画和每个细胞上面使用。\n\n```JavaScript\nfor (let row = 0; row < height; row++) {\n  for (let col = 0; col < width; col++) {\n    const idx = getIndex(row, col);\n\n    ctx.fillStyle = cells[idx] === DEAD\n      ? DEAD_COLOR\n      : ALIVE_COLOR;\n\n    ctx.fillRect(\n      col * (CELL_SIZE + 1) + 1,\n      row * (CELL_SIZE + 1) + 1,\n      CELL_SIZE,\n      CELL_SIZE\n    );\n  }\n}\n```\n\n现在我们知道 fillStyle 资源耗费比较多，那么我们该怎么避免他呢？我们需要判断细胞的生命状态来自决定 fillStyle 的值，设想，如果先设定`fillStyle = ALIVE_COLOR`，再绘制所有的活着的细胞，然后设置`fillStyle = DEAD_COLOR`，再设置所有的死细胞，最后我们只设置 fillStyle 两次。\n\n```JavaScript\n// Alive cells.\nctx.fillStyle = ALIVE_COLOR;\nfor (let row = 0; row < height; row++) {\n  for (let col = 0; col < width; col++) {\n    const idx = getIndex(row, col);\n    if (cells[idx] !== Cell.Alive) {\n      continue;\n    }\n\n    ctx.fillRect(\n      col * (CELL_SIZE + 1) + 1,\n      row * (CELL_SIZE + 1) + 1,\n      CELL_SIZE,\n      CELL_SIZE\n    );\n  }\n}\n\n// Dead cells.\nctx.fillStyle = DEAD_COLOR;\nfor (let row = 0; row < height; row++) {\n  for (let col = 0; col < width; col++) {\n    const idx = getIndex(row, col);\n    if (cells[idx] !== Cell.Dead) {\n      continue;\n    }\n\n    ctx.fillRect(\n      col * (CELL_SIZE + 1) + 1,\n      row * (CELL_SIZE + 1) + 1,\n      CELL_SIZE,\n      CELL_SIZE\n    );\n  }\n}\n```\n\n修改之后，刷新页面，此时的 fps 已经上升到 60。\n\n如果重新看原来的数据，现在每一刻只使用 10 毫秒。\n\n![更新后的性能检查](https://rustwasm.github.io/book/images/game-of-life/drawCells-after-waterfall.png)\n\n消除了 fillStyle 的性能瓶颈，发现比较消耗资源的是 fillRect，用来绘制每一个细胞的。\n\n![目前的性能损耗都在fillRect上面](https://rustwasm.github.io/book/images/game-of-life/drawCells-after-flamegraph.png)\n\n### 让时间变快\n\n有些人可能不喜欢等待，更希望一帧跑完九刻而不是一刻。我们可以通过修改 renderLoop 函数实现。\n\n```JavaScript\nfor (let i = 0; i < 9; i++) {\n  universe.tick();\n}\n```\n\n在机器上，fps 降到了 35，但是我们一定要到 60fps！\n\n现在我们知道性能瓶颈在 tick 函数上面，所以我们给函数的每一步都加上 Timer 监视，我猜测是创建向量和释放向量占用了很多资源造成的。\n\n```Rust\npub fn tick(&mut self) {\n    let _timer = Timer::new(\"Universe::tick\");\n\n    let mut next = {\n        let _timer = Timer::new(\"allocate next cells\");\n        self.cells.clone()\n    };\n\n    {\n        let _timer = Timer::new(\"new generation\");\n        for row in 0..self.height {\n            for col in 0..self.width {\n                let idx = self.get_index(row, col);\n                let cell = self.cells[idx];\n                let live_neighbors = self.live_neighbor_count(row, col);\n\n                let next_cell = match (cell, live_neighbors) {\n                    // Rule 1: Any live cell with fewer than two live neighbours\n                    // dies, as if caused by underpopulation.\n                    (Cell::Alive, x) if x < 2 => Cell::Dead,\n                    // Rule 2: Any live cell with two or three live neighbours\n                    // lives on to the next generation.\n                    (Cell::Alive, 2) | (Cell::Alive, 3) => Cell::Alive,\n                    // Rule 3: Any live cell with more than three live\n                    // neighbours dies, as if by overpopulation.\n                    (Cell::Alive, x) if x > 3 => Cell::Dead,\n                    // Rule 4: Any dead cell with exactly three live neighbours\n                    // becomes a live cell, as if by reproduction.\n                    (Cell::Dead, 3) => Cell::Alive,\n                    // All other cells remain in the same state.\n                    (otherwise, _) => otherwise,\n                };\n\n                next[idx] = next_cell;\n            }\n        }\n    }\n\n    let _timer = Timer::new(\"free old cells\");\n    self.cells = next;\n}\n```\n\n看这些时间戳，很明显我的猜测是错误的：大部分时间确实用在计算下一代细胞上面，每一刻都调用和释放向量竟然无足轻重。所以一定要使用性能监视器！\n\n![性能监视](https://rustwasm.github.io/book/images/game-of-life/console-time-in-universe-tick.png)\n\n下一部分需要`nightly`编译，因为我们将会使用[test-feature-gate](https://doc.rust-lang.org/unstable-book/library-features/test.html)来跑 benchmark（性能测试）。我们将会安装另一个工具[cargo-benchcmp](https://github.com/BurntSushi/cargo-benchcmp)。一个迷你的有`cargo bench`支持的性能测试工具。\n\n让我们写一个函数使用`#[bench]`属性，我们可以使用更成熟的测试工具测试它。\n\n```Rust\n#![feature(test)]\n\nextern crate test;\nextern crate wasm_game_of_life;\n\n#[bench]\nfn universe_ticks(b: &mut test::Bencher) {\n    let mut universe = wasm_game_of_life::Universe::new();\n\n    b.iter(|| {\n        universe.tick();\n    });\n}\n```\n\n我们也要注释掉所有`#[wasm_bindgen]`，否则\"cdylib\"或则其他编译流程会失败，\n\n此时，我们可以跑`cargo bench | tee before.txt`来编译项目查看性能日志了！\n\n```shell\n$ cargo bench | tee before.txt\n    Finished release [optimized + debuginfo] target(s) in 0.0 secs\n     Running target/release/deps/wasm_game_of_life-91574dfbe2b5a124\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n     Running target/release/deps/bench-8474091a05cfa2d9\n\nrunning 1 test\ntest universe_ticks ... bench:     664,421 ns/iter (+/- 51,926)\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out\n```\n\n他也告诉我们二进制文件的位置，我们可以跑第二次性能测试。但这次可以使用系统的性能测试工具。因为我用的是 Linux，所以 perf 就是我的测试工具。\n\n```shell\n$ perf record -g target/release/deps/bench-8474091a05cfa2d9 --bench\nrunning 1 test\ntest universe_ticks ... bench:     635,061 ns/iter (+/- 38,764)\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out\n\n[ perf record: Woken up 1 times to write data ]\n[ perf record: Captured and wrote 0.178 MB perf.data (2349 samples) ]\n```\n\n查看性能测试报告，得知所有的时间都如期使用在`Universe::tick`。\n\n![perf的结果](https://rustwasm.github.io/book/images/game-of-life/bench-perf-report.png)\n\nperf 会指明函数中到底是什么操作引起的性能损耗（译者：虽然我也没看出来）。\n\n![perf的结果](https://rustwasm.github.io/book/images/game-of-life/bench-perf-annotate.png)\n\n它告诉我们 26.67%的时间花在总和细胞数目，23.41%的时间花在获取列序号，另外 15.42%花在取得行序号。这三个性能瓶颈中，第二和第三都使用了比较耗费性能的 DIV 命令。这些 DIV 的实现是在`Universe::live_neighbor_count`。\n\n回想这个函数的定义：\n\n```Rust\nfn live_neighbor_count(&self, row: u32, column: u32) -> u8 {\n    let mut count = 0;\n    for delta_row in [self.height - 1, 0, 1].iter().cloned() {\n        for delta_col in [self.width - 1, 0, 1].iter().cloned() {\n            if delta_row == 0 && delta_col == 0 {\n                continue;\n            }\n\n            let neighbor_row = (row + delta_row) % self.height;\n            let neighbor_col = (column + delta_col) % self.width;\n            let idx = self.get_index(neighbor_row, neighbor_col);\n            count += self.cells[idx] as u8;\n        }\n    }\n    count\n}\n```\n\n使用取余运算是为了避免使用杂乱的 if 代码来处理边界，但导致我不得不用 DIV 这样比较耗费性能的指令。相反，如果用 if 处理边界，并展开循环，则分支条件将会比较适合 CPU 处理。\n\n```Rust\nfn live_neighbor_count(&self, row: u32, column: u32) -> u8 {\n    let mut count = 0;\n\n    let north = if row == 0 {\n        self.height - 1\n    } else {\n        row - 1\n    };\n\n    let south = if row == self.height - 1 {\n        0\n    } else {\n        row + 1\n    };\n\n    let west = if column == 0 {\n        self.width - 1\n    } else {\n        column - 1\n    };\n\n    let east = if column == self.width - 1 {\n        0\n    } else {\n        column + 1\n    };\n\n    let nw = self.get_index(north, west);\n    count += self.cells[nw] as u8;\n\n    let n = self.get_index(north, column);\n    count += self.cells[n] as u8;\n\n    let ne = self.get_index(north, east);\n    count += self.cells[ne] as u8;\n\n    let w = self.get_index(row, west);\n    count += self.cells[w] as u8;\n\n    let e = self.get_index(row, east);\n    count += self.cells[e] as u8;\n\n    let sw = self.get_index(south, west);\n    count += self.cells[sw] as u8;\n\n    let s = self.get_index(south, column);\n    count += self.cells[s] as u8;\n\n    let se = self.get_index(south, east);\n    count += self.cells[se] as u8;\n\n    count\n}\n```\n\n接下来再跑一次性能测试，将他输出到`after.txt`。\n\n```shell\n$ cargo bench | tee after.txt\n   Compiling wasm_game_of_life v0.1.0 (file:///home/fitzgen/wasm_game_of_life)\n    Finished release [optimized + debuginfo] target(s) in 0.82 secs\n     Running target/release/deps/wasm_game_of_life-91574dfbe2b5a124\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n     Running target/release/deps/bench-8474091a05cfa2d9\n\nrunning 1 test\ntest universe_ticks ... bench:      87,258 ns/iter (+/- 14,632)\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out\n```\n\n感觉性能提高了不少，现在对比一下前后的数据。\n\n```shell\n$ cargo benchcmp before.txt after.txt\n name            before.txt ns/iter  after.txt ns/iter  diff ns/iter   diff %  speedup\n universe_ticks  664,421             87,258                 -577,163  -86.87%   x 7.61\n```\n\n哇！提高了 7.61 倍！\n\nWebAssembly 意图和原生系统贴近，但是我们确实需要在 WebAssembly 环境下也作一次测试。\n\n从新编译程序，刷新浏览器页面，画面重新跑在 60fps，每一帧大概是 10 毫秒。\n\n成功！\n\n![测试结果](https://rustwasm.github.io/book/images/game-of-life/waterfall-after-branches-and-unrolling.png)\n\n### 练习\n\n- 现在，下一个性能瓶颈是`Universe::tick`调用和释放函数的部分，尝试缓存细胞状态，让 Universe 维护两个向量，永远不释放他们，也不掉用新的区间。\n- 换一种方式实现游戏，让 Rust 和 JavaScript 以细胞的列表交互，这样能让渲染画布更快吗？你能实现这个设计同时不在每个 tick 函数中调用新的列表吗？\n- 就性能显示来看 2D 画布渲染显然不够快，使用 WebGL 画布重新渲染，WebGL 能多快？使用 WebGL 能在遇到瓶颈前创建多大的宇宙空间？\n\n## 压缩.wasm 文件大小\n\nrustc 有很多配置项，可以让`.wasm`二进制文件更加小。在很多情况下更小的生成文件意味着更长的编译时间。另外更小的文件使得 WebAssembly 的运行时间更长。我们应该意识到这些方面上的牺牲。在这些情况下，当我们要减少编译文件大小时，我们应该考虑到使用性能监视器衡量一下这种改动是否值得。\n\n### 使用链接配置器编译\n\n在`Cargo.toml`，增加`lto=true`：\n\n```toml\n[profile.release]\nlto = true\n```\n\n者给予 LLVM 更多机会去内联和简化函数，不仅仅会使`.wasm`更小，还会让他在运行时运行得更快！但是会让他编译得更长。\n\n### 配置 LLVM 牺牲速度换文件大小\n\nLLVM 默认配置是为了运行速度，并不是大小。我们可以通过更改`Cargo.toml`去修改这一配置。\n\n```toml\n[profile.release]\nopt-level = 's'\n```\n\n或者，更激进的可以把它改成\"z\"。\n\n但是，配置为\"s\"的时候有的时候会比\"z\"更小，所以一定要做测量！\n\n### 使用 wasm-opt 工具\n\n[Binaryen](https://github.com/WebAssembly/binaryen)是一个关于 WebAssembly 编译工具的集合。他比 LLVM 更加后端，使用`wasm-opt`处理生成文件常常会节省 15%~20%的代码，同时又会提高运行速度。\n\n```\n# 输出为压缩的文件大小。\nwasm-opt -Os -o output.wasm input.wasm\n\n# 更激进的输出为压缩的文件大小。\nwasm-opt -Oz -o output.wasm input.wasm\n\n# 输出文件追求运行速度。\nwasm-opt -O -o output.wasm input.wasm\n\n# 输出文件更激进的追求运行速度。\nwasm-opt -O3 -o output.wasm input.wasm\n```\n\n#### 注意调试信息\n\n占用生成文件大小的主要成分是调试信息和函数名。`wasm-pack`能够默认移除调试信息。然而`wasm-opt`在使用`-g`参数时能删除函数名。\n\n这意味着，如果你按照以上操作，生成文件应该既没有调试信息也没有函数名。如果你想保留某些调试信息，请一定注意这一点。\n\n### 文件大小检查调查\n\n如果修改编译配置不能获得更小的文件大小，就应该调查一下是什么代码导致文件太大。\n\n> 就像做性能测试，我们应让工具来判断哪里出了问题，否则我们会浪费更多自己的时间。\n\n#### twiggy 代码检查器\n\n[twiggy](https://github.com/rustwasm/twiggy)是一个支持 WebAssembly 的代码大小检查器，他能分析二进制代码的调用图，并解决如下问题：\n\n- 为什么这个函数被编译到这段代码中。\n- 这个函数占用大小是多少？如果我删除这个函数以及其相关函数我能节省多大的空间？\n\n```\n$ twiggy top -n 20 pkg/wasm_game_of_life_bg.wasm\n Shallow Bytes │ Shallow % │ Item\n───────────────┼───────────┼────────────────────────────────────────────────────────────────────────────────────────\n          9158 ┊    19.65% ┊ \"function names\" subsection\n          3251 ┊     6.98% ┊ dlmalloc::dlmalloc::Dlmalloc::malloc::h632d10c184fef6e8\n          2510 ┊     5.39% ┊ <str as core::fmt::Debug>::fmt::he0d87479d1c208ea\n          1737 ┊     3.73% ┊ data[0]\n          1574 ┊     3.38% ┊ data[3]\n          1524 ┊     3.27% ┊ core::fmt::Formatter::pad::h6825605b326ea2c5\n          1413 ┊     3.03% ┊ std::panicking::rust_panic_with_hook::h1d3660f2e339513d\n          1200 ┊     2.57% ┊ core::fmt::Formatter::pad_integral::h06996c5859a57ced\n          1131 ┊     2.43% ┊ core::str::slice_error_fail::h6da90c14857ae01b\n          1051 ┊     2.26% ┊ core::fmt::write::h03ff8c7a2f3a9605\n           931 ┊     2.00% ┊ data[4]\n           864 ┊     1.85% ┊ dlmalloc::dlmalloc::Dlmalloc::free::h27b781e3b06bdb05\n           841 ┊     1.80% ┊ <char as core::fmt::Debug>::fmt::h07742d9f4a8c56f2\n           813 ┊     1.74% ┊ __rust_realloc\n           708 ┊     1.52% ┊ core::slice::memchr::memchr::h6243a1b2885fdb85\n           678 ┊     1.45% ┊ <core::fmt::builders::PadAdapter<'a> as core::fmt::Write>::write_str::h96b72fb7457d3062\n           631 ┊     1.35% ┊ universe_tick\n           631 ┊     1.35% ┊ dlmalloc::dlmalloc::Dlmalloc::dispose_chunk::hae6c5c8634e575b8\n           514 ┊     1.10% ┊ std::panicking::default_hook::{{closure}}::hfae0c204085471d5\n           503 ┊     1.08% ┊ <&'a T as core::fmt::Debug>::fmt::hba207e4f7abaece6\n```\n\n#### 手动修改 LLVM-IR\n\nLLVM-IR 是 LLVM 生成 WebAssembly 代码的最后一步。所以，他和最终生成的 WebAssembly 很像。更多的 LLVM-IR 代码意味着生成的文件越大，当一个函数占用了 LLVM-IR 中 25%的位置，则代表他占用了 25%的文件大小。当然这些数字只是个经验值，因为 LLVM-IR 还有一些 WebAssembly 没有的重要的信息（因为 WebAssembly 没有诸如 DWARF 调试信息）。\n\n你可以使用 cargo 生成 LLVM-IR 代码：\n\n```shell\ncargo rustc --release -- --emit llvm-ir\n```\n\n接下来你可以使用 find 命令去寻找存储在 cargo 生成目录(target)下的`.ll`文件。\n\n```shell\nfind target/release -type f -name '*.ll'\n```\n\n相关可以参考[LLVM 语言](https://llvm.org/docs/LangRef.html)\n\n#### 更激进的工具\n\n修改编译配置是比较好上手的。如果你想前进一个里程，你可以使用一些更激进的工具，像是重写代码以减少冗余。以下是一些不太优雅的代码，但是的确能减少生成文件大小。\n\n##### 避免字符串格式化\n\n`format!`,`to_string`等，能加入很多冗余代码。如果可能，在调试环境用格式化，而在发布环境使用静态字符串。\n\n##### 避免使用崩溃\n\n这很明显，使用 twiggy 之类的工具或者人工检查 LLVM-IR 能帮助你查出到底哪个函数崩溃。\n\n崩溃并不总是出现在`panic!()`宏，他们会在很多情况下出现。\n\n- 访问切片越界，如：`my_slice[i]`\n- 除 0，如：`dividend/divider`\n- 解 Option 类型或者 Result 类型，如：`opt.unwrap()`或者`res.unwrap()`\n\n前两个可以被改成第三个，访问切片可以使用`my_slice.get(i)`。除法可以使用`checked_div`，所以你只有一种需要处理的情况。\n\n解开`Option`或者`Result`有两种方法安全的和不安全的。\n\n安全的方式是使用 abort 方法而不是返回 None 和 Error 值。\n\n```Rust\n#[inline]\npub fn unwrap_abort<T>(o: Option<T>) -> T {\n  use std::process;\n  match o {\n    Some(t) => t,\n    None => process::abort(),\n  }\n}\n```\n\n最终，崩溃在`wasm32-unknown-unknown`被翻译成退出，因此不会造成代码冗余。\n\n相反的，[unreachable](https://crates.io/crates/unreachable)包为 Option 和 Result 类型提供不安全的[unchecked_unwrap](https://docs.rs/unreachable/1.0.0/unreachable/trait.UncheckedOptionExt.html#tymethod.unchecked_unwrap)方法。让 Rust 编译器假定 Option 类型是 Some 类型而 Result 类型是 Ok 类型。如果值是不正确的的情况是未被考虑的。你一定要在 110%确认的情况下使用这个包，因为编译器可没那么聪明能预估出错误。即使你这么做了，你一定要在调试环境下面做检查，而在发布环境下去掉检查。\n\n#### 避免调用内存或者使用 wee_alloc\n\nRust 的默认调用器是`dlmalloc`的一部分。它能达到 10KB。如果能够避免动态调用，你应该能省下 10KB。\n\n完全避免动态语言调用可能会非常困难。但是删除调用却在某些情况下很简单，在这些情况下，可以使用[`wee_alloc`](https://github.com/rustwasm/wee_alloc)代替全局的调用器可以从 10KB 中节省很多。`we_alloc`是当你想要一些调用器时的一个选择，并能同时减少代码大小。\n\n#### 使用 trait 来替代泛型\n\n当你创建一些泛型函数。\n\n```Rust\nfn whatever<T: MyTrait>(t: T) { ... }\n```\n\n`rustc`和 LLVM 会为不同类型生成新的函数拷贝。这为编译器提供了各种类型使用这个函数的机会。但会增加代码大小。\n\n如果你为对象提供 trait，如下：\n\n```Rust\nfn whatever(t: Box<MyTrait>) { ... }\n// or\nfn whatever(t: &MyTrait) { ... }\n// etc...\n```\n\n这样经过虚调用动态派遣（dynamic dispatch）的方法就被使用了，如此只会用一个函数会放在`.wasm`。这样的缺点是丢失了编译器自定义的机会，并且增加了不直接的，动态的语言调用。\n\n#### 使用 wasm-snip 工具\n\n[`wasm-snip`](https://github.com/fitzgen/wasm-snip)使用`unreachable`方法代替了 WebAssembly 的函数。这是一个又沉又钝的锤子，更像是徒手。\n\n也许你知道有些函数可能永远不会在运行时被调用，但是编译器不能保证？掐了他！执行`wasm-opt`加上`--dce`参数，所有无关函数就会被剪掉。\n\n这个工具对删除崩溃及其有用。\n\n### 我们能把生命游戏缩到多小？\n\n默认的配置下，WebAssembly 二进制大小为 29410 字节。\n\n```shell\n$ wc -c pkg/wasm_game_of_life_bg.wasm\n29410 pkg/wasm_game_of_life_bg.wasm\n```\n\n打开 LTO 之后设置`opt-level=\"z\"`执行`wasm-opt -Oz`，结果是 17317 字节。\n\n```shell\n$ wc -c pkg/wasm_game_of_life_bg.wasm\n17317 pkg/wasm_game_of_life_bg.wasm\n```\n\n如果使用 gzip 压缩，你能搞到 9045 字节！\n\n```shell\n$ gzip -9 < pkg/wasm_game_of_life_bg.wasm | wc -c\n9045\n```\n\n### 练习\n\n- 使用`wasm-snp`工具删掉会有崩溃的函数，它能减少多少字节？\n- 使用`wee_alloc`作为全局调用器，，修改`Cargo.toml`：\n\n```\n[features]\ndefault = [\"wee_alloc\"]\n```\n\n能够减少多少大小呢？\n\n- 我们只实现了一个 Universe，所以相比使用构造器，我们可以导出一个`static mut`实例，如果这个实例使用的是双向缓存，我们也可以让这些缓存也是全局`staic mut`。这样就移除了所有的动态调用，我们可以增加`#![no_std]`包取消掉调用器。这回能缩小多少大小？\n\n## 发布到 NPM\n\n首先，确保你登入了 npm。\n\n接着，使用`wasm-pack login`登入。\n\n### 发布\n\n确保已经执行`wasm-pack build`并且 pkg 文件已经编译好。\n\n已经准备好之后，跑`wasm-pack publish`上传包到 npm。\n\n这样就发布了！\n\n有哥们照着这个指导做完发布失败，是因为\"name\"字段存在重名\n\n```toml\n[package]\nname = \"wasm-game-of-life-my-username\"\n```\n\n接着，重新编译并发布\n\n```shell\nwasm-pack build\nwasm-pack publish\n```\n\n这会应该能行。\n\n## 与 JavaScript 相互交互\n\n### JavaScript 函数的输出和引用\n\n#### 在 Rust 一边\n\n在 JavaScript 为主的世界里使用 WebAssembly，引入和输出函数比较直接，有点类似于 C。\n\nWebAssembly 模块声明了一系列引入，每一个都有模块名。模块名可以使用`#[link(wasm_import_module)]`提供给`extern {...}`。\n\n导出的 WebAssembly 线性内存被导出作\"memory\"。\n\n```Rust\n// import a JS function called `foo` from the module `mod`\n#[link(wasm_import_module = \"mod\")]\nextern { fn foo(); }\n\n// export a Rust function called `bar`\n#[no_mangle]\npub extern fn bar() { /* ... */ }\n```\n\n因为 WebAssembly 的值类型有局限，这些函数只有基础的数字类型。\n\n#### 在 JavaScript 一边\n\n在 JavaScript 中，wasm 二进制文件转换成 ES6 模块。它必须被实例化为线性内存并由一系列函数能对应到这些引入。细节描述可在[MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiateStreaming)找到。\n\nES6 的模块包括从 Rust 暴露给 JavaScript 的函数，现在可以用 JavaScript 调用。\n\n[这里](https://www.hellorust.com/demos/add/index.html)有一个很简单的构建流程。\n\n### 除了数字\n\n当在 JavaScript 中使用 WebAssembly，WebAssembly 的内存和 JavaScript 的内存有很大的不同。\n\n- 每个 WebAssembly 模块的线性内存，JavaScript 可以自由访问。\n- 对应之下，WebAssembly 不能访问 JavaScript 的内存。\n\n所以，有两种复杂的交互。\n\n- 复制二进制数据到 WebAssembly 内存。\n- 建立一个在 JavaScript 上的堆内存，提供一堆地址。这样 WebAssembly 访问 JavaScript 对象，间接通过 JavaScript 访问。\n\n幸运的是，通过`bindgen`框架[`wasm-bindgen`](https://github.com/rustwasm/wasm-bindgen)可以帮助交互。这个框架可以将已习惯的 Rust 语言自动翻译到 JavaScript。\n\n### 自定义部分（译者：所以这个到底是干什么用的？）\n\n自定义部分允许随意继承人一的数据进入 WebAssembly 模块，这个数据是在编译时设置，不能在运行时修改。\n\n在 Rust 中，自定义部分是通过`#[link_section]`属性暴露的静态数组([T; size])。\n\n```Rust\n#[link_section = \"hello\"]\npub static SECTION: [u8; 24] = *b\"This is a custom section\";\n```\n\n这样给 wasm 增加一个 hello 部分，这个 SECTION 变量是随意的，但是无论怎么赋值，内容总是这些文字。\n\n这个自定义内容可以被 JavaScript 通过[`WebAssembly.Module.customSections`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Module/customSections)获得自定义部分，它返回一个`ArrayBuffer`，如果有同名的部分，他们会被放到一个数组中。\n\n```JavaScript\nWebAssembly.compileStreaming(fetch(\"sections.wasm\"))\n.then(mod => {\n  const sections = WebAssembly.Module.customSections(mod, \"hello\");\n\n  const decoder = new TextDecoder();\n  const text = decoder.decode(sections[0]);\n\n  console.log(text); // -> \"This is a custom section\"\n});\n```\n\n## 哪些包能在 WebAssembly 下面使用\n\n最简单的就是列出 WebAssembly 上能用的 Rust 包：如果避开了以下内容，则这些包可以在 WebAssembly 使用。如果一个包支持`#![no_std]`\n的包，这个包也可能支持 WebAssembly。\n\n### 以下包不能使用\n\n#### C 和系统级依赖\n\nWebAssembly 不提供系统一级别的库，所以任何链接系统库的地方都无法成功。\n\n使用 C 库可能不会成功，既然没有稳定的交叉编译 ABI，和提供给 WebAssembly 交叉链接的连接库。虽然 clang 已经发布 wasm32 的生成，但是还远远不足。\n\n#### 文件 I/O\n\nWebAssembly 没有访问文件系统的功能，所以访问文件系统的库都不能使用。\n\n#### 调用线程\n\n目前有计划[加入线程](https://rustwasm.github.io/2018/10/24/multithreading-rust-and-wasm.html)，但是还没被发布。尝试调用线程会导致崩溃。\n\n### 有哪些目的的包能在 WebAssembly 下面使用\n\n如果只是提供[算法](https://crates.io/categories/algorithms)和[数据结构](https://crates.io/categories/data-structures)的包。\n\n#### #![no-std]\n\n[不依赖于标准库的包](https://crates.io/categories/no-std)能够运行在 WebAssembly 下面。\n\n#### 解析器\n\n只要是接受输入且无需文件操作的[解析器](https://crates.io/categories/parser-implementations)就可能运行在 WebAssembly 下。\n\n#### 文字处理\n\n[复杂的语言处理](https://crates.io/categories/text-processing)可能会运行在 WebAssembly 下面。\n\n#### Rust 范式\n\n[适用于不同情况下的包](https://crates.io/categories/rust-patterns)可能运行在 WebAssembly 下。\n\n## 如何给常用库增加 WebAssembly 支持\n\n本部分讲解如何将常用库增加 WebAssembly 支持。后面的内容我就捡感兴趣的写了。\n\n### 在 CI 增加 wasm32-unknown-unknown\n\n保证 CI 中增加如下命令\n\n```shell\nrustup target add wasm32-unknown-unknown\ncargo check --target wasm32-unknown-unknown\n```\n\n举个例子，在 travis 的配置中增加如下配置：\n\n```yaml\nmatrix:\n  include:\n    - language: rust\n      rust: stable\n      name: \"check wasm32 support\"\n      install: rustup target add wasm32-unknown-unknown\n      script: cargo check --target wasm32-unknown-unknown\n```\n\n### 在 node.js 或者无头浏览器（译者：卧槽是这么翻译么）\n\n你可以使用`wasm-bindgen-test`和`wasm-pack test`去跑测试，详细内容上面已经提到。\n\n## 发布 WebAssembly 到线上\n\n> 发布过程几乎和任何 web 应用发布是一样的。\n\n为了发布 Web 应用，复制生成文件到线上环境，配置你的 HTTP 服务器让他们可访问。\n\n### 保证服务器支持 application/wasm\n\n为了让浏览器加载变快，[WebAssembly.instantiateStreaming](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiateStreaming)函数会使用管道传输文件（请确定你的打包器能够使用这个函数）。但是 instantiateStreaming 需要 HTTP 返回类型支持`application/wasm`，否则会丢出错误。\n\n- [如何配置 Apache 服务器](https://httpd.apache.org/docs/2.4/mod/mod_mime.html#addtype)\n- [如何配置 Nginx 服务器](https://nginx.org/en/docs/http/ngx_http_core_module.html#types)\n\n### 更多内容\n\n- [webpack 线上打包的最佳实践](https://webpack.js.org/guides/production/)\n","collection":"blog","data":{"type":"post","category":"fe","tag":["rust","wasm"]}},{"id":"2020/02/28/Movie-supplementary-file-plan-filial-piety-and-grandson.md","slug":"2020/02/28/movie-supplementary-file-plan-filial-piety-and-grandson","body":"\n# 电影补档计划：孝子贤孙伺候着\n\n![孝子贤孙伺候着](https://img9.doubanio.com/view/photo/l/public/p2376859119.webp)\n\n故事就是男主角（陈佩斯饰）在政府工作支持火葬，然而家里老人（赵丽蓉饰）不同意，老人装死试试孩子能不能真的去土葬，结果儿子大操大办整得一片慌乱，最终老人认清事实，同意火葬。\n\n很荒诞的喜剧，可惜画质已经不行了。\n","collection":"blog","data":{"type":"post","category":"movie"}},{"id":"2020/02/29/Movie-supplementary-program-imitate-the-game.md","slug":"2020/02/29/movie-supplementary-program-imitate-the-game","body":"\n# 电影补档计划：模仿游戏\n\n![the imitation game](https://img3.doubanio.com/view/photo/l/public/p2216739941.webp)\n\n阿兰图灵二战时期被安排秘密破译德军的电报「英格玛」，「英格玛」是一台每天变更配置的加密机器，即使已经截获了机器也无法破解，必须猜出配置，图灵希望制造一台机器来破译，然而和同事发生分歧。幸好图灵遇到了琼，琼成为了小组的粘合剂，终于使小组齐心协力完成了初代图灵机。图灵以自己的初恋命名其为 Christopher。然而 Christopher 还是无法快速解密，机缘巧合，图灵从琼的朋友口中得知可以通过几个固定词语解密。终于图灵机通过解密「希特勒万岁」解开密码，然而，为了让德国不知道英国已经解开秘密，不得不牺牲很多士兵。即使是战争结束，小组也不能泄露信息。\n\n后来图灵因为同性恋而被指控，接受激素治疗，最终选择自杀。而模拟游戏则是图灵提出的，通过对话判断对方是否是机器的方法。\n","collection":"blog","data":{"type":"post","category":"movie"}},{"id":"2020/03/01/2.md","slug":"2020/03/01/2","body":"\n# 2 月总结\n\n整理一下整个二月完全在家窝着的结果。\n\n## 回顾一下一月计划的完成情况\n\n- （完成）蛋白粉买了\n- （完成）整理爬虫+单侧（写完了）\n- （进行中）rust 开发前端，完成了一部份，还差个成果\n- （重判中）写了个 hello world 的 flutter 应用，目前来看没有 react native 那么喜爱\n- （未做）旅游计划还没做\n- （未做）报名 5 月的雅思\n\n## 二月的工作总结\n\n- 完成了 python 爬虫一揽子的 Windows 开发，目前来说谈不上喜爱吧，毕竟 python 的语法和别的语言不一样，导致我除非天天只用 python 否则难以习惯，再一个类型库没有 TypeScript 好，虽然 VScode 体验比原生 JavaScript 好，但是远不如 TypeScript。\n- 电影：\n  1. 「1917」\n  2. 「好莱坞往事」\n  3. 「乔乔兔」\n  4. 「婚姻故事」\n  5. 「利刃出鞘」\n  6. 「时空旅人」\n  7. 「孝子贤孙伺候着」\n  8. 「模仿游戏」\n- 美剧：\n  1. 「九号秘事」\n- Rust 在 web 上面学习：\n  1. 服务端：actix_web，对比 Rust 的学习曲线，这个框架还真是简单。\n  2. 客户端：\n     - GTK，太丑\n     - QT，太难链接\n     - flutter，以后说\n     - WebAssembly，目前还在继续\n- Flutter 学习：\n  1. 完全依赖翻墙，国内学习起来太困难了\n  2. 语法虽然看起来 JavaScript，但思想上完全是 Java\n- ruby：\n  1. 国内写 ruby 比写 flutter 都难...\n- 软件开发：\n  1. 利用 Stryker 做 mutation 测试，这里受益很多。\n- Windows 舒适计划：\n  1. strokePlus，能够在桌面使用鼠标手势\n  2. mouse without borders，能让四台 PC 共用一个鼠标。\n- 新工具：\n  1. insta360 Go：去年就想买了，跌破 1000 之后马上入手嘻嘻。\n  2. 买了个 east top 的 C-G 口琴，虽然音质没有 boogie man 好，但是能够用 G 调还是比较爽的。\n- 新书进程：\n  1. （已完成）「你不懂的 JavaScript 上卷」，原作者正在更新第二版，第二版内容比第一版更加深刻，十分推荐。\n  2. （进行中）「你不懂的 JavaScript 中卷」，目前原作者没更新到第二版，在看第一版。\n  3. （计划）「你不懂的 JavaScript 下卷」，同上。\n  4. （进行中）「Kotlin 程序员面试算法宝典」，这是工业出版社疫情期间免费发的书，寻思给他翻译成 TypeScript 版本。\n\n## 总结\n\n往往一件事情无法推进，可能是因为它不能度量，本月我在尝试结合微软的 to do 应用和 GitHub 结合（哎？都是微软了）很好的推进了一些事情。\n\n但是还有一些事情，比如整理数据结构历史、准备雅思考试等工作还是存在拖延。\n\n## 3 月计划\n\n- 完成 game of life\n- 完成「你不懂的 JavaScript」中卷和下卷\n- 开始完成阅读词汇背诵\n- 完成「CSS 揭秘」\n- 把博客搞成基于 Gatsby\n- 努力开始粤语的 to do\n- 努力开始「美国名师带你学口琴」\n- 开始「程序员的数学（线性代数）」\n- 开始「函数式编程思维」\n- 参考看一下「Algorithms for visual design using the processing language」\n- 参考看一下「自制编程语言」\n\n三月 flag 有点多，并不是要全部完成，尽全力就好。\n","collection":"blog","data":{"type":"post","category":"plan"}},{"id":"2020/03/05/Jekyll-Gatsby.md","slug":"2020/03/05/jekyll-gatsby","body":"\n# 从 Jekyll 迁移博客到 Gatsby\n\n很久以前就想迁移了，但是一直没下手，原因很简单，就是 ruby 不太熟悉，而使用 node 工具链比较趁手。\n\n当然了，Gatsby 的主题对比 Jekyll 就少太多了，没关系，大不了自己设计（又是一个大坑）。\n\n[Gatsby 官网](https://www.gatsbyjs.org/)的 tutorial 已经很详细了，这里只提简单的几个注意。\n\n- 所谓的 TypeScript 项目仅仅指的是前端，后端部分（因为是静态服务，应该说成编译的钩子`gatsby-node.js`）还是用的是 JavaScript，但是可以通过引入`ts-node`实现引用 TypeScript 文件。\n\n- 不确定是不是 WSL 或者 Windows 的锅，执行`gatsby develop`或者`gatsby build`的时候会偶尔出现权限无法访问并在根目录创建`reduxcache*`文件，挺烦人的其实，回头还得执行`sudo rm -Rf reduxcahce*`删除。\n\n- 无论`components`还是`pages`，其实都做了一层隐式封装，所以只有`default`暴露的组件参能使用 Gatsby 里面诸如`useStaticQuery`的钩子函数。\n\n- Gatsby 默认的 URL 格式和 Jekyll 不一样，为了保持持续性，我修改了`server/onCreateNode`来修改文件的 URL。\n\n- 修改 Travis 上传到`gh-pages`分支后，服务竟然挂了，查看 setting 说我只能在`master`分支上面放编译后的文件（莫非政策有变化？）。无所谓了，把`gatsby`分支改成默认分支，设置`master`分支为部署分支即可。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["jekyll","gatsby"]}},{"id":"2020/03/06/Utterance-GitHub-issue.md","slug":"2020/03/06/utterance-github-issue","body":"\n# 使用 Utterance 为博客添加基于 Github-issue 的评论系统\n\n最近在重构我部署在 GitHub pages 的博客，本来不想添加评论系统的，但是手贱，非想要加一个。\n\n尝试了 disqus（一个在国内无法使用的评论系统），貌似`page.url`中不能使用中文字符...这就尴尬了，突然想起来以前看 hackernews 的时候有人提起过使用 GitHub issue 搭建博客的想法。如果你是直接使用静态页面做网站，只需要去[Utterance](https://utteranc.es/)授权 GitHub 账号，复制对应的代码粘贴到网站即可。\n\n因为我新重构的网站是基于 Gatsby 的，Utterance 也提供了[react 高阶组件](https://www.npmjs.com/package/with-utterances)可以使用。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["github"]}},{"id":"2020/03/09/JS.md","slug":"2020/03/09/js","body":"\n# 读完「你不知道的 JS」第一版\n\n![book cover](./you-dont-know-about-JS.jpg)\n\n「你不知道的 JS」是[getify](https://github.com/getify)的一本关于深究 JavaScript 的书，中文版分为三册，前一阵子发现作者正在更新第二版，读了几页真的不错，于是找来第一版读了下。\n\n第一版第一册就是深究词法、上下文，这些东西大部分书都提的比较少，说实话，虽然我已经了解了，但是总是忘。这本书第二版比第一版好太多了，有兴趣的可以去读一下。\n\n第二册，异步，关于 promise 和生成器，应该是现有的关于异步写的最详细的书了，不过我更感兴趣他能更深度讲解一下 observable，虽然这个还不是 JavaScript 的标准。\n\n第三册，ES6 相关，很有趣的是，真本书前半部分都是关于第一第二册的简述，所以如果你刚好上不了网只能买书的话，直接看这一本也差不多。\n\n后面我可能会读一下书中推荐的[Functiional Light JS](https://github.com/getify/Functional-Light-JS)，以及 2ality 写的[Deep JavaScript: Theory and techniques](https://exploringjs.com/deep-js/)。\n","collection":"blog","data":{"type":"post","category":"book","tag":["JavaScript"]}},{"id":"2020/03/10/docker-strapi.md","slug":"2020/03/10/docker-strapi","body":"\n# 腾讯云 docker 安装 strapi\n\n## Docker engine\n\n如下是[官网的安装过程](https://docs.docker.com/install/linux/docker-ce/ubuntu/)，首先移出 Ubuntu 原有的 docker（如果有的话）\n\n```shell\n sudo apt-get remove docker docker-engine docker.io containerd runc\n sudo apt-get update\n```\n\n安装相关依赖\n\n```\nsudo apt-get install \\\n    apt-transport-https \\\n    ca-certificates \\\n    curl \\\n    gnupg-agent \\\n    software-properties-common\n```\n\n增加 docker 的安装源\n\n```shell\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n```\n\n开始安装（我的架构是 x86_64）\n\n```shell\nsudo add-apt-repository \\\n   \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\\n   $(lsb_release -cs) \\\n   stable\"\n\nsudo apt-get update\nsudo apt-get install docker-ce docker-ce-cli containerd.io\n```\n\n## Docker compose\n\n安装新版本`docker-compose`，因为文件存储在 github 上面，这里直接从 DaoCloud 下载。\n\n```\nsudo curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.4/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose\nsudo chmod +x /usr/local/bin/docker-compose\n```\n\n## 解决 ERROR: Couldn't connect to Docker daemon at http+docker://localhost - is it running？\n\n需要增加自己用户到 docker 组，然后重新进入即可\n\n```shell\nsudo gpasswd -a ${USER} docker\n```\n\n## Strapi\n\n按照[strapi 官方文档](https://strapi.io/documentation/3.0.0-beta.x/installation/docker.html)执行如下操作。\n\n新建文件夹，并增加`docker-compose.yaml`\n\n```yaml\nversion: \"3\"\nservices:\n  strapi:\n    image: strapi/strapi\n    environment:\n      DATABASE_CLIENT: mongo\n      DATABASE_NAME: strapi\n      DATABASE_HOST: mongo\n      DATABASE_PORT: 27017\n      DATABASE_USERNAME: strapi\n      DATABASE_PASSWORD: strapi\n    links:\n      - mongo:mongo\n    volumes:\n      - ./app:/srv/app\n    ports:\n      - \"1337:1337\"\n\n  mongo:\n    image: mongo\n    environment:\n      MONGO_INITDB_ROOT_USERNAME: strapi\n      MONGO_INITDB_ROOT_PASSWORD: strapi\n    volumes:\n      - ./data/db:/data/db\n    ports:\n      - \"27017:27017\"\n```\n\n修改 docker 镜像选择[腾讯加速器](https://cloud.tencent.com/document/product/457/9113)。\n\n```json\n//  /etc/docker/daemon.json\n{\n  \"registry-mirrors\": [\"https://mirror.ccs.tencentyun.com\"]\n}\n```\n\n重启服务\n\n```shell\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n```\n\n下载镜像。\n\n```shell\ndocker-compose pull\n```\n\n启动镜像\n\n```shell\ndocker-compose up -d\n```\n\n现在你的 1337 端口已经交给 strapi 了。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["docker","tencent","strapi"]}},{"id":"2020/03/10/ssh.md","slug":"2020/03/10/ssh","body":"\n# ssh 免密码登录\n\n总是忘，这里做个记录。\n\n简单说就是把本地的`id_rsa.pub`存储到远端机器的`authorized_keys`里面，详细操作可参考[此文](http://www.linuxproblem.org/art_9.html)。\n","collection":"blog","data":{"type":"post","category":"tech","tag":["ssh"]}},{"id":"2020/03/11/WSL2-Virtualbox.md","slug":"2020/03/11/wsl2-virtualbox","body":"\n# 应该是目前最好的 WSL2 和 Virtualbox 共存的方法了\n\n因为 WSL2 使用的是 Hyper-V（看来微软爸爸并不是完全拥抱开源了），所以其它虚拟化软件都不能和它共存，所以目前最好的办法就是在开机的时候做一个切换。\n\n```batch\nbcdedit /copy {current} /d \"Disable Hyper-V\"\n```\n\n上面操作会生成一个 GUID，它对应开机目录上一个选项，接下来把他的 hyper-v 选项关掉\n\n```batch\nbcdedit /set {<GUID>} hypervisorlaunchtype off\n```\n\n如果本地已经关闭了 hyper-v，可以执行下面的命令打开。\n\n```batch\nbcdedit /set {<GUID>} hypervisorlaunchtype auto\n```\n\n重启的时候长按 shift 键就可以唤起启动目录了。\n","collection":"blog","data":{"type":"post","category":"tech","tag":["WSL2","virtualbox","hyper-v"],"series":{"slug":"windows-howto","name":"Windows舒适指南"}}},{"id":"2020/03/11/apt.md","slug":"2020/03/11/apt","body":"\n# 为 apt 添加代理\n\n我的上帝啊，这两天都在忙活代理（翻译腔）。\n\n系统全局下的`http_proxy`似乎对 apt 无效，需要单独设置。\n\n```shell\nsudo nano /etc/apt/apt.conf.d/proxy.conf\n```\n\n增加代理\n\n```shell\nAcquire {\n  HTTP::proxy \"http://127.0.0.1:8080\";\n  HTTPS::proxy \"http://127.0.0.1:8080\";\n}\n```\n","collection":"blog","data":{"type":"post","category":"tech","tag":["apt","proxy"]}},{"id":"2020/03/11/docker-Jenkins.md","slug":"2020/03/11/docker-jenkins","body":"\n# 使用 docker 安装 Jenkins\n\n自从成功通过 docker 安装了 strapi，我一下子对安装一切产生了很大兴趣。\n\n通过`docker-compose.yaml`可以很快安装。\n\n```yaml\njenkins:\n  restart: always\n  image: jenkins/jenkins:lts\n  container_name: gongbaodd-jenkins\n  volumes:\n    - ./docker/jenkins:/home/ubuntu/jenkins_home\n  ports:\n    - \"50000:50000\"\n    - \"8080:8080\"\n```\n\n然后访问服务器的 8080 端口，即可安装对应插件，注意，这些插件不能走代理，所以...非常慢...国内还是用 coding.net 吧。\n","collection":"blog","data":{"type":"post","category":"tech","tag":["docker","jenkins","ci"]}},{"id":"2020/03/11/snap.md","slug":"2020/03/11/snap","body":"\n# 为 snap 添加代理\n\n想在腾讯云里面做个 CI，本着用新不用旧的思想，我打算试试搭建 microk8s。可是我国强大的网络环境无法导致无法安装，也没有个大厂出一个镜像解围，只好挂下代理解决。\n\n## sslocal\n\n注意，腾讯云里面安装 sslocal 会被和谐的，但是试了下 docker 却可以，我安装了 [teachmyself/sslocal](https://hub.docker.com/r/teachmyself/sslocal) ，目前没问题。\n\n## 修改`/etc/environment`\n\n```ini\nhttp_proxy=http://[服务器地址]:[端口号]\nhttps_proxy=http://[服务器地址]:[端口号]\n```\n\n重启 snap 即可\n\n```\nsudo systemctl restart snapd\n```\n","collection":"blog","data":{"type":"post","category":"tech","tag":["microk8s","snap","docker","shadowsocks","proxy"]}},{"id":"2020/03/15/Coding.net-Jenkins-CI-CD.md","slug":"2020/03/15/codingnet-jenkins-ci-cd","body":"\n# Coding.net 使用 Jenkins 实现自动部署(CI/CD)\n\n最近在做一些后端部署的工作，本来打算使用 Travis 部署，但是用于我的服务器在国内，所以在外网也需要挂梯子登陆到国内。但是使用 Coding.net 部署到腾讯云就方便很多（毕竟是同一家公司）。\n\n## 在 Coding 创建制品库和部署\n\n往往创建好 Coding 仓库之后需要手动配置来获得部署和制品库功能。点击「项目设置>功能开关」把「构建与部署」和「制品库」打开即可。\n\n点击「制品库」增加 docker 仓库，这里的指引很方便，可以本地写一个 hello-world 发布上去。\n\n点击「构建与部属>构建」新建构建计划，默认我都是选择代码仓库中的 Jenkins 文件，但是可以使用 coding 自带的图形化 Jenkins 编辑器，个人感觉还是比较鸡肋的，但是作为一个文件格式化工具还是不错的。另外[帮助文档](https://help.coding.net/docs/devops/ci/env.html?_ga=2.145117619.605259297.1584251292-35448522.1584251292#%E6%9E%84%E5%BB%BA%E8%AE%A1%E5%88%92%E8%AE%BE%E7%BD%AE%E4%B8%AD%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F)中有详细的变量说明。\n\n## Jenkins 配置\n\nJenkins 的主要功能是检出代码(git clone)，编译代码，执行测试，打包成 docker image 最后上传到制品库。详细内容可以参考[代码](https://github.com/gongbaodd/query.gongbushang.com/blob/master/Jenkinsfile)。\n\n```groovy\npipeline {\n  agent any\n  stages {\n    stage('检出') {\n      steps {\n        checkout([\n          $class: 'GitSCM', branches: [[name: env.GIT_BUILD_REF]],\n          userRemoteConfigs: [[\n            url: env.GIT_REPO_URL,\n            credentialsId: env.CREDENTIALS_ID\n          ]]\n        ])\n      }\n    }\n    stage('编译') {\n      steps {\n        script {\n          docker.image('strapi/base').withRun {\n            docker.image(\"strapi/base\").inside {\n              sh 'node -v && yarn --version && yarn install && NODE_ENV=production yarn build'\n            }\n          }\n        }\n\n      }\n    }\n    stage('打包镜像') {\n      steps {\n        script {\n          sh \"docker build -t strapi:${env.GIT_BUILD_REF} -t gongbaodd-docker.pkg.coding.net/query_gongbushang_com/docker/strapi:latest .\"\n        }\n\n      }\n    }\n    stage('发布') {\n      steps {\n        script {\n            sh \"docker login -u ${env.REGISTRY_USER} -p ${env.REGISTRY_PASS} ${REGISTRY_URL}\"\n            sh \"docker push ${REGISTRY_URL}/query_gongbushang_com/docker/strapi:latest\"\n        }\n      }\n    }\n  }\n}\n```\n\n## 服务器部分\n\n接下来就需要服务器自己下载镜像并执行了，这里有一个比较好的工具叫[watchtower](https://github.com/containrrr/watchtower)，它会每五分钟检查镜像是否有更新并更新本地镜像。\n\n```shell\nsudo docker run -d \\\n    --name watchtower \\\n    -v /var/run/docker.sock:/var/run/docker.sock \\\n    containrrr/watchtower\n```\n\n接下来在服务器执行刚才编译好的镜像即可。\n","collection":"blog","data":{"type":"post","category":"tech","tag":["coding.net","jenkins","docker"]}},{"id":"2020/03/17/Windows-Cypress.md","slug":"2020/03/17/windows-cypress","body":"\n# Windows 下面搞 Cypress 真心不容易\n\n最近在忙活让网站使用 [Cypress](https://www.cypress.io/) 做测试，之前使用苹果电脑以及 Linux 下面用起来还不错，这次在 Windows 下面碰壁比较多（其实我国的网络也有一部分功劳），所以在这里记录一下。\n\n## 尝试使用 WSL（失败）\n\nWSL 可以使用 XServer，所以我打算在 WSL 下面搭建，需要安装 [VcXsrv](https://sourceforge.net/projects/vcxsrv/) ，启动之后一路下一步就可以了，最后将 WSL 显示映射上去（在 bashrc 里面添加下面代码）。\n\n```shell\n# Display\nexport DISPLAY=localhost:0\nsudo /etc/init.d/dbus start &> /dev/null\n```\n\n另外需要把用户加到 sudoers 里面，否则每次启动还要输一遍密码\n\n```shell\nsudo echo \"{user} ALL = (root) NOPASSWD: /etc/init.d/dbus\" >> /etc/sudoers.d/dbus\n```\n\n然而，失败了，启动程序会报 GPU 渲染错误，同样的操作在 WSL2 中依然不行，可是[网络中有人成功了](https://nickymeuleman.netlify.com/blog/gui-on-wsl2-cypress/)。\n\n我相信更多的原因在于编译的时候网络环境太差了。\n\n## 尝试使用 MSYS\n\n直接跑 Windows 原生应用除了运行起来会更快，还可测试如 Edge 等浏览器，[MSYS](https://www.msys2.org/) 安装起来很简单，软件仓库管理使用的是 pacman，安装源可以尝试华中科大和清华的。\n\n```ini\n# C:\\msys64\\etc\\pacman.d\\mirrorlist.mingw32\nServer = http://mirrors.ustc.edu.cn/msys2/mingw/i686/\nServer = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/i686/\n```\n\n```ini\n# C:\\msys64\\etc\\pacman.d\\mirrorlist.mingw64\nServer = http://mirrors.ustc.edu.cn/msys2/mingw/x86_64/\nServer = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/x86_64/\n```\n\n```ini\n# C:\\msys64\\etc\\pacman.d\\mirrorlist.msys\nServer = http://mirrors.ustc.edu.cn/msys2/msys/$arch/\nServer = https://mirrors.tuna.tsinghua.edu.cn/msys2/msys/$arch/\n```\n\n另外需要在「控制面板>系统安全>系统>高级系统设置>环境变量」中增加`MSYS2_PATH_TYPE`值为`inherit`，这样 MSYS 里面的 PATH 就是用的是系统的 PATH 了。\n\n如果习惯使用 WWindows Terminal，可以尝试这个[issue](https://github.com/msys2/MSYS2-packages/issues/1684)，在 Windows Terminal 里面运行 MSYS。\n\n```shell\n$ cat .ms-terminal/wt-msys2.cmd\n@echo off\nsetlocal\n\nrem To activate windows native symlinks uncomment next line\nset MSYS=winsymlinks:nativestrict\n\nrem Shell types\nif \"x%~1\" == \"x-msys2\" set MSYSTEM=MSYS\nif \"x%~1\" == \"x-mingw32\" set MSYSTEM=MINGW32\nif \"x%~1\" == \"x-mingw64\" set MSYSTEM=MINGW64\n\n\nrem Shell types\nrem set MSYSTEM=MSYS\n\nC:\\msys64\\usr\\bin\\bash.exe --login -i\n\nexit /b 0\n```\n\n```json\n{\n  \"guid\": \"{e129fe71-3c94-40b5-8d92-961a3248f175}\",\n  \"commandline\": \"C:\\\\\\\\msys64\\\\home\\\\gongb\\\\wt-msys2.cmd\",\n  \"name\": \"MSYS2\",\n  \"startingDirectory\": \"%USERPROFILE%\",\n  \"icon\": \"ms-appx:///ProfileIcons/{0caa0dad-35be-5f56-a8ff-afceeeaa6101}.png\",\n  \"useAcrylic\": true,\n  \"acrylicOpacity\": 0.75\n}\n```\n\nWindows 下面的开发环境配置比较困难的原因之一就是这些链接库，比如安装一个`libpng-dev`，可以使用 Visual Studio Toolchain，也可以使用 MSYS，还可以使用微软开源的 VCPKG，然而没有一个体验能够达到极致。这导致 Gatsby 在我国的网络下永远不能部署成功。\n\n但是，直接在官网下载下来二进制包再进行[安装](https://docs.cypress.io/guides/getting-started/installing-cypress.html#Install-binary)也是可以的。\n\n```shell\nCYPRESS_INSTALL_BINARY=/local/path/to/cypress.zip npm install cypress\n```\n\n这样就可以运行 Cypress 了。\n\n## 最佳实践\n\n由此可知，其实 Cypress 可以在 Windows 下面原生执行，那么可以单独使用一个代码仓库管理测试用例，如本博客的测试用例放在[这里](https://github.com/gongbaodd/cy-blog.gongbusang.com)，在持续集成的时候将代码下载下来测试即可。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["cypress","Windows","WSL2","MSYS","VcXsrv"]}},{"id":"2020/03/21/Functional-Light-JS.md","slug":"2020/03/21/functional-light-js","body":"\n比较简单的一本[开源书](https://github.com/getify/Functional-Light-JS)，大概算函数式编程的入门书+JavaScript 部分介绍了。\n\n推荐章节：\n\n- 第四章，为什么要减少函数参数以及柯里化，这样有利于使用 compose 函数组合步骤。\n- 第八章，递归，利用 es6 上面的尾递归调用提高代码可读性。\n- 附录 A，提高性能，减少运算损耗。\n","collection":"blog","data":{"type":"post","category":"book","tag":["JavaScript","functinal-programming"]}},{"id":"2020/03/22/react-three-fiber-WebGL.md","slug":"2020/03/22/react-three-fiber-webgl","body":"\n# 使用 react-three-fiber 体验美好的 WebGL 开发\n\n使用 threejs 开发 webGL 应用应该是几乎每个前端工程师想要做的事儿，然而虽然对比于原生 WebGL 开发来说，threejs 已经做了很多，但是相对于现代的一些前端框架。threejs 还稍显不足。针对这些不足，微软开发了[Babylon.js](https://www.babylonjs.com/)，给 threejs 量身定制了一个节点编辑器，如果做过 blender 或者 unity 的同学，对于节点编辑器肯定不会陌生，但对我本人来说还是没有触碰到 G 点。\n\n## 描述组件关系的重要性\n\n本人觉得，对于前端开发来说，提供一个能够准确描述组件和组件结构关系的语言（DSL）是至关重要的，如 HTML 之于 web 开发，xml 之于安卓开发。这些 DSL 能够以最直观的方式表达页面将会展示什么，就从开发的角度上来说，或许入门不是很方便，毕竟要处理很多文件。但是维护起来却异常的轻松，就是前面提到的原因，直观。当然因为 JavaScript 跟 HTML 的交互有很大的性能缺陷。所以给很多模板语言提供了机会。比如 mustache 还有 react 的 JSX。在安卓也能看到 anko 在 kotlin 社区兴起，但是仅仅一年就没有更多人使用了，个人体验，在 Android studio 中使用 xml 和 anko 开发体验差距并不大，有时候 xml 甚至占优，也许这就是原因之一了吧。\n\n几年前我翻查了很多框架，老实说可能更多人并没有把结构描述放在如我想的位置上，哪怕连个 JSON 的方案都没有。但是的确有[aframejs](https://aframe.io/)这种直接用 HTML 管理 canvas 中元素关系的库，可惜它更关注于 VR 开发，而我更希望 WebGL 能够成为诸如图书注解一样的工具，当然这种专注于一个方面的做法或许是正确的，毕竟能够汇聚一个小圈的开发者，也不会有很多流失。\n\n## 用 JSX 开发 WebGL\n\n今年运气就好多了，react-reconciler 使得我们能够直接接管组件的 render 函数，而 react-hooks 在开发体验上完美超出现有框架，[react-babylonjs](https://github.com/brianzinn/react-babylonJS) 和 [react-three-fiber](https://github.com/react-spring/react-three-fiber) 应运而生。我同时试用了这两个框架，简单来说，react-three-fiber 更加成熟些，对 tTypeScript 的支持更好，而 react-babylonjs 开发的时候往往会因为处理类型而费心，最后又不得不使用 JavaScript 开发。\n\n## 怎么使用 react-three-fiber\n\nreact-three-fiber 的[官方文档链接](https://inspiring-wiles-b4ffe0.netlify.com/)描述很详细，建议详读。另外 threejs 官方来链接的[threejs fundamentals](https://threejsfundamentals.org/)有时间也可以拿来读读。\n\n如果想把原来的 threejs 模块迁移到 react 模块，只需要使用一层 primitive 包装即可。每个拥有 set 和 get 的参数都可以作为 props 的成员，构造器参数则是`props.args: any[]`类型。\n\n```JavaScript\nconst grid = new GridHelper(2000, 20, 0x000000, 0x0000000);\n(grid.material as Material).opacity = 0.2;\n(grid.material as Material).transparent = true;\n\nconst Grid = () => {\n  useFrame(({ scene }) => {\n    if (!scene.fog) {\n      const fog = new Fog(0xa0a0a0, 200, 800);\n      scene.fog = fog;\n    }\n  });\n\n  return <primitive object={grid}></primitive>;\n};\n\n```\n\n## 调试工具\n\n这点 babylonjs 要好得多，一个节点编辑器秒杀一切，但是 threejs 还有一个「够用」的[threejs inspector](https://chrome.google.com/webstore/detail/threejs-inspector/dnhjfclbfhcbcdfpjaeacomhbdfjbebi?hl=en)。\n\n使用时需要把你的 scene 和 THREE 模块暴露给 window 作用域。\n\n```JavaScript\nwindow.scene = scene;\nwindow.THREE = THREE;\n```\n\n然后刷新浏览器就可以在场景添加光源，查看节点等操作了。\n\n## 提示\n\n因为 threejs 及其模块本身不是编译好的 ES5，在 nextjs 中一定记得使用`next-transpile-modules`编译，当然即使已经完美适配 ES5，在 IE11 的展示也不是很乐观 😅。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["threejs","webGL","react"],"series":{"slug":"threejs-howto","name":"细品threejs"}}},{"id":"2020/03/26/Tailwind-CSS.md","slug":"2020/03/26/tailwind-css","body":"\n# [Tailwind](https://tailwindcss.com/) 一个像宏语言的 CSS 解决方案\n\n先把刀放下，我知道，现在已经有 n 种 CSS 的解决方案，而且基本上没有一个用着顺心的。\n\n我记得曾有一段时间，好像是使用 YUI 那会儿，CSS 的 class 往往会命名成布局规则，比如希望一个 div 有 10 像素的留白，就给他添加一个 class，`.margin-10px`，然后对这个 class 的描述为。\n\n```CSS\n.margin-10px {\n    margin: 10px;\n}\n```\n\n当然，这种方式在我入职一段时间后马上消失了，大家都更倾向于使用组件语义化的 class，如显示头像，则把 class 命名为`.avatar`而不是`.margin-10px.padding-5px.radius-50`这种怎么看都不知道是干什么的命名。\n\n于是 CSS 开始和组件越来越近，自从有了 scope CSS， React 和 Vue 的组件库逐渐成形，更多的方案逐渐青睐[CSS in JS](https://cssinjs.org/?v=v10.1.1)，单纯的 CSS 解决方案除了 [bulma](https://bulma.io/) 剩下的就不多了。设计的时候往往要先考虑使用的这个组件库的设计语言能给改造预留出多大的空间，然后再设计。\n\n## 回头想一想\n\n其实把几个 CSS 语句合起来作为一个集合使用并不是错的，现有的 SASS 框架也会用 utils 库专门存储封装好的`@mixins`。想到以前使用[Yo](https://github.com/doyoe/Yo)做前端样式时常会用`@yo-flex('.box'){}`这样的函数，这个函数其实就是将 flex 布局的以及它的降级 box 布局，甚至是优雅降级到不支持 box 布局的样式集合到一起。\n\n如果你认同上面这段话，那么 tailwind 一定是个适合你的工具，个人比较喜欢的是这个工具仅仅基于 postcss，这意味着你不需要使用 SASS（并不是 SASS 不好，只是国内用起来太悲剧，即使已经有 sass dart，但是因为普遍还没支持，每次使用的时候神经都要紧绷一下），它和 SASS 也不冲突。你还可以使用 config 文件来自定义样式（这很像很多 CSS in JS 的样式库，这应该是我喜欢那些库的唯一一点了）。\n\n## 操练起来\n\n[官网安装方式](https://tailwindcss.com/docs/installation)很详细，基本上能提到的工具都提过了。\n\n就拿前面的`.avatar`来举例，使用 tailwind 的代码应如下（注意 tailwind 单位不是 px 而是 rem，这里假定 html 的字体大小为 10px）。\n\n```CSS\n.avatar {\n    @apply m-4;\n    @apply p-2;\n    @apply rounded-full;\n}\n```\n\n这样既满足了，类名的语义化，还能使用 config 文件来统一自己的设计语言，最重要的，如果你拿 houdini 写个什么奇葩的 polyfill，就算预编译器读不懂，他也会容错，毕竟这就是原生 CSS。\n\n至于官网的示例，我个人很不支持，感觉是一种开倒车的方式，但萝卜白菜各有所爱，如果有公司会因为我写那样的代码而给我钱的话，我当然无所谓。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["css","tailwind","postcss"]}},{"id":"2020/03/27/svelte.md","slug":"2020/03/27/svelte","body":"\n# Svelte 让人眼前一亮的前端框架\n\n我觉得必须要介绍一下 [svelte](https://svelte.dev/) 这个框架，确切的说是 svelte v3，这应该是继 [riotjs](http://riot.js.org/)、[typescript](https://www.typescriptlang.org/) 和 [rust](https://www.rust-lang.org/) 之后又一个能给我眼前一亮的感觉的产品了。\n\n## 关于 Svelte\n\n不得不提到他的作者 [Rich Harris](https://github.com/Rich-Harris)，提到他的另一个作品就是大名鼎鼎的 [rollup](http://rollupjs.org/)，这可是第一个提出 tree-shaking 的前端打包器（说实话，这导致我有更多的担忧，svelte 可能会变成像 rollup 一样的小众狂欢）。\n\n回到 svelte，他从 v1 的时候目标就是简单，只不过 v1 版本看起来太像 zepto 了（那我为什么不用原生 JavaScript）。不过 v3 版本这个框架换了个方向，从框架变成了编译器，类似于 riotjs 和 vuejs，组件的 html、css 和 js 可以写在一起，其实我并不是特别推崇这种做法，往往有时候我更倾向于 angularJS 的做法，但是 svelte 的处理真的太完美。\n\n```html\n<script>\n  const hello = \"world\";\n</script>\n\n<h1>{hello}</h1>\n\n<style>\n  h1 {\n    color: black;\n  }\n</style>\n```\n\n看到了吗？没有多出来的 `Vue.extend()`，HTML 和 JavaScript 部分的交互竟然这儿么完美！要是 CSS 再加把力就更好了（不过如果是 CSS in JS 的话...那还是用某个 preprocessor 勉强一下好了）。HTML 模板类似比较简单的 handlebars 语法，甚至支持异步模板。\n\n另外 svelte 没有虚拟 DOM，这一点我有一些相见恨晚，我之前就写过[文章](/fe/2016/03/31/VUE&Riot&React实力比较.html)质疑虚拟 DOM 是不是真的能带来性能提高（结果是性能很差），但是最终被人喷了，导致一年后不得不[弃坑 riotjs 改用 preact](/fe/2017/05/15/弃坑Riot转向Preact.html)。但我始终认为虚拟 DOM 更是一个范式而不是能带来性能提升的神器。所以你代码差，换什么范式，性能都差，喷别人之前先称称自己几斤几两好么？\n\nsvelte 符合响应式模式，这一点和 riotjs 很类似，借助 svelte 这个编译器，写好的组件会被编译成响应式函数。也许拿 riotjs 做比方会比较难，这里拿 react 做比方，在 react 中实现响应式需要使用`setState()`。\n\n```JavaScript\nconst Com = () => {\n    const [state, setState] = useState(1);\n    useEffect(() => setState(state + 1), [])\n    const stateX2 = state*2;\n\n    return (\n    <>\n        <div>{state*2}</div>\n        <div>{stateX2}</div>\n    </>\n    );\n}\n/* 输出\n * <div>2</div>\n * <div>2</div>\n*/\n```\n\n而由于 svelte 是个编译器，svelte 里面不仅代码更少，而且正确的输出了`stateX2`的值。\n\n```HTML\n<script>\nimport { onMount } from \"svelte\";\n\nlet state = 1;\n\nonMount(() =>  state += 1);\n\n$: let stateX2 = state * 2;\n</script>\n\n<div>{state}</div>\n<div>{stateX2}</div>\n\n<!--\n    输出\n    <div>2</div>\n    <div>4</div>\n-->\n```\n\n没错，完全没有多余的代码（其实 svelte 编译器会默默地给`state`增加一个`observable`的配置，但是这都是编译器自己做的，开发者完全不需要考虑）。这里发现`stateX2`前面有一个`$`标识，表明后面的语句是响应式的。这一点真的很巧妙，因为这个语法是 JavaScript 标准里百年不遇的`goto`语句，svelte 高明的使用 JavaScript 原有的语法实现了新的功能，不像某框架愣是加了一个 JSX 语法（不是鄙视 JSX，JSX 也很牛逼的说）。\n\n在 n 多个框架都在模仿 react 的主流下，这个框架还能别出心裁，不得不赞，如果你感兴趣，我强烈推荐浏览他们的[例子](https://svelte.dev/examples#hello-world)。store 和 context 都非常有启发。\n\n最大的缺点就是目前还没有官方的 TypeScript 支持，这一点很有尴尬，因为 svelte 本身就是 TypeScript 写的。不过现在有第三方的[svelte-preprocess](https://github.com/kaisermann/svelte-preprocess)对 TypeScript 提供支持，不知道啥时候转正。\n\n## Sapper\n\nriotjs 同样没有虚拟 DOM，这使得它在 SSR 方面会[有一些问题](https://riot.js.org/documentation/#riot-dom-caveats)，但是 Svelte 提供了一套 SSR 解决方案，[sapper](https://sapper.svelte.dev/) 同时支持 node 渲染和静态发布。\n\nSapper 受 next.js 启发，使用`src/route`文件夹下的文件做路由。\n\n```\nsrc/routes\n    _layout.svelte -- 布局文件\n    _error.svelte  -- 404目录\n    index.svelte   -- /或者/index\n    posts.json.js  -- /post.json，可以使用类似express路由的方式写接口\n```\n\n想要在 index 里面实现 server 端的预加载，可以使用 sapper 的 preload API。\n\n```html\n<script context=\"module\">\n  export async function preload(page, session) {\n    const res = await this.fetch(\"posts.json\");\n    const { posts } = await res.json();\n\n    return { posts };\n  }\n</script>\n```\n\n这样会在`window`上面注入一个`__SAPPER__`变量把 server 端预加载的值赋上去。\n\n因为 sapper 还在 beta 阶段，我也不敢拿来开发什么大项目，但真心想写写 svelte，因为它在很多地方非常有新意，历史包袱也不大，暂时写个 [CSS playground](https://css.gongbushang.com/) 来做 [CSS Secrets](http://shop.oreilly.com/product/0636920031123.do) 的笔记好了。\n\n## 单元测试\n\n[testing-library](https://testing-library.com/docs/svelte-testing-library/intro) 提供单元测试支持，配置起来绝对比 react 和 vue 简单，只是因为比较新，所以没有类似的 create react app 这种官方脚手架，当然如果 sapper 出正式版了就算有了。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["svelte","sapper","JavaScript","rollup"]}},{"id":"2020/03/29/Rust-crate.io.md","slug":"2020/03/29/rust-crateio","body":"\n# Rust 开发更换 crate.io 源\n\n使用 VSCode 开发 Rust 的我，最难过的一刻就是打开编辑器时的 RLS 检查，可以看做它是一个用来检查代码语法的后台程序，在 RLS 的 issue 里面有很多人吐槽他初始化的速度实在是太慢了，然而大佬的回复都是说他们不需要使用这种辅助工具。作为使用 JavaScript 都一定要 TypeScript 编译，打字都是通过语音输入来打字的我来说（没错，这篇博文是语音转换过来的），臣妾做不到啊。\n\nRLS 检查有一个步骤是`cargo check`，这里会链接`crate.io`检查包的完整性。由于`crate.io`的包大多托管在 GitHub，所以外网的宝宝们吐槽的慢只是秒级别的，而中国的宝宝是小时级的 😭。\n\n但是尚有修补的余地，中科大爸爸给国内开发者提供国内的镜像了。修改`~/.cargo/config`增加中科大的源。\n\n```ini\n[source.crates-io]\nregistry = \"https://github.com/rust-lang/crates.io-index\"\nreplace-with = 'ustc'\n\n[source.ustc]\nregistry = \"git://mirrors.ustc.edu.cn/crates.io-index\"\n```\n\n中科大就是我的神啊！开发 Rust 终于可以和国外一样慢了 😂！\n","collection":"blog","data":{"type":"post","category":"fe","tag":["rust","crate.io","ustc","cargo"]}},{"id":"2020/03/30/CSS Secret.md","slug":"2020/03/30/css-secret","body":"\n# CSS Secret 有感\n\n虽然维多利亚的秘密没有了，但是 CSS 的秘密还是可以考虑考虑的，这本书是 2015 年出版的，相比于现在，显然里面的很多属性已经可以做到多平台兼容了，当然里面还没有涉及 grid 布局，强烈推荐 [wesbos 的 grid 课程](https://cssgrid.io/)，虽然看完也是忘 😅。\n\n要说编程算法难学，跟 CSS 比起来还是个弟弟，不仅仅要了解一些拓扑的知识，编出来的图形还得好看。\n\n书中的实现都放在[这里](http://play.csssecrets.io/)，同时我也挑了一些喜欢的[自己实现了一下](http://css.gongbushang.com/)。\n\n书里面涉及到的有\n\n- outline\n- box-shadow\n- background-image（里面提到了一个纯 CSS 实现北京图案的[网站](https://leaverou.github.io/css3patterns/)，值得拥有）\n- background-origin\n- border-image\n- path-clip\n- transform\n- filter\n- font-variable\n- keyframe\n\n目前个人比较感兴趣然而未被涉及的是\n\n- grid\n- css variables\n\n当然这些那会儿都还没有，所以闲着没事儿干的时候还要多逛逛[css-tricks](https://css-tricks.com/)。\n\n还有，在写[svelte](/fe/2020/03/27/svelte一个让人眼前一亮的的前端框架.html)曾经提过如果有一个比较好的 CSS 和 JavaScript 以及 HTML 交互的方法就好了，细想之下 css variables 或许可以。试想如下结构。\n\n```html\n// Back.svelte\n<div class=\"bg\">\n  <slot></slot>\n</div>\n\n<style>\n  .bg {\n    --color: red;\n  }\n</style>\n```\n\n```html\n// Menu.svelte\n<ul>\n  <li>Menu</li>\n</ul>\n\n<style>\n  ul > li {\n    color: var(--color, blue);\n  }\n</style>\n```\n\n```html\n// App.svelte\n<script>\n  import Back from \"Back.svelte\";\n  import Menu from \"Menu.svelte\";\n</script>\n\n<Back>\n  <menu></menu>\n</Back>\n```\n\n此时的 Menu 应该是 Back 里面设置好的红色（我自己没尝试，只是写这个博文的时候临时起意）。这最大的好处显而易见，类似于 react 里面的 theme，`<Back/>`组件给`<Menu/>`组件提供了配合的样式，而不仅仅局限于 JavaScript 传入的数据。\n\n只可惜 CSS variables 需要做向下兼容，而且就算是 postcss 的[postcss-css-variables](https://www.npmjs.com/package/postcss-css-variables)也只能兼容放到`:root`下的变量（那要你有何用囧），不过就[caniuse](https://caniuse.com/#feat=css-variables)的数据，不考虑中国用户的话，确实可以大胆使用 CSS variables，就算是降级估计也没那么难看吧。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["CSS"]}},{"id":"2020/03/31/2020-Q1.md","slug":"2020/03/31/2020-q1","body":"\n# 2020 年 Q1 总结\n\n又到了每个月打脸的时间了，首先，住司徒正美大大颈椎病早日康复，在 Qunar 的时候有幸听过分享，虽然方言很重，但是因此对 MVVM 有所了解。前几天 jellow 里面有人问大家 Q1 计划完成了没有，我觉得比较有趣，那么以后每三个月做一次季度总结比较好。\n\n## 总结三月\n\n- 完成博客从 Jekyll 到 Gatsby 的迁移。\n- 读完「你不知道的 JS」系列，包括里面提到的「functional light JS」，另外在阅读「exploring JS」的时候发现和前面两系列存在大量重叠，主要是免费部分，也许收费部分会有更多新意，但我打算暂时不在精进了。\n- server 端的 strapi 已经初步做成自动更新，但没有去做更好的验证，不知道鲁棒性如何。期间了解了下 micro-k8s 之类的信息，遗憾没有更多的主观以及客观因素更精进 k8s 了。\n- 目前全项目都添加了单元测试以及 cypress 集成测试。\n- 在重构之前的 WebGL 作业的时候找到了一本 threejs fundamental，接下来的一个月可能会看这本书。\n- 读完「CSS Secret」，并使用 svelte 整理了部分笔记发布到网站中。\n- 发现了 yew 框架，所以暂时搁置 game of life 计划，打算做一个 figma -> yew 的工作流实验。\n\n## 对比二月的计划\n\n- (进行中) 开始完成阅读词汇背诵\n- (完成) 完成「你不懂的 JavaScript」中卷和下卷\n- (完成) 完成「CSS 揭秘」\n- (完成) 把博客搞成基于 Gatsby\n- (暂停) 完成 game of life\n- (搁置) 努力开始粤语的 to do\n- (搁置) 努力开始「美国名师带你学口琴」\n- (搁置) 开始「程序员的数学（线性代数）」\n- (取消) 开始「函数式编程思维」\n- (搁置) 参考看一下「Algorithms for visual design using the processing language」\n- (搁置) 参考看一下「自制编程语言」\n\n可见 flag 不要立得太多，好在三月相比于二月没发现那么多新东西，这些搁置得事情会逐渐在以后几个月消灭掉。\n\n## 三月的发现\n\n- Little Big，神奇的俄罗斯天团，他们的歌一听就上瘾，导致这一个月跑步都在听。\n- 运动踏板，因为一直在隔离，基本上没有多少运动的机会，只能买个踏板，之前担心会不会伤到膝盖，不过管不了那么多了，每天 10 到 20 分钟，也可以边看美剧边晒灯，边运动，不得不说，再隔离下去我就适应了 🤣。\n- [joshwcomeau.com](https://joshwcomeau.com/)，一个值得关注的博主，这个月已经随意搜到了两篇有趣的 react 文章了。\n- [svelte](/fe/2020/03/27/svelte一个让人眼前一亮的的前端框架.html)，相关赞美它的话我就不多说了，早日支持 TypeScript 哟。\n- [tailwind](/fe/2020/03/26/Tailwind一个像宏语言的CSS解决方案.html)，不是必须学习，但是不能不了解。\n- [threejs fundamentals](https://threejsfundamentals.org/)，这个不用说了下个月就要看这本了。\n- [用 Javascript 當個影像魔術師](https://ithelp.ithome.com.tw/users/20121089/ironman/2838?sc=iThelpR)，逛 IT 帮帮忙的时候看到的，我觉得有可能做成 figma 插件试试。\n\n## Q1 总结\n\n从这个季度开始，我临时修改了今年的计划，以结果导向管理我的工作计划，所以可以发现这个季度我的产出异常多。\n\n- 一月，完成 scrapy 学习，完成阅读 rust 之道、unity 游戏实现。\n- 二月，完成体系的 rust 学习，尝试 flutter\n- 三月，实现 blog、www、css、graphics、query 网站上线\n\n下一个季度就是我在深圳的最后一个季度了，更希望我的工作模型从学习模型转向产出模型，但明显觉得了解的越多不知道的就越多，怎么办呢，走一步看一步吧。\n\n## 四月计划\n\n- 读完[threejs fundamentals](https://threejsfundamentals.org/)\n- 给博客增加按照 category 分类子项\n- 使用 yew 开发 game of life\n- 测试服务器上的 strapi\n- 背完阅读词汇背诵\n\n可补充项目\n\n- 学习[用 Javascript 當個影像魔術師](https://ithelp.ithome.com.tw/users/20121089/ironman/2838?sc=iThelpR)，逛 IT 帮帮忙的时候看到的，我觉得有可能做成 figma 插件试试。\n- 继续 flutter 学习\n- 学习 tensorflow.js\n","collection":"blog","data":{"type":"post","category":"plan"}},{"id":"2020/04/02/docker-mongodb.md","slug":"2020/04/02/docker-mongodb","body":"\n# docker 化的 mongodb 使用方案\n\n之前提到过[使用 watchtower 更新本地的 image 的方案](/tech/2020/03/15/Coding.net使用Jenkins实现自动部署CI&CD)，本来我的系统一直使用 sqlite 来做数据库，现在想改成 mongodb。\n\n涉及到 mongodb 就不得不需要考虑怎么本地化，并且如何做备份。数据本地化很好做，只需要 docker 的 volume 即可，编写`docker-compose.yml`，使用`docker-compose up -d`。\n\n```ini\nversion: '3.7'\n\nvolumes:\n  mongo:\n  strapi:\n\nservices:\n  mongo:\n    image: mongo\n    restart: always\n    volumes:\n      - mongo:/data/db\n    ports:\n      - 27017:27017\n  adminmongo:\n    image: mrvautin/adminmongo\n    ports:\n      - 1234:1234\n    environment:\n      - HOST=0.0.0.0\n      - CONN_NAME=mongo\n      - DB_HOST=mongo\n      - DB_PORT=27017\n      - PASSWORD=$ADMIN_MONGO_PASSWORD\n    links:\n      - mongo:mongo\n  strapi:\n      image: <strapi registry>\n      environment:\n        DATABASE_CLIENT: mongo\n        DATABASE_NAME: strapi\n        DATABASE_HOST: mongo\n        DATABASE_PORT: 27017\n      links:\n        - mongo:mongo\n      volumes:\n        - ./app:/srv/app\n      ports:\n        - '1337:1337'\n\n\n```\n\n## 备份\n\n使用如下命令备份\n\n```shell\ndocker-compose exec -T mongo mongodump --archive --gzip --db <database> > dump.gz\n```\n\n## 还原\n\n```shell\ndocker-compose exec -T mongo mongorestore --archive --gzip < dump.gz\n```\n\n## 可视化管理 docker\n\n使用 [portainer](https://www.portainer.io/) 能够可视化管理现在运行的 docker。执行如下命令，再访问 localhost:9000，嗒嗒！以后再也不需要执行`docker ps`了。\n\n```shell\ndocker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer\n```\n\n## 可视化管理 mongodb\n\n可以使用[adminmongo](https://github.com/mrvautin/adminMongo)提供一套简单可用的 WebUI，我已经写到了 docker compose 里面了。\n\n另外`environment`里面的`PASSWORD`并不好使，已经有[issue](https://github.com/mrvautin/adminMongo/issues/166)，不过已经是 2017 年的了，最快的解决方式就是删除`config/app.json`，只需要在 portainer 里面选择`Containers > mongodb_adminmongo_1` 点击 `Edit`，修改 `Command` 并重新部署。\n\n![portainer的设置](./portainer-config.jpg)\n","collection":"blog","data":{"type":"post","category":"tech","tag":["docker","portainer","mongodb"]}},{"id":"2020/04/04/ObservableHQ-JS-Jupyter.md","slug":"2020/04/04/observablehq-js-jupyter","body":"\n# ObservableHQ-JS 终于有自己的 Jupyter 笔记本了\n\n学习机器学习的时候用上 python 的 Jupyter notebook 是真好用，曾经就想，如果 JavaScript 也有一个就好了，没错[ObservableHQ](https://observablehq.com/)就是基于 D3.js 的数据可视化笔记本。\n\n官方的[入门](https://observablehq.com/@observablehq/a-taste-of-observable)讲的很详细，接下来一周我可能会专心于里面的[D3 教程](https://observablehq.com/@d3/learn-d3)，间或去学习 threejs fundamental。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["observablehq","JavaScript","d3","jupyter"]}},{"id":"2020/04/07/D3.md","slug":"2020/04/07/d3","body":"\n# 学习 D3 的新姿势\n\n今天用了半天的时间把 observable HQ 上面的 [Learn D3](https://observablehq.com/@d3/learn-d3) 学习了一遍，[这](https://observablehq.com/@gongbaodd/d3-js)是纯笔记版。\n\n不过今天真的是爽到了，没错，我终于找到了以前学习 D3 没动力的原因了，那么厚的一本书，基本上就是把 D3 gallery 抄了一遍。最开始基本上还要学一个 D3 版本的 jQuery 选择器，数据还要自己搞，基本读了两章就打算放弃。\n\n```JavaScript\nvalues = [...\"123456\"];\nimport {chart as chart1} with {values as data} from \"@d3/histogram\";\n```\n\n这就是一个柱状图了！！！爽到有没有？\n\n如果你想写一个控制界面\n\n```JavaScript\nviewof replay = html`<button>Replay</button>`\n```\n\n使用这个控制器\n\n```JavaScript\nreplay, html`\n<svg viewBox=\"0 0 ${width} ${height}\">\n  ${d3.select(svg`<g>`).call(shape_xAxis).node()}\n  ${d3.select(svg`<g>`).call(shape_yAxis).node()}\n  ${d3.select(svg`\n    <path\n      d=\"${line(shape_data)}\"\n      fill=\"none\"\n      stroke=\"steelblue\"\n      stroke-width=\"1.5\"\n      stroke-miterlimit=\"1\"\n      stroke-dasharray=\"0,1\"\n    >\n    </path>\n  `).call(reveal).node()}\n</svg>\n`\n```\n\n哈哈，有趣，这语法很有想象力，比 svelte 更加大胆，仿佛用 JavaScript 实现了一个类似于 python 的词法。如果你想创建一个复杂的变量，你可以：\n\n```JavaScript\nsum = {\n  let s = 0;\n  for (let i = 0; i < 10; ++i) {\n    s += i;\n  }\n  return s;\n}\n```\n\nObservable HQ 的每个语句类似于 react 的 render 函数，你甚至可以把它写成一个迭代器。当 replay 被点击，页面展示的数值会从 1 逐渐增加到 299。\n\n```JavaScript\n{\n  replay;\n  for (let i = 0, n = 300; i < n; ++i) {\n    yield i;\n  }\n}\n```\n\n另外可以参考[如何利用 Wikipedia 的数据](https://observablehq.com/@mbostock/working-with-wikipedia-data)进一步使用 observable HQ。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["observablehq","d3"]}},{"id":"2020/04/09/Amazon's-anti-drug-drama-zero-zero.md","slug":"2020/04/09/amazons-anti-drug-drama-zero-zero","body":"\n# 亚马逊年度禁毒大戏「零零零」\n\n前几天刷推特，都在传「零零零」这个剧怎么怎么火，说实话，关于黑帮和毒品的剧我还真不敢兴趣，试着抱一抱的心态看了一集，结果一发不可收拾把第一季全看完了，接下来，本文全是剧透！\n\n![截图](./zzz.jpg)\n\n第一集详细介绍了出场人物，分别是买方（buyer）、中间人（broker）以及卖方（seller）。\n\n买方是一对意大利爷孙，暂时称买方爷爷和买方孙子，买方爷爷正在培养孙子处理生意，而孙子则认为爷爷杀死了父亲而暗自结合朋友猪猪仔准备抢下爷爷的生意并复仇。\n\n中间人是美国的一家人，中间人爸爸带着子女两人（中间人姐姐，Emma 和中间人弟弟）相依为命，Emma 帮着父亲处理家庭生意而因为弟弟遗传了母亲的病，中间人爸爸出于保护不愿意给生意交给儿子，而弟弟却一直想出力。\n\n卖方在墨西哥买通缉毒警察，缉毒警察表面在缉毒，暗地里收了卖方的钱偷偷保护卖方，在一次出警时，虽然已经偷偷通知交易双方，但还是在枪战中杀死了中间人爸爸。\n\n中间人爸爸死后，Emma 哄骗弟弟说爸爸同意他们一起接手生意，弟弟很开心并要求自己亲手接管最新的一批可卡因。然而赶到美国参加追悼会的买家孙子认为姐弟俩太弱小，并且想换到自己的中间人手上来架空爷爷，偷偷买通运货的船长，制造船上事故。\n\n在运输中，船长放火打算把弟弟和船一起烧了，然而在船长逃离后，弟弟成功灭火，并一个人把船开到了非洲。Emma 和弟弟在非洲汇合，为了躲开海关检查，姐弟俩选择了一条穿过圣战分子占领的路前往摩洛哥的卡萨布兰卡，中途险些丧命。\n\n同时，卖方缉毒警察清理了自己部队里面的正义分子，完全黑化后和贩毒者发生金钱上的分歧，逐渐壮大之后，干脆干掉原来的卖方自己收钱。\n\n卖方爷爷得知孙子想复仇，来了一出杀猪儆孙（话说爷爷真的很有人格魅力，不愧是意大利黑帮），坦白自己当年杀儿子的原因。爷爷遭到追杀，孙子假装被爷爷打伤放走爷爷，可是因为演技太差被猪猪仔看出来，猪猪仔挟持孙子妻女，让孙子截下停留在卡萨布兰卡的货。\n\n赶到卡萨布兰卡的买方孙子找到中间人弟弟逼迫他说出货的位置，弟弟故意拖延，成功让货物运出，却因此丧了命。Emma 得知弟弟丧命，到意大利找到买方爷爷，买房爷爷为了保全生意，杀死孙子，并解决掉猪猪仔一帮人。\n\nEmma 来到墨西哥交付尾款，发现卖方已经被缉毒警取而代之，交接下一单的要求后，虽然面带微笑带心怀感伤的离开。而远在意大利，买方爷爷重出江湖处理毒品，并准备培养他的曾孙。\n\n所以，千万不要贩毒 😂。\n","collection":"blog","data":{"type":"post","category":"tv"}},{"id":"2020/04/13/threejs-fundamentals-threejs.md","slug":"2020/04/13/threejs-fundamentals-threejs","body":"\n# threejs fundamentals 名副其实的 threejs 入门书\n\n最近几天真是忙，除了读这本书，我的平板（酷比魔方 Mix Plus）突然进不去系统了，查了一下，原来山寨本硬盘质量不好，莫名其妙全清了（惊！），好在做了备份，当然因为不想花钱，没再买一个 SATA SSD 硬盘，花了一些时间重做系统。\n\n祸不单行，主力机 Dell inspiron 13 风扇坏了，虽然已经报修，但还在走流程，这使得我现在只能以 1.8GHz（关闭风扇） 工作 😭。\n\n正好，刚做完系统，所以这篇文章我争取在平板上写，以保证系统安装正确。\n\n另外，因为抢到了福田的消费券，所以这本书的实现，争取在本周完成。\n","collection":"blog","data":{"type":"post","category":"book","tag":["threejs","JavaScript","webGL"]}},{"id":"2020/04/16/CSS.md","slug":"2020/04/16/css","body":"\n# CSS 渐变利器\n\n[CSS gradient generator](https://mybrandnewlogo.com/color-gradient-generator)\n","collection":"blog","data":{"type":"post","category":"fe","tag":["css","gradient"],"series":{"slug":"tools","name":"利器"}}},{"id":"2020/04/21/threejs-mesh.md","slug":"2020/04/21/threejs-mesh","body":"\n# threejs 细化-创建一个 mesh、使用加载器、多个场景\n\n记录下最近几天的事，终于 Dell 的维修把我电脑的风扇修好了，不过感觉 inspiron 的风扇设计有 bug，新风扇估计也撑不了多久，但愿只是我多疑了。另外通过神奇的某宝，我将我手上的小米平板二升级了内存和硬盘，考虑到 8GB 内存对于 Atom Z8500 这个 CPU 有点多余，于是升级到了 4GB + 128GB，到手之后果然比 2GB 流畅（当然肯定没法比酷睿了），所以这个配置还是比较推荐的。\n\n回到主题，最近一周我都在使用 react-three-fiber 来学习 threejs，这里会做一个系列来详细整理一下。\n\n## 创建一个 mesh\n\n可以使用 JSX 创建 mesh, 因为 mesh 有 material 和 geometry 两个访问器，在 JSX 中可以作为属性使用。\n\n```JavaScript\nexport default () => (\n    <Canvas>\n        <mesh\n            name=\"mesh\"\n            material={new MeshBasicMaterial()}\n            geometry={new BoxBufferGeometry(1, 1, 1)}\n        />\n    </Canvas>\n);\n```\n\n当然作为参数也可以。\n\n```JavaScript\nexport default () => (\n    <Canvas>\n        <mesh arg={[new BoxBufferGeometry(1, 1, 1), new MeshBasicMaterial()]}/>\n    </Canvas>\n);\n```\n\n官网还提供了一个绝妙的方法。\n\n```JavaScript\n// 实现不了，不知道咋回事儿\nexport default () => (\n    <Canvas>\n        <mesh>\n            <boxBufferGeometry attach=\"geometry\" />\n            <meshBasicMaterial attach=\"material\" />\n        </mesh>\n    </Canvas>\n);\n```\n\n另外因为 Canvas 里面的元素和 JSX 的绑定使用的是 memo，所以如果使用 primitive 定义元素的时候会丢。\n\n```JavaScript\n// 这么做虽然会渲染出来，但是Box有的时候会丢\nconst Box = new Mesh(\n    new BoxBufferGeometry(1, 1, 1),\n    new MeshBasicMaterial(),\n);\n\nexport default () => (\n    <Canvas>\n        <primitive object={Box} />\n    </Canvas>\n);\n```\n\n## 加载器\n\n加载 texture 时，可以使用`useEffect`自己写，当然也有更优雅的方法，利用 react 自己的`useMemo`或者`useCallback`，再就是使用 react three fiber 的`useLoader`。\n\n```JavaScript\n// 使用 useMemo\nconst Plane = () => {\n    const texture = useMemo(() => new TextureLoader().load(\"xxx.jpg\"), [])\n    return <mesh\n        material={new MeshBasicMaterial({map: texture})}\n        geometry={new PlaneGeometry(1, 1)}\n    />\n}\n```\n\n```JavaScript\n// 使用 useLoader\nconst PlaneAsync = () => {\n    const [texture] = useLoader(TextureLoader, \"xxx.jpg\");\n\n    return <mesh\n        material={new MeshBasicMaterial({map: texture})}\n        geometry={new PlaneGeometry(1, 1)}\n    />\n}\n\nconst Plane = () => (\n        <Suspense fallback={<mesh />}>\n            <PlaneAsync />\n        </Suspense>\n    )\n```\n\n## 使用多个场景\n\nthree react fiber 会默认给一个场景(scene)、一个摄像头(camera)还有一个渲染器(render)。可是如果我需要多个场景，比如建模工具往往会给一个正交视图以及正视图，这种情况就需要多个场景。\n\n首先要使用`setDefaultCamera`将新建的摄像头代替默认摄像头。\n\n```TypeScript\nexport default () => {\n    const { setDefaultCamera } = useThree();\n    const camera = useRef<PerspectiveCamera>();\n\n    useLayoutEffect(() => camera.current && setDefaultCamera(camera.current), [])\n\n    return <perspectiveCamera\n      name=\"camera\"\n      ref={camera}\n    />\n}\n```\n\n接下来是创建场景，场景不需要代替原有场景，但是需要使用`useFrame`修改`render`方法。\n\n```TypeScript\n// 再原画面的左上角绘制场景\nexport default () => {\n    const scene = useRef<Scene>();\n    const {\n        size: {left, top, width, height},\n        camera,\n    } = useThree();\n\n    useFrame(({ gl }) => {\n        gl.autoClear = true;\n        gl.setScissor(left, top, width / 2, height / 2);\n        gl.setViewport(left, top, width / 2, height / 2);\n\n        scene.current && gl.render(scene, camera)\n    }, 10);\n\n    return (\n        <scene ref={scene}>\n            <mesh />\n        </scene>\n    );\n}\n```\n\n这里`useFrame`的第二个参数表示它的优先级，值越高，越先渲染，这意味着比它优先级低的场景渲染之前要把`gl.autoClear`设置为`false`，以避免被清除。\n\n## 其它\n\n另外可以看看京东的一篇博客[凹凸实验室](https://aotu.io/notes/2018/10/18/cannonjs/index.html)。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["threejs","JavaScript","webGL"],"series":{"slug":"threejs-howto","name":"细品threejs"}}},{"id":"2020/04/22/Devs.md","slug":"2020/04/22/devs","body":"\n# Devs -配乐很美丽，故事有点虎头蛇尾的剧\n\n![Devs cover](./devs.jpg)\n\n本剧的主角 Lily 和她的男友在一家高端技术公司工作，男友因为项目表现优异被提拔到 Devs 项目中。当天晚上，男友因为帮助俄罗斯特工偷窃 Devs 的代码而被公司的保安男杀害。\n\n第二天 Lily 询问公司高管男友的踪迹被告知男友自杀，Lily 无意间发现男友手机内安装了加密软件，所以找到备胎前男友解锁。备胎前男友本着「当然还是原谅她」的原则帮她解锁并联系上了俄罗斯线人。线人准备拉 Lily 下水，但被 Lily 拒绝，这次联络被保安男发现，保安男解决掉线人，并打算送 Lily 去精神病院。\n\nLily 和备胎前男友发现男友的自杀证据有造假，确定男友是被谋杀，可是 Lily 被保安男胁迫去精神病院。备胎前男友偷偷带 Lily 逃离精神病院，并一同前往公司高管对峙什么是 Devs。\n\n公司高管告诉 Lily，Devs 通过算法用来预测过去与未来，并且这个机器预测到 Lily 和高管一起死亡后就宕机了。\n\n其实 Devs 是公司高管用来复活出车祸女儿的设备，在坚持单一宇宙观多次失败之后，一个工程师加入了多元宇宙的算法，最终能够近似地预测过去和未来，但因为打破 Devs 的初衷，这名工程师也被开除，被设计自杀。\n\nLily 决定不回公司，这样就能打破机器的预测。意外的是保安男将备胎前男友杀死，准备杀 Lily 的时候，被 Lily 家门口的乞丐男杀死。乞丐男是另一个俄罗斯特工，他要求 Lily 回到香港，这样能躲过追责，然而 Lily 最终还是先择走机器预测的路，回到了公司，高管和 Lily 一同看了宕机前得预测，原来 Lily 持枪和高管在电梯对峙，枪击中高管并破坏了电梯，两人跌落而亡。\n\n不过和预测不同的是，Lily 在和高管进入电梯时故意扔掉枪，这样就又打破了机器的预测。高管告诉 Lily，Devs 其实是 Deus，只是 u 设计得太像 v 了（王德发？）。可是电梯还是被认为失控，两人坠落而亡。\n\nLily 醒来，发现男友还在身旁，备胎前男友也活着，到公司发现高管和他的女儿都活着。原来高管将所有人复制到了 Deus 得世界中，所以即使现实两人已经死亡，只要 Deus 不关闭，他们总能生活在这个虚拟的平行空间中，全剧终（王德发？？？？）。\n","collection":"blog","data":{"type":"post","category":"tv"}},{"id":"2020/04/25/Tales.From.the.Loop.md","slug":"2020/04/25/talesfromtheloop","body":"\n# Tales from the Loop-北欧治愈风黑镜\n\n\n八个小故事，但又是发生在同一个小镇中的一群人中。安利[大聪说电影](https://www.bilibili.com/video/BV1Ze411x7sd/) 的解说，最喜欢的就是最后一集，时间转瞬即逝啊，珍惜吧，骚年。\n","collection":"blog","data":{"type":"post","category":"tv"}},{"id":"2020/04/26/Hunger-Platform-Direct-Reviewing-Class-Questions-Movies.md","slug":"2020/04/26/hunger-platform-direct-reviewing-class-questions-movies","body":"\n# 饥饿平台 直接评论阶级问题的电影\n\n听[黑水公园](https://music.163.com/#/program?id=2066839072)提到的电影，相比于「寄生虫」这里把阶级关系写的有点直接，本身出身比较低的我并不太想讨论这种话题，包括即刻里面的「你为什么考不上人大附」还有 B 站「你那么穷，就别发油管上，好象全国都很穷」之类的话题，因为没意义。就跟电影里面送上去的蛋糕一样，哪怕你送上去的是小女孩，又怎样？\n","collection":"blog","data":{"type":"post","category":"movie"}},{"id":"2020/04/27/threejs.md","slug":"2020/04/27/threejs","body":"\n# threejs 细化-在网格上渲染，停止渲染，使用物理引擎\n\n这是细化了解 threejs 的第二篇，[第一篇](/fe/2020/04/21/threejs细化-创建一个mesh、使用加载器、多个场景.html)\n\n## 在网格上渲染\n\n这里有一点类似于使用多个场景，设想如果想要做一个类似于水晶球的设计，水晶球有一个 scene1，水晶球自己又在另一个 scene0 里面，这里就需要使用 renderTarget 渲染 scene1 到水晶球上面。\n\n先创建一个 target。\n\n```typescript\nconst target = new WebGLRenderTarget(width, height);\n```\n\n再创建一个球，并使用 target 作为材料。\n\n```tsx\nconst ball = () => {\n  return (\n    <mesh name=\"ball\">\n      <sphereBufferGeometry attach=\"geometry\" args={[1, 32, 16]} />\n      <meshPhongMaterial attach=\"material\" map={target.texture} />\n    </mesh>\n  );\n};\n```\n\n然后创建 scene1。\n\n```ts\nconst scene1 = new Scene();\nconst camera = new PerspectiveCamera(75, 1, 0.1, 5, position: [0, 1, 2]);\n\n{\n  const light = new HemisphereLight();\n  scene1.add(light);\n}\n\n{\n  const mesh = new Mesh(\n    new BoxBufferGeometry(1, 1, 1),\n    new MeshPhongMaterial({ color: 0x8844aa }),\n  );\n  scene1.add(mesh);\n}\n```\n\n貌似 react-three-fiber 的 render 函数也可以把 JSX 渲染成 scene。但是使用的时候告诉我需要创建 context，难道是要用 React.createContext? 感觉坑很多，所以暂时没有尝试，以后再补充这里。\n\n```tsx\nconst scene = new Scene();\nconst context = createContext();\n\nrender(\n  <>\n    <perspectiveCamera />\n    <hemishpereLight />\n    <mesh>\n      <boxBufferGeometry args={[1, 1, 1]} attach=\"geometry\" />\n      <meshPhongMaterial color={0x8844aa} attach=\"material\" />\n    </mesh>\n  </>,\n  scene,\n  context\n);\n```\n\n好了，回到正题，现在需要在 target 上面渲染 scene1.\n\n```ts\nuseFrame(({ gl }) => {\n  gl.setRenderTarget(target);\n  gl.render(scene1, camera); // 这里的camera是scene1里面的camera\n  gl.setRenderTarget(null);\n});\n```\n\n和渲染两个 scene 一样，不管打算渲染几个场景，实际的渲染器只有一个，所以渲染好 target 后还要把要渲染的目标换回来。\n\n## 停止渲染\n\nreact-three-fiber 默认会一直渲染每一帧，而在网页上，我们往往不需要它一直耗费 GPU 时间，比如渲染好的动画，只需要它在特殊时间才运动，react-three-fiber 有一个 invalidateFrameloop 选项可以暂停渲染。\n\n```tsx\n<Canvas invalidateFrameloop />\n```\n\n另外`useThree().invalidate`也可以暂停渲染，但这个不太稳定，不确定是不是我的问题。\n\n比如加载进来一个模型，想让它动画结束后就停止 GPU 渲染。\n\n```tsx\nconst animate = useMemo(() => new AnimationMixer(obj));\nconst action = useMemo(() => {\n  const act = animate.clipAction(obj.animations[0]);\n  act.setLoop(LoopOnce, 1);\n  act.enabled = true;\n  act.clampedWhenFinished = true;\n  act.play();\n  return act;\n}, []);\n\nconst { invalidate } = useThree();\n\nuseFrame((_, delta) => {\n  animate.update(delta);\n  if (!act.isRunning()) {\n    invalidate();\n  }\n});\n```\n\n## 使用物理引擎\n\n物理引擎是使用 webGL 最爽的部分，主要是不用考虑那些公式，这里用`Cannon.js`打个比方，（感动常在）。\n\n首先创建世界，比如创建一个 z 轴加速度为 9.82 的世界，还需要 NaiveBroadphase 做碰撞检测。\n\n```ts\nconst world = new World();\nworld.gravity.set(0, 0, -9.82);\nworld.broadphase = new NaiveBroadphase();\n```\n\n接下来创建一个物体，包括它的形状（shape）和在世界中的细节参数（body）。\n\n```ts\nconst shape = new Sphere(1);\nconst body = new Body({ mass: 5, shape });\nworld.add(body);\n```\n\n接下来设置渲染的时间间隔。\n\n```ts\nuseFrame(() => world.step(1 / 60)); // 单位秒\n```\n\n好了，那么怎么和 react-three-fiber 玩耍呢？其实可以写一个[useCannon](https://github.com/gongbaodd/webgl_demos/blob/dev/hooks/useCannon.tsx)。\n\n但是考虑到有现成的 hooks，自己就不用写轮子了，[react-spring/use-cannon](https://github.com/react-spring/use-cannon)，他是用 web worker 跑的，性能肯定更好，直接看例子好了，白嫖真爽。\n\n```jsx\nimport { Canvas } from \"react-three-fiber\";\nimport { Physics, usePlane, useBox } from \"use-cannon\";\n\nfunction Plane(props) {\n  const [ref] = usePlane(() => ({ rotation: [-Math.PI / 2, 0, 0], ...props }));\n  return (\n    <mesh ref={ref}>\n      <planeBufferGeometry attach=\"geometry\" args={[100, 100]} />\n    </mesh>\n  );\n}\n\nfunction Cube(props) {\n  const [ref] = useBox(() => ({ mass: 1, position: [0, 5, 0], ...props }));\n  return (\n    <mesh ref={ref}>\n      <boxBufferGeometry attach=\"geometry\" />\n    </mesh>\n  );\n}\n\nReactDOM.render(\n  <Canvas>\n    <Physics>\n      <Plane />\n      <Cube />\n    </Physics>\n  </Canvas>,\n  document.getElementById(\"root\")\n);\n```\n","collection":"blog","data":{"type":"post","category":"fe","tag":["threejs","webgl"],"series":{"slug":"threejs-howto","name":"细品threejs"}}},{"id":"2020/04/28/keyLemon.md","slug":"2020/04/28/keylemon","body":"\n# keyLemon 让任何一个摄像头都支持人脸登入\n\nWindows hello 是一个用一次就回不去的功能，目前我的笔记本支持指纹登入，一台平板外接了一个指纹接收器，另一台只能 PIN 码登入。显然 PIN 码用起来就不是很爽，然而这机器还是用来看书的。\n\n然而 Windows Hello 对摄像头要求很苛刻，于是我在想，有没有类似于安卓的单镜头解锁方案，KeyLemon 就是，v3 版本已经支持 Windows 10，虽然网上有评论说这软件免费版只能用 7 天，但是软件中只看到三种授权方式，basic 仅支持一张人脸和无活体检测的人脸登录，貌似这个 basic 就是免费版。\n\n实际体验，这个软件受光照影响很大，晚上录入的脸到早上就不识别了，这时输入 PIN 码依然可以登入。\n","collection":"blog","data":{"type":"post","category":"tech","tag":["windows","facial-recognition","keyLemon"],"series":{"slug":"windows-howto","name":"Windows舒适指南"}}},{"id":"2020/05/01/4.md","slug":"2020/05/01/4","body":"\n# 4 月工作总结\n\n一年的 1/3 已经结束了，而且距离离开深圳仅剩两个月了。\n\n## 计划完成情况\n\n- （完成）读完 threejs fundamentals\n- （完成）为博客增加 category 子项\n- （完成）测试服务器上的 strapi\n- （进行中）背完阅读词汇\n- （进行中）使用 yew 开发 game of life\n- （未进行）js 影像魔术师\n- （未进行）flutter 学习\n- （未进行）tensorflow.js 学习\n\n## 其他内容\n\n- 使用 portainer 管理我的后台服务\n- 学习使用 observableHQ，基于 D3 的笔记本工具\n- 为博客增加 tag 子项\n- 美剧：\n  - 零零零， 非常爽的贩毒剧\n  - Devs， 硬科幻剧，虎头蛇尾，有点可惜\n  - 环形物语，北欧治愈风的科幻剧\n- 电影：\n  - 饥饿平台，讨论阶级问题，哎，麻木了\n- 神器：\n  - KeyLemon，让任何 Windows 都支持人脸识别\n\n## 总结\n\n这个月完成了大部分上个月计划的事儿，中途顺便升级并重装了我的两个平板，现在我正在重置我的笔记本。\n\n这个月比较有意思的是碰到 yew 正在实现 functional component，所以我打算把 rust 学习部分延后一点，虽然 rust 真的很合适 wasm，但最合适的未必就是最后赢家，就好像手动挡是最厉害的座驾，但普遍选择都是自动挡（甚至电动车）。\n\n## 五月计划\n\n- 重置我的笔记本，可能是之前安装 hyper-v，导致现在系统更新只能手动安装，真心不方便。\n- 卖掉平衡车\n- 卖掉电饭锅\n- 把以前的笔记本寄回家\n- 把 Uklele 寄回家\n- 五一期间学习 flutter\n- 继续背诵单词\n","collection":"blog","data":{"type":"post","category":"plan"}},{"id":"2020/05/04/RN-Flutter-Dart.md","slug":"2020/05/04/rn-flutter-dart","body":"\n# 从 RN 到 Flutter-从 Dart 开始\n\n这是一篇翻译，原文来自于[官方文档](https://flutter.dev/docs/get-started/flutter-for/react-native-devs)，当然，里面夹带私货，哈哈。\n\n## 从 JavaScript 到 Dart\n\n就像 React Native，Flutter 也是用响应式界面。但是 React Native 是链接原生环境，而 flutter 则是直接编译到原生环境中。Flutter 可以控制屏幕上面的每一个像素，可以避免 JavaScript 和原生环境桥的性能问题。\n\nDart 是一个简单的语言，并提供以下功能。\n\n- 提供一个开源可伸缩的开发环境并提供给网页端、服务器端、移动端使用。\n- 提供单继承面向对象的 C 语法支持，并支持 AOT 编译至原生环境。\n- 可翻译到 JavaScript\n- 支持接口和虚基类的数据结构\n\n以下是几处 JavaScript 和 Dart 的不同之处。\n\n### 入口\n\nJavaScript 没有与设定的入口函数。\n\n```js\nfunction startHere() {\n  // 可以用来做入口函数\n}\n```\n\nDart 有一个顶级`main()`函数作为入口函数使用。\n\n```Dart\nmain() {}\n```\n\n在 [DartPad](https://dartpad.dev/0df636e00f348bdec2bc1c8ebc7daeb1) 上使用。\n\n### 打印日志\n\n在 Dart 中打印日志需要使用`print()`函数。\n\n```js\nconsole.log(\"Hello JavaScript!\");\n```\n\n```Dart\nprint(\"Hello Dart!\");\n```\n\n在 [DartPad](https://dartpad.dev/cf9e652f77636224d3e37d96dcf238e5) 试用。\n\n### 变量\n\nDart 是类型安全的——它结合静态类型检查和动态类型检查确保变量总是符合它的静态类型。即使类型是强制的，但类型标识并不是必须的，因为 Dart 会预判类型。\n\n#### 声明变量并赋值\n\n在 JavaScript 中，变量是无类型的（这是原文说的，不是我说的，我不是很同意）。\n\n```js\nvar name = \"JavaScript\";\n```\n\n在 Dart 中，变量必须声明类型，或者让系统能够预判类型。\n\n```Dart\nString name = \"Dart\";\nvar otherName = \"Dart\";\n```\n\n在 [DartPad](https://dartpad.dev/3f4625c16e05eec396d6046883739612) 中试用。\n\n点[这里](https://dart.dev/guides/language/sound-dart)了解 Dart 的类型系统。\n\n#### 默认值\n\n在 Javascript 中，未初始化的变量是`undefined`（他可能指的是函数作用域变量）。\n\n```js\nvar name; // undefined\n```\n\n在 Dart 中，未初始化的变量值为`null`。因为 Dart 中的类型都是对象，所以即使定义了类型但没有赋值它的默认值依然是 null。\n\n```dart\nvar name; // null\nint x; // null\n```\n\n在 [DartPad](https://dartpad.dev/57ec21faa8b6fe2326ffd74e9781a2c7) 使用。\n\n更多关于 [Dart 变量](https://dart.dev/guides/language/language-tour#variables) 的信息。\n\n#### 空值检查和零值检查\n\n在 JavaScript 中非空对象被认为是真值。\n\n```JavaScript\nvar myNull = null;\nif (!myNull) {\n  console.log(\"null是假值\");\n}\nvar zero = 0;\nif (!zero) {\n  console.log(\"0是假值\");\n}\n```\n\nDart 中，只有布尔真值是真值。\n\n```Dart\nvar myNull = null;\nif (myNull == null) {\n  print(\"使用 == null 做空值检查\");\n}\nvar zero = 0;\nif (zero == 0) {\n  print(\"使用 == 0 做零值检查\");\n}\n```\n\n在 [DartPad](https://dart.dev/guides/language/language-tour#variables) 上使用。\n\n#### 函数\n\n两个语言的函数基本上相同。\n\n```JavaScript\nfunction fn() {\n  return true;\n}\n```\n\n不同点是他们的声明。\n\n```dart\n{\n  fn() {\n    return true;\n  }\n}\n\n{// 也能这么写\n  bool fn() {\n    return true;\n  }\n}\n```\n\n在 [DartPad](https://dartpad.dev/5454e8bfadf3000179d19b9bc6be9918) 上使用，点[这里](https://dart.dev/guides/language/language-tour#functions)查看函数细节。\n\n#### 异步开发\n\n##### Futures\n\n和 Javascript 一样，Dart 支持单线程执行。JavaScript 使用 promise 对象处理异步的成功以及失败状态，并获取它的值。\n\n```js\nconst getIp = () =>\n  fetch(\"https://httpbin.org/ip\")\n    .then((res) => res.json())\n    .then(({ origin: { ip } }) => ip);\n\ngetIp()\n  .then((ip) => console.log(ip))\n  .catch((errpr) => console.error(error));\n```\n\n而在 Dart 中，使用 [Future](https://dart.dev/tutorials/language/futures) 对象处理异步。\n\n```Dart\nimport \"dart:convert\";\nimport \"package:http/http.dart\" as http;\n\nFuture<string> getIp() {\n  return http.get(\"https://httpbin.org/ip\")\n    .then((res) {\n      String ip = jsonDecode(res.body)[\"origin\"];\n      return ip;\n    });\n}\n\nmain() {\n  getIp()\n    .then(ip => print(ip))\n    .catchError((error) ==> print(error));\n}\n```\n\n点击[这里](https://dart.dev/tutorials/language/futures)了解 Future 对象。\n\n##### `async` 和 `await`\n\n使用 `async` 标识符声明异步函数。\n\n在 JavaScript 中，`async`函数返回一个`Promise`对象，并使用`await`处理它。\n\n```js\nasync function getIp() {\n  const res = await fetch(\"http://httpbin/ip\");\n  const { origin } = await res.json();\n  return origin;\n}\n\nasync function main() {\n  try {\n    const ip = await getIp();\n    console.log(ip);\n  } catch (e) {\n    console.log(e);\n  }\n}\n```\n\n在 Dart 中，`async`函数返回`Future`类型，函数体会被安排运行，`await`运算符被用来获取`Future`的返回值。\n\n```dart\nimport \"package:http/http.dart\" as http;\nimport \"dart:convert\"\n\nFuture<string> getIp() {\n  final res = await http.get(\"http://httpbin.org/ip\");\n  String ip = jsonDecode(res.body)['origin'];\n  return ip;\n}\n\nmain() async {\n  try {\n    final ip = await getIp();\n    print(ip);\n  } catch(e) {\n    print(e);\n  }\n}\n```\n\n了解更多[async 和 await](https://dart.dev/guides/language/language-tour#asynchrony-support)的信息。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["react-native","flutter","dart"],"series":{"slug":"Flutter-for-RN-devs","name":"从RN到Flutter","number":1}}},{"id":"2020/05/04/Upload.md","slug":"2020/05/04/upload","body":"\n# Upload 科幻喜剧，这个可以\n\n![Tech support!](./2020-05-04-upload.png)\n\nNanthan 在一场车祸之后被自己的白富美女友将自己的意识上传至网上，在虚拟世界 Nanthan 爱上了自己的服务人员，并意识到自己的死亡可能是一场阴谋。\n\n这不是一个烧脑剧，逻辑上有很多纰漏，角色也有点脸谱化，演员可能故意演得很生硬使得这个剧更加轻喜剧化，虽然讲的是谋杀但整个看起来很轻松，值得一看。\n\nMay the 4th be with you.\n","collection":"blog","data":{"type":"post","category":"tv"}},{"id":"2020/05/05/RN-Flutter.md","slug":"2020/05/05/rn-flutter","body":"\n# 从 RN 到 Flutter-简单说说\n\n## 如何创建一个 Flutter 应用\n\n创建一个 React Native，可以在终端中使用`create-react-native-typescript-app`，或者`expo-cli`。\n\n```shell\ncreate-react-native-typescript-app <projectname>\n```\n\n使用 Flutter 创建应用，可以采用以下两种方式。\n\n- 使用 IDE 中的 Flutter 和 Dart 插件。\n- 使用`flutter create`命令，请确保 Flutter SDK 已经在 PATH 中，[Windows 用户可以参考此文](/fe/2020/02/21/Windows安装flutter开发环境.html)。\n\n```shell\nflutter create <projectname>\n```\n\n更多内容，可以参考[快速入门](https://flutter.dev/docs/get-started)，入门是一个创建单按钮的计数项目，并能够部署在 Android 和 iOS 设备中的示例应用。\n\n## 如何运行应用\n\n在 React Native 中，你可以使用`npm run`或者`yarn run`。\n\n在 Flutter 中，可以参考如下方式：\n\n- 使用 IDE 中的\"run\"选项。\n- 在项目根目录执行 `flutter run`。\n\n你的应用会在连接好的设备上执行。\n\n更多信息，请参考 Flutter 的[快速入门](https://flutter.dev/docs/get-started)。\n\n## 如何引入部件\n\n在 React Native 中，你需要引入组件。\n\n```JavaScript\nimport React from \"react\";\nimport { StyleSheet, Text, View } from \"react-native\";\n```\n\n在 Flutter 中，需要引入`material.dart`包来使用 Material Design 库中的部件。要使用 iOS 样式的部件则需要引入 Cupertino 库。想使用更多基础部件，需要引入他们的库，或者你也可以自己写一个部件库，并引入。\n\n```Dart\nimport \"package:flutter/material.dart\";\nimport \"package:flutter/cupertino.dart\";\nimport \"package:flutter/widgets.dart\";\nimport \"package:flutter/my_widgets.dart\";\n```\n\n无论你引入了什么包，Dart 只会使用你在应用中使用的部件。\n\n## 写一个和 React Native 中一样的 Hello World 应用\n\n在 React Native 中，`HelloWorldApp`是`React.Component`的一个实现，并返回如下 view 组件实现。\n\n```tsx\nimport React, { FC } from \"react\";\nimport { StyleSheet, Text, View } from \"react-native\";\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: \"#fff\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n});\n\nconst App: FC = () => (\n  <View style={styles.container}>\n    <Text>Hello world!</Text>\n  </View>\n);\n\nexport default App;\n```\n\n在 Flutter 中，创建一个 Hello World 应用需要使用`Center`和`Text`核心部件，`Center`部件在部件树的根部件，并拥有唯一子部件`Text`。\n\n```Dart\nimport \"package:flutter/material.dart\";\n\nmain() {\n  runApp(\n    Center(\n      child: Text(\n        \"Hello World!\",\n        textDirection: TextDirection.ltr,\n      )\n    )\n  );\n}\n```\n\n（卧槽，写 Hello World 还挺简短的，怕不是错觉...）\n\n| Android                                                                                                                                                                | iOS                                                                                                                                                            |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| ![Android展示样式](https://flutter.dev/assets/get-started/android/react-native/hello-world-basic-ed1ed2698fc492892552a8d719b0e124b7a50e2f8e0327f1548e2834b0aa515a.png) | ![iOS展示样式](https://flutter.dev/assets/get-started/ios/react-native/hello-world-basic-1ba3dfcb9fcbee11f5307cde947ab29dd4f52683f311b049242a28fefb37412b.png) |\n\n这就是 Flutter 中最基础的应用，下一个部分将会利用 Flutter 丰富的组件库创建现代应用。\n\n## 如何使用在部件树中增加部件\n\n在 Flutter 中，几乎一切都是部件。\n\n部件是创建用户界面的基础块。部件组成的层级结构叫做部件树。每个部件接入它的父部件，并继承它们的属性。即使应用对象本身也是个部件。并没有分离的\"application\"对象，根部件就是它。\n\n一个部件可以定义如下内容：\n\n- 一个有结构的元素 —— 如一个按钮或菜单。\n- 一个样式元素 —— 如字体或者颜色方案。\n- 一个布局或视角 —— 如边距或者对齐。\n\n如下的例子使用 Material Design 创建部件，在此例子中，部件树链接在`MaterialApp`跟部件下。\n\n```Dart\nimport \"package:flutter/material.dart\";\n\nWidget MyApp() {\n  return MaterialApp(\n    title: \"Welcome to Flutter\",\n    home: Scaffold(\n      appBar: AppBar(\n        title: Text(\"Welcome to Flutter\"),\n      ),\n      body: Center(\n        child: Text(\"Hello world\"),\n      ),\n    ),\n  );\n}\n\nmain() => runApp(MyApp());\n```\n\n如下是使用 Material Design 部件创建的 “Hello world!” 应用。\n\n| Android                                                                                                                                                                             | iOS                                                                                                                                                                          |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| ![Adroid Material Design Hello World](https://flutter.dev/assets/get-started/android/react-native/hello-world-198f4b19ca6d3dd72f6a17dd858814cc42cf2bc696f61d7f273be95818110777.png) | ![iOS Material Design Hello World](https://flutter.dev/assets/get-started/ios/react-native/hello-world-ed7cf47213953bfca5eaa74fba63a78538d782f2c63a7c575068f3c2f7298bde.png) |\n\n写应用的时候，会使用到两种部件`StatelessWidget`和`StatefulWidget`（上面我写的就是`StatelessWidget`不过没有按照面向对象的写法去写）。一个`StatelessWidget`是一个没有状态的部件，它一旦被创建就不会改变。一个`StatefulWidget`会基于数据变化或者用户输入动态改变。\n\n`StatelessWidget`和`StatefulWidget`二者的最大不同点，就是`StatefulWidget`拥有一个`State`对象来存储数据，以避免在部件树渲染的时候丢失。\n\n在简单的项目中，写部件树是容易的，但是当代码变多之后，应用会越来越复杂，你应该将很深的部件封装成函数或者简单的类。创建封装好的函数和类有利于在复杂项目中实现复用。\n\n## 如何创建可复用的组件\n\n在 React Native 中，创建一个可复用的组件，并使用`props`向它传入属性和值。在如下的例子中，`CustomCard`就是个可复用组件。\n\n```tsx\nconst CustomCard: FC<{ index?: number; onPress?: () => void }> = ({\n  index,\n  onPress,\n}) => (\n  <View>\n    <Text>Card {index}</Text>\n    <Button title=\"Press\" onPress={() => onPress()} />\n  </View>\n);\n\n// Usage\n<CustomCard onPress={() => console.log(1)} index={1} />;\n```\n\n在 Flutter 中，可以通过创建一个后浪于（怎么样，这说法阳春不？）部件的类，并实现它的`build`函数，你也可以创建一个函数并复用它。\n\n```dart\nWidget CustomCard({int index, Function onPress}) {\n  return Card(\n    child: Column(\n      children: <Widget>[\n        Text('Card $index'),\n        FlatButton(\n          child: const Text('Press'),\n          onPress: onPress,\n        ),\n      ],\n    ),\n  );\n}\n\n// Usage\nCustomCard(index = 1, onPress = () { print('Card 1'); })\n```\n\n以上`CustomCard`参数的大括号是 Dart[可选参数](https://dart.dev/guides/language/language-tour#optional-parameters)。\n\n在类的构造函数中，可以使用`@required`实现必要参数。\n\n如下截图是`CustomCard`的展示效果。\n\n| Android                                                                                                                                                              | iOS                                                                                                                                                          |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| ![Android CustomCard](https://flutter.dev/assets/get-started/android/react-native/custom-cards-6bdba4664044a9e5328c0304a51c45fc2812bb37b3d0d57b0c93b98d5bab1f42.png) | ![iOS CustomCard](https://flutter.dev/assets/get-started/ios/react-native/custom-cards-47e3e1e3e73a0ce419eacbee11dc2f15b9acac9b5877c43cd1a783a792b519dc.png) |\n","collection":"blog","data":{"type":"post","category":"fe","tag":["react-native","flutter","dart"],"series":{"slug":"Flutter-for-RN-devs","name":"从RN到Flutter","number":2}}},{"id":"2020/05/05/The-third-season-of-the-Western-World,-which-is-made-up.md","slug":"2020/05/05/the-third-season-of-the-western-world-which-is-made-up","body":"\n# 凑数的西部世界第三季\n\n虽然第三季和很多剧比起来依然优秀，但是烧脑程度和剧情都比不上前两季。可能因为前两季观众都以为 AI 开始覆灭人类了，编剧偏偏不，然后安排了个一季领盒饭的反派拖时间，然后第四季再开始毁灭人类...\n","collection":"blog","data":{"type":"post","category":"tv"}},{"id":"2020/05/06/RN-Flutter.md","slug":"2020/05/06/rn-flutter","body":"\n# 从 RN 到 Flutter-部件\n\n在 Flutter 中，你应该使用部件去描述针对于现有状态和配置的界面。\n\n部件是由许多很小或者单一目的的部件组成。比如`Container`部件就包括几个相关布局、绘制、定位和定型组件，像是`LimitedBox`、`ConstrainedBox`、`Align`、`Padding`、`DecoratedBox`以及`Transform`部件。除了使用`Container`来实现效果，你也可以用几个组件来实现它。\n\n`Center`部件是另一个控制布局的例子。想要剧中部件，就用`Center`包住它。这些部件没有自己的展示，他们的目标就是控制内部部件的布局。想要理解部件是如何渲染，可以去查看他们的相邻部件。\n\n了解更多信息，可以查看[Flutter 技术概览](https://flutter.dev/docs/resources/technical-overview)。\n\n想要了解更多部件信息，可以查看[Flutter 基础部件](https://flutter.dev/docs/development/ui/widgets/basics)，[Flutter 部件目录](https://flutter.dev/docs/development/ui/widgets) 或者 [Flutter 部件索引](https://flutter.dev/docs/reference/widgets)。\n\n## 界面\n\n### Flutter 中的 `View` 组件\n\n在 React Native 中，`View`是支持`Flexbox`布局、样式处理、触摸处理和无障碍化的组件。\n\n在 Flutter 中，你可以使用诸如`Container`、`Column Row`和`Center`的核心布局部件。更多信息可以参考[布局部件](https://flutter.dev/docs/development/ui/widgets/layout)目录。\n\n### Flutter 中的 `FlatList` 和 `SectionList` 组件\n\n一个`List`是垂直排布的可滚动列表。\n\n在 React Native 中，`FlatList`和`SectionList`可以用来渲染简单的或者复杂内容的列表。\n\n```tsx\n<FlatList data={[]} renderItem={({ item }) => <Text>{item.key}</Text>} />\n```\n\n`ListView`是 Flutter 中最常被使用的滚动部件。默认的构造器接受一列准确定义的数据。`ListView`适合少量个数部件渲染。对于无限滚动，需要使用`ListView.builder`，它会按需渲染，并之渲染能展示出来的数据。\n\n```dart\nvar data = [];\nListView.builder(\n    itemCount: data.length,\n    itemBuilder: (context, int index) {\n        return Text(data[index]);\n    },\n);\n```\n\n| Adroid ListVIew                                                                                                                                                | iOS ListView                                                                                                                                           |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| ![Android ListView](https://flutter.dev/assets/get-started/android/react-native/flatlist-91d7c8beaadff16f52d663e94aae7b4c9959d1d811dd7f12ea2005a10e166d34.gif) | ![iOS ListView](https://flutter.dev/assets/get-started/ios/react-native/flatlist-2a18c0173248dd8bf250b29fab7e4cdbc917c27d90ac33c1c791ecb73463f3a5.gif) |\n\n阅读[你的第一个 Flutter 应用，第一部分](https://codelabs.developers.google.com/codelabs/first-flutter-app-pt1)更多了解如何实现无限滚动。\n\n### 如何使用画布\n\n在 React Native 中是没有相关组件的，需要引入类似于`react-native-canvas`的第三方组件。\n\n```tsx\nconst App = () => {\n  return (\n    <View>\n      <Canvas\n        ref={(canvas) => {\n          const ctx = canvas.getContext(\"2d\");\n          ctx.fillStyle = \"skyblue\";\n          ctx.beginPath();\n          ctx.arc(75, 75, 50, 0, 2 * Math.PI);\n          ctx.fillRect(150, 100, 300, 300);\n          ctx.stroke();\n        }}\n      />\n    </View>\n  );\n};\n```\n\n在 Flutter 中，你可以使用`CustomPaint`和`CustomPainter`类去绘制画布。\n\n下面的例子展示的是如何使用`CustomPaint`部件绘制。它实现了虚类 `CustomPainter`，并传递了 `CustomPaint` 的属性。`CustomPaint` 的子类必须实现 `paint()` 和 `shouldRepaint()` 方法。\n\n```dart\nclass MyCanvasPainter extends CustomPainter {\n    paint(Canvas anvas, Size size) {\n        {\n            Paint paint = Paint();\n            paint.color = Colors.amber;\n            canvas.drawCircle(Offset(100.0, 200.0), 40.0, paint);\n        }\n        {\n            Paint paint = Paint();\n            paint.color = Colors.lightBlue;\n            Rect rect = Rect.fromPoints(Offset(150.0, 300.0), Offset(300.0, 400.0));\n            canvas.drawRect(rect, paintRect);\n        }\n    }\n    shouldRepaint() => false;\n}\n\nWidget getCanvas() {\n    return Scaffold(\n        body: CustomPaint(\n            paint: MyCanvasPainter(),\n        ),\n    );\n}\n```\n\n| Android CustomPaint                                                                                                                                             | iOS CustomPaint                                                                                                                                         |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| ![Android CustomPaint](https://flutter.dev/assets/get-started/android/react-native/canvas-cf039fc10bae17fb60b21adb4228eb928b2bf284f95fee71c5a20033c217e333.png) | ![iOS CustomPaint](https://flutter.dev/assets/get-started/ios/react-native/canvas-2cc207759f6ab912bf73e1c3298dc2183618ef207ed989f4d83f6c08fd3a3279.png) |\n\n## 布局\n\n### 如何使用布局部件\n\n在 React Native，许多布局可以通过 props 传入。比如，你可以使用`View`的`style`属性去指定 flexbox 布局。想要让组件成列排列，可以指定样式为`flexDirection: \"column\"`。\n\n```JavaScript\n<View\n    style={{\n        flex: 1,\n        flexDirection: \"column\",\n        justifyContent: \"space-between\",\n        alignItems: \"center\"\n    }}\n/>\n```\n\n在 Flutter 中，布局主要是由既定的布局部件和他们的参数实现。\n\n举个例子，`Column`和`Row`组件接受一个数组作为参数来以列或者以行排列。一个`Container`部件既能处理样式也能处理布局，一个`Center`部件可以将组件居中。\n\n```Dart\nCenter(\n    child: Column(\n        children: <Widget> [\n            Container(\n                color: Colors.red,\n                width: 100.0,\n                height: 100.0,\n            ),\n            Container(\n                color: Colors.blue,\n                width: 100.0,\n                height: 100.0\n            ),\n            Container(\n                color: Colors.green,\n                width: 100.0,\n                height: 100.0,\n            ),\n        ],\n    ),\n)\n```\n\nFlutter 提供一堆布局部件，比方说，`Padding`、`Align`和`Stack`。\n\n了解全部的布局部件，可以查看[布局部件](https://flutter.dev/docs/development/ui/widgets/layout)。\n\n| Adroid Layout                                                                                                                                                    | iOS Layout                                                                                                                                               |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| ![Adroid Layout ](https://flutter.dev/assets/get-started/android/react-native/basic-layout-2490ba3bed87bbf579b422977dcaa34f51a5b77dab53abbd460028acda33a000.gif) | ![iOS Layout](https://flutter.dev/assets/get-started/ios/react-native/basic-layout-bb720a0054daf418b7bafb40619c490933b730f9e45bd9003254ea9d80d6c163.gif) |\n\n### 如何堆叠部件\n\n在 React Native，可以使用绝对定位`absolute`来堆叠组件。\n\nFlutter 使用`Stack`部件让部件按照图层分布。部件会部分覆盖于下面的部件。\n\n```dart\nStack(\n    alignment: cont Alignment(0.6, 0.6),\n    children: <Widget>[\n        CircleAvatar(\n            backgroundImage: NetworkImage(\n                'https://avatars3.githubusercontent.com/u/14101776?v=4'\n            )\n        ),\n        Container(\n            decoration: BoxDecoration(\n                color: Colors.black45,\n            ),\n            child: Text(\"Flutter\"),\n        ),\n    ],\n)\n```\n\n上面的例子使用`Stack`来布局一个`Container`并展示一个拥有黑色半透明背景的`Text`部件覆盖于`CircleAvatar`部件。这个部件通过对齐参数来规定文字位置。\n\n| Android Stack                                                                                                                                            | iOS Stack                                                                                                                                        |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------ |\n| ![Android Stack](https://flutter.dev/assets/get-started/android/react-native/stack-65e0c9e7fc3db73d80d3943f6e88fc788819b1ab4c1354c11e4711298e26ecd0.png) | ![iOS Stack](https://flutter.dev/assets/get-started/ios/react-native/stack-04b7bf2727e1eb71f5dfea8430ee833f24be1ced1893ae86270795b2ab76c5b9.png) |\n\n更多信息可以查看`Stack`对象[文档](https://api.flutter.dev/flutter/widgets/Stack-class.html)。\n\n## 样式\n\n### 如何处理组件样式\n\n在 React Native 中，内联样式和`stylesheets.create`是用来处理组件样式的。\n\n```tsx\nconst style = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: \"#fff\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n});\n\n<View style={styles.container}>\n  <Text style={{ fontSize: 32, color: \"cyan\", fontWeight: \"600\" }}>\n    This is a simple text\n  </Text>\n</View>;\n```\n\n在 Flutter 中，`Text`部件可以使用`TextStyle`类，这个类的对象也可以给多个部件复用。\n\n```dart\nvar textStyle = TextStyle(\n    fontSize: 32.0,\n    color: Colors.cyan,\n    fontWeight: FontWeight.w600,\n);\n\nCenter(\n    child: Column(\n        children: <Widget>[\n            Text(\n                'sample text',\n                style: textStyle,\n            ),\n            Padding(\n                padding: EdgeInsets.all(20.0),\n                child: Icon(\n                    Icons.lightbulb_outline,\n                    size: 48.0,\n                    color: Colors.redAccent,\n                ),\n            ),\n        ],\n    ),\n)\n```\n\n| Android Style                                                                                                                                                     | iOS Style                                                                                                                                                 |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| ![Android Style](https://flutter.dev/assets/get-started/android/react-native/flutterstyling-10cfb607a02859b2a1e9767237029b3cc47891fd017bd70d84536de26383b39c.gif) | ![iOS Style](https://flutter.dev/assets/get-started/ios/react-native/flutterstyling-8b812e5226435b0db6f72b4f2f03a7c72b45bf0794965a0bee882fea909fc7b8.gif) |\n\n### 如何使用图标和颜色\n\nReact Native 没有支持图标的库（这点我不是很同意）。\n\n在 Flutter 中，引入 Material 库包含一堆[Material 图标](https://api.flutter.dev/flutter/material/Icons-class.html)和[颜色](https://api.flutter.dev/flutter/material/Colors-class.html)。\n\n```dart\nIcon(Icons.lightbulb_outline, color: COlors.redAccent)\n```\n\n使用`Icons`类时，记住要把`uses-material-design: true`设置在`pubspec.yaml`中。这保证`MaterialIcons`字体会被包括在应用中。\n\n```yaml\nname: my_awesome_application\nflutter:\n  uses-material-design: true\n```\n\nFlutter 的[Cupertino](https://flutter.dev/docs/development/ui/widgets/cupertino)包，完全遵守 iOS 设计语言。要使用`CupertinoIcons`字体，在项目中增加`cupertino_icons`依赖。\n\n```yaml\nname: my_awesome_application\ndependencies:\n  cupertino_icons: ^0.1.0\n```\n\n要完全的自定义组件的色彩和样式，使用`ThemeData`来定义主题。设置`MaterialApp`的`ThemeData`对象。`Colors`类提供遵守 Material 设计语言的调色盘。\n\n```dart\nWidget build() {\n    return MaterialApp(\n        title: \"Sample App\",\n        theme: ThemeData(\n            primarySwatch: Colors.blue,\n            textSelectionColor: Colors.red,\n        ),\n        home: SampleAppPage()\n    );\n}\n```\n\n### 如何增加主题样式\n\n在 Ract Native，主题是组件定义好的。\n\n在 Flutter 中，使用`ThemeData`类为整个`MaterialApp`部件提供主题。\n\n```dart\nWidget build() {\n    return MaterialApp(\n        title: \"Sample App\",\n        theme: ThemeData(\n            primarySwatch: Colors.blue,\n            textSelectionColor: Colors.red,\n        ),\n        home: SampleAppPage()\n    );\n}\n```\n\n一个`Theme`甚至可以不依赖于`MaterialApp`部件。[Theme](https://api.flutter.dev/flutter/material/Theme-class.html)部件需要一个`ThemeData`传入它的`data`参数中，以适配它的所有子部件。\n\n```dart\nclass SampleTheme extends StatelessWidget {\n    Widget build(BuildContext context) {\n      return Theme(\n           data: ThemeData(\n               primaryColor: Colors.cyan,\n               brightness: brightness,\n           ),\n           child: Scaffold(\n               backgroundColor: Theme.of(context).primaryColor,\n           )\n       )\n    }\n}\n```\n","collection":"blog","data":{"type":"post","category":"fe","tag":["react-native","flutter","dart"],"series":{"slug":"Flutter-for-RN-devs","name":"从RN到Flutter","number":4}}},{"id":"2020/05/06/spacedesk.md","slug":"2020/05/06/spacedesk","body":"\n# spacedesk 让任意一台设备成为扩展屏幕\n\n之前我有一篇[文章](/tech/2020/02/23/Mouse_without_borders让鼠标同时连接四台设备.html)，让鼠标和键盘能跨越四台 Windows，而[spacedesk](https://spacedesk.net/)则是让所有设备成为主计算机的扩展屏幕，注意，这里是所有，包括 Windows 设备和手机设备，应该是类似于 miracast 的技术，安利应用商店里的 slave 端，运行很快。\n","collection":"blog","data":{"type":"post","category":"tech","tag":["windows"],"series":{"slug":"windows-howto","name":"Windows舒适指南"}}},{"id":"2020/05/07/RN-Flutter.md","slug":"2020/05/07/rn-flutter","body":"\n# 从 RN 到 Flutter-路由器\n\n> 我要死了，这个系列怎么这么长。\n\n许多应用都有多个页面来展示不同信息。比方说，你可能在页面展示一个产品的图片，当用户点击时打开这个产品的详情。\n\n在 Android，新的页面叫做 Activities。在 iOS 新的页面叫 ViewControllers，在 Flutter，新的页面也是部件！包括导航至这些页面的导航器也是导航器部件。\n\n## 如何在页面中导航\n\n在 React Native 里面，有三个导航器`StackNavigator`，`TabNavigator`和`DrawerNavigator`。都提供了配置的接口。\n\n```js\n// React Native\nconst MyApp = TabNavigator(\n  { Home: { screen: HomeScreen }, Notifications: { screen: tabNavScreen } },\n  { tabBarOptions: { activeTintColor: \"#e91e63\" } }\n);\nconst SimpleApp = StackNavigator({\n  Home: { screen: MyApp },\n  stackScreen: { screen: StackScreen },\n});\nexport default MyApp1 = DrawerNavigator({\n  Home: {\n    screen: SimpleApp,\n  },\n  Screen2: {\n    screen: drawerScreen,\n  },\n});\n```\n\n在 Flutter 中，有两个部件用于处理页面路由。\n\n- `Route` 是页面的抽象。\n- `Navigator` 是管理路由的部件。\n\n`Navigator`通过将一列页面以堆的方式覆盖，并提供方法管理这个堆，像是[Navigator.push](https://api.flutter.dev/flutter/widgets/Navigator/push.html)和[Navigator.pop](https://api.flutter.dev/flutter/widgets/Navigator/pop.html)。[MaterialApp](https://api.flutter.dev/flutter/material/MaterialApp-class.html) 部件提供 routes 参数接受这些路由，这些路由可能会明确指出或者动态生成，比如标题动画。下面是一个指明路由的例子。\n\n```dart\nclass App extends StatelessWidget{\n    Widget build(BuildContext: context) {\n        return MaterialApp(\n           routes: <String, WidgetBuilder> {\n                '/a': (BuildContext: context) => usualNavscreen(),\n                '/b': (BuildContext: context) => drawerNavscreen(),\n          },\n       ),\n    }\n}\n```\n\n使用`Navigator.of()`并指定一个`BuildContext`来处理导航，比如前往某个特定页面，可以使用`pushNamed`。\n\n```dart\nNavigator.of(context).pushNamed('/a');\n```\n\n你可以使用`push`方法调用已存在的[Route](https://api.flutter.dev/flutter/widgets/Route-class.html)，这样会动画打开 Route。下面的例子中[MaterialPageRoute](https://api.flutter.dev/flutter/material/MaterialPageRoute-class.html)提供一个模态的页面，并适配系统动画。\n\n```dart\nNavigator.push(context, MaterialPageRoute(builder: (BuildContext context)\n => UsualNavscreen()));\n```\n\n## 如何使用选项卡和抽屉导航\n\n在 Material 设计语言中，为 Flutter 提供了两种导航选项，tab 和 drawer。如果空间使用 tab 很紧张，则 drawer 是个不错的替代。\n\n### 选项卡导航\n\n在 React Native 中，`createBottomTabNavigator`和`TabNavigation`被用来处理选项卡和导航。\n\n```js\nimport { createBottomTabNavigator } from \"react-navigation\";\n\nconst MyApp = TabNavigator(\n  { Home: { screen: HomeScreen }, Notifications: { screen: tabNavScreen } },\n  { tabBarOptions: { activeTintColor: \"#e91e63\" } }\n);\n```\n\nFlutter 提供特别的部件处理抽屉和选项卡导航。\n\n- [TabController](https://api.flutter.dev/flutter/material/TabController-class.html)\n\n  提供`TabBar`和`TabBarView`的控制器\n\n- [TabBar](https://api.flutter.dev/flutter/material/TabBar-class.html)\n\n  展示横向的选项卡\n\n- [Tab](https://api.flutter.dev/flutter/material/Tab-class.html)\n\n  展示 Material 设计语言的单一选项\n\n- [TabBarView](https://api.flutter.dev/flutter/material/TabBarView-class.html)\n\n  展示选中的选项卡\n\n```dart\nTabController controller = TabController(length: 2, vsync: this);\n\nTabBar(\n    tabs: <Tab>[\n        Tab(icon: Icon(Icons.person),),\n        Tab(icon: Icon(Icons.email),),\n    ],\n    controller: controller,\n),\n```\n\n一个`TabController`用于协调`TabBar`和`TabBarView`。构造参数中的`length`属性，提供选项卡的个数。一个`TickerProvider`被用来处理框架状态变化的消息的，通过`vsync`传入。`vsync:this`参数是创建`TabController`必要的。\n\n[TickerProvider](https://api.flutter.dev/flutter/scheduler/TickerProvider-class.html)是可以产生[Ticker](https://api.flutter.dev/flutter/scheduler/Ticker-class.html)对象的类的接口。Ticker 是可以用来接收框架消息的对象，但是他们基本上都是间接通过[AnimationController](https://api.flutter.dev/flutter/animation/AnimationController-class.html)。`AnimationController`需要`TickerProvider`来获取`Ticker`对象。如果你正在从 State 里面创建一个 AnimationController，你可以使用[TickerProviderStateMixin](https://api.flutter.dev/flutter/widgets/TickerProviderStateMixin-mixin.html)或者[SingleTickerProviderStateMixin](https://api.flutter.dev/flutter/widgets/SingleTickerProviderStateMixin-mixin.html)对象以得到`TrickerProvider`。如果你用的是`flutter-hooks`你可以使用`useSingleTickerProvider`获取`Ticker`对象。\n\n[Scaffold](https://api.flutter.dev/flutter/material/Scaffold-class.html)部件封装了一个新的`TabBar`部件并创建两个选项卡。`TabBarView`部件通过`body`参数传入。所有页面的`TabBar`都是`TabBarView`部件的子部件。\n\n```dart\nclass Home extends StatefulWidget {\n  Home() : super();\n  @override\n  State<StatefulWidget> createState() {\n    return _Home();\n  }\n}\n\nclass _Home extends State<Home> with SingleTickerProviderStateMixin {\n  @override\n  Widget build(BuildContext context) {\n    TabController controller = TabController(length: 2, vsync: this);\n    return Scaffold(\n        appBar: AppBar(\n          title: Text('home'),\n        ),\n        bottomNavigationBar: Material(\n          color: Colors.blue,\n          child: TabBar(\n            controller: controller,\n            tabs: <Tab>[\n              Tab(\n                icon: Icon(Icons.person),\n              ),\n              Tab(\n                icon: Icon(Icons.email),\n              )\n            ],\n          ),\n        ),\n        body: TabBarView(\n          children: <Widget>[\n            Center(\n              child: Text('person'),\n            ),\n            Center(\n              child: Text('email'),\n            )\n          ],\n          controller: controller,\n        ));\n  }\n}\n\n```\n\n当然也可以使用`flutter-hooks`，其实如果收拾一下的话都要写两个类，就看你爱怎么写了。\n\n```dart\nclass Home extends HookWidget {\n  @override\n  Widget build(BuildContext context) {\n    final vsync = useSingleTickerProvider();\n    final controller = useMemoized(() {\n      return TabController(length: 2, vsync: vsync);\n    });\n\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Home'),\n      ),\n      bottomNavigationBar: Material(\n        color: Colors.blue,\n        child: TabBar(\n          controller: controller,\n          tabs: <Widget>[\n            Tab(icon: Icon(Icons.person)),\n            Tab(icon: Icon(Icons.email))\n          ],\n        ),\n      ),\n      body: TabBarView(\n        controller: controller,\n        children: <Widget>[\n          Center(child: Text(\"person\")),\n          Center(\n            child: Text(\"email\"),\n          )\n        ],\n      ),\n    );\n  }\n}\n\n```\n\n## 抽屉导航\n\n在 React Native 中，需要引入`react-navigation`包，并使用`createDrawerNavigator`和`DrawerNavigation`。\n\n```js\nexport default MyApp = DrawerNavigator({\n  Home: {\n    screen: SimpleApp,\n  },\n  Screen2: {\n    screen: drawScreen,\n  },\n});\n```\n\n在 Flutter 中，我们可以使用`Drawer`部件结合`Scaffold`部件创建 Material 设计语言的抽屉。想要创建一个带有抽屉的应用，需要将`Drawer`封装至`Scaffold`中。`Scaffold`部件提供一套基于[Material 设计标准](https://material.io/design)的样式结构，并且还支持许多特殊的 Material 设计组件，比如`Drawer`、`AppBar`和`SnackBar`。\n\n`Drawer`部件是一个基于 Material 设计的控制台，它在`Scaffold`水平方向的边缘，展示应用的导航链接。你可以在这个部件中使用[RaisedButton](https://api.flutter.dev/flutter/material/RaisedButton-class.html)和[Text](https://api.flutter.dev/flutter/widgets/Text-class.html)组件，或者一个列表。在下面的例子中[ListTile](https://api.flutter.dev/flutter/material/ListTile-class.html)就提供了点击导航的功能。\n\n```dart\n// Flutter\nDrawer(\n  child:ListTile(\n    leading: Icon(Icons.change_history),\n    title: Text('Screen2'),\n    onTap: () {\n      Navigator.of(context).pushNamed('/b');\n    },\n  ),\n  elevation: 20.0,\n),\n```\n\n在`Scaffold`部件的`AppBar`会自动适配给`Drawer`一个图标，并且`Scaffold`能够自动处理`Drawer`的左滑手势。\n\n```dart\n// Flutter\n@override\nWidget build(BuildContext context) {\n  return Scaffold(\n    drawer: Drawer(\n      child: ListTile(\n        leading: Icon(Icons.change_history),\n        title: Text('Screen2'),\n        onTap: () {\n          Navigator.of(context).pushNamed('/b');\n        },\n      ),\n      elevation: 20.0,\n    ),\n    appBar: AppBar(\n      title: Text('Home'),\n    ),\n    body: Container(),\n  );\n}\n```\n\n另外，如果不爽页面转场动画单一，然后自己又懒得写动画，可以直接用[page_transition](https://pub.dev/packages/page_transition)包。\n\n| Android Drawer                                                                                                                                                 | iOS Drawer                                                                                                                                             |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| ![Android Drawer](https://flutter.dev/assets/get-started/android/react-native/navigation-98906732ed22d9aa8e0ce0eb846dbcc7d24c123ad026c359f9f7fcc44ba99230.gif) | ![iOS Drawer](https://flutter.dev/assets/get-started/ios/react-native/navigation-1939f60628bec820bad0fe88d58c562984c1c00d8cfd755a4135f4321a37417e.gif) |\n","collection":"blog","data":{"type":"post","category":"fe","tag":["React-Native","flutter"],"series":{"slug":"Flutter-for-RN-devs","name":"从RN到Flutter","number":6}}},{"id":"2020/05/08/RN-Flutter.md","slug":"2020/05/08/rn-flutter","body":"\n# 从 RN 到 Flutter-动画\n\n好的动画会使 UI 更加直观，是应用更加精致，并提高用户体验。Flutter 的动画使简单动画和复杂动画的实现变得容易。Flutter SDK 所遵守的 Material 设计语言包含了标准的动态效果，你可以简单地自定义它们并应用于你的应用。\n\n在 React Native 中，Animated API 被应用于创建动画。\n\n在 Flutter 中，使用[Animation](https://api.flutter.dev/flutter/animation/Animation-class.html)类和[AnimationController](https://api.flutter.dev/flutter/animation/AnimationController-class.html)类。`Animation`是包括一个动画初始状态到它终态（完成或者取消）状态的抽象类。`AnimationController`类控制动画的执行、反转或者停止动画，乃至于设置动画为某一个值以做到自定义的目的。\n\n## 实现一个淡入动画\n\n下面的 React Native 例子是利用 Animated API 创建的`FadeInView`组件。初始状态、终止状态已经过程都需要定义。该组件包裹需要动画的组件，透明值`fadeAnim`向下继承到`Text`组件中，使得执行`start()`后，动画就开始了。\n\n```js\n// React Native\nclass FadeInView extends React.Component {\n  state = {\n    fadeAnim: new Animated.Value(0) // Initial value for opacity: 0\n  };\n  componentDidMount() {\n    Animated.timing(this.state.fadeAnim, {\n      toValue: 1,\n      duration: 10000\n    }).start();\n  }\n  render() {\n    return (\n      <Animated.View style={{...this.props.style, opacity: this.state.fadeAnim }} >\n        {this.props.children}\n      </Animated.View>\n    );\n  }\n}\n    ...\n<FadeInView>\n  <Text> Fading in </Text>\n</FadeInView>\n    ...\n```\n\n想在 Flutter 中实现相应效果，需要创建一个 [AnimationController](https://api.flutter.dev/flutter/animation/AnimationController-class.html) 对象，命名为`controller`并指明持续时间。默认`AnimationController`会在持续时间内线性执行动画。这个动画控制器在每一帧都会返回一个新值，默认是每秒 60 个值。\n\n使用`AnimationController`时，必须传入`vsync`对象。引入`vsync`的目的是避免不在屏幕上的动画浪费资源。你可以使用你的状态机作为`vsync`，只要在类定义的时候混入`TickerProviderStateMixin`。一个`AnimationController`构造时需要一个 TickerProvider 作为`vsync`参数。\n\n[Tween](https://api.flutter.dev/flutter/animation/Tween-class.html)描述初始值和结束值之间的插值。动画中使用`Tween`对象，可以将`Tween`的`animate()`返回值传给要修改的`Animation`对象。\n\n使用`controller.forward()`开始动画。其他操作如`fling()`和`repeat()`也可以开始动画。比如下面的例子，将[FlutterLogo](https://api.flutter.dev/flutter/material/FlutterLogo-class.html)部件放在`FadeTransition`部件中。\n\n```dart\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(Center(child: LogoFade()));\n}\n\nclass LogoFade extends StatefulWidget {\n  _LogoFadeState createState() => _LogoFadeState();\n}\n\nclass _LogoFadeState extends State<LogoFade> with TickerProviderStateMixin {\n  Animation animation;\n  AnimationController controller;\n\n  initState() {\n    super.initState();\n    controller = AnimationController(\n        duration: const Duration(milliseconds: 3000), vsync: this);\n    final CurvedAnimation curve =\n    CurvedAnimation(parent: controller, curve: Curves.easeIn);\n    animation = Tween(begin: 0.0, end: 1.0).animate(curve);\n    controller.forward();\n  }\n\n  Widget build(BuildContext context) {\n    return FadeTransition(\n      opacity: animation,\n      child: Container(\n        height: 300.0,\n        width: 300.0,\n        child: FlutterLogo(),\n      ),\n    );\n  }\n\n  dispose() {\n    controller.dispose();\n    super.dispose();\n  }\n}\n```\n\n也可以把动画的实现封装成 hook。\n\n```dart\nAnimation useFadeIn() {\n  final ticker = useSingleTickerProvider();\n  final controller = useMemoized(() => AnimationController(\n      duration: const Duration(milliseconds: 3000), vsync: ticker));\n  final animation = useMemoized(() => Tween(begin: 0.0, end: 1.0)\n      .animate(CurvedAnimation(parent: controller, curve: Curves.easeIn)));\n\n  useEffect(() {\n    controller.forward();\n    return () => controller.dispose();\n  });\n\n  return animation;\n}\n```\n\n| Android fadeIn                                                                                                                                                   | iOS fadeIn                                                                                                                                               |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| ![Android fadeIn](https://flutter.dev/assets/get-started/android/react-native/flutter-fade-241787290a9da1d7406516a96845a65c42c97b5a8219f4ff29f0c3412ab281ba.gif) | ![iOS fadeIn](https://flutter.dev/assets/get-started/ios/react-native/flutter-fade-2596d382757ecf7c4a2db020871d715da585db9fabed9956cbff6ef011b2786b.gif) |\n\n## 为卡片增加滑动关闭动画\n\n在 React Native 里，可以使用如`PanResponder`或者第三方库实现华东关闭。\n\n在 Flutter 中，为部件增加滑动动画可以使用[Dismissible](https://api.flutter.dev/flutter/widgets/Dismissible-class.html)部件。\n\n```dart\nchild: Dismissible(\n  key: key,\n  onDismissed: (DismissDirection dir) {\n    cards.removeLast();\n  },\n  child: Container(\n    ...\n  ),\n),\n```\n\n| Android Dismissable                                                                                                                                                 | iOS dismissable                                                                                                                                             |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| ![Android Dissmisable](https://flutter.dev/assets/get-started/android/react-native/card-swipe-20a57fe25c2e274bfbe0e9f3d4d1aebd5443fc9d2ce81bd6e9d2588e94e28b16.gif) | ![iOS Dismissible](https://flutter.dev/assets/get-started/ios/react-native/card-swipe-ed0bd70d7698b81793f2a44bea69ddf51be44ac486e8410961aabff16176e3ce.gif) |\n\n啊啊啊啊，这个系列翻译完了！！！后面还有一个 Flutter 和 React Native 组件的[对照表格](https://flutter.dev/docs/get-started/flutter-for/react-native-devs#react-native-and-flutter-widget-equivalent-components)，我就不贴上来了。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["React-Native","flutter"],"series":{"slug":"Flutter-for-RN-devs","name":"从RN到Flutter","number":8}}},{"id":"2020/05/10/Flutter.md","slug":"2020/05/10/flutter","body":"\n# Flutter 的手表应用-从入门到放弃\n\n这是一个写得一头沮丧的文章，可能是期待值比较高吧，所以任何一个想用 Flutter 写 wearOS 的朋友都要注意一点，他能写，但可能没那么好。这篇文章本来想参考[Flutter: Building Wear OS app](https://medium.com/flutter-community/flutter-building-wearos-app-fedf0f06d1b4)，因为`wear`这个包已经年久失修不支持最新的 SDK（我天，这可是 2019 年 6 月的文章），于是后来参考[Experimenting with Flutter on Wear OS](https://medium.com/@mjohnsullivan/experimenting-with-flutter-on-wear-os-f789d843f2ef)。如果不想踩坑，只是想写个应用截图发朋友圈的话，直接 clone[这个 repo](https://github.com/sbis04/flutter_os_wear)就好，热爱生命，避免折腾，哈哈。\n\n## 可以用 Flutter 来写手表应用吗\n\n答案是可以的，而且还意料之外地能用。首先要在本机安装模拟器（注意不要安装中国版，中国版真的会卡住）。然后直接运行 flutter 的官方示例就可以了。\n\n![模拟器下的Flutter示例](./2020-05-10-flutter-watch.png)\n\n## 表盘形状\n\n在 Flutter 中可以使用 MediaQuery 获取到屏幕的大小：\n\n```dart\nfinal screenSize = MediaQuery.of(content).size;\nfinal screenHeight = screenSize.height;\nfinal screenWidth = screenSize.width;\n```\n\n但是不能获取到表盘的形状，但是可以通过 kotlin 从安卓 Wear OS 的库里面获取。Flutter 为 Dart 提供了一个支持双向传输的数据通道[MethodChannels](https://flutter.io/platform-channels/)，比起 QML，这更像 JS bridge 的实现，因为这些数据是异步传输的，这些数据也可以通过流传输[EventChannels](https://docs.flutter.io/flutter/services/EventChannel-class.html)。\n\n在安卓的 MainActivity 中可以调用如下方法向 Flutter 传递表盘状态，注意因为是 Wear OS，所以在`Android/app/build.gradle`修改`minSdkVersion`为 23，并在以下依赖中增加以下项目。\n\n```gradle\ndependencies {\n    ...\n    implementation 'com.android.support:wear:27.1.1'\n    implementation 'com.google.android.support:wearable:2.3.0'\n    compileOnly 'com.google.android.wearable:wearable:2.3.0'\n    ...\n}\n```\n\n`AndroidManifest.xml`中打开权限。\n\n```xml\n<!-- Required for ambient mode support -->\n<uses-permission android:name=\"android.permission.WAKE_LOCK\" />\n\n<!-- Flags the app as a Wear app -->\n<uses-feature android:name=\"android.hardware.type.watch\" />\n\n<!-- Flags that the app doesn't require a companion phone app -->\n<application>\n<meta-data\n    android:name=\"com.google.android.wearable.standalone\"\n    android:value=\"true\" />\n</application>\n```\n\n```kotlin\nprivate fun setShapeMethodChannel() {\n  MethodChannel(flutterView, shapeChannel).setMethodCallHandler { _, result ->\n    setOnApplyWindowInsetsListener(flutterView, {_, insets: WindowInsetsCompat? ->\n      if (insets?.isRound == true) {\n        result.success(0)\n      }\n      else {\n        result.success(1)\n      }\n      WindowInsetsCompat(insets)\n    })\n    requestApplyInsets(flutterView)\n  }\n}\n```\n\n在 Dart 部分通过监听 channel 获得形状\n\n```dart\nenum Shape { square, round };\nShape shape;\ntry {\n  final int result = await platform.invokeMethod('shape');\n  shape = result == 1 ? Shape.square : Shape.round;\n} on PlatformException catch (e) {\n  // Default to round\n  print('Error detecting shape: $e');\n  shape = Shape.round;\n}\n```\n\n## 省电模式(Ambient mode)\n\n手表耗电是很棘手的，所以安卓手表的应用都会选择支持长期显示时进入省电模式（我就惊了，你说用电子纸多好，偏偏所有人都用 LED，又不是拿手表看片，要那么好的显示搞什么？）。\n\n可以在 kotlin 部分获取省电模式的事件并通过 channel 传给 dart。\n\n```kotlin\nclass MainActivity: FlutterActivity(), AmbientMode.AmbientCallbackProvider {\n    private var mAmbientController: AmbientMode.AmbientController? = null\n    override fun onCreate(savedInstanceState: Bundle?) {\n        // Set the Flutter ambient callbacks\n        mAmbientController = AmbientMode.attachAmbientSupport(this)\n    }\n    override fun getAmbientCallback(): AmbientMode.AmbientCallback {\n        return FlutterAmbientCallback(flutterView)\n    }\n}\n\nprivate class FlutterAmbientCallback(val flutterView: FlutterView): AmbientMode.AmbientCallback() {\n    override fun onEnterAmbient(ambientDetails: Bundle) {\n        MethodChannel(flutterView, ambientChannel).invokeMethod(\"enter\", null)\n        super.onEnterAmbient(ambientDetails)\n    }\n    override fun onExitAmbient() {\n        MethodChannel(flutterView, ambientChannel).invokeMethod(\"exit\", null)\n        super.onExitAmbient()\n    }\n    override fun onUpdateAmbient() {\n        MethodChannel(flutterView, ambientChannel).invokeMethod(\"update\", null)\n        super.onUpdateAmbient()\n    }\n}\n```\n\n在 Dart 部分处理事件。\n\n```dart\n@override\ninitState() {\n    super.initState();\n    platformAmbient.setMethodCallHandler((call) {\n        switch (call.method) {\n            case 'enter':\n                setState(() => ambientMode = Mode.ambient);\n            break;\n        case 'update':\n            if (widget.update != null)\n                widget.update();\n            else\n                setState(() => ambientMode = Mode.ambient);\n        break;\n        case 'exit':\n            setState(() => ambientMode = Mode.active);\n        break;\n    }\n  });\n}\n```\n\n## 总结\n\nFlutter 能写安卓应用吗？能，而且比不好用要强得多。但是如果想写出 apple watch 的应用那种，还是道阻且长。不过考虑 wear OS 本身自己的应用都不咋地，感兴趣玩一下还是可以的。\n\n另外 Flutter 没有为 wearOS 设计 Material 设计语言的部件，所以都要自己设计（虽然屏幕也就 1~2 英寸）。也没有左滑后退的能力，只能在界面增加一个后退按钮，如果用户不小心左滑了，应用就关闭了（尴尬）。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["flutter","wearOS"]}},{"id":"2020/05/10/Hollywood-A-pot-of-old-duck-soup.md","slug":"2020/05/10/hollywood-a-pot-of-old-duck-soup","body":"\n# 好莱坞——一锅陈年老鸭汤\n\n![hollywood](./2020-05-10-hollywood.png)\n\n本来以为这部电影类似昆汀的「好莱坞往事」，第一集就是男女演员导演编剧卖肉，妥妥的「逐梦演艺圈」大胆北美版。不过第二集剧情就变得有点「歌舞青春」的方向发展，乡村寻梦白人男主和黑人编剧通过卖身养家，白人男主遇到自己将来的女老板，女老板女儿爱上他；黑人编剧接活遇见自己未来男友，未来男友也是来好莱坞寻梦的。同时另一个支线，年轻导演想要导演他自己的处女作，却被要求先导一部已经决定的影片「Peg」，这部影片正好是黑人编剧写的，年轻导演的黑人女友看了剧本，表示如果女主改成黑人会更好。\n\n前面介绍人物的剧情，实在是没啥好说的，感觉更像是以物语换收视。不过后面的剧情变得理想主义化，颇有「新闻编辑室」的感觉，剧情开始讨论女权、种族、同性恋等话题。虽说剧情起伏有点戏剧化，结局奥斯卡获奖以及每个人都有的 happy ending 实在有点 cliche。但今年这个情况，老鸭汤是必须的了。\n","collection":"blog","data":{"type":"post","category":"tv"}},{"id":"2020/05/11/WSL-Xserver.md","slug":"2020/05/11/wsl-xserver","body":"\n# WSL 下运行 Xserver 鼠标太小\n\n不太清楚是不是 HIDPI 造成的，在 VcXsrv 下面的鼠标指针及其小。解决方法只能是换一个看起来大一些的鼠标。\n\n```shell\nsudo apt-get install big-cursor\n```\n\n接下来，重命名 VcXsrv 下面的`font/misc`（比如`C:\\Program Files\\VcXsrv\\fonts\\misc)`）的`cursor.pcf.gz`为`cursor-small.pcf.gz`。\n\n然后将刚才安装在 wsl 中的`/usr/share/fonts/X11/misc/big-cursor.pcf.gz`拷贝到上面的目录下，并重命名为`cursor.pcf.gz`。\n\n重启 VcXsrv 即可。\n","collection":"blog","data":{"type":"post","category":"tech","tag":["windows","wsl","vcxsrv"],"series":{"slug":"windows-howto","name":"Windows舒适指南"}}},{"id":"2020/05/12/flutter-CICD.md","slug":"2020/05/12/flutter-cicd","body":"\n# 多平台上的 flutter 以及 CICD\n\nFlutter 是一个号称面向全平台的框架，既然立了 flag，早晚要去摘的。除了 iOS 和 Android，beta 版本的 flutter 还支持 web 网页以及 mac 桌面端，alpha（master 分支）版本还提供 Windows 和 Linux 桌面端的支持，本篇除了介绍 flutter 在各端如何开发发布还会提及如何通过 CICD 发布安卓 apk，以及这段时间使用 Flutter 的感想。\n\n## Web 支持\n\nWeb 应该是 dart 语言一直想抢的蛋糕，在早期 chrome 上面就有 dart VM，甚至提供了 dart2js 这样的工具，所以 Flutter 在一炮走红之后立刻提供 web 支持是不意外的。\n\n创建 Web 端的 Flutter 应用，以下几项是必须的：\n\n- 安装 Flutter SDK\n- Chrome 浏览器\n- 一个支持开发 Flutter 的编辑器\n\n确定以上几项后执行下面命令切换 Flutter 到 beta 版本，并打开 Web 端支持。\n\n```shell\n flutter channel beta\n flutter upgrade\n flutter config --enable-web\n```\n\n以上命令执行成功后执行`flutter devices`应该能看到 Chrome 浏览器和 Web 伺服器的支持。\n\n打开任何一个 Flutter 项目的根目录，执行`flutter run -d chrome`，稍等片刻 chrome 会被自动打开并渲染项目（这个体验很割裂，真的，这个片刻其实比较久，而且你的终端会不会显示任何东西）。\n\n执行`flutter build web`就会编译项目至`/build/web`文件夹下。\n\n### Web 支持总结\n\n编译 web 应用已经相对稳定，基本上你老姑（谷歌）想要的功能也都有（比如 service-worker 什么的），但因为是 js 渲染，SEO 什么的可能没 SSR 项目号，再一个，我在使用的时候没发现有 sourcemap，估计 debug 的方法也会和普遍 web 应用不太一致。\n\n## Windows 桌面支持\n\n到 Flutter 的目录下，将它 checkout 到 master 分支，此时执行`flutter doctor`，它会检查你是否安装`Visual Studio`、`MSVC`以及`Windows10 SDK`（当然了，这是在 Windows 下面执行才有），没错，alpha 版本的 flutter 已经可以编译 Windows 桌面应用了，只需安装社区版的`Visual Studio`，在安装项里面添加`Clang`、`MSVC`和`Windows10 SDK`即可。\n\n另外还需要在项目中增加[flutter desktop embedding](https://github.com/google/flutter-desktop-embedding)，尝试到这里我有点失望，看了这个项目的 issue，目前 Windows 的桌面支持还是用 Win32 的 API，项目正在计划使用 UWP 来替换。同样 Linux 桌面也在纠结于到底使用 QT 还是 GTK 做框架，因此这两个桌面端的支持相较于 Mac 延后。\n\n## flutter-rs\n\n这是我的另一个 Flag，几个月前我在尝试用 rust 写桌面应用，几个平台都不理想，于是尝试了这个包。然而[flutter-rs](https://github.com/flutter-rs/flutter-rs)依然不太理想，不过更多原因可能是因为这个项目还在 WIP 阶段。\n\n目前 rust 推荐在 WSL 上面开发，考虑到 WSL1 对图形的支持不太好，我更新了[WSL2](https://aka.ms/wsl2kernel)的内核，并使用 Ubuntu 20.04 开发。\n\n这里注意下，WSL2 是完整的 Linux 内核，所以代理什么的都不能使用 WSL1 里面的`localhost`。\n\n```shell\nexport WSL_VERSION=$(wsl.exe -l -v | grep -a '[*]' | sed 's/[^0-9]*//g')\nexport WSL_HOST=$(tail -1 /etc/resolv.conf | cut -d' ' -f2)\nexport DISPLAY=$WSL_HOST:0\n\nexport HTTP_PROXY=http://$WSL_HOST:1080\nexport HTTPS_PROXY=http://$WSL_HOST:1080\nexport NO_PROXY=127.0.0.1,localhost,$WSL_HOST\n```\n\n同样在运行`vcXsrv`时也要加上`-ac`参数已打开远端支持。\n\n安装编译`flutter-rs`需要很多依赖，\n\n```shell\nsudo apt install build-essential libssl-dev pkg-config libxcb-util-dev libxcb-render-util0-dev libxcb-shape0-dev libxcb-xfixes0-dev libclang-dev libglfw3\n\ncargo install flutter-rs\n```\n\n尴尬的来了，执行`cargo flutter run`，打开的 flutter 窗口闪了一下就崩溃了...查了下，好像是 Skia 在 rust 上面链接的问题，哎，不跟进了。\n\n## hover\n\n那么就没有一个能稳定点的桌面端方案了么？有！go 提供了一套 API 接口[hover](https://hover.build/)也叫[go-flutter](https://github.com/go-flutter-desktop/go-flutter)，框架是 GLFW。\n\n在 MSYS 里面就可以安装 golang（太好了，WSL 下面编译 GUI 不敢恭维啊）。\n\n```shell\npacman -S mingw-w64-x86_64-go\n```\n\n初次运行提示找不到 go 命令，貌似`mingw-w64`不在 PATH 上，查了好多都没找到原因，干脆直接添加上好了。\n\n```shell\nexport PATH=/c/tools/msys64/mingw64/bin:$PATH\n```\n\n下面安装 hover\n\n```shell\nGO111MODULE=on go get -u -a github.com/go-flutter-desktop/hover\n```\n\n随便找个已有的 flutter 项目，执行`hover run`，它会询问你是否增加一段 fushia 的代码`lib/main_desktop.dart`，没错，所有的 desktop 端都叫 fushia，它也是桌面端的入口文件，直接回复 Y 即可。\n\n和 flutter 的命令类似，执行`hover build windows`就会在`/build/output/windows`下生成编译好的可执行文件。\n\nhover 相对来说是目前唯一比较成熟的 Flutter 桌面运行时了，更多内容可以查看它的[文档](https://github.com/go-flutter-desktop/hover)。但是运行结果不能说如意，比如在处理改变窗口大小时，界面不会跟着鼠标变化，直到释放之后才会改变，这对于 2020 年的人类来说，体验真是不够好，但是运行起来确实是比 electron 好些，起码笔记本风扇没有疯狂打转。\n\n### Windows 桌面支持总结\n\n在官方支持遥遥无期的情况下，桌面支持真是百花齐放，不过另一方面微软爸爸直接提供亲生的[React Native Windows](https://github.com/Microsoft/react-native-windows)可是支持 UWP 下面的 Fluent Design 哦，所以在多段支持上，起码 Windows 这里，React Native 略胜一筹。\n\n## CICD\n\n本来想写一下测试的，结果发现没啥新东西。干脆提一下利用 Github action 做 CICD 好了。（其实基本上就复制[别人](https://github.com/nabilnalakath/flutter-githubaction)的`/.github/workflows`文件夹就好，白嫖很开心）。\n\n```yaml\non: push\nname: Test, Build and Release apk\njobs:\n  build:\n    name: Build APK\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v1\n      - uses: actions/setup-java@v1\n        with:\n          java-version: \"12.x\"\n      - uses: subosito/flutter-action@v1\n        with:\n          flutter-version: \"1.7.8+hotfix.4\"\n      - run: flutter pub get\n      - run: flutter test\n      - run: flutter build apk --debug --split-per-abi\n      - name: Push APK to Releases\n        uses: ncipollo/release-action@v1\n        with:\n          artifacts: \"build/app/outputs/apk/debug/*.apk\"\n          token: ${{ secrets.TOKEN }}\n```\n\n## 总结\n\nFlutter 相对于 React Native 的确有性能上的优势，毕竟跳过了 js 和原生环境交互的沟壑，但是对比开发环境还是没有 RN 全面。\n\n- 如果只是移动端应用，两者皆可，Flutter 有对 Material Design 更原生的支持，所以如果设计上是 Material Design，开发效率会更高；但是 RN 则在可定制上更高一筹。\n- 如果是 Wear OS，必然 Flutter。\n- 如果是桌面应用，目前我站 RN，除了工具链全面，它对比 Electron 已经很好了，而 Flutter 即使理论上性能更高，但其 alpha 的不稳定也要考虑在内。\n- 如果是 Web 端，感觉 Flutter 根本打不过现有的框架，不过仅仅对比 RN 的话，Flutter 可以不做配置就直接编译 Web，也就是说如果你有一个移动应用，又不想关心 Web 是怎么回事儿，用它还是可以的。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["flutter","CICD","rust","golang","wsl2","hover","github-action","vcXsrv","MSYS"]}},{"id":"2020/05/18/Talk-about-my-experience-as-a-idle-fish-seller.md","slug":"2020/05/18/talk-about-my-experience-as-a-idle-fish-seller","body":"\n# 谈谈我当闲鱼卖家的经验\n\n闲鱼是我默认选择卖二手的平台，但是随着用户变多，这个平台开始变得混乱，骗子丛生，这里总结一下我过去一周的闲鱼卖家经验。\n\n## 避开二手贩子\n\n闲鱼上面有很多二手贩子，会以自己手头紧，买给朋友之类的原因和你砍价买到手再以高价倒卖。二手贩子本身我是不反感的，只是这种手段是以骗人实现也就太下三滥了。\n\n这些骗子，自己的主页往往会只有一种产品，比如我卖平衡车时，有一个哥们要送朋友（我很好奇是多铁的朋友才会送二手当礼物），于是看了他的主页，全部都是平衡车，我查了我的机器的同款型号定价，竟是他给我报价的三倍。\n\n再一个，往往他们会以公司名命名，比如买我移动 wifi 的人叫做「仙童科技」，我当时还好奇，仙童不是 Intel 前身么，同一个理由，送朋友。我因为知道我的移动 wifi 成色不好，所以定价 160（原价 375），这哥哥估计也是刚当骗子，没问几句就拍下来了。收到货，他发现成色确实不好，主要是机身有个标签，他想按照原价倒卖，没有标签卖不了。我开始不同意退货，他便开始信息轰炸，顺便也露馅他是骗子的本质，他告诉我他以 200 块多的价格买了很多我的同款，成色都比我的好（废话，我有那么好成色我也卖 200 多），连贴了好几个他的订单。最后烦的我实在受不了就同意了他的退款。\n\n经验就是，二道贩子肯定会以超低价买入你的产品，并高价销售。但是骗人部分实在恶心，如果有人以「送朋友」为目的买你的二手，想想，这么抠的人，最好别和他们打交道。再一个，卖货之前一定要反复询问，并在说明中写上不退不换，以后可以拿来做证据。\n\n## 与到手刀战斗到底\n\n没错，我遇见手刀了。我以 299 卖出了我的 kindle paper white 3（原价 865），这个价位在闲鱼上都买不到 2 代，很简单，就是感觉读书这种东西拿价格衡量有点不雅。万没想到，自己高尚别人小人，来了一个缠着要我拍设备的人，我是白天拍，夜里拍，就差把机子拆开了（其实我很烦，你想买，老子还不想卖呢）。终于被他买下来，到货了骂骂咧咧说有瑕疵，我让他退回来，现在 3 天了，依然不确认到货，也不退货。\n\n这种无赖确实很难对付，我至今也只能苟着。比较烦的是，以前还能看信用分来评价，现在信用分放水太多了，毫无参考价值。反正像这种自己也不太乐意卖的东西，找个下家好比古代下嫁公主。一定要确认对方会及时确认收货，并不会退货。\n\n## 不要一下子卖很多东西\n\n闲鱼号称能利用闲时卖东西，但其实你就成为了 7x24 小时客服，对方可能知道自己买的是二手，但他可能需要比一手还要好的售后服务，并希望你把他当作上帝之余还包邮。我本来打算 6 月卖完我的东西，但后来发现太浪费精力了，而且不知道闲鱼怎么关闭通知，即使写了不讨价还价依然有人来烦你。\n\n## 最好包邮\n\n咸鱼的智能邮费几乎没有准的，当它预估邮费 12 块（跨省默认 12 元，所以蒙这个数只是个高概率事件），其实运费 30 的时候我真是要吐血了。另外我还有一个笔记本支架，25 元+邮费，居然无人问津。然后我改成 45 元包邮，竟来了一堆要买的。\n\n## 最好别用闲鱼\n\n我的意思是宣传，二手产品不出圈很重要，但是闲鱼故意加了个恶心的社交功能。如果你卖个二手车，然后来个油门都找不着的人来买，买了回家出车祸说你车的问题，你真是哭死。闲鱼的社交让二手产品出圈了，就让很多想试一试的人入圈，但是因为有 7 天的收货时间，那这些圈外人就完全可以以「不是我想要的」这种理由白嫖。所以在确认买家详情之后，再通过闲鱼做第三方担保或许是个更好的方法（而且闲鱼被微信禁了，那恶心的体验，真不如抽时间自己写个网站）。\n","collection":"blog","data":{"type":"post","category":"life"}},{"id":"2020/05/20/Record-JD.com's-experience-of-being-deceived-in-the-world-of-Yuexiang-in-the-world.md","slug":"2020/05/20/record-jdcoms-experience-of-being-deceived-in-the-world-of-yuexiang-in-the-world","body":"\n# 记录下京东购买乐行天下被骗经历\n\n大概去年买的乐行天下的平衡车，用了一个月就爆胎了，当时联系售后更换，辗转多次终于一个月后修好。后来骑了几个月，突然有一天又不能开机了，急忙又联系售后，又过了几个月才修好。导致我整个一年里只是用这台机子不到 150km。前面只是质量问题，后面更尴尬。这几天我打算把它以二手卖掉，谈拢价格后我在 APP 解绑了机器，有意思的事情发生了，我的机器在蓝牙里面显示的型号竟然不是原来的 V5D 而是原价便宜一千块的 V5！现在想想不寒而栗，V5D 和 V5 外型基本一致，如果不是特意跑一下性能测试你根本不会意识到被掉包了。而如果只是代码里把这台机器改型号简直太轻松了，真是套路。\n\n现在是，虽然这台机器才跑了 150km，我根本不敢卖，我也不敢自己骑。如此看来，即使京东的服务也未必安全。由此延伸，已经 2020 年了，国内的制造业像乐行天下之流不算少数，显然他们依旧顺风顺水，售后维护等服务始终没有保障，购买产品的消费者依然没有安全感。以后还是以欧美大牌为主吧。\n","collection":"blog","data":{"type":"post","category":"life"}},{"id":"2020/05/28/If-the-demon-is-reduced,-the-ghosts-and-gods-after-the-founding-of-the-People's-Republic-of-China-went-to-Hong-Kong.md","slug":"2020/05/28/if-the-demon-is-reduced-the-ghosts-and-gods-after-the-founding-of-the-peoples-republic-of-china-went-to-hong-kong","body":"\n# 降魔的，建国后鬼神都去香港了\n\n去年看过「金宵大厦」后，我就开始关注 TVB 的鬼神片了，最近听说「降魔的 2.0」上映，看了一集没看懂，于是把 2017 年的第一季也看了。这篇文章写在看完 2.0 的第 18 集之后。\n\n![石敢当](./stone.jpg)\n\n「降魔的」主要讲出租司机马季一泡尿解封被封印百年的石精灵「石敢当」，石敢当为报答解封之恩，答应帮马季养母找亲生儿子豪仔的灵魂，不料，在为马季开天眼时能力被马季吸收，马季因此成为降魔人。为了灭掉一个魔，石敢当把自己的全部能量给马季，并和魔同归于尽。第一季结尾，马季终于碰到豪仔的灵魂。\n\n第二季目前讲的是豪仔和海魔做过交易，必须吃人续命，于是找到马季希望能帮忙消灭海魔以解开诅咒。\n\n比较喜欢这部剧环境的设定，比如鬼是人死后为了完成遗愿存在，完成愿望就会去所谓的「目的地」，精灵则是因为被人赋予情感而成形，比如「莉莉」是一个洋娃娃幻化的精灵、「风狮爷」是一个寄予一个爱情故事的石像，魔的存在就更有趣，第一季的大 boss，黑鼠尾草是吸收很多人的血幻化而成，第二季的谎言魔是一幅多年被倒卖的假画幻化而成。\n\n第二季又引入科学解释，搞得这部剧多了些反迷信的色彩（虽然它是鬼片），更加感兴趣它后面的发展了。\n","collection":"blog","data":{"type":"post","category":"tv"}},{"id":"2020/05/29/WebRTC.md","slug":"2020/05/29/webrtc","body":"\n# WebRTC，谈谈我这几天对它的研究\n\nWebRTC 是一个我在大学时期就关注的技术了，然而由于时间过早，很多技术细节都还在草案上就暂时罢休。今年年初，全世界都进入在家办公状态，视频会议工具被推到风口浪尖，webRTC 技术又一次被推到小高潮，于是便有了[这个实现](https://github.com/gongbaodd/ReactRTC)以及这篇文章。\n\n## WebRTC 是什么\n\nWebRTC 是实现网络端视频会议的技术，包括实现获取客户端的媒体 API，如获取摄像头以及麦克风的 `navigator.mediaDevices.getUserMedia()` 以及录制屏幕的 `navigator.mediaDevices.getDisplayMedia()`；还有实现双端数据传输的 `RTCPeerConnection` 类。\n\n目前主流的实现方式是将用户本地视频上传到后台服务器，由服务器转发视频数据到客户端。很恐怖是吧，没错，这就是为什么疫情刚刚开始大部分视频服务都因为访问过多而宕机，但是因为技术架构相对简单，容易实现并可以迁移到多个平台上面。\n\nWebRTC 依赖的是 P2P 技术，一旦两台机器实现连接，双方直接进行数据传输而不需要第三方转发，所以相对安全，但是实现细节比较困难，强烈推荐看一下 MDN 的[介绍](https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API)。\n\n## 两台机器如何连接\n\nP2P 说起来简单，实现起来并不容易，目前互联网主流使用 IPv4 协议，这意味着在网络环境中，真正暴漏的单一 IP 对应的是后台基于 NAT（Network Address Transition）技术连接的一簇终端设备。当我们使用网络传输数据时，是有一台暴露在外网的路由将收到的数据转发给自己的端口上面，但这一层转发，很多实现是广播的，意味着端口上面的每一台设备都能收到传输数据，如果要指定某台机器接收，需要在数据包里包含设备的描述，就好像 90 年代打电话往往要胡同门口小卖铺的王大爷叫一下。实现多设备链接就需要使用 ICE 技术（你的地址描述）的 TURN 或者 STUN 服务（提供地址描述的服务）。\n\n### ICE 技术\n\nICE（Interactive Connectivity Establishment）技术，我称之为「破冰」技术，它提供一个通过 TURN 或者 STUN 服务获取的一堆关于本地地址的描述，在 webRTC 中可以[获得本地描述](https://codesandbox.io/s/reactrtc-f365m?file=/src/components/PeerConnection.tsx:2363-2403)和[添加远端描述](https://codesandbox.io/s/reactrtc-f365m?file=/src/components/PeerConnection.tsx:3078-3139)。\n\n```typescript\nuseEffect(() => {\n  // 获取本地地址\n  connection.addEventListener(\"icecandidate\", (event) => {\n    if (event.candidate) {\n      // TODO: 保存 `event.candidate.toJSON()` 到服务器\n      // ...\n    }\n  });\n}, [connection]);\n\nconst onGetRemoteCandidate = useCallback(async () => {\n  // 添加远端地址\n  await connection.addIceCandidate(new RTCIceCandidate(data));\n}, [connection]);\n```\n\n### STUN 服务和 TURN 服务\n\nSTUN（Session Traversal Utilities for NAT）是一个能够帮助获取到客户端地址描述的协议。\n\n![STUN 服务](https://mdn.mozillademos.org/files/6115/webrtc-stun.png)\n\n在 RTCPeerConnection 中可以使用 google 的 STUN 服务。\n\n```ts\nconst [connection] = useState(() => {\n  return new RTCPeerConnection({\n    iceServers: [\n      {\n        urls: [\n          \"stun:stun1.l.google.com:19302\",\n          \"stun:stun2.l.google.com:19302\",\n        ],\n      },\n    ],\n    iceCandidatePoolSize: 10,\n  });\n});\n```\n\n而 TURN（Traversal Using Relays around NAT）则针对于只能接受对称 NAT（Symmetric NAT） 的路由器，设备对应的端口可变，相对于传统的锥形 NAT（Cone NAT），需要在 STUN 协议的基础上增加 Relay 转发。\n\n![TURN 协议](https://mdn.mozillademos.org/files/6117/webrtc-turn.png)\n\n如果心情好的话，你可以使用[COTURN](https://github.com/coturn/coturn)自己搭建一个 TURN 服务，更多关于 P2P 协议的描述可以参考[这篇博文](https://www.cnblogs.com/pannengzhi/p/5048965.html)。\n\n### SDP 会话描述\n\n如果你写过 HTTP 服务的话，一定会知道，要实现一个有状态的 HTTP 请求的实现基于会话，服务器和客户端通过一个会话 ID 实现双方的认证。会话在 P2P 下一样成立，这个会话 ID 则称为 SDP（Session Description Protocol）。\n\n一个 SDP 的结构如下，m 表示会话中的媒体描述。\n\n```ini\nv=0\no=mozilla...THIS_IS_SDPARTA-76.0.1 8725109466872836540 0 IN IP4 0.0.0.0\ns=-\nt=0 0\na=fingerprint:sha-256 A9:89:58:E6:B5:E3:23:F8:F4:4C:15:13:58:F5:7B\na=group:BUNDLE 0 1\na=ice-options:trickle\na=msid-semantic:WMS *\nm=audio 9 UDP/TLS/RTP/SAVPF 109 9 0 8 101\nc=IN IP4 0.0.0.0\na=sendrecv\na=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level\na=extmap:2/recvonly urn:ietf:params:rtp-hdrext:csrc-audio-level\nm=video 9 UDP/TLS/RTP/SAVPF 120 121 126 97\nc=IN IP4 0.0.0.0\na=sendrecv\na=extmap:3 urn:ietf:params:rtp-hdrext:sdes:mid\na=extmap:4 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time\na=extmap:5 urn:ietf:params:rtp-hdrext:toffset\n```\n\n当然生成二进制 SDP 的过程是不需要人工字符串拼接的，可以使用`connection.createOffer`和`connection.createAnswer`生 SDP，并使用`connection.setLocalDescription`和`connection.setRemoteDescription`建立会话。\n\n```ts\n// 发起端生成SDP\nconst createOffer = useCallback(async () => {\n  const offer = await connection.createOffer();\n  await conn.setLocalDescription(offer);\n  // TODO: 保存发起端的SDP到服务器\n  // ...\n}, [connection]);\n```\n\n## P2P 会议室的流程\n\n### 事前准备\n\n了解了上面的部分，我们需要如下内容以完成一次 P2P 连接\n\n- 一个 STUN 服务或者一个 TURN 服务来获取地址描述\n- 一台服务器，能够实现存储一端 ICECandidate（地址描述） 和 SDP（会话描述），并使另一端通过无论是 websocket 实现还是像 firebase 一样做轮询（polling）的技术获取数据。\n- 两台终端设备，其实要的就是两个`RTCPeerConnection`，但如果需要视频会议的话，还需要两个以上摄像头（反正我有 3 台 PC~）。\n\n### 1. 设置 RTCPeerConnection\n\n注意，网上很多示例会创建一个`localConnection`和一个`remoteConnection`，因为他们是在一台终端上做演示，所以理论上如果只要两台设备联络，代码里面创建一个`RTCPeerConnection`就可以实现两台设备连接了。\n\n[这里](https://codesandbox.io/s/github/gongbaodd/ReactRTC?file=/src/components/PeerConnection.tsx:618-663)因为项目用的是 React，我把实现封装成了一个`PeerConnection`组件。\n\n```ts\nconst config = {\n  iceServers: [\n    {\n      urls: [\"stun:stun1.l.google.com:19302\", \"stun:stun2.l.google.com:19302\"],\n    },\n  ],\n  iceCandidatePoolSize: 10,\n};\n\nconst CTX = createContext<RTCPeerConnection | null>(null);\n\nexport const PeerConnection: FC = ({ children }) => {\n  const [connection] = useState(() => {\n    return new RTCPeerConnection(config);\n  });\n\n  return <CTX.Provider value={connection} children={children} />;\n};\n```\n\n### 2. 处理本地 IceCandidate\n\n建立好 RTCPeerConnection 对象后，需要收集本地的 IceCandidate 并上传至服务器。\n\n```ts\nuseEffect(() => {\n  // 获取本地地址\n  // 假设这段代码是发起端，存储数据到callerAddress\n  // 如果是接收端，则存储到calleeAddress\n  connection.addEventListener(\"icecandidate\", async (event) => {\n    if (event.candidate) {\n      const db = await firebase.firestore();\n      const caller = await db.collection(\"callerAddress\");\n      caller.add(event.candidate);\n    }\n  });\n}, [connection]);\n```\n\n### 3. 获得远端 IceCandidate\n\n从数据库中中找到远端的地址（根据黑暗森林法则，如果知道对方地址，就可以杀死对方了），知道对方地址就可以建立会话了。\n\n```ts\n// 获得远端地址\n// 同样假设这段代码是发起端\n// 如果是接收端，则需要监视callerAddress\nconst db = await firebase.firestore();\nconst caller = await db.collection(\"calleeAddress\");\ncaller.onSnapshot((snapshot) => {\n  snapshot.docChanges().forEach(async (change) => {\n    if (change.type === \"added\") {\n      const address = change.doc.data();\n      await connection.addIceCandidate(new RTCIceCandidate(address));\n    }\n  });\n});\n```\n\n至此两边已经了解对方地址，可以进行会话了。\n\n### 4. 发起方获得本地媒体数据\n\n通过`navigator.mediaDevices.getUserMedia`获得媒体数据后，可以用`addTracks`函数把数据流添加到连接里面。\n\n```ts\nconst getUserMedia = useCallback(async () => {\n  const userStream = await navigator.mediaDevices.getUserMedia({\n    video: true,\n    audio: true,\n  });\n  userStream.getTracks().forEach((t) => {\n    connection.addTrack(t, localStream);\n    console.log(\"[P2P] stream to peer\", localStream);\n  });\n}, [connection]);\n```\n\n### 5. 发起方发送 offer SDP\n\n了解对方地址之后，发起方就可以发送 SDP 来建立会话了。\n\n```ts\nconst createOffer = useCallback(async () => {\n  const offer = await connection.createOffer();\n  await connection.setLocalDescription(offer);\n\n  const db = await firebase.firestore();\n  const offer = await db.collection(\"offer\");\n  offer.add({ type: offer.type, sdp: offer.sdp });\n\n  return offer;\n}, [connection]);\n```\n\n### 6. 接收方收到 offer，并返回 answer SDP\n\n接收方通过轮询服务器得到 offer，为连接添加远端会话描述，生成自己的会话描述（answer SDP），并存储到服务器，注意，这些步骤是不能更换的。\n\n```ts\nconst db = await firebase.firestore();\nconst offerRef = await db.collection(\"offer\");\nconst answerRef = await db.collection(\"answer\");\n\nofferRef.onSnapshot((snapshot) => {\n  snapshot.docChanges().forEach(async (change) => {\n    if (change.type === \"added\") {\n      const offer = change.doc.data();\n      await connection.setRemoteDescription(offer); // 设置远端会话描述\n      const answer = await conn.createAnswer(); // 生成本地会话描述\n      await conn.setLocalDescription(answer); // 设置本地会话描述\n      await answerRef.add(answer); // 存储本地会话到云端\n    }\n  });\n});\n```\n\n### 7. 发起方收到 answer，会话建立\n\n和接收方类似，发送方也需要从服务器收到会话的应答，设置好远端会话描述后，会话开始。\n\n```ts\nconst db = await firebase.firestore();\nconst answerRef = await db.collection(\"answer\");\n\nanswerRef.onSnapshot((snapshot) => {\n  snapshot.docChanges().forEach(async (change) => {\n    if (change.type === \"added\") {\n      const answer = change.doc.data();\n      await connection.setRemoteDescription(answer); // 设置远端会话描述\n    }\n  });\n});\n```\n\n### 8. 收到远端媒体流\n\n通过监听 track 事件，就可以获取远端媒体流了。注意，track 事件返回的是多个媒体流（因为 RTCPeerConnection 的`addTrack`可以使用多个媒体流），每个媒体流包括音轨和画轨。\n\n```ts\nconst video = useRef<HTMLVideoElement>(null);\n\nuseEffect(() => {\n  connection.addEventListener(\"track\", ({ streams: [remoteStream] }) => {\n    const stream = new MediaStream();\n    remoteStream.getTracks().forEach((t) => stream.addTrack(t));\n    video.current && video.current.srcObj = stream; // 设置HTML元素使用远端媒体流\n  });\n}, [connection]);\n```\n\n### 9. 会话结束\n\n停止一个媒体流，要关闭它的轨道。\n\n```ts\nstream.getTracks().forEach((t) => t.stop());\n```\n\n关闭连接则需要调用`close`函数。\n\n```ts\nawait connection.close();\n```\n\n## 传输文字信息\n\nRTCPeerConnection 不仅仅可以传输媒体流，使用[RTCDataChannel](https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Simple_RTCDataChannel_sample)可以传递文字信息。\n\n每一个 RTCPeerConnection 建立之后会有一个\"datachannel\"事件，这个事件会返回一个 chennel 对象，用来接收发送方传来的数据。\n\n```ts\nconnection.addEventListener(\"datachannel\", ({ channel }) => {\n  channel.addEventListener(\"open\", () => {\n    console.log(\"[P2P receiver] open\");\n  });\n  channel.addEventListener(\"message\", ({ data }) => {\n    console.error(\"[P2P receiver] message\", data);\n  });\n  channel.addEventListener(\"close\", () => {\n    console.log(\"[P2P receiver] closed\");\n  });\n});\n```\n\n在发起端创建一个 datachannel 向远端发送数据了。\n\n```ts\nconst sender = connection.createDataChannel(\"xxx\");\n// ... 发送信息必须在sender收到open事件后\nsender.send(\"hello\"); // 向接收端发送\"hello\"字符串\n```\n\n## 附录\n\n### 实现多端链接\n\n目前为止，RTCPeerConnection 只能做一对一连接。不过，要想实现多端连接，可以创建多个 RTCPeerConnection。那么一个浏览器最多能使用多少个 RTCPeerConnection 呢？根据[这篇文章](https://bloggeek.me/webrtc-rtcpeerconnection-one-per-stream/)，显然这个问题比较复杂，这个文章里面提过大概是 200 个，但由于网络等原因，可能并不能顺利建立这么多连接。\n\n### 调试方法\n\n我不太清楚出了什么状况，我的 demo 只能在火狐里面跑起来，但是调试起来类似，可以参考[这篇](https://testrtc.com/webrtc-internals-parameters/)。\n\n### PWA 里面能用 P2P 吗\n\n既然 DataChannel 能够实现端对端传输文字信息，那么结合 ServiceWorker 我们是不是可以创建一个完全去中心化的网页呢？答案是目前不可以，但是方案已经写进 webtorrent，具体内容可以在[此链接](https://github.com/webtorrent/webtorrent/issues/1721)跟进。\n\n### CodeSandbox 的使用体验\n\nCodeSandbox 可以理解为一个线上 Web 前端开发编辑器。\n\n因为现在是五月末六月初，在大陆依赖于 npm 的开发到了无比艰难的一段时间，导致我开始不得不考虑在[CodeSandbox](https://codesandbox.io/)进行开发。开发体验还是很可观的，虽然写代码会出现不跟手的情况，偶尔代码会出现因为远端没同步导致丢失（好在可以通过 github 同步）。\n\n我推荐以下情况可以考虑使用 codeSandbox：\n\n- 一个全新的项目\n- 项目比较简单，浏览器不至于卡死\n","collection":"blog","data":{"type":"post","category":"fe","tag":["webRTC","p2p","codesandbox","firebase"]}},{"id":"2020/06/01/6.md","slug":"2020/06/01/6","body":"\n# 6 月总结 + 半年评价\n\n目测是全年最糟心的一个月了，主要是涉及了闲鱼上卖东西，还意外发现了一个长达一年的上当故事。\n\n## 6 月计划完成情况\n\n全部完成！撒花~\n\n- 这个月完成了 flutter 的系统学习，不仅仅在移动端，甚至考虑到可穿戴+桌面端的开发，另外揭示 Rust 就目前处理 GUI 能力还是很差的事实。\n- 闲鱼卖货的经验就是，以后尽量买快销好了，二手这玩意儿玩不好。\n- （其它收获）推荐美剧「好莱坞」，喝鸭汤的感觉。\n- （其它收获）推荐美剧「Upload」，科幻喜剧。\n- （其它收获）推荐 TVB 剧「降魔的」，感觉比「金宵大厦」。\n- （其它收获）系统的学习了 WebRTC，已经能够建造一款 P2P 应用了。\n- （其它收获）spacedesk 多设备屏幕方案。\n- （其他收获）react native for windows，开发支持 Windows 的跨平台应用。\n\n## 7 月计划\n\n- 整理手上的东西，送回大连\n- 准备离开深圳，是个好城市，然而香港对我已经没了兴趣了，再加上家人旁敲侧击，只好放弃。\n- 购买去海口的机票\n- 在万宁找一个义工\n- 把深圳这里的关系迁出\n- 开发「览胜」网站\n\n## 半年工作评价\n\n这半年做了不少工作，罗马不是一天建成的，参考几年前的一次裸辞，相比于急于求成写一个成品，这次我更关注基础。\n\n1. 学习了如何先上部署爬虫、静态网站以及编译生成应用\n2. 把和我工作相关的书，包括 JS、CSS、Flutter、WebGL、WebRTC 都系统的整理出来\n3. Rust 确定了一个基于 yew 的学习方向\n4. 深度学习找到了一个正确的学习方向\n\n下半年打算先搞定义工，然后完成「览胜」。\n","collection":"blog","data":{"type":"post","category":"plan"}},{"id":"2020/06/04/Industrial-Station!Discover-Qingshuihe.md","slug":"2020/06/04/industrial-stationdiscover-qingshuihe","body":"\n# 工业站！探清水河\n\n我一直喜欢老火车，在北京的时候就特意去过火车博物馆。其实深圳也有一个小的火车博物馆（说起来也不算，毕竟就是个网红拍照场所），叫做工业站，之前是深圳去九龙中的一个小站（清河还是草埔来着，查攻略的时候两个说法都有）。\n\n公交到章輋(shē)村站，穿过村子看到下图的桥就是工业站了。\n\n![门口用车厢做的的茶饮](./001.jpg)\n\n背这桥沿着铁路走不到一公里就能看见以前的老站台了。\n\n![铁路](./002.jpg)\n\n![工业站](./003.jpg)\n\n![老站台](./004.jpg)\n\n![东风车头](./005.jpg)\n\n火车不多，也就两辆。\n\n![两车之间](./007.jpg)\n\n![铁路](./008.jpg)\n\n虽然车站取消了，但是周边的铁路依然还用于运输，旁边还时不时有和谐号路过。\n\n![站牌](./009.jpg)\n\n![路过的和谐号](./010.jpg)\n\n车皮上面还有一些有时代感的刻字囧。\n\n![永爱TFBOYS](./011.jpg)\n\n车站的标语很有时代感，话说对于疫情还挺应景。\n\n![时代感的标语](./012.jpg)\n\n车道边的小心火车标志。\n\n![小心火车](./013.jpg)\n\n遗憾的是附近除了茶饮并没有更多玩的地方了，这对于文青来说真是打击。火车站附近大概两公里，有一个很大的洪湖公园，从地图上看，有点模仿美国中央公园的感觉。\n\n![洪湖公园的荷花](./014.jpg)\n\n走出洪湖公园就能看到地王大厦和京基 100，如果眼神好，还能看见更远的平安中心。\n\n![地王大厦和京基100](./015.jpg)\n\n大概 1~2km 之外就是深圳的老街，一直觉得这条街拉低了深圳一线城市的形象，但是 whatever，游客都来这儿。\n\n![老街](./016.jpg)\n\n![老街](./017.jpg)\n\n在老街吃了份螺蛳粉，请记住，戴口罩不要吃螺蛳粉！！！坐公交熏得我头晕眼花，途径深业上城，突然意识到我还没去过，下车去逛一下。\n\n深业上城的测温区，虽然听说过很久了，但这种测温装置我还是第一次见到。\n\n![测温区](./018.jpg)\n\n深业上城带有一点包豪斯风格的街道，很吸引各种网红来打卡，旁边也有很多来拍婚纱照的人。\n\n![深业上城](./019.jpg)\n\n![Just do IT](./020.jpg)\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/06/06/Python.md","slug":"2020/06/06/python","body":"\n# 读「Python 深度学习」数学基础\n\n- 「学习」是指找到一组模型参数，使给定的训练数据样本和对应目标上的损失函数最小化。\n- 学习的过程：随机取包含数据样本及其目标值的批量，并计算批量损失相对于网络参数的梯度（梯度可以理解为对于张量计算的倒数）。随后将网络参数沿着梯度的反方向稍稍移动（移动距离由学习率指定）。\n- 整个学习过程之所以能够实现，是因为神经网络是一系列可微分的张量运算，因此可以使用求导的链式法则来得到梯度函数，这个函数将当前参数和当前数据批量映射为一个梯度值。\n- 「损失」是训练过程中需要最小化的量，因此它能够衡量当前任务是否已经成功解决。\n- 「优化器」是损失梯度更新参数的具体方式，比如 RMSProp 优化器，带动量的随机梯度下降（SGD）等。\n","collection":"blog","data":{"type":"post","category":"book","tag":["tensorflow"],"series":{"slug":"learn-tensorflow","name":"张量麻辣烫"}}},{"id":"2020/06/07/WSL2-Keras.md","slug":"2020/06/07/wsl2-keras","body":"\n# 在 WSL2 安装 Keras 及其依赖\n\n## 安装 python\n\n首先安装 python3 和 pip3，并且使用 USTC 源。\n\n```shell\nsudo apt install python3 python3-pip python3-dev\npip3 install -i https://mirrors.ustc.edu.cn/pypi/web/simple pip -U\npip3 config set global.index-url https://mirrors.ustc.edu.cn/pypi/web/simple\n```\n\n## 安装 python 科学套件\n\n1. 安装 BLAS 库（OpenBLAS），确保可以在 CPU 上面做张量运算。\n\n   ```shell\n   sudo apt install build-essential cmake git unzip pkg-config libopenblas-dev liblapack-dev\n   ```\n\n2. 安装 Python 科学套件：Numpy、SciPy 和 Matplotlib。这是做科学计算必须的。\n\n   ```shell\n    sudo apt install python3-numpy python3-scipy python3-matplotlib python3-yaml\n   ```\n\n3. 安装 HDF5，最初由 NASA 开发，用于保存数值数据的大文件。它可以帮助 Keras 模型快速高效保存到磁盘。\n\n   ```shell\n    sudo apt install libhdf5-serial-dev python3-h5py\n   ```\n\n4. 安装 Graphviz 和 pydot-ng，这两个包用于可视化 Keras 模型。并不是必须的。\n\n   ```shell\n    sudo apt install graphviz\n    pip3 install pydot-ng\n   ```\n\n5. 安装 tensorflow\n\n   ```shell\n   pip3 install tensorflow\n   pip3 install tensorflow-gpu\n   ```\n\n## 安装 Keras\n\n使用 pip3 安装 Keras。\n\n```shell\npip3 install keras\n```\n\n可以从 GitHub 中下载 Keras 的例子\n\n```shell\ngit clone https://github.com/keras-team/keras.git\n```\n\n测试一个例子\n\n```shell\npython3 mnist_cnn.py\n```\n\n执行成功后会在`~/.keras/keras.json`生成配置文件。\n","collection":"blog","data":{"type":"post","category":"book","tag":["tensorflow","keras","wsl2","python"],"series":{"slug":"learn-tensorflow","name":"张量麻辣烫"}}},{"id":"2020/06/08/Keras.md","slug":"2020/06/08/keras","body":"\n# Keras 分类问题-电影评论分类\n\n> 「Python 深度学习」的例子在[GitHub](https://github.com/fchollet/deep-learning-with-python-notebooks)上。\n> 别问我为啥不写在 notebook 上，等我心情好就给网站加一下这给你功能吧\n\n本文的 notebook 在[这个连接](https://github.com/gongbaodd/keras_study/blob/master/3.5%20movie%20reviews.ipynb)。\n\n将 IMDB 上的 50000 条两极分化的评论，一般用于训练，一半用于测试。这些数据中 data 是词索引组成的二维数组，每一行对应每条评论，label 为 0\\1 数组，0 表示负面评论，1 表示积极评论。\n\n## 处理数据\n\n```py\nimport keras\nfrom keras.datasets import imdb\n\n(train_data, train_labels), (test_data, test_labels) = imdb.load_data(num_words = 1000)\n```\n\n数据集里面的数字可以解析成评论，每一个`data`都是如`[0, 14, 32, 56...]`的数组。\n\n```py\nword_index = imdb.get_word_index()\nreverse_word_index = dict([(value, key) for (key, value) in word_index.items()])\ndecoded_review = ' '.join([reverse_word_index.get(i-3, '?') for i in train_data[0]])\n```\n\n使用以下方法即可以把训练数据处理成 0/1 二维张量。\n\n```py\nimport numpy as np\n\ndef vectorize_sequences(sequences, dimension=10000):\n    results = np.zeros((len(sequences), dimension))\n    for i, sequence in enumerate(sequences):\n        results[i, sequence] = 1\n    return results\n\nx_train = vectorize_sequences(train_data)\nx_test = vectorize_sequesnces(test_data)\n\ny_train = np.array(train_labels).astype('float32')\ny_test = np.array(test_labels).astype('float32')\n```\n\n简单地说，x 值为 25000\\*10000 的二维数组，某个单词出现则在它所在的评论序号和对应的单词索引的位置上赋值 1，而 y 对应每个 x 行评论的正负反馈。\n\n## 构建网络\n\n使用 rlu 激活（线性整流函数 `max(0, input)`）的全链接层(Dense)就能很好处理这种输入值为标量和向量的情况，如`Dense(16, activation='relu')`。前面的 16 是一个隐藏单元，表示会将数据表示在一个 16 维的表示空间中，隐藏单元越高，能够学到的网络越复杂，计算代价也越大，但并不是越高越好，往往高了会学到不正确的模式。\n\n两个中间网络，第三层使用 sigmoid 激活（s 函数）以输出 0~1 的值\n\n![S函数](https://wikimedia.org/api/rest_v1/media/math/render/svg/a26a3fa3cbb41a3abfe4c7ff88d47f0181489d13)\n\n```py\nfrom keras import models\nfrom keras import layers\nfrom keras import optimizers\nfrom keras import losses\nfrom keras import metrics\n\nmodel = models.Sequential()\nmodel.add(layers.Dense(16, activation='relu', input_shape=(10000,)))\nmodel.add(layers.Dense(16, activation='relu'))\nmodel.add(layers.Dense(1, activation='sigmoid'))\n\nmodel.compile(optimizer=optimizers.RMSprop(lr=0.001),\n              loss=losses.binary_crossentropy,\n              metrics=[metrics.binary_accuracy])\n```\n\n编译网络需要选择损失函数和优化器，这里是个二分类问题，网络最终输出一个概率值，所以最好使用 binary_crossentropy（二元交叉熵），优化器在这里选择 rmsprop。\n\n## 验证模型\n\n现在取训练数据的前 10000 条作为训练，并取后 10000 条做验证数据，20 个轮次，每次使用 512 个样本训练。\n\n```py\nx_val = x_train[:10000]\npartial_x_train = x_train[10000:]\n\ny_val = y_train[:10000]\npartial_y_train = y_train[10000:]\n\nhistory = model.fit(\n  partial_x_train,\n  partial_y_train,\n  epochs=20,\n  batch_size=512,\n  validation_data=(x_val, y_val)\n)\n```\n\n我们可以使用 history 这个变量绘制每次训练的精确度以及损失值变化。训练的损失会随着轮次减少，而验证则不然，大概训练到第 4 次能够拿到理想的结果。\n\n## 预测结果\n\n```py\nmodel = models.Sequential()\nmodel.add(layers.Dense(16, activation='relu', input_shape=(10000,)))\nmodel.add(layers.Dense(16, activation='relu'))\nmodel.add(layers.Dense(1,  activation='sigmoid'))\n\nmodel.compile(\n    optimizer='rmsprop',\n    loss='binary_crossentropy',\n    metrics=['accuracy']\n)\n\nmodel.fit(\n    x_train,\n    y_train,\n    epochs=4,\n    batch_size=512\n)\nresults = model.evaluate(x_test, y_test) # [0.3345052400302887, 0.8581200242042542]\n\nmodel.predict(x_test)\n```\n\n使用`predict`既可预测测试数据的正负反馈了。\n\n```py\narray([[0.3796336 ],\n       [0.996838  ],\n       [0.667047  ],\n       ...,\n       [0.11539856],\n       [0.14184406],\n       [0.47513008]], dtype=float32)\n```\n\n## 多分类问题\n\n书中还介绍了路透社新闻分类，不同点是构建网络时选用单元比较多（书中选择 64 维，因为有 46 个分类），最后一层激活函数选择`softmax`函数，它能保证这 46 个类的概率和为 1.\n\n最终编译时应选择`categorical_crossentropy`做损失函数。\n","collection":"blog","data":{"type":"post","category":"book","tag":["tensorflow","keras","wsl2","python"],"series":{"slug":"learn-tensorflow","name":"张量麻辣烫"}}},{"id":"2020/06/10/Keras.md","slug":"2020/06/10/keras","body":"\n# Keras 回归问题-预测房价\n\n回归问题用于预测一个连续值而不是离散值，如预测明天气温或者软件完成需要的时间。\n\n这个例子是要预测 20 世纪 70 年代中期波士顿郊区房价的中位数。\n\n## 获取数据\n\n```py\nfrom keras.datasets import boston_housing\n\n(train_data, train_targets), (test_data, test_targets) =  boston_housing.load_data()\n```\n\n得到的训练数据`train_data`是一个 404x13 张量，测试数据为 102x13 张量，这 13 项包括：\n\n- 总犯罪率\n- 超过 25000 平方英尺的住宅比例\n- 非商用地比例\n- charles river 变量（1 或 0）\n- 氮氧化物浓度\n- 公寓房间数\n- 建于 1940 年前建筑的占有量\n- 到五个波士顿就业中心的加权平均值\n- 放射状公路可达指数\n- 每 \\$1000 的物业税\n- 城镇学生教师比例\n- 1000(Bk – 0.63)^2，城镇黑人占有率\n- 低收入人群占有率\n\n```py\ntrain_data[0]\n# array([-0.27224633, -0.48361547, -0.43576161, -0.25683275, -0.1652266 ,\n#       -0.1764426 ,  0.81306188,  0.1166983 , -0.62624905, -0.59517003,\n#        1.14850044,  0.44807713,  0.8252202 ])\n```\n\n`train_targets` 对应房价，单位为千美元。\n\n```py\ntrain_targets\n# array([15.2, 42.3, 50. , 21.1, 17.7, 18.5, 11.3, 15.6, 15.6, 14.4, 12.1,...\n```\n\n## 准备数据\n\n对于这 13 种数据，取值范围不统一，这里要做取值的标准化，简单上讲让每个特征减去其平均值并除以标准差，这样，每个特征值都会取值于 0 左右，和统一的标准差。\n\n```py\nmean = train_data.mean(axis=0)\ntrain_data -= mean\nstd = train_data.std(axis=0)\ntrain_data /= std\n\ntest_data -= mean\ntest_data /= std\n```\n\n这里使用训练数据的平均值，这是不对的，但是书里面就这么写，我靠。\n\n## 创建网络\n\n```py\nfrom keras import models\nfrom keras import layers\n\ndef build_model():\n    model = models.Sequential()\n    model.add(layers.Dense(64, activation='relu',\n                          input_shape=(train_data.shape[1],)))\n    model.add(layers.Dense(64, activation='relu'))\n    model.add(layers.Dense(1))\n    model.compile(optimizer='rmsprop', loss='mse', metrics=['mae'])\n    return model\n```\n\n网络最后一层只有一个单元，没有激活，这是标量回归。最后一层的激活函数用于限定输出值的范围，如果是 sigmoid 函数，则输出 0-1 的值，如果最后一层为纯线性层，则可以预测任意范围的值。\n\n编译网络使用 mse 损失函数，即均方误差（mean squared error），预测值和目标值差的平方。训练的指标为 mae 平均绝对误差（mean absolute error），目标值和预测值差的绝对值。如果 MAE 值为 0.5 则代表预测房价与实际房价平均相差 500 美元。\n\n## 利用 K 折验证\n\n因为数据集比较小，可以使用 K 折验证，即把数据分为几分区（一般 4~5 组），最终取几个分区的平均值。\n\n```py\nimport numpy as np\n\nk = 4\nnum_val_samples = len(train_data) // k\nnum_epochs = 100\nall_scores = []\nfor i in range(k):\n    print('processing fold #', i)\n    # Prepare the validation data: data from partition # k\n    val_data = train_data[i * num_val_samples: (i + 1) * num_val_samples]\n    val_targets = train_targets[i * num_val_samples: (i + 1) * num_val_samples]\n\n    # Prepare the training data: data from all other partitions\n    partial_train_data = np.concatenate(\n        [train_data[:i * num_val_samples],\n         train_data[(i + 1) * num_val_samples:]],\n        axis=0)\n    partial_train_targets = np.concatenate(\n        [train_targets[:i * num_val_samples],\n         train_targets[(i + 1) * num_val_samples:]],\n        axis=0)\n\n    # Build the Keras model (already compiled)\n    model = build_model()\n    # Train the model (in silent mode, verbose=0)\n    model.fit(partial_train_data, partial_train_targets,\n              epochs=num_epochs, batch_size=1, verbose=0)\n    # Evaluate the model on the validation data\n    val_mse, val_mae = model.evaluate(val_data, val_targets, verbose=0)\n    all_scores.append(val_mae)\n```\n\n这样获得值如下，2.1~2.6 不等。\n\n```py\nall_scores\n# [2.1905605792999268,\n#  2.4371392726898193,\n#  2.3653202056884766,\n#  2.5255486965179443]\n```\n\n如果想让数据更精确，不如让训练次数从 100 增加到 500，但是书里面最终的数据到 80 就差不多过拟合了，再加上我的笔记本跑不起来 500 次，这里就算了吧。。。\n\n## 预测\n\n```py\nmodel = build_model()\nmodel.fit(train_data, train_targets,\n          epochs=80, batch_size=16, verbose=0)\ntest_mse_score, test_mae_score = model.evaluate(test_data, test_targets)\n```\n\n最后预测的房价和现实房价相差大概 2714 美刀（书里预测的是 2550）.\n","collection":"blog","data":{"type":"post","category":"book","tag":["tensorflow","keras","wsl2","python"],"series":{"slug":"learn-tensorflow","name":"张量麻辣烫"}}},{"id":"2020/06/14/ml5.js-tensorflow.js.md","slug":"2020/06/14/ml5js-tensorflowjs","body":"\n# ml5.js 和 tensorflow.js，终于聊到前端部分了\n\n既然在浏览器中也可以计算多维数组，拿浏览器做深度学习也可以理解了。Google 给浏览器中设计了 [tensorflow.js](https://www.tensorflow.org/js)，跟 python 下面的 tensorflow 是同一套 API。又有一群人在 tensorflow 的基础上封装了一套[ml5.js](https://ml5js.org/)。对比 tensorflow.js，ml5.js 去掉了很多张量计算的部分（说实话，这些东西真不是人学的，我这一周都在研究这些计算...）。所以本文会以 ml5.js 开始。\n\n## ml5.js\n\n这是[Daniel Shiffman](http://www.shiffman.net/)主导的 JS 深度学习库，我特喜欢看他的视频睡觉。这个库的[使用教程](https://learn.ml5js.org/docs/#/reference/index)不能更详细了！\n\n官网的简介，是使用 MobileNet 了`imageClassifier`，这是我的[笔记](https://observablehq.com/@gongbaodd/untitled)，可以用来判断图片、视频中的物体是什么。\n\n另外也可以使用`neuralNetwork`，这是[笔记](https://observablehq.com/@gongbaodd/ml5-js-neural-network)，基本上前面两篇关于 tensorflow 的文章都可以使用它来跑。\n\n使用 ML5.js 很大的简化了 tensorflow 的 API，然而并不是你可以不了解 tensorflow，因为期间会有很多参数难以理解，又不得不回头看它。\n\n## tensorflow.js\n\n基本上会了 python 版本，js 版本就算是个子集了，基本上很多需要的包都有替代。[这里](https://www.tensorflow.org/js/guide/layers_for_keras_users?hl=zh-cn)是一个给 keras 用户使用的 tensorflow.js 指南。另外去强烈建议看看[tensorflow.js 指南](https://www.tensorflow.org/js/guide?hl=zh-cn)。\n\n- `tf.layers` => Keras\n- `@tensorflow/tfjs-vis`原生支持 tensorflow 的数据可视化库（那敢情好啊）\n","collection":"blog","data":{"type":"post","category":"fe","tag":["tensorflow","keras","wsl2","python"],"series":{"slug":"learn-tensorflow","name":"张量麻辣烫"}}},{"id":"2020/06/24/Hainan-Travel-Program.md","slug":"2020/06/24/hainan-travel-program","body":"\n# 海南旅行计划\n\n## 珠海 - 146\n\n6 月 28 日（周日），蛇口 10：00-珠海横琴 11：30，中途会路过港珠澳大桥 65 元（已付）\n\n横琴码头附近貌似有麦当劳，到横琴湾酒店或者马戏酒店，可以搭乘机场横琴线，36 元。\n\n珠海梦海公寓酒店，（45 元，飞猪已付）\n\n## 海口 - 1410\n\n6 月 29 日（周一），9:40 珠海金湾机场到 10:45 海口美兰机场（150 元，已付） - 150\n\n6 月 29 日~7 月 11 日，机场海口梦之乡酒店 609 元（51x12 天） - 609\n\n期间基本上每天麻辣烫（21 元）+ 清补凉（10 元）+ 芒果（7 元） \\* 10 - 380\n\n7 月 2 日 海南省博物馆 + 糟粕醋（18 元） + 芒果肠粉（12 元）+ 鸡失藤（18 元） - 48\n\n7 月 6 日 住海口（86 元）+ 清补凉（15 元）+ 海南粉 （8 元） + 麦当劳&肯德基（100 元）+ 海口美兰来回（14 元） - 223\n\n7 月 10 日之前要确定之后的旅程，因为还有 100 块优惠券\n\n## 三亚 - 2302.5\n\n美兰 - 亚龙湾 95\n\n7 月 11 日~7 月 20 日 途家民宿，三亚海堂区后海村 56 号（转角遇到海）624\n\n麦当劳鸡翅 14 元\n\n7 月 11 日\n\n公交 35 路（12 元）海棠湾 1 路（2 元）\n清补凉 12 元\n海鲜炒饭 30 元\n沙县拌面 8 元\n清补凉 14 元\n椰子 5 元\n鸡排 13 元\n\n7 月 12 日\n\n沙县拌面 8 元\n老盐汽水 9 元\n海鲜砂锅 38 元\n抱罗粉 13 元\n茶饮 13 元\n\n7 月 13 日\n\n酸粉 12 元\n黎族饭团 35 元\n羊肉砂锅 28 元\n茶饮 13 元\n\n7 月 14 日\n\n肉丝拌面 12 元\n牛肉砂锅 28 元\n老盐汽水 9 元\n功能饮料 15 元\n德克士冰淇淋 13.5 元\n馄饨面 15 元\n水果 10 元\n\n7 月 15 日\n\n馄饨面 15 元\n鸡排 13 元\n绿茶 8 元\n肉丝面 12 元\n\n7 月 16 日\n\n酸菜肉丝面 12 元\n清补凉 12 元\n可乐鸡排洋葱圈 20 元\n星食烤奶 7 元\n椰子 5 元\n\n7 月 17 日\n\n肉丝拌面 12 元\n鸡腿饭 17 元\n奶茶 7 元\n羊肉砂锅 28 元\n椰奶清补凉 12 元\n水果 10 元\n\n7 月 12 日、13 日 冲浪 660 元\n\n冲浪租板子 200 元\n\n7 月 20 日 亚龙湾 - 美兰 95 元\n\n青菜肉丝面 12 元\n\n需要找 20 ~ 21 日的酒店\n\n公交去大顶村 2 元\n好丽友派 7 元\n机场早餐 36 元\n\n## 海口 - 161.88\n\n清补凉 16 元\n鸡失藤 15 元\n芒果肠粉 20 元\n\n隐居花园酒店 48.88 元\n飞猪会员 39 元\n\n水果 15 元\n椰汁 + 雪糕 8 元\n\n## 长沙 - 584.88\n\n7 月 21 日 九元航空 9:55~11:55 海口-长沙 270 元\n\n7 月 21 日 - 7 月 27 日 长沙明曦宾馆 293.88 元\n\n光猪圈健身 7 次卡 21 元\n\n## 总消费 - 4605.26\n","collection":"blog","data":{"type":"post","category":"plan"}},{"id":"2020/06/27/Nanshan-Museum-Ukiyo-World-Painting-Exhibition.md","slug":"2020/06/27/nanshan-museum-ukiyo-world-painting-exhibition","body":"\n# 南山博物馆浮世绘展览\n\n过去一个月基本上每周都去南山文体中心游泳，常常会路过南山博物馆，因为疫情原因，南山博物馆一直是关闭的，直到我看到了浮世绘的海报，从 6 月份开始南山博物馆开始展览。\n\n因为疫情还在继续，前往南山博物馆需要提前预约并申报健康码。\n\n![南山博物馆入口](./05.jpg)\n\n浮世绘就是源于日本民间的版画，最早是被荷兰人从包装商品的废纸中翻出来，日本人发现竟然有人稀罕这东西，便也拿出来给西方人卖。\n\n![装修成南京大排档一样的展厅](./06.jpg)\n\n## 主题\n\n因为产自民间，浮世绘往往绘画美人、戏曲中的角色、还有春宫图（嘿嘿）。当然，像是风景画什么的也很多见。展览最后说浮世绘影响了西方的印象派绘画，还拿出梵高、莫奈的画来当证据，不过，浙江的博物馆也说水墨画影响了西方印象派...反正都是几百年前的事儿，也没法考证，爱咋咋地吧~\n\n![这春宫图实在是太清水了](./01.jpg)\n\n![这个也一般](./03.jpg)\n\n![本山老师的猪腰子脸在过去可是美人的标准](./02.jpg)\n\n## 六大家\n\n擅长绘制嬉戏女性的铃木春信、绘制已婚妇女生活情景的鸟居清长、偏向中国水墨山水画风的哥川广中、绘制美人肖像画的喜多川歌麿、绘制歌舞剧情景的东洲斋写乐以及以神奈川冲浪里出名的葛饰北斋是浮世绘的六大家。\n\n![神奈川冲浪里](./04.jpg)\n\n![东洲斋写乐的画和我还是有几分神似](./07.jpg)\n\n## 审查制度\n\n和水墨画上面的印章不一样，浮世绘上面的印章主要表示它是被谁审查的，就像现在的版号，可以根据这些印章判断版画的出版时间。\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/06/27/Shekou-only-one-of-the-Meizu-offline-experience-stores.md","slug":"2020/06/27/shekou-only-one-of-the-meizu-offline-experience-stores","body":"\n# 蛇口仅剩的一家魅族线下体验店\n\n在育才中学附近有一个蛇口仅存的一家魅族线下体验店。\n\n![魅族线下体验店](./m2.jpg)\n\n店面有点寒酸，起码对比于万象天地的小米和华为的气派，只能说寒酸。\n\n![华为线下体验店](./m3.jpg)\n\n店面一侧摆着魅族 17 和魅族 16，这回主要看白色，旁边的黑色就没去看。\n\n![白色的魅族17](./m1.jpg)\n\n不得不说有点喜欢，之前就看上了小米 Mix2s 白色版，可是只能买到黑色的，挖孔屏的电量处理也很得我心意，重量嘛，虽然比我期望的魅族的重量要沉，但比我现在的手机轻。\n\n背面虽然看起来是磨砂，但摸起来有些胶质的感觉，可能和我的期望有点不同，到也谈不上失望或是惊喜。\n\n今年手机都上 5G 了，可我并不看好，除了电量损耗和手机质量的提升，5G 信号覆盖不全而且价格也不低...这种低性价比的东西若不是国家硬推，真是完全不能打，我搞不清楚为什么我要为它付费。\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/06/28/Zhuhai-Hengqin-Line-crossing-Macau.md","slug":"2020/06/28/zhuhai-hengqin-line-crossing-macau","body":"\n# 珠海横琴线横穿澳门\n\n![B站连接](https://www.bilibili.com/video/bv14v411B7Tt)\n\n一直没有机会去澳门，疫情期间就更没机会了，不过最近招商游轮开了新航线，从深圳蛇口港到珠海横琴港，中间会横穿澳门，怎么说也算是去过澳门了。\n\n## 横穿澳门\n\n![航线中间经过澳门](./1.jpg)\n\n因为澳门是由澳门半岛和氹仔与路环岛（后面两个岛已经填海连起来了），这次航线就是从澳门这两个岛中间穿过。\n\n招商邮轮疫情期间这个航线单程只要 65 块钱，于是一大早我便赶到蛇口港登船。\n\n![蛇口港](./2.jpg)\n\n回头可以看见连接深圳香港的深港大桥，左边是深圳右边是蛇口。\n\n![深港大桥](./3.jpg)\n\n途径珠港澳大桥，照片左边金字塔形状的建筑的是珠港澳大桥的人工岛。\n\n![珠港澳大桥人工岛](./4.jpg)\n\n因为疫情关系，珠三角间的健康码还没能互通，大桥上面一辆车都没有。\n\n![珠港澳大桥](./5.jpg)\n\n途径的海岛架满风车用于发电。\n\n![风车](./6.jpg)\n\n大概一小时左右，船驶入澳门，此时已经能收到澳门的短信了，但是广播要求最好不要打开漫游，以避免影响到健康码。\n\n![澳门塔](./7.jpg)\n\n![澳门塔和新葡京](./8.jpg)\n\n澳门的葡式建筑很有特色，比如下面的 8 字摩天轮。\n\n![8字摩天轮](./9.jpg)\n\n到达横琴港看澳门那边，和香港差不多的是，澳门也把最不发达的地方面向大陆。\n\n![从横琴港看向澳门](./10.jpg)\n\n下面是横琴港的照片和我的盛世美颜。\n\n![钟楼](./11.jpg)\n\n![港口](./12.jpg)\n\n![我](./13.jpg)\n\n尴尬的地方是这个港口非常小，小到连一个公共厕所都没有，最近的厕所也要 500m 左右。\n\n## 长隆\n\n横琴是珠海比较欠发达的地方，几乎除了长隆就没什么可以提的地方了，从横琴到珠海市区或者机场都要到长隆乘坐旅游巴士，而且这两个地方的买票地点不一样。景区的工作人员会带你去前往市区的买票点，去机场的买票点则在各种酒店（企鹅酒店或者马戏酒店），在微信搜索珠海机场快线也能预定车票。\n\n![长隆](./14.jpg)\n\n![长隆马戏酒店](./15.jpg)\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/06/30/Hidden-corner.md","slug":"2020/06/30/hidden-corner","body":"\n# 隐秘的角落\n\n「隐秘的角落」是爱奇艺迷雾剧场上的一部 12 集电视剧，主要讲的是单亲男孩朱朝阳暑假偶遇从福利院跑出来的严良和普普，三人去爬山遇到少年宫老师张东升谋杀自己岳父母，并借此事威胁张东升来救助普普的弟弟的故事。\n\n难得好看的国产剧，本来已经对国产剧有些失望，没想到还真有一部好看的。\n","collection":"blog","data":{"type":"post","category":"tv"}},{"id":"2020/07/01/Hainan-Provincial-Museum.md","slug":"2020/07/01/hainan-provincial-museum","body":"\n# 海南省博物馆\n\n刚到海口的旅店，就发现门口的大树上面生了一颗波罗蜜。\n\n![门口的波罗蜜](./01.jpg)\n\n海南博物馆附近有一家「老姐情怀」，顺便体验一下，芒果肠粉很好吃，糟粕醋就是一种粉，个人感觉不怎么好吃。\n\n![芒果肠粉和糟粕醋](./02.jpg)\n\n海南博物馆很大，貌似是有一部分介绍海南人文饮食和产物的老馆和介绍南海以及南海历史的新馆组成，新老馆的差距很明显，新馆有空调。\n\n老馆关于沉香的制作过程很详细，那么大一棵树，最后只能做那么一点沉香我也是惊了。新馆声电做的很震撼，也很吓人。\n\n![博物馆里的民国街](./03.jpg)\n\n博物馆力荐一种清补凉，叫鸡屎藤。是使用一种鸡失藤的野菜榨汁拧成细条放到椰汁里面，在骑楼街体验了一下，没啥特别的(ˉ▽ˉ；)...\n\n![骑楼街](./04.jpg)\n\n骑楼街是海口第一的景点，是以中山路为中心的东南亚风格的骑楼群。这种建筑在厦门、汕头、广州等都很常见，也基本都叫中山路。\n\n![人民路](./05.jpg)\n\n因为住在美兰，从海口去美兰大概 7 分钟的环岛车程。票价也是 7 块。\n\n![随处可见的椰树牌椰汁的广告](./06.jpg)\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/07/03/Dark.md","slug":"2020/07/03/dark","body":"\n# 暗黑\n\n这是网飞德国的一部对标「怪奇物语」的电视剧，但是逻辑上绝对比「怪奇物语」复杂得多...也算是德国种族天赋了，能看懂这部剧...总共三季，我超级简单说一下。\n\n第一季是男主角和小伙伴在丛林玩，却遗失了一个男孩。根据自杀的亲生父亲给男主留下的线索，男主找到一个山洞。山洞里面存放着多年来核电站遗弃的核废料，而这些核废料包括阴差阳错生产出来的上帝粒子，导致时空错乱，那个山洞连通了三个时空，未来男主回来就是要毁灭掉这个时空通道，第一季结尾时空通道被毁灭，但是因为方法不对，竟开通了另一条时空隧道。\n\n第二季，男主因为新的时空隧道穿越到未来，意识到自己原来的时空即将发生世界末日。一心想回家的他却回到了核电站建成之前，着这个时空里面他认识了老年的自己，老年的男主自称亚当，欺骗男主利用时空机回到父亲自杀之前，劝服父亲不要自杀，这样就能组织世界末日。然而男主发现父亲本来没打算自杀，而自己的出现却促成这一事件发生。男主希望找回当初遗失的男孩（也就是他父亲），这样虽然他自己就不存在了，依然能拯救世界，认为没有他的世界会更好。但在本季结尾，女主被亚当杀死，世界末日依然发生，来自另一个时空的女主带走了男主。\n\n第三季，男主来到了一个没有他的世界，遇到了这个世界的 boss，夏娃。夏娃说这个世界和原来的世界大体类似，也会有世界末日，两个世界有一个链接保护，亚当的做法会让世界更混乱。男主按照夏娃的指示一步步做，但发现该发生的还是发生了，而另一方面女主被亚当抓走，亚当认为女主怀着另一个世界男主的孩子，这个孩子的力量足以毁灭掉这两个世界，让混乱结束。然而亚当实验之后发现世界并没有结束，受人提示才知道，男主和女主的两个世界本来不该存在。1986 年一个科学家因为儿子离家出走遇到意外，科学家发明时光机想回到过去阻止，不料打开了这两个世界。男女主来到这个本源世界救回科学家儿子阻止了时光机的开发，从此两个世界消失。\n","collection":"blog","data":{"type":"post","category":"tv"}},{"id":"2020/07/17/20.md","slug":"2020/07/17/20","body":"\n# 20 年代初的小程序开发浅谈\n\n貌似有两周没怎么更新博客了哈，因为这几天白天就是冲浪游泳晒太阳，晚上就是写代码（啊~惬意），写了一个踏浪 App，用来查看大陆东南沿岸的冲浪浪点情况。\n\n![踏浪小程序码](./2020-07-17.jpg)\n\n## 为什么选择小程序\n\n就国内来说，如果是放到 web 这个纯开放平台上，就是 SEO 做得再好，也要被埋到广告里面；放到酷安和苹果商店...开发者要交钱的...我为爱发电还没这么强。反倒放到小程序里，因为大陆微信普及率很高，基本上说一句「你要是想看看浪情，去微信搜一下踏浪 App」就好了，再一个，微信小程序的云函数也提供了类似于 Google firebase 的前后台 sdk，也不用担心搭建服务器什么的了（毕竟我在旅游，运维的事情还是不想做）。\n\n## 包管理的尴尬\n\n小程序其实就是个优化了的浏览器，但是开发的时候不能搞到浏览器实例（window），这导致大部分 NPM 库里的 JS 都不能不加修改地在小程序中运行（哪怕是 lodash 这样的基础库），甚至是 D3 都跑！不！了！\n\n应该有很多库已经提供解决方案了，毕竟就是个编译就能解决掉的问题，可是像包管理这种东西，小程序上了这么年，一直都很烂，可见它是多不挣钱。\n\n## 云函数\n\n小程序的云函数只能在小程序编辑器里面开发，哪怕是到了腾讯云后台都看不到，这个不知道是不是鹅厂内部的问题。\n\n## SVG\n\n小程序 CSS 中支持 SVG。这点可以有，好多图我都是 figma 里面妥妥拽拽导出 SVG。但是在 Vdom 中直接插入 SVG 还是不行。\n\n## WSL\n\n另外，在 Windows 下面开发小程序是无法使用 WSL 环境的，哪怕是映射过去的文件地址也不行，但是可以把项目放在 Windows 的目录下如`/mnt/c/minprogram`开发。\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2020/07/19/Study-surfing-in-Houhai,-Sanya.md","slug":"2020/07/19/study-surfing-in-houhai-sanya","body":"\n# 在三亚后海学习冲浪\n\n谈到冲浪，其实是国内的一个小众运动（不得不说，国内不管什么运动对比这么大的人口基数都很小众）。大陆的东南沿海都有浪点，尤其是海南岛的东海岸更是冲浪的好地方。\n\n然而有浪点还不足，还需要有租板子的地方，毕竟那家伙一人多高，运起来很不方便。在海南西海岸，接近三亚的地方，海浪常年 1m 左右，很适合初学者学习，另外租金对于清水湾、日月湾来说更便宜。\n\n## 学习冲浪\n\n在后海学习冲浪和租浪板的价格不是很透明，基本上一个店一个价，学习冲浪一节课从 300~600，租用一天冲浪板价格也是从 100~300 不等，所以最好还是货比三家。\n\n往往第一节课的目的是能让你站在板上面，教练在后面推板子，听口令在板子上面蹲下，找到平衡后侧身站起来；第二节课开始教划水，基本上是在板子上做自由泳的动作；第三节，学习怎么抓浪，这一节课教练就不会推你了。\n\n因为家境贫寒，我就学了两节课，好在本身有滑板基础，三节课我两节也能搞定。\n\n另外，感觉课上教的方法虽然普及度很高，但是真的很累啊，首先抓浪起跑，跳到板子上面还要双手划拉，冲完了自己还要推板子回到海里面...其实还有个比较简单的方法，就是走到海水大概没过大腿的位置上，看到浪之后直接起跑，跳到板子上面，不划水直接站起来，这个方法真的要轻松很多。\n\n## 谈谈感受\n\n冲浪真的是一个很上瘾的运动，哪怕无数次试验只有一次成功，那种成就感迸发的肾上腺素就足以让人满足。学习冲浪其实要先查看浪报的，大部分人会上[magicseaweed.com](https://magicseaweed.com/)查看最近是否有好一些的浪，一般将近 1m 的浪对初学者就很合适。\n\n为了方便大家看浪报，我开发了一个踏浪 App 的小程序，直接抓的 magicseaweed 的数据，7 天浪情预报的功能我以后再上。\n\n![踏浪小程序码](../17/2020-07-17.jpg)\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/07/24/2D-svg-3D.md","slug":"2020/07/24/2d-svg-3d","body":"\n# 快速把 2D 的 svg 生成为 3D\n\n[vectary](www.vectary.com)可以把 2D 的 SVG 渲染成 3D，但是免费版导出的图片是有水印的，导出模型的功能也是收费的（但是我发现可以从 network 中扒`*.obj`文件，是，我知道这很 low🤣）\n","collection":"blog","data":{"type":"post","category":"fe","tag":["svg"],"series":{"slug":"tools","name":"利器"}}},{"id":"2020/07/25/The-Changsha-Museum-is-still-worth-going.md","slug":"2020/07/25/the-changsha-museum-is-still-worth-going","body":"\n# 长沙市博物馆还是值得去的\n\n之前我去[湖南省博物馆](/travel/2019/04/07/湘江没有百舸争流倒有汉墓一座.html)看过马王堆女尸，本来及已经很震撼了，但是长沙其实还有一座值得去的博物馆，就是长沙博物馆。\n\n考虑到古时候的长沙是比整个湖南还要大一点的地方，而且长沙是一个历史可以追溯到战国时期，它在唐之前的历史是可以再单独布置一套博物馆用于展示的。长沙博物馆距离北辰三角洲地铁站还有大概一公里的距离。\n\n## 看什么\n\n长沙古时是楚国的属地，楚国的青铜器是一绝，确切的说，我国南方的青铜器都比北方要精致。就我个人看来，应该是北方产铜量比不上南方；铸造技术传到南方的时间比较晚，已经成熟；再加上北方更早进入铸铁阶段，技术更新太快导致艺术上就没那么高追求了。\n\n![青铜剑](./2020-07-25-0.jpg)\n\n![青铜铙](./2020-07-25-2.jpg)\n\n另一个，因为长沙国作为封国的时间比较久（到了东汉时期依然存在），大量的墓葬都按照汉国王室墓制处理而又没有过度盗掘，保留了很多诸如黄肠题凑、金缕玉衣的墓葬制度，可以一饱眼福。\n\n![黄肠题凑](./2020-07-25-3.jpg)\n\n再一个，在近代馆里面看见了「万国图志」的原本。\n\n![万国图志](./2020-07-25-6.jpg)\n\n## 特展：粟特人在大唐\n\n这是洛阳博物馆在长沙的特展，就是一堆唐三彩，里面的一个兽面纹还挺像建国的。\n\n![唐三彩](./2020-07-25-5.jpg)\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/07/26/Wanjiali-can-really-be-a-hard-core-endorsement-of-Changsha.md","slug":"2020/07/26/wanjiali-can-really-be-a-hard-core-endorsement-of-changsha","body":"\n# 万家丽真是可以作为长沙的硬核代言了\n\n长沙有个地铁站叫做万家丽广场，是长沙当地的一个大老板开发的，号称「亚洲第一大单体建筑」的万家丽国际购物中心。所谓「硬核」的地方，是它的 11 层，是一个巨大的空中花园，是一个东西方名人雕塑汇聚的地方。\n\n![弥勒佛和看着希腊裸女笑出了花](./2020-07-26.jpg)\n\n空中花园里，弥勒佛看着希腊裸女笑出了花，毛爷爷的笑容也是异常尴尬，不太明白为什么要在四个方向上面放弥勒佛、毛主席、财神和孔子四尊金像，在他们对面还要摆一个希腊裸女。\n\n花园四周分别是湖南名人展览、万家丽介绍、历代帝王介绍以及名人蜡像馆，这些全部免费！而且历代帝王的每一代都有画像，而且不重样！是不是比人教版的教材都要良心！\n\n没完，乘电梯到 28 楼，还有四个巨大的停机坪，四角又放着四个金塔，金塔上面浮雕着中华传统故事，远远地俯瞰长沙的 CBD，简直不能再良心了。\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/07/27/7.md","slug":"2020/07/27/7","body":"\n# 抢了一张光猪圈健身的 7 天健身券\n\n我在长沙这几天，除了是因为大连成为疫区回不去，还有一个就是我在大众点评上面抢到了光猪圈的 7 天健身券。\n\nAPP 注册账号后，会给我一个手环，用于开箱子和打开器械区的设备，所有的运动内容都会被记录到 APP 中。个人并不清楚这些设备的成本如何，不过创新还是可以赞许的。\n\n![器械区](./2020-07-27.jpg)\n","collection":"blog","data":{"type":"post","category":"gym"}},{"id":"2020/07/28/In-addition-to-the-tall,-the-Guizhou-Museum-should-consider-some-connotative-things.md","slug":"2020/07/28/in-addition-to-the-tall-the-guizhou-museum-should-consider-some-connotative-things","body":"\n# 贵州博物馆除了高大上应该考虑一些内涵上的东西\n\n在贵阳坐地铁就可以到位于城郊的会展中心和博物馆，但是稍稍吐槽一下，贵阳的地铁并不支持第三方扫码支付，官方的扫码 APP 还必须绑定贵阳银行以进行支付，好在乘坐地铁的人不多，可以购买单程票。\n\n走了大概一公里的上坡路就能达到贵州省博物馆了，是一个彩色的不规则多边形建筑物，对应的是「多彩贵州」的广告词。参观博物馆需要提前预约，不过就是到现场再预约也不迟。\n\n贵州少数民族多，一进博物馆就是各种少数民族的介绍，包括服饰、产品、生存现状等。但是很快就意识到一个问题，这些介绍不是按照少数民族划分而是按照类别划分，举例说，当介绍服饰时，要分别介绍几个民族的服饰，而当饮食时又会重新分民族介绍，个人感觉整天下来，并不能记下来任何一个民族。\n\n![苗族节庆的巫师服饰](./2020-07-28-1.jpg)\n\n博物馆顶楼是远古化石和贵州历史，贵州历史简单带过夜郎国和土司历史就没了...个人感觉对于贵州还可以介绍一下它的地貌，比如各种形制的喀斯特地貌、再一个，少数民族的特色说的也不是很清楚，空荡荡的博物馆，只有那么多东西，哎。\n\n![博物馆对面会展中心正竖着大大的中指](./2020-07-28-0.jpg)\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/07/28/The-dream-of-red-pepper-and-the-reality-itself-is-very-chaotic.md","slug":"2020/07/28/the-dream-of-red-pepper-and-the-reality-itself-is-very-chaotic","body":"\n# 红辣椒，梦与现实本身就很混乱\n\n一研究院研究出能进入梦境的装置，DC Mini，该设备可以用来治疗精神类疾病。女科学家在院长指示下帮助警长治疗，女科学家在梦境中化名「红辣椒」。然而 DC Mini 还在测试阶段，却被盗走，盗走 DC Mini 的人在使用它操纵别人的梦。\n\n创造 DC Mini 的科学家想找出幕后黑手戴上 DC Mini 不料被人操控，女科学家为了救出他化身红辣椒去救却发现自己被暗恋自己的科学家禁锢在梦里。无数次醒来后红辣椒发现大 boss 是研究所的投资人并吸走了投资人的梦。\n","collection":"blog","data":{"type":"post","category":"movie"}},{"id":"2020/07/29/Qianlingshan-Park-watch-monkeys.md","slug":"2020/07/29/qianlingshan-park-watch-monkeys","body":"\n# 黔灵山公园看猴子\n\n按照地图指示坐地铁就能到黔灵山东门了，但是如果是要看猴子的话，一般都是从南门弘福寺进入（我真的是翻了整整一座山才到的）。\n\n![弘福寺的猴子](./2020-07-29.jpg)\n\n基本上在黔灵山是看不见猴子的，需要走到弘福寺附近，显然连猴子都知道去寺庙的人带的东西肯定更好吃。\n\n因为疫情，黔灵山门票免费，在山脚下有一个叫做麒麟洞的天然溶洞，小是小了点，但毕竟免费不去白不去。\n\n弘福寺是要收香火费的，所以我就在门口逛了逛，整个黔灵山其实也不大，大概两到三个小时就逛完了。\n\n## 贵阳附近的小吃\n\n逛完黔灵山后我又到附近的健身房做了一个小时的 CrossFit，全部结束我已经饥肠辘辘了。好在贵阳不大，就算是住在城郊的我离市中心也不过 10km。\n\n在贵阳谈及最多的是肠旺面，就是猪大肠、猪肝做的碱面。另外就是丝娃娃，大概可以理解为京酱肉丝没有肉丝...\n\n在中山西路有一个地下的小吃街，能吃到各种街头小吃，当然基本上可以理解为高油碳水，不过是真好吃啊~附近还有一家安顺小舒冰粉冰浆，点一份黄瓜牛奶冰浆解一解腻。\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/07/31/A-scenic-spot-in-Yelanggu's-imagination.md","slug":"2020/07/31/a-scenic-spot-in-yelanggus-imagination","body":"\n# 夜郎谷一个臆想出来的景区\n\n夜郎国是大概西汉时期位于贵州的小国，史记有记载夜郎自大的典故，贵州省博其实就一个展牌有介绍夜郎国，估计除了史记也没什么实际的考古发现来证明它。不过没关系，一个美术家，宋培伦通过二十年直接在贵阳大学城做了个假的夜郎国遗址。\n\n![夜郎谷](./2020-07-31-0.jpg)\n\n前往夜郎谷并不容易，整个贵阳大学城在贵阳的最南端，是个完全鸟不拉屎的地方，因为重要的交通枢纽都在北方，前往夜郎谷至少要转两班公交大概两个小时车程才能到。\n\n尽管旅程很长，但是夜郎谷绝对值得一看。话说毕竟是艺术家，相比于长沙的万家丽，这个夜郎谷虽说没什么依据，审美上是完全超群的。迎合疫情，柱状人面都带上了口罩。话说整个景区有一种隐约的性隐喻。穿过一群人面石柱，藏着一个悬崖，崖面有一个裂缝，裂缝里面是一个溶洞可以走到山坡顶。\n\n![合个影也是很开心的体验](./2020-07-31.jpg)\n\n个人感觉，如果在贵阳，这个景区是绝对值得去的，何况现在还是免费的~\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/08/03/Anshun-Dragon-Palace.md","slug":"2020/08/03/anshun-dragon-palace","body":"\n# 安顺龙宫\n\n这一周我都在贵阳，总感觉应该去几个地标性的地方。查了一下贵州旅游在 7 月 31 号之前是免费的，哭了。\n\n要说贵州最地标的地方，自然是黄果树瀑布。但是疫情期间黄果树瀑布只能远观，不能走到水帘洞里面，什么鬼，那不是和看视频差不多？查了一下，同在黄果树所在的安顺市里面还有一个值得去的地方，龙宫水洞。其实我去过的水洞景区也不多，只有一个本溪水洞，只能说这个龙宫水洞很大，乘船进入水洞后还可以在水洞里走一段路程。\n\n在龙宫里，入口处的水洞被称作一进宫，一进宫出来可以游览一个叫做龙虎穴的旱洞，这点就比本溪水洞爽了，毕竟旱洞里面可以拍照。出了龙虎穴还可以游玩二进宫，显然二进宫就没开发得那么完整。据说龙宫水洞总共五进宫，目前开发完成的只到二进宫，后面路程只能原路返回。\n\n怎么评价这个景区呢，标准合家欢景区...老少咸宜，但是少了那么多刺激感，景区各种标志只是为了你选择收费项目尽快完成，不过 85 块看三个这样的水洞依然很值。\n\n另外，虽然贵阳到安顺普快也就一个半小时，但是位于山区的安顺天气会明显多变，十几分钟的雨下个不停，倒也不是很大，主要是湿漉漉的山路不得不要放慢脚步。\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/08/04/CrossFit.md","slug":"2020/08/04/crossfit","body":"\n# Crossfit 初体验\n\n![CrossFit 红壤](./2020-08-04-2.jpg)\n\n![CrossFit Top Power](./2020-08-04-1.jpg)\n\n过去一周，我在贵阳的两个健身房（位于小十字的红壤体育馆和位于花果园的 TopPower 运动馆）体验了大概一周多的 CrossFit 体验，红壤比较爽，在大众点评抢到了一张 21 块的 7 天体验，毕竟他们一次课要 89，而 Top Power 一次课需要 69 元。\n\n先说说 CrossFit 是什么，CrossFit 其实是个品牌，类似于腹肌撕裂者，是有一系列运动组合成的课程。不同的是，CrossFit 的课表是每天从官网下发的，也就是说，即使你经常往返于几个健身房，能够做的课程是连贯的。\n\nCrossFit 的发起人是个体操运动员，运动项目以徒手为主，个人感觉大部分运动依靠爆发力，所以技巧性要求很高，比如一次 66 个倒立撑，这种运动如果不了解借力根本做不到 😂。CrossFit 一般是几套爆发力动作不断半小时左右，再加上贵阳这里的饮食以素菜为主，导致我这几天简直是暴瘦。\n\n再说说这两个店，两家貌似都是才开门，还有好多推广，器材也很新。红壤位置在地下，颇有点 fight club 的感觉，top power 的教练还有一些是兼职的（好羡慕啊，一直想做这种工作日编程，周末当教练的生活 😶，不过想想 996 还是算了）。\n\n谈谈运动设备：\n\n划船机，这感觉在 CrossFit 中有氧的地位很高（高于跑步，因为跑步对膝盖损伤大，CrossFit 里面的跑步一般都很少），划船动作很严格，要胸触膝盖收缩，双腿蹬踏板，身体全部伸展后再拉浆到胸前，运动完屁股很疼 🙃\n\n跑步机，这个在红壤里面有，不是那种常见的电驱动跑步机，而是靠自己带动履带的。\n\n滑雪机，单车，这两个都是跑步的替代，按照 8/10 和 8/20 完成\n\n运动内容都是单杠，哑铃，壶铃，杠铃以及台阶为主。\n","collection":"blog","data":{"type":"post","category":"gym"}},{"id":"2020/08/05/Window10-action center.md","slug":"2020/08/05/window10-action-center","body":"# 解决Windows10的action center无法打开的问题\n\n最近打开平板发现任务栏右下角的事件中心无法打开了，不仅如此，连wlan、声音大小、省电中心都不能打开了，简单的查了一下，或许是因为升级之后uwp注册出错了，需要重新注册，管理模式打开powershell输入以下命令重新注册应用。\n\n```\nGet-AppxPackage | % { Add-AppxPackage -DisableDevelopmentMode -Register “$($_.InstallLocation)\\AppxManifest.xml” -verbose }\n```","collection":"blog","data":{"type":"post","category":"tech"}},{"id":"2020/08/07/Spring-and-autumn-fly-to-the-book-with-your-own-book.md","slug":"2020/08/07/spring-and-autumn-fly-to-the-book-with-your-own-book","body":"\n# 春秋随心飞记账小本本\n\n上个月我买了春秋的随心飞，反正大连疫情爆发我也回不去，索性全国随心玩一圈，看看花销能多少了。\n\n## 长沙 - 490.01\n\n在长沙买了 7 天的光猪圈健身体验，顺便在长沙住七天。\n\n- 7 月 21 日\n  - 磁悬浮 20 元\n  - 饮料等 37.6 元\n  - 肯德基 43.5 元\n  - 牛磺酸 5 元\n  - 书亦烧仙草 10 元\n- 7 月 22 日\n  - 饮料 21.7 元\n  - 午饭 17 元\n  - 水果 14.9 元\n  - 晚饭 8 元\n  - 牛奶 6.5\n  - 西瓜 7.7\n  - 肥皂等 7 元\n- 7 月 23 日\n  - 肯德基 34 元\n  - 星巴克 35 元\n- 7 月 24 日\n  - 肯德基半价桶 65 元\n  - 牛奶 14.61\n- 7 月 25 日\n  - 拉面 43\n  - 肯德基 18.5\n  - 书亦烧仙草 15 元\n- 7 月 26 日\n  - 大香肠 13 元\n  - 茶颜悦色 15 元\n  - 吉野家 38 元\n\n## 贵阳 - 1448.88\n\n长沙虽然博物馆多，但是太热，38 度的高温，终于知道太祖为什么洗冷水澡了。另外，贵阳 cross fit 很火，参加了一个 19.9 的红壤 crossfit 体验。\n\n- 7 月 27 日-8 月 3 日\n  - 红壤 CrossFit 19.9\n- 7 月 27 日\n  - G1321 长沙南 - 贵阳北 314.5\n  - 湘菜米线 42\n  - 铜锅洋芋饭 15\n  - 旺肠面 12\n  - 地铁 2\n  - 地铁 6\n  - 麦当劳 12\n  - 公交 1.48\n  - 饼干 11.3\n- 7 月 28 日\n  - 大碗面 14\n  - 饮料 5\n  - 德克士 13.2\n  - 迪卡侬 176\n  - 水果 10.8\n- 7 月 29 日\n  - 小笼包 9\n  - 冰粉 12\n  - 面包 4.5\n  - 肥牛粉 20\n  - 地铁 4\n  - 夜郎谷公交 8\n  - 夜郎谷返程 5\n  - 快乐柠檬 16\n  - 牛排 39\n  - 牛奶 20\n- 7 月 30 日\n  - 地铁 4\n  - 麦当劳 9\n  - 牛排 51\n  - 牛排 39\n  - 水果 15.9\n- 8 月 2 日\n  - K1501 贵阳 - 安顺 15.5\n  - 奶茶 14\n  - 肯德基 13\n- 8 月 3 日\n  - 龙宫 85\n  - C5988 安顺西 -贵阳北 43\n  - 炒酸奶 20\n- 8 月 4 日\n  - TopPower crossfit 65\n  - 烤肉 100\n  - 水果 12\n  - 包子 30\n- 8 月 5 日\n  - G406 贵阳北 - 芷江 156\n  - 德克士 28.8\n  - 快递 40\n\n## 芷江 - 177\n\n在芷江机场转机路过，如果感兴趣的话可以去看看受降纪念馆，有一个非现实主义的画作，受降仪式升的是五星红旗（日军受降的时候还没五星红旗呢...）。\n\n- 8 月 6 日\n\n  - 怀化芷江 - 昆明长水 50\n  - 华莱士 18\n  - 饮料 13\n  - 混沌 10\n  - 茶饮 8\n  - 唯度宾馆 78\n\n- 6 月 28 日至 8 月 6 日共花费： 6721.15 元\n\n## 昆明\n\n- 8 月 6 日、7 日\n  - 鸿发宾馆 117.96\n- 8 月 6 日\n  - 昆明地铁 7\n  - 菌菇火锅 128\n  - 昆明地铁 4\n- 8 月 7 日\n  - 汉堡王 42\n  - 公交 1.5\n- 8 月 8 日、9 日、10 日\n  - 倾城青年旅舍 （11 日离店）144\n- 8 月 8 日\n  - 三碗豆花米线 20.5\n  - 家乐福 38.82\n  - 老挝手标奶咖 15\n  - 梅菜扣肉饼 8\n  - 鸡排 19\n- 8 月 9 日\n  - 午饭 13\n  - 麦当劳 20\n  - 公交 1.8\n  - 牛奶 8.89\n  - 纹身 1500\n- 8 月 10 日\n  - 牛肉饼 10\n  - 羊肉汤 23\n  - 地铁 2\n  - 地铁 2\n  - 紫米露 10\n  - 公交 1.8\n  - 公交 1.8\n  - 傣雀园 88\n  - 光猪圈 16.8\n- 昆明共消费 2244.87， 6 月 28 日至 8 月 10 日共消费 8966.02\n\n## 普者黑\n\n- 8 月 11 日 - 195\n  - 昆明南 普者黑 75\n  - 麦当劳 10\n  - 普者黑张三青旅 36\n  - 地铁 6 元\n  - 卤肉饭 35\n  - 普者黑公交 5\n  - 炸洋芋 紫米露 28\n- 普者黑消费 195， 6 月 28 日至 8 月 11 日共消费 9161.02\n\n## 玉溪\n\n- 8 月 12 日\n\n  - 公交 5\n  - 动车 75\n  - 动车 29\n  - 康师傅 46\n  - 怪兽充电 1.5\n  - 玉溪公交 0.9\n  - 麦当劳 18\n  - 沃尔玛 20.6\n\n- 8 月 13 日\n\n  - 德克士 32.69\n  - 哈罗单车 1\n  - 哈啰 0.9\n  - 哈罗单车 1\n  - 肯德基 9.9\n  - 火腿肉 133\n  - 哈啰单车 1\n  - 哈罗单车 3\n  - 哈罗单车 4\n  - 哈啰次卡 9.9\n  - 奥利奥 6.5\n  - 洪记凉米线 12\n  - 沃尔玛 42.64\n  - 饮料 5\n\n- 8 月 14 日\n\n  - 傣味 69\n  - 沃尔玛 25\n  - 麦当劳 26\n  - 花枝烧仙草 12\n\n- 8 月 15 日（离店）\n\n  - 江川公交 5\n  - 江城公交 3\n  - 明星公交 3\n  - 澄江悦庭酒店 89\n  - 烤肠 3\n  - 明星鱼洞 7.5\n  - 面包牛奶 25\n\n- 8 月 16 日\n\n  - 澄江海栖民宿 118\n  - 傣味 95.5\n  - 澄江公交 3\n  - 冰淇淋 7\n\n- 8 月 17 日\n\n  - 摩范用车 10\n  - 龙华宾馆 42\n  - 花枝烧仙草 12\n  - 麦当劳 21.9\n  - 沃尔玛 25\n  - 华莱士 12.99\n  - 1991 健身 - 29.9\n\n- 玉溪 1103.32， 6 月 28 日到 8 月 17 日共消费 10264.34\n\n## 建水 + 蒙自\n\n- 8 月 18 日\n  - 玉溪 - 建水 26\n  - 建水倾城湖畔旅行酒店 46\n  - 凉米线 12\n  - 正新鸡排 15\n  - 哈罗单车 3\n  - 肯德基 35\n- 8 月 19 日 建水\n  - 包子 4\n  - 益禾堂 6\n  - 沃尔玛火腿月饼 29.76\n  - 蒙自源米线 19\n  - 饮料 3\n  - 乍甸牛奶 8\n  - 建水倾城湖畔旅行酒店 46\n- 8 月 20 日 离开建水\n  - 建水 - 蒙自 15 11：09 c8301\n  - 蒙自公交 1.8\n  - 蒙自公交 1.8\n  - 蒙自滇越驿站 31\n  - 蒙自博物馆\n  - 康唯国际健身俱乐部 9.9\n  - 茶颜观色 12\n  - 自助烤肉 38.3\n- 8 月 21 日 （周五）蒙自\n  - 德克士 25.2\n  - 蒙自公交 1.8 2 路\n  - 蒙自公交 1.8 4 路\n  - 蒙自公交 1.8 18 路\n  - 蒙自 - 建水 15\n  - 建水公交 2\n  - 麦当劳 我 24\n  - 张阿姨奶茶 10.68\n  - 建水南迁语酒店 69\n- 8 月 22 日\n  - 凉米线 10\n  - 饮料 10\n  - 正新鸡排 13\n  - 沃尔玛 28.57\n  - 建水南迁语酒店 69\n- 建水和蒙自共消费 644.41，6 月 28 日至 8 月 22 日共消费 10908.75。\n\n## 景洪\n\n- 8 月 23 日 -（离开建水） 建水\n  - 景洪 13:00 229.79\n  - 米线 豆腐 25\n  - 7 天 76\n- 8 月 24 日 景洪\n  - 德克士 30.6\n  - 牛奶 13.1\n  - 曼听花园 20\n  - 阳阳小吃 31\n  - 晚饭 12.9\n  - 7 天 76\n- 8 月 25 日 景洪\n\n  - 华莱士 14.99\n  - 景洪公交 1.1\n  - 景洪公交 1.1\n  - 7 天 76\n  - 芒果饭 咖啡 28.8\n  - 众力恒 19.8\n\n- 8 月 26 日\n\n  - 泰版纳菠萝饭 38\n  - DQ 28\n  - 景洪公交 1.1\n  - 18:10 嘎洒机场 - 23:50 浦东机场 50\n\n- 景洪共消费 773.28，从 6 月 28 日到 8 月 26 日共消费 11682.03。\n\n## 上海\n\n- 8 月 26 日\n  - 机场出租 244\n  - 上海大隐国际青年旅舍 64\n- 8 月 27 日\n\n  - 上海大隐国际青年旅舍 64\n  - 鱼香肉丝冷面 20\n  - 牛奶 16.7\n  - 上海地铁 4\n  - OFFF 咖啡 32\n  - shake shack 47\n  - 上海地铁 4\n  - 羊肉串 10\n\n- 上海共消费 505.7，从 6 月 28 日到 8 月 27 日共消费 12187.73。\n\n## 十堰\n\n- 8 月 28 日\n  - 哈罗单车 1.14\n  - 豆浆 19\n  - 浦东机场 T2 8：20 - 武当山机场 10：55 50\n  - 机场大巴 20\n  - 松果单车 1\n  - 盖浇饭 25\n  - 武当山公交 105\n  - 瓜瓜芝士 12\n  - 水 2\n  - 松果单车 5.7\n  - 送过单车 1\n- 8 月 29 日\n  - 松果单车 2.4\n  - 热干面 15\n  - 蜜雪冰城 6\n  - 沙县扣肉 13\n  - 蜜雪冰城 7\n  - 松果单车 2.5\n  - 响茶 15\n  - 沙拉烤肉饭 12\n  - 松果单车 2.7\n- 8 月 30 日\n\n  - 热干面 7\n  - 武当山 12：10-浦东机场 14：15 49.43\n  - 上海地铁 4\n  - 单车 3.5\n  - 麦当劳 28\n  - 小杨生煎 17.9\n  - 99 优选 川沙妙境路 76\n\n- 十堰共消费 503.27， 从 6 月 28 日到 8 月 30 日共消费 12691。\n\n## 海口\n\n- 8 月 31 日\n\n  - 上海浦东-三亚 50\n  - 凤凰-海口东 103\n  - 公交 0.01\n  - 迪卡侬 176\n  - 公交 0.5\n  - 儋州米烂 30\n  - 老盐汽水 6\n  - 海口嘻哈太空仓 49\n\n- 9 月 1 日\n\n  - 麦当劳 10\n  - 椰语堂 15.8\n  - 哈罗单车 1.5\n  - 健身 6.6\n  - 海口嘻哈太空舱 49\n  - 湛江生蚝 128\n  - 海口公交 0.5\n  - 满杯百香果 7\n\n- 海口共消费 632.91，从 6 月 28 日到 9 月 1 日共消费 13323.91 元\n\n## 万宁\n\n- 9 月 2 日\n  - 海口-万宁 59\n  - 麦当劳 12.5\n  - 万宁公交 5.01\n  - 万宁小刚驿站 41\n  - 晚餐 40\n- 万宁共消费 157.51， 6 月 28 日到 9 月 2 日共消费 13481.42 元。\n\n## 三亚\n\n- 9 月 3 日\n  - 饮料 3\n  - 皮蛋瘦肉粥 5\n  - 神州-陵水 13\n  - 蒸膳美 32\n  - 清补凉 18\n  - 潜水 OW 3200\n- 9 月 4 日\n  - 叉烧包 20\n  - 水 3\n  - 清补凉 18\n- 9 月 5 日\n  - 小笼包 20\n- 9 月 6 日\n  - 陵水-三亚 23\n  - 三亚 4 路 2\n  - 海天之交 50\n  - 午饭 24\n  - 水 2\n  - 清补凉 20\n  - 牛奶 10.5\n  - 冲浪 100\n- 9 月 7 日\n  - 海天之交 50\n  - 早饭 24\n  - 冲浪 150\n  - 水果 20\n  - 百香果飘香奶茶 16\n  - 芒果冰球清补凉 20\n  - 牛奶 10.5\n- 9 月 8 日\n  - 辣条 5\n  - 火车盒饭 20\n  - 三亚-海口 79\n  - 海口-湛江 k458 69.33\n  - 湛江公交 2\n  - 土蚝生蚝 53\n  - 饮料 4.3\n  - 沃尔玛 6.67\n  - 八方快捷酒店 72\n- 三亚共消费 4165.3，从 6 月 28 日-9 月 8 日共消费 17646.72。\n\n## 湛江\n\n- 9 月 9 日\n  - 麦当劳 12\n  - 湛江公交 2\n  - 咖喱三鲜面 20\n  - 八方快捷酒店 91\n- 9 月 10 日\n  - 湛江-银川 100\n  - 真功夫 11\n  - 打车 17.22\n  - 梅菜扣肉 52\n  - 机场大巴 20\n  - 充电宝 1.5\n  - 牛奶 6\n  - 肯德基 19.4\n  - 公交 1\n  - 银川国安青旅 36\n- 湛江共消费 389.12，从 6 月 28 日-9 月 10 日共消费 18035.84。\n\n## 银川\n\n- 9 月 11 日\n  - 公交 1\n  - 肯德基 10\n  - 迪卡侬 394.37\n  - 公交 1\n  - 羊肉泡馍 20\n  - coco 奶茶 9\n  - 矿泉水 1\n  - 滩羊 99\n  - 银安国际青旅 36\n- 9 月 12 日\n  - 小笼包 8\n  - 公交 1\n  - 公交 8\n  - 当代美术馆 20\n  - 公交 1\n  - 公交 1\n  - DQ 26\n  - 公交 1\n  - 烤蛋 4\n  - 水果 10\n  - 公交 1\n  - 公交 1\n  - 啤酒 7.8\n  - 银川国安青旅 36\n- 9 月 13 日\n  - 老木瓜羊肉搓面 17\n  - 公交 1\n  - 地质博物馆 10\n  - 公交 1\n  - 牛奶 9.08\n  - 正新鸡排 12\n  - 公交 1\n  - 公交 1\n  - 机场大巴 20\n  - 机场拉面 56.9\n  - 机场眯一会 75.24\n- 9 月 14 日\n  - 肯德基 16.5\n  - 银川-正定 50\n  - 99 连锁正定机场 76\n- 银川共消费 1043.89，6 月 28 日至 9 月 13 日共消费 19079.73。\n\n## 呼和浩特\n\n- 9 月 15 日\n  - 麦当劳 13.5\n  - 鸡蛋灌饼 12\n  - 正定-呼和浩特 50\n  - 烤包子 21.5\n  - 公交 1\n  - 呷脯呷脯 72\n  - 尚俭太空舱 37\n- 9 月 16 日\n  - 手抓饼 7\n  - 饮料 2.2\n  - 公交 1\n  - 奶茶 42\n  - 公交 1\n  - 贝德宝健身 29.9\n  - 敕勒歌冰煮羊 120\n  - 太空舱 37\n- 呼和浩特共消费 447.1，6 月 28 日至 9 月 13 日共消费 19526.83。\n\n## 鄂尔多斯\n\n- 9 月 17 日\n  - 公交 1\n  - 正新鸡排 12\n  - 呼和浩特-东胜西 41.5\n  - 鄂尔多斯公交 3\n  - 肯德基 37.9\n  - 鄂尔多斯公交 3\n  - 牛奶 17.8\n  - 健身 8.8\n  - 东胜宝日陶海 56\n- 9 月 18 日\n  - 稍麦 8\n  - 鄂尔多斯公交 3\n  - 豪士骑马俱乐部 500\n  - 出租 100\n  - 羊肉 122.6\n  - 健身 8.88\n  - 牛奶 14.44\n  - 东胜宝日陶海 56\n- 鄂尔多斯共消费 993.92，6 月 28 日至此共消费 20520.75\n\n## 包头\n\n- 9 月 19 日\n  - 肯德基 40.5\n  - 包头客运 33\n  - DQ 29.9\n  - 德克士 17.1\n  - 公交 1\n  - 牛奶 13.5\n  - 摩拜 1\n  - 单车券 2.8\n  - 稍美 7.2\n  - 恒辉太空舱 36\n- 9 月 20 日\n  - 吉野家 26.5\n  - 迪卡侬 85.4\n  - 健身 18.8\n  - 锅包肉 13\n  - 蜜雪冰城 9\n  - 恒辉太空船 36\n- 9 月 21 日\n  - 麦当劳 6\n  - 包头-呼和浩特 43.5\n  - 冰煮羊 88.8\n  - 美团单车 2.4\n  - 呼和浩特地铁 4\n  - 饮料 4.5\n  - 呼和浩特-上海 50\n  - 地铁 3\n  - 长丘国际青旅 54\n- 包头共消费 626.9，6 月 28 至此 21147.65\n\n## 四川（成都-九寨沟-广汉-绵阳）\n\n- 9 月 22 日\n  - 维他奶 3.3\n  - 地铁 3\n  - 地铁 3\n  - 上海-成都 50\n  - 蜜雪冰城 9\n  - 乡村基 19.9\n  - 花椒冰淇淋 25\n  - 鲜芋仙 30\n  - 公交 1.8\n  - 饮料 12\n  - 熊猫公寓 59\n- 9 月 23 日\n  - YTY 80\n  - 香肠 20\n- 9 月 24 日\n  - YTY 80\n  - 午饭 10\n- 9 月 25 日\n  - YTY 80\n  - 沙棘 5\n  - 沙棘 8\n  - 牛肉 60\n- 9 月 26 日\n  - 解说 80\n  - 牛奶 8.4\n  - 充电 3\n  - 地铁 3\n  - 地铁 2\n  - 沃尔玛 39.6\n  - 沃尔玛 8.6\n  - 乡村基 25\n  - My Space 60\n- 9 月 27 日\n  - 麦当劳 16\n  - 成都-广汉北 18\n  - 广署宾馆 82\n  - 天府通 1.8\n  - 三星堆 72\n  - 广汉公交 2\n  - 郑一涵小吃 25\n  - 超市 29.2\n- 9 月 28 日\n  - 乐山豆腐脑 27\n  - 广汉-绵阳 27\n  - 绵阳公交 1.6\n  - 蜜雪冰城 6\n  - 小吃九宫格 39.9\n  - 牛奶 14.8\n  - 金山酒店 64\n- 9 月 29 日\n  - 牛肉饼 5\n  - 抄手 9.9\n  - 鸡排 13\n  - 水果 12.9\n  - 金山酒店 64\n- 9 月 30 日\n  - 德克士 29\n  - 出租车 18.6\n  - 石锅拌饭 40\n  - 绵阳-大连 99.7\n- 四川共消费 1507，6 月 28 日至此共消费 22654.65\n\n## 北疆\n\n- 10 月 13 日\n  - 大连-乌鲁木齐 100\n  - 华住早餐 18\n  - 乌鲁木齐地铁 6\n  - 公交 1\n  - 烤包子 6\n  - 蜜雪冰城 7\n  - 公交 1\n  - 奶啤 10.5\n  - 停泊青旅 55\n- 10 月 14 日\n  - 德克士 25.14\n  - 公交 1\n  - 乌苏 32.47\n  - 停泊青旅 55\n  - 瓦那 wana 83.6\n- 10 月 15 日-10 月 23 日\n  - 住宿 600\n  - 车费 481.5\n  - 住宿 600\n  - 车费 481.5\n  - 车费 361\n  - 拼团返款 -226\n  - 拼团 192.8\n  - 拼团返款 -42\n  - 喀纳斯住宿 300\n  - 眼药膏 8.4\n  - 冰淇淋 9\n  - 冰淇淋 10\n  - 饭钱 33.3\n  - 饭钱 40\n  - 住宿拼团 261\n  - 拼团返款 -58.5\n- 10 月 24 日\n  - 库尔勒 58\n  - 肯德基 6\n  - 拼团 37.84\n  - 拼团 50.67\n  - 拼团 20\n  - 按摩 15\n  - 乌鲁木齐-酒泉 342.5\n- 北疆共消费 2902.22，6 月 28 日至此共消费 25556.87。\n\n## 酒泉\n\n- 10 月 25-28 日\n  - 午饭 28\n  - 水 6\n  - 午餐 43.67\n  - 拼车 262.59\n  - 午餐 26.67\n  - 拼车返款 -34.67\n  - 住宿 80.84\n  - 吃饭 22.46\n  - 奶茶 9.7\n  - 乌尔麦牛肉面 21\n  - 水果 20\n  - 拼团 114\n  - 住宿 57.34\n  - 水果 4.8\n  - 拼团返款 39\n  - 耳机转接线 25\n  - 维生素 30\n  - 书亦烧仙草 11.9\n  - 哈罗单车 0.9\n  - 哈罗单车 5\n- 10 月 29 日\n  - 汉堡王 24.5\n  - 西瓜 17\n  - 耳机 99\n  - 家庭宾馆 48\n- 10 月 30 日\n  - 汉堡王 18.3\n  - 冰煮羊 158\n  - 牛奶 4\n  - 家庭宾馆 48\n- 10 月 31 日\n  - 牛排自主 58\n  - 牧马人青旅 37\n  - 共享单车 1.4\n  - 水 2\n  - 冰煮羊 100\n- 11 月 1 日\n  - 嘉峪关站-敦煌站 22.5\n  - 万家缘客栈 31\n  - 顺张驴肉黄面 56\n  - 米雪 9\n- 11 月 2 日\n  - 水果 6\n  - 晚饭 12\n  - 水果 12\n  - 肯德基 39\n  - 甜胚子 6\n  - 万家缘客栈 31\n- 11 月 3 日\n  - 张量麻辣烫 27.5\n  - 米雪 9\n  - 万家缘客栈 31\n  - 晚饭 22.8\n- 11 月 4 日\n  - 张亮 33.7\n  - 滴滴 34\n  - 麦当劳 43.5\n  - 敦煌-沈阳 100\n- 酒泉共消费 1915.4，6 月 28 日至此共消费 27472.27\n\n## 沈阳\n\n- 11 月 5 日\n  - 机场大巴 15\n  - 汉堡王 29.5\n  - 汉堡王 42\n  - 健身 99.8\n  - 7 天 69\n- 11 月 6 日\n  - 吉野家 20\n  - 迪卡侬 43.5\n  - 7 天 69\n- 11 月 7 日\n  - 吉野家 35\n  - 锅包肉 44\n  - 家乐福 9.8\n  - 7 天 69\n- 11 月 8 日\n  - 讲解 15\n  - 地铁 0.3\n  - 吉野家 11\n  - 吉野家 20\n  - 公交 4\n  - 牛奶 9\n  - 宝地宾馆 24\n- 11 月 9 日\n  - 水果 13.8\n  - 宝地宾馆 24\n  - 星巴克 6\n  - 地铁 0.3\n  - 地铁 0.3\n- 11 月 10 日\n  - 汉堡王 26.8\n  - 炸鸡串 10\n  - 串珠子 5\n  - 蜜汁排骨 15\n  - lazybee 52\n- 11 月 11 日\n  - 永和 9.9\n  - 鸡架 8\n  - 鸡排 6\n  - 蜜雪 7.9\n  - 炒酸奶 12\n  - lazybee 52\n- 11 月 12 日\n  - 汉堡王 39\n  - 迪卡侬 207\n  - 美黑 49\n  - 地铁 0.3\n  - 地铁 0.2\n  - 地铁 2\n  - 森乡嘉禾 79\n- 11 月 13 日\n  - 沈阳-北海 50\n  - 浑南电车 2.85\n  - 永和 36\n  - 机场巴士 20\n  - 单车 5.9\n  - 忘尘青旅 34\n- 在沈阳共消费 1403.15，6 月 28 日至此消费 28875.42 元\n\n## 北海\n\n- 11 月 14 日\n  - 虾饼 10\n  - 奶茶 8.9\n  - 健身 14.9\n  - 鱼香肉丝 25\n  - 矿泉水 2\n  - 梨子 5.49\n  - 忘尘青旅 34\n- 11 月 15 日\n  - 酸菜鱼 29\n  - 水 2\n  - 储物柜 30\n  - 正新鸡排 13\n  - 牛奶 40.68\n  - 海蓝别院 51\n- 11 月 16 日\n  - 正新鸡排 18\n  - 酸菜鱼 23.88\n  - 单车 5.9\n  - 海蓝别院 51\n- 11 月 17 日\n  - 美团单车 1\n  - 健身 8.8\n  - 饭团 13.8\n  - 正新鸡排 13\n  - 鸡排饭团 6.9\n  - 忘尘青旅 34\n- 11 月 18 日\n  - 叉烧包 7\n  - 单车 1\n  - 忘尘青旅 34\n- 11 月 19 日\n  - 单车券 5.9\n  - 拉面 28\n  - 存储 30\n  - 海蓝别院 49\n- 11 月 20 日\n  - 早餐 8\n  - 单车 2.99\n  - 存储 30\n  - 海蓝别院 49\n- 11 月 21 日\n  - 酸菜鱼 29\n  - 机场大巴 20\n  - 北海-哈尔滨 50\n  - 机场巴士 20\n  - 稻香青年旅舍 29\n  - 肯德基 42.5\n- 北海共消费 897.14，6 月 28 至今共消费 29772.56 元\n\n## 哈尔滨\n\n- 11 月 22 日\n  - 吉野家 20\n  - 哈尔滨公交 2\n  - 肯德基冰淇淋 15\n  - 牛奶 12.8\n  - 迪卡侬 109.39\n  - 充电宝 4\n  - 公交 2\n  - 吉野家 15\n  - 稻香青旅 29\n- 11 月 23 日\n  - 吉野家 15\n  - 俄餐 39.9\n  - 帽子 45\n  - 雪糕 9\n  - 稻香青旅 29\n- 11 月 24 日\n  - 24fit 19.9\n  - 汉堡 41\n  - 咖啡 56\n  - 公交 2\n  - 公交 1\n  - 喝酒 80\n  - 稻香青旅 29\n- 11 月 25 日\n  - 机场大巴 20\n  - 麦当劳 22\n  - 住店 60\n  - 牛奶 31.3\n  - 麻辣烫 16\n  - 烤奶 12\n  - 哈尔滨-漠河 50\n- 哈尔滨共消费 787.29，6 月 28 日至此共消费 30559.85\n\n## 漠河\n\n- 11 月 26 日\n  - 烤肉饭 12\n  - 牛奶 19.8\n  - 牛奶 17.9\n  - 奶茶 9\n  - 金谷酒店 60\n- 11 月 27-30 日\n  - 雪糕 7\n  - 莫斯科饮料 6.7\n  - 拼团 842.65\n  - 奶 23.8\n  - 漠河北岸青旅 30\n- 12 月 1 日\n  - 麻辣烫 19\n  - 漠河-哈尔滨 50\n  - 稻香青旅 29\n  - 出租 20\n  - 巴士 20\n  - 吉野家 15\n  - 外婆烧仙草 9\n  - 水 2.5\n- 漠河共消费 1193.35，6 月 28 日至此共消费 31753.2\n\n## 哈尔滨\n\n- 12 月 2 日\n  - 拌饭 29.8\n  - 公交 1\n  - 牛奶 19.97\n  - 暖宝宝 26.6\n  - 充电 2\n  - 健身 29.9\n  - 公交 2\n  - 汉堡王 38\n  - 公交 2\n  - 面包 21.4\n  - 稻香国际 29\n- 12 月 3 日\n  - 咖喱饭 20.5\n  - 名都滑雪场 59\n  - 稻香国际 29\n  - 公交 1\n  - 公交 1\n  - 库滋明 38.8\n  - 水果 13.8\n- 12 月 4 日\n  - 公交 1\n  - 午饭 20\n  - 哈尔滨-长春 39.69\n  - 关东商务酒店 89\n  - 地铁 2\n- 哈尔滨共消费 516.46，6 月 28 至此消费 32269.66\n\n## 长春-铁岭\n\n- 12 月 5 日\n  - 酱骨头 29\n  - 地铁 5\n  - 讲解 20\n  - 饮料 5\n  - 牛奶 11\n  - 炸蘑菇 10\n  - 地铁 5\n  - 冰淇淋 14\n  - 关东商务酒店 89\n- 12 月 6 日\n  - 长春-铁岭 37.5\n  - 虾堡 14.5\n  - 双拼饭 21\n  - 健身 19\n  - 公交 2\n  - 优家民宿 54\n- 12 月 7 日\n  - 羊汤 14\n  - 鸡排 12\n  - 公交 3\n  - 铁岭-沈阳 12.5\n  - lazybee 39\n  - 吉野家 20\n  - 牛奶 48.2\n- 长春到铁岭共消费 484.7，6 月 28 日至此共消费 32754.36。\n\n## 沈阳\n\n- 12 月 8 日\n  - lazybee 39\n  - 头盔 30\n  - 柜子 20\n  - 保险 5\n  - 冷面卷臭豆腐 14\n  - 牛奶 5.77\n  - 山药豆 5\n  - 鸡排 8\n  - 怪坡滑雪 84\n- 12 月 9 日\n  - 牛奶 10\n  - 吉野家 20\n  - 蜜雪冰城 9.9\n  - lazybee 39\n- 12 月 10 日\n  - lazybee 39\n  - 地铁 0.3\n  - 电车 1.9\n  - 汉堡王 27\n  - 电车 1.9\n  - 汉堡王 12\n  - 地铁 1\n  - 挑战者实弹射击 178\n  - 地铁 2\n  - 牛奶 7.79\n  - 李先生牛肉面 12\n  - 烤冷面卷豆腐 12\n- 12 月 11 日\n  - 永和 30.23\n  - 地铁 0.3\n  - 电车 2.85\n  - 麦旋风 14.5\n  - 南京地铁 8\n  - 麦当劳 12\n  - 沈阳-南京 50\n- 沈阳共花费 702.44，6 月 28 日至此共消费 33456.8\n\n## 南京\n\n- 13 日\n  - 地铁 3\n  - 地铁 2\n  - 地铁 2\n  - 讲解 15\n  - 自由落体青旅 44\n- 14 日\n  - 地铁 5\n  - 牛首山 98\n  - 公交 1\n  - 公交 1\n  - 讲解 20\n  - 充电宝 3\n  - 地铁 5\n  - 鸭血粉丝 38\n  - 自由落体青旅 44\n  - 奶茶 4.2\n- 15 日\n  - 肯德基 6\n  - 南京地铁 3\n  - 汉堡王 31\n  - 六朝 Crossfit 89.9\n  - 麦当劳 11.9\n  - 宫廷牛肉饼 10\n  - 对象家 54\n  - 烧仙草 6.9\n  - 烤冷面 10\n  - 水 3\n- 16 日\n  - 对象家 54\n  - 汉堡王 37\n  - 正新鸡排 15\n  - 一鸣鲜奶 14\n  - 牛奶 17\n- 南京共花费 647.9，6 月 28 至今已经花费 34104.7。\n\n## 镇江-扬州\n\n- 17 日\n  - 南京地铁 2\n  - 南京-镇江 29.5\n  - 汉堡王 35\n  - 麻辣烫 27.1\n  - 牛奶 30.66\n  - 镇江慕思酒店 58\n- 18 日\n  - 麦当劳 23.9\n  - 讲解 20\n  - 星巴克 6\n  - 镇江慕思酒店 58\n  - 邵顺兴面馆 10\n  - 酸奶 6\n  - 自行车 1.5\n- 19 日\n  - 烧饼 6.8\n  - 牛肉卤汁饭 19\n  - CoCo 都可 14\n  - 公交 3\n- 20 日\n  - 公交 2\n  - 炒饭 28\n  - 汤圆奶茶 15\n  - 汉堡王 25\n  - 牛奶 6.9\n  - 轻住四月印象 75.9\n- 21 日\n  - 麦当劳 25.14\n  - 机场巴士 30\n  - 扬州-大连 50\n  - 八宝粥 8\n  - 大连地铁 1\n  - 南蛮鸡肉饭 20.5\n  - 地铁 0.2\n- 22 日\n  - 大连地铁 0.2\n  - 吉野家 20\n  - 榛果拿铁 38\n- 扬州镇江两地共消费 696.3 元，至 6 月 28 日到 12 月 22 日共消费 34801 元，2020 年旅行结束。\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/08/10/HTTP2.md","slug":"2020/08/10/http2","body":"\n# HTTP/2 基础教程\n\n这是在昆明纹身的时候，实在无聊翻出来平板读的书做笔记。\n\n## http1 的问题\n\n队头阻塞\ntcp 利用低效\n消息头部臃肿\n优先级设置受限\n第三方资源\n\n## http2 对于 http1.1 的变化\n\n二进制协议\n首部压缩\n多路复用\n加密传输\n推送\n\n## http/2 的反模式\n\n因为 http2 对比 http1 的改动很多，导致有一些针对 http1 的优化，比如分散多个域名分发资源在 http2 中不会被视为优化，同时雪碧图也不再有优化作用。\n\n## 未来的 http\n\nquic，tcp 导向 udp\n","collection":"blog","data":{"type":"post","category":"book"}},{"id":"2020/08/11/Kunming's-flowing-account.md","slug":"2020/08/11/kunmings-flowing-account","body":"\n# 昆明的流水账\n\n在昆明短暂地住了几天，\n\n- 第一天，在昆明南站附近吃了菌菇火锅，\n- 第二天，去星巴克确认接下来的行程，晚上吃了傣族手抓饭，很好吃，强烈安利\n- 第三天，搬到翠湖边，睡了一天（南站的住宿真是不行）\n- 第四天，去纹身，把我后背的疤覆盖掉，一动不动趴了一天\n- 第五天，早晨去光猪圈健身，中午去了昆明博物馆（有一个飞虎队纪念馆），特意去了云南铁路博物馆，可惜暂时闭馆了。晚上前往 1903 公园，是建在滇池边上的新地标，或许对昆明人很新奇吧，但是北上广深这种地方真是遍地都是 👀。晚上又吃了傣味，实话说，还是手抓饭好吃。\n\n总的来说，昆明气候有点冷，大夏天才 20 度。物价比较高，处处对标一线城市的设施自然换来一线城市的物价。好了，接下来就去普者黑了\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/08/12/The-complicated-universal-travel-trip.md","slug":"2020/08/12/the-complicated-universal-travel-trip","body":"\n# 心情复杂的普者黑之行\n\n普者黑在昆明东面，因为紧挨着广西和贵州，地形上是喀斯特地貌，因为「三生三世十里桃花」而出名，虽然我没看过这个电视剧，考虑到之前桂林和腾冲的体验就很美好，二者合并一下一定不错，何况动车也才75元，干嘛不去，哈哈。\n\n普者黑动车站出站后可以乘坐7路公交（5元）前往普者黑村。安利一个张三青年旅社，他们家的平台很完美，晚上坐过去吹吹风很舒服。普者黑目前做生意的，很像是大理早期，比如我去喝茶的地方，老板闲着没事儿干还弹了会儿琵琶。\n\n从青旅出来走村子的主干路，也是条泥路，会找到一个叫做情人桥的地方，桥后有一座比较矮的小山，爬上去就可以俯瞰整个普者黑村。很多人也会在这里拍日出和日落，但是显然对于多雨的普者黑，机会很少。\n\n怎么说旅程复杂呢，之前芷江的受降纪念馆放共产党接待受降就已经很震惊了（显然1945年，接待受降的是国民党，而且五星红旗还没设计出来呢，更不可能受降的时候挂五星红旗），在普者黑相继遇到的游人，很多是有一点财富积累因为疫情出不去的老人，总爱讨论政治，什么「香港很多人有英国护照，先赶他们走，让他们成为侨民，等他们想家了，自然会回来投资」，「文革开创了中国的民主，只不过太过分变成民粹了」...我真是大开眼界，这些手握北上广深多套房产的既得利益者思维真是可怕。","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/08/15/The-finale-of-SHIES-Agent,-Grandpa-Qinghui.md","slug":"2020/08/15/the-finale-of-shies-agent-grandpa-qinghui","body":"\n# 神盾局特工大结局，爷青回\n\n无需多言，神盾局最后解散了，真的从大学开始追到工作完结的剧。\n","collection":"blog","data":{"type":"post","category":"tv"}},{"id":"2020/08/18/Yuxi-is-more-Yunnan-than-Kunming.md","slug":"2020/08/18/yuxi-is-more-yunnan-than-kunming","body":"\n# 玉溪比昆明更加云南\n\n12 日到 18 日这几天我都在玉溪游玩，不管是物价还是风景，个人感觉，玉溪都是要比昆明更加像云南的城市。\n\n## 交通\n\n- 高铁\n- 公交\n- 共享电动车\n- 共享汽车\n\n玉溪紧挨着昆明的南边，从昆明南站只要 29 元。玉溪站位于市中心，去红塔区（市中心）或者江川区（抚仙湖南边）都有公交车可以坐，如果只是在红塔区逛逛，可以办一个共享电动车的卡，无论哈罗还是青桔都有投放。前往江川区可以乘坐 50 路公交，不过也可以扫一个共享汽车，比如这次旅行我就仅仅花了 10 块钱环抚仙湖跑了一圈。\n\n## 景区\n\n- 聂耳音乐广场\n- 聂耳公园\n- 玉溪市博物馆\n- 抚仙湖景区\n  - 抚仙湖孤山景区（江川区）\n  - 抚仙湖明星景区（江城县）\n  - 抚仙湖禄充风景区（澄江县）\n  - 月亮湾湿地公园（澄江县）\n  - 澄江化石博物馆\n\n## 旅行笔记\n\n### 13 日 玉溪博物馆\n\n我住在聂耳音乐广场附近，一方面住宿真的好便宜，仅仅 42 元一晚，距离在网上找到的健身房（1991 健身）仅仅 1 公里，离全市唯一的沃尔玛也就 3 公里。\n\n聂耳广场被设计成小提琴的形状，广场边缘的人工湖湖水清澈，当地人说是用来为抚仙湖蓄水，防止清澈的抚仙湖水被旁边星云湖倒灌而准备的。\n\n其实古滇国在抚仙湖附近，所以玉溪博物馆会提到很多滇国的考古内容，只可惜大部分青铜器都放在云南博物馆内，另外玉溪博物馆还藏有很多化石材料，只是展厅布置太恐怖（太多摇头晃脑的假恐龙）再加上只有我一个人，没敢进去看。\n\n玉溪博物馆外边就是聂耳公园，个人看来就是个大妈跳广场舞的地方，逛了一下走了。\n\nBTW，在昆明喝到的玛卡酒只能在昆明买到，哭。\n\n### 14 日 红塔山工厂\n\n红塔山工厂就在红塔区，只不过找起来不太容易，因为在地图上面搜一下到处都是烟店...红塔山工厂中间有一个市民公园，很有深圳南山的荔香公园的感觉，公园有一个红塔，元朝时期本来是白塔，建国后刷的红油漆。骑车就可以进入卷烟厂，烟厂是开放的，不去厂房不需要登记，公园内能够闻到很浓的烟味，爱烟的人或许能喜欢。\n\n### 15 日 明星鱼洞\n\n从红塔区乘坐 50 路（5 元）到达江川客运站可以转乘江川到江城的客运（3 元），到达江城客运站，再乘坐江城到明星的客运（3 元，且只接受现金），一路颠簸就到达明星村。明星村是个鸟不拉屎的地方，如果指望在明星村吃饭你可以放弃了，除了蹭村民的厨房，根本没有饭店。\n\n明星鱼洞在明星村北方 1 公里处，这里因为地形有很多连通湖水的山洞，当地渔民会在山洞中捕鱼。明星鱼洞还是个潜点，可以在这里潜水，不过考证的话，看起来还是挺贵的...所以宝宝没去。\n\n### 16 日 澄江县城\n\n逛完明星鱼洞玉溪开始下暴雨，据说因为暴雨昆明好多航班都被取消了，也导致我没能继续逛抚仙湖。从明星鱼洞到澄江客运站可以乘坐抚仙湖的环湖公交，只是这公交一小时一班，我在湖边逛了两圈也不过是看见过一辆。好在路上有很多经过的其它客车，招招手还是能接下人的，都是 10 块钱。\n\n澄江县城对比明星村起码能吃顿饭，吃好可以去客运站乘坐环湖西线公交或者澄江到海口公交，一定要和司机说好在哪里下，否则司机不会给你停，深受其害...\n\n澄江有一个古化石博物馆，今年八月刚刚开放，只不过位置距离月亮湾还有 2 公里山路，除了开车去只能走路，导致我千辛万苦到达，人家刚好下班，只能在门口买个 7 块钱的冰淇淋和大门合个影。\n\n### 17 日 回到玉溪市区\n\n第二天澄江大雨，好在旅店楼下就有摩范汽车的停车点，艰难的人脸识别注册流程之后就可以开车上路，环湖基本上除了雨也没啥风景了，新用户每小时 3 块钱，加上保险，到达聂耳音乐广场总共就花了 10 块钱，不过这软件依然有问题，点了还车，虽然锁车了，但依然在计费，问题是我还在车上啊？？？最后联系客服才解决...\n\n## 总结\n\n不论如何玉溪都是个比昆明更像云南城市的地方，昆明明显在对标一线城市，所以在昆明的感觉基本和北上广没区别，而玉溪则更慵懒一些，饭店基本上不到饭点就吃不了饭，物价也很便宜更别提 1991 那个巨大的厂房改造的健身房了。\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/08/21/Live-in-Mengzi-temporarily.md","slug":"2020/08/21/live-in-mengzi-temporarily","body":"\n# 暂住在蒙自\n\n本来打算直接从建水出发前往景洪，无意间发现蒙自还有一个红河博物馆。本着好奇，反正建水去蒙自也就 15 块就启程了。\n\n## 滇越驿站\n\n在火车站乘坐 31 路到州政府，就能找到驿站，客栈很有特色，房间都是设计成火车车厢，过道还展览着过去的车票和粮票，活脱脱一个小博物馆。\n\n驿站楼下是自己的食堂，点一份米线，汤肉和米线是分开打的，不得不说蒙自的米线更好吃一些。但我还是喜欢玉溪的凉米线。\n\n![旅店内部](./2020-08-21-1.jpg)\n\n![粮票](./2020-08-21-4.jpg)\n\n![车票](./2020-08-21-5.jpg)\n\n## 红河州博物馆\n\n和云南的博物馆类似，先大讲特讲化石古生物，然后简单的几个青铜器，再就是法国的小火车，但是基本上只是简单的物品陈述。二楼是少数民族介绍，少数民族部分主要是一直沿用到 1950 年代的土司制度和少数民族服饰。其它的就比较少，比如各种少数民族的语言就没怎么提。\n\n![青铜器](./2020-08-21-2.jpg)\n\n## 蒙自海关档案馆\n\n法国占有越南之后和清政府要到邮政权，在蒙自建立海关，蒙自曾经繁荣一时。在昆明铁路建成后，蒙自海关就名存实亡了。不过海关面向纳湖公园的部分还留了一部分楼可以开放查看文件。\n\n## 康唯国际健身\n\n喝了一杯「茶颜观色」就是茶颜的盗版，之后我买了 9.9 的健身体验，位置在中央大街附近，虽然没有玉溪的 1991 大，但是设备也很多，可以去练一下。\n\n![健身房](./2020-08-21-3.jpg)\n\n## 总结\n\n蒙自的市区建设比较发达，随处可以见到直饮机。城市也很干净，物价也比较低。共享单车并不是大厂的牌子，自然不能免押金，而且有些需要预支付一定金额才能使用。从蒙自火车站出来可以乘坐公交前往市区，但是因为火车站的公交发车时间是按照火车行程安排的，所以一旦错过了一班公交就意味着这一班火车也错过了。\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/08/23/The-last-Jiangnan-in-southern-Yunnan,-build-water.md","slug":"2020/08/23/the-last-jiangnan-in-southern-yunnan-build-water","body":"\n# 滇南最后一个江南，建水\n\n从玉溪乘坐高铁仅需要 26 块钱就能到达建水，然后乘坐火车站的公交 2 元能够抵达建水古城。\n\n## 倾城湖畔青旅\n\n我在建水住了两段时间，中间去了一趟蒙自。最开始没有住在古城里面，而是在欢乐谷附近的一家青旅。倾城青旅貌似是云南这边的连锁，不论是建水还是昆明装修都很有特色，阳台外面就有一片湖（只是这湖水并不清澈），楼下可以逗店家养的龙猫。\n\n## 建水文博馆\n\n距离青旅大概 2 公里，有一个建水文博馆，进门要登记，馆藏有一些建水相关的木雕，陶器等。\n\n## 建水古城\n\n后面两天我住在建水古城附近，不得不感叹建水的物价真便宜，超市里面的水果拼盘 1 块一包，古城里面很多景区都是华侨城改建的仿古建筑，我是荷包羞涩了。\n\n## 建水从小火车\n\n建水古城东门外是临安站，建水小火车的特点是采用寸轨，远远窄于标准轨道，说是为了防止法国侵占，也有减少花销的目的。不过现在仅仅用来旅游了，100 一张硬座，还是挺贵的。\n\n## 总结\n\n建水绝对是滇南最后一个江南了，华侨城基本上把古城东门改造成了浙东的景区，晚上能吃到全国各地的小吃。\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/08/26/In-Xishuangbanna-in-Xishuangbanna,-you-must-always-bring-the-knowledge-of-Huajun.md","slug":"2020/08/26/in-xishuangbanna-in-xishuangbanna-you-must-always-bring-the-knowledge-of-huajun","body":"\n# 在西双版纳必须随时带着识花君\n\n目前前往西双版纳，要么是飞过去，要么是客车过去。考虑到我已经到达建水，不想走回头路就坐了 8 小时 230 块的客运到达西双版纳。从建水去西双版纳的客车只有两班，中午一点和下午四点，建水客运站就在古城东门一公里处，走着就能到，上车地点在客运站门口，如果你在候车厅傻傻地等很有可能错过了。\n\n话说西双版纳到普洱基本上都是原始森林，所以如果是晴天到晚上就是一片璀璨的星空。刚到西双版纳本来以为是扑面而来的异域特色，但幻想马上被门口的广场舞大妈和接人的摩的师傅破坏，基本上和大部分大陆城市差不多嘛。\n\n## 曼听花园\n\n曼听花园是古代傣王行宫，门票 20 元，景区内种植各种热带植物，必须随身携带识花君一个一个扫着看。曼听花园还有各种傣族表演、鹦鹉表演和大象表演（很有 90 年代动物园的感觉）。\n\n## 大佛寺\n\n曼听花园外面的大佛寺，明显建筑上是更加恢宏，竟然是免费的！看介绍是原有的南传寺庙，文革期间完全损毁在 1989 年重修至今。\n\n## 景洪大佛寺\n\n澜沧江对岸新建了一个景洪大佛寺，大佛寺下面是一个巨大的沿江夜市，可以吃到老挝、泰国、越南、缅甸的小吃。\n\n## 总结\n\n景洪的物价不低但是住宿很便宜，至于景区基本上都是原始森林，所以基本上几个花园也看不出来什么区别。普通人还是来吃吃吃，比如菠萝饭芒果饭什么的还是很好吃的。\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/08/30/You-have-to-do-a-strategy-to-go-to-Wudang-Mountain.md","slug":"2020/08/30/you-have-to-do-a-strategy-to-go-to-wudang-mountain","body":"\n# 去武当山还是得做攻略\n\n从上海出发到武当山大概两小时就到，武当山机场在山顶上，因此到达时都感觉不到飞机降落。武当山机场是新机场，可以坐机场小巴去武当山脚下。\n\n武当山下有一个武当山村，可以吃饭，但是因为才开始做旅游，如果跟机场提武当山村怎样怎样基本上都不清楚，淦。武当山村有松果电动车可以骑到距离武当山 1 公里左右，然后自行走到门口。\n\n武当山源于汉朝五斗米教，真武大帝真修的地方。目前的建筑基本上是明朝，朱棣为了证明自己是真龙天子，自称真武大帝转世，照着北京故宫的修治重修武当山而成。所以基本上明朝北京故宫有的，武当山也有一套。\n\n游览武当山必须要一天半，所以有一天要在山上住，这一点很重要，因为我是在山脚下住的，导致根本没爬完就急忙返回了。本来以为湖北景区门票全免是个很爽的事儿，然而进门就要交 105 的巴士费，巴士可以到太子坡和琼台，到太子坡将近一小时，从太子坡可以爬到山顶，或者可以从太子坡到琼台坐 170 块的索道（车路也是一个小时...），如果爬山爬嗨了错过巴士就只能住山上，住宿要将近 400 一晚。因此导致我根本没时间看紫霄宫和金顶就草草回去了。\n\n在武当山村里面有两个博物馆，武当博物馆和武当山地质博物馆，武当博物馆很值得一去，甚至比去武当山更值得去。博物馆分为三部分，建筑介绍、道教简介以及武当山塑像。游览之后大致了解明朝道教的兴盛，以及明朝之后的打压。或许没有清朝的灭道运动，或许今天的道教会有今天佛教的感觉。\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/09/01/How-to-play-Wanning.md","slug":"2020/09/01/how-to-play-wanning","body":"\n# 万宁怎么玩\n\n3 号晚上要去分界洲学习潜水，所以正好空出 1 天可以在万宁冲一个浪。从海口到万宁高铁 56 元即达，再坐旅游二号线即可到达神州半岛。旅游二号线貌似是新的线路网上还没有信息，乘车和三亚很像上下车都要扫码，分段计算。\n\n神州半岛的海滩是给保利的小区私有的，但是可以趁保安不注意溜进去。可惜今天是中元节，去海边玩太显眼，我们只能晚上去灯塔看看。\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/09/04/Boundaries.md","slug":"2020/09/04/boundaries","body":"\n# 分界洲打卡\n\n从神州半岛乘坐动车 13 元即可到达陵水站，在陵水站旁边停车场可以看到前往分界洲的免费巴士。大概一个小时就能到达分界洲上岛码头乘船上岛了。\n\n此行目的是在分界洲学习水肺潜水，后面会有一篇单独讲潜水的事儿，这篇只讲分界洲玩的感觉。\n\n分界洲号称是平分了海南岛，但我看地图感觉还是偏下了一些。岛上主要是垂钓游泳和爬山，个人感觉沙滩比蜈支洲的要浅，沙子也要粗一些，所以只是游泳，还是蜈支洲好一些（当然，蜈支洲也有点浅）。\n\n从码头沿着小吃街走就能到达网红拍照区域，基本上跟国内大部分景点大同小异了。岛上吃的每家价格不同，想省钱就得多问下。问了下住宿，有 98 元一天的床铺，也有 440 一天的酒店。\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/09/06/OW.md","slug":"2020/09/06/ow","body":"\n# 终于考下来 OW 潜水证书\n\n前面说，我这一程是为了学习水肺潜水。路过抚仙湖的时候就想要潜水，可是抚仙湖潜水太贵了，对比现在能去的 PADI 潜点，分界洲算是比较好的，因为很多国外的教练现在都滞留在国内，而且这是唯一包食宿的潜点（据我调查），三亚又有很多珊瑚礁可以看，干嘛不去呢。\n\nOW 潜水分为理论和实践两部分（废话），理论基本上按照 PADI 的教材来。潜水有两天，第一天大概 3m 左右，水下能看到佛像，还能在水下喂鱼。第一天的学习主要是如何解决二级头以及面镜掉落的问题；第二天潜水就能到 17m（OW 最多是 18m ），水下有沉船，还能看见个五菱宏光。第二天的内容就复杂些，包括中性悬浮和如何使用 CESA 在无潜伴和空气的情况下升到水面。\n\n两天潜水结束，真是筋疲力竭，最后一潜我几乎是像海豹一样上了船。下午考完试，我就成为了一名初级潜水员。\n\n那么我还升级到高级吗？额，可能短时间不会了，反正 6 个月内再潜水一次就不需要复习，so，有 6 个月考虑时间呢。\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/09/07/Great-East-Sea-Surfing-Experience.md","slug":"2020/09/07/great-east-sea-surfing-experience","body":"\n# 大东海冲浪体验\n\n在分界洲学完潜水，正好浪情完美，就急忙赶到大东海冲浪。相比于海棠湾，大东海冲浪要贵很多，100 元每 2 小时，150 元每天。\n\n另外大东海的水要比海棠湾深，基本上踩到水里面半身就进去了，难怪时常听说有人在大东海冲浪淹死的，个人感觉大东海冲浪必须得会游泳了。\n\n饮食上面，大东海周边的选择要比海棠湾多很多，不远就是夏日百货。里面有一家赛百味（竟然是哈尔滨的...）。另外安利三亚的郑阿婆清补凉，定价在三亚里面算良心了。\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/09/08/Rotating-on-the-train,-crossing-the-Qiongzhou-Strait.md","slug":"2020/09/08/rotating-on-the-train-crossing-the-qiongzhou-strait","body":"\n# 火车上轮渡，横穿琼州海峡\n\n从三亚到达湛江的直达专列一天有三班，首先一路到达海口港，我短暂的逛了一下海口港，基本上啥也没有，所以打算在海口港或者海口站周边逛逛的人还是谨慎一点，真的啥也没有...\n\n火车在海口站会停留一个小时左右，紧接着火车会分成几段分别被车头推入轮船里面，可惜不是动力车头，导致车厢没有空调，小百号人挤在海南的夏日里共同忍受着车厢内的高温（以及我旁边座位的高嗓门大爷...）。大概幽闭乐一个小时，重见阳光，就看到湛江港了，没错这就是横穿琼州海峡的感觉，所以有向往的文青还是算了吧 😂。\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/09/09/In-Zhanjiang,-oysters-are-unmanned.md","slug":"2020/09/09/in-zhanjiang-oysters-are-unmanned","body":"\n# 在湛江简直蚝无人性\n\n早就听说湛江生蚝便宜的一绝，反正三亚回上海的机票抢不到，就转道走湛江北上好了。\n\n湛江老城区在赤坎区，这里是「隐秘的角落」的主要拍摄地，强烈推荐这里有一家叫做「土蚝」的高压锅生蚝，53 块钱生蚝吃到爽！\n\n另外赤坎区还有湛江博物馆，很苏联时代的建筑，老实说，能在广东这个地方看见这种建筑我还是很意外的。\n\n湛江机场位于霞山区，是以前的法殖民地，有一些殖民时期遗留建筑，另外海滨广场也在这个区。因为机场也不远，住在霞山区前往机场打车也就二十以内。\n\nBTW，我拿我的吃生蚝的照片给同学看，居然有人说 53 块钱吃贝壳真奢侈...这帮内陆人，不长见识...\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/09/14/Yinchuan-has-no-McDonald's.md","slug":"2020/09/14/yinchuan-has-no-mcdonalds","body":"\n# 银川没有麦当劳\n\n为什么要去银川呢？这个问题问得好，确实没有什么特别的意义，或许仅仅是为了弥补一下宁夏还没有玩过的缺点，再或者了解一下西夏文字那个方块字的奇葩，再或许仅仅是羊肉。\n\n从湛江去银川的航线，中间要经停潮汕和合肥，在银川的上空观察地面就是一片荒芜的沙漠，经过黄河之后飞机会降落到一片绿色之中，这就是银川。\n\n想象中的银川或许和西宁很像，在西夏团灭之后，忽必烈特别指定这一片土地给回民建成塞上江南，所以觉得应该到处清真寺，这个城市应该时被圆形的白色圆顶包围，并装饰绿色新月图案。然而到达宁夏，别说新月图案了，就算特意去一趟清真寺，也是汉化很多的样子。不过，回民小吃是不变的，烤羊腿、牛肉饼、滩羊，让我这个在广东呆了快两年的人赞不绝口。\n\n## 宁夏省博物馆\n\n宁夏博物馆在人民广场附近，基本上和西北博物馆一样的方形建筑，搭配上西夏的装饰。宁夏省博基本也是罗列历史了，比较有意思的是西夏的佛头，眼睛使用黑釉上色之后和佛身一起烧制，黑釉烧制时会融化，使得佛像会有两道黑色的泪痕。\n\n## 银川当代美术馆\n\n银川当代美术馆在很遥远的郊区，目前有两个展览，中国早期油画展以及地图发展史，很值得一看。\n\n中国早期油画包括两部分，一部分是传教士为了讨好皇室而绘制的画像，另一部分是广东一带海上丝绸之路为销往西方而绘制的中国风油画。\n\n地图发展则是从 17 世纪早期传教士的地图开始，到现代航海测绘的地图结束，展示了多种不同地图，有的地图甚至像是一种全景图而不是目前常见的俯瞰效果。这个展览更有意思的是中国地图，从早期只有沿海一带的长条形逐渐变成现在我国版图的形状竟然过了几百年的时间。\n\n## 宁夏地质博物馆\n\n地质博物馆也在人民广场附近，因为宁夏是我国的稀土产区之一，内部包括我国稀土介绍、宁夏地形介绍、宁夏古生物以及主要矿产介绍。宁夏地形部分可以一看，起码了解到贺兰山中「贺兰」为蒙古语骏马的意思，指贺兰山形像骏马奔腾。\n\n## 总结\n\n感觉银川还是一个没有很大特色的城市（也许是西夏对我的吸引不大），连麦当劳都没有，这还真奇怪，肯德基遍地竟然没有麦当劳。西夏啤酒尝起来也没什么特色，但临走之前在健身房下面的超市试吃了几口哈密瓜，我去，真甜！\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/09/16/Watch-the-exhibition-in-Hohhot-for-two-days.md","slug":"2020/09/16/watch-the-exhibition-in-hohhot-for-two-days","body":"\n# 在呼和浩特两天都在看展\n\n> 今天一早六点就赶往正定机场差点把笔记本落在候机厅上，好在春秋的空姐帮我找回了，大赞！\n\n下了飞机马上赶往内蒙古博物院，呼和浩特作为内蒙的省会，省会标配地铁，可以直接坐地铁从机场到达博物院。\n\n那么在呼和浩特能看什么馆呢？两个必看，一个是内蒙古博物院，另一个就是内蒙古自然博物馆。博物院基本上就是把汉民族从周开始到清朝初期的所有敌人都详细介绍了一番，而自然博物馆最值得看的就是恐龙了，基本上中国发现的恐龙都在内蒙这儿呢。\n\n## 内蒙古博物院这几个展览就是汉族世仇展啊\n\n内蒙古博物院如果想仔细逛一下基本上要安排一天的时间，一进门先去顶层的远古蒙古，现在回想起来基本上也就记下来一个红山文化。其实这里比较有趣的是夏家店文化，夏家店文化是我国最早使用青铜器的文华，这个夏家店文化分为下层和上层，这两个文化并不属于同一文化分支，可以想象或许就是这一文化借助强大的青铜器技术打倒夏朝并建立商朝（当然这都是我猜的，毕竟商朝号称是从我国东北部打下来的）。\n\n接下来就是周朝，北方主要敌人是胡，后来胡人被匈奴击退到东面成为东胡，再后来又被单于击散，变成乌桓和鲜卑（没事儿，他们还会回来的）。\n\n接下来是匈奴，最主要的是匈奴金冠和王昭君嫁单于的单于和亲瓦当，顺便提一句，原来匈奴并不是一个王，相当于多个部落，当年王昭君嫁单于相当于大汉和北方匈奴一个部落和亲共同抵御更北方更强大的匈奴。当然匈奴没开心一阵子就被汉武帝这个富二代打到西方卖烤肉去了。\n\n后来三国时期曹魏灭了乌桓，让鲜卑异常发达，并参与了五胡乱华，最强大的拓跋鲜卑建立了北魏，当时拓跋鲜卑的敌人是柔然，也就发生了花木兰传说的故事。\n\n可惜没提突厥灭柔然的故事，直接讲唐朝的草原丝绸之路了。然后契丹崛起（嗯，也是鲜卑的后代），建立辽朝，这部分博物馆讲的相当详细，特别开了个展厅介绍，甚至确定一部分契丹后人在云南，另一部分被蒙元挤到中东并建立了短暂的王国。\n\n再后来女真族建立的金朝（毕竟不是本家的民族展馆只介绍它怎么亡的）被蒙古击败，BTW，蒙古也是鲜卑从呼伦贝尔发展过来的，这么来看北面的是少数民族其实都是自己家人打架。\n\n再就是天骄馆，非常详细地介绍了蒙元地发展，但大部分文物都是蒙文，只听见一群蒙古族人看见一个石碑并小声嘟囔「成吉思汗」，估计和在故宫看见康熙提笔差不多吧。\n\n蒙古族后来就是和女真联合建立清朝，清朝投其所好在蒙古搭建藏传佛教黄教寺庙，实际是为了让大量蒙古男性从事喇嘛教而达到降低蒙古族实力的目的（这操作骚啊）。\n\n## 一定要去内蒙古自然博物馆\n\n无缘去澄江自然博物馆看寒武纪生物但这次在内蒙古自然博物馆遇到了二叠纪和三叠纪。\n\n关于恐龙我基本上聊不了多少，内蒙古自然博物馆有两栋楼，一栋介绍内蒙古自然风光和产物，另一栋各种详细介绍恐龙，总之不虚此次行。\n\n## 冰煮羊\n\n强烈推荐呼和浩特的冰煮羊，尽最大可能地保证羊肉鲜嫩，这真算内蒙的美味了。\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/09/18/Ordos-is-the-way-to-open-Inner-Mongolia.md","slug":"2020/09/18/ordos-is-the-way-to-open-inner-mongolia","body":"\n# 鄂尔多斯是打开内蒙古的方式\n\n老实说，呼和浩特给我的感觉并不像内蒙古，毕竟也是个大城市，然而到了鄂尔多斯的东胜西站，下火车的一瞬间就看到碧蓝的天空，几朵貌似触手可及的白云给我的感觉只有「心旷神怡」。\n\n跟本地人聊，对鄂尔多斯大举投资旅游三缄其口，比如特意把鄂尔多斯的主要行政区划都从东胜搬到新区，个人感觉，起码绿化上甩了附近几个城市几条街，从火车站到东胜区中心一路鲜花绿树，让人惊讶这是快要入冬的内蒙。\n\n这次在东胜，主要是来骑马的。在美团上查到这里有一家豪士骑马俱乐部可以去草原野骑，预约好行程，第二天打车到达马场。\n\n这次算是真的骑马，没有人给我拉着缰绳。感觉骑马就是自己和马较劲，刚开始给我一匹厉害的马，以我的魄力根本招架不住，只有它主人的鞭子才能让它动一下。\n\n后来换了匹蒙古马，虽然矮小，但是真的很能跑，松了缰绳就开始狂奔，颠得我猝不及防。但是双脚猛地往前蹬，拽紧缰绳就不怕被甩下来。\n\n东胜还有一个鄂尔多斯青铜馆，乘坐高铁也可以去鄂尔多斯博物馆看看，我的行程时间有限，这两个地方就没去。\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/09/20/Passing-by-Baotou-Museum.md","slug":"2020/09/20/passing-by-baotou-museum","body":"\n# 路过包头博物馆\n\n从鄂尔多斯到包头，就好像又从草原回到城市。包头是一个到处是广场的城市，传说成吉思汗在这里挖出来一棵树根，大呼「鹿角」，蒙语音译过来便是包头，而这个城市也因此成为鹿城。\n\n包头博物馆的基本上算是内蒙古博物馆的缩小版，目前有一个关于印章的特展比较有意思，主要是景教的印章，景教是唐朝基督教的一个分支，马可波罗游记也有提及，可惜后来在国内失传。景教的印章实际是一个十字架纽扣，可以取下来当作印章。\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/09/23/Directly-pounding-Huanglong.md","slug":"2020/09/23/directly-pounding-huanglong","body":"# 直捣黄龙\n\n从虹桥机场出发前往成都，这是我2020年第一次行程的最后一站，这一程比较轻松，基本是跟团游九寨沟，顺便把阿坝周边都逛下来。\n\n过了汶川大概几小时山路就能到达黄龙景区，刚到的时候天气晴朗，远方的山颇有一点优山美地的感觉。景区对高反很强调，基本上比我去拉萨要严格，但个人感觉还可以，起码上山2小时，下山1小时时间刚刚好。\n\n山上都是栈道，和长白山类似，爬起来轻松地多，风景也和长白山类似，只是只有冷泉没有温泉，山上流水清澈见底，大晴天能拍好多照片。","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/09/24/Jiuzhaigou-watched-water-to-see-Blu-ray-fatigue.md","slug":"2020/09/24/jiuzhaigou-watched-water-to-see-blu-ray-fatigue","body":"\n# 九寨沟看水看到蓝光疲劳\n\n一直想要去九寨沟看看，看一看所谓天下第一的水，然而它比较远，距离成都有将近 200 公里的山路，而且 17 年地震之后去年才恢复开放。\n\n早上七点从川主寺出发，大概中午到达九寨沟的临时入口，临时入口在正在修建的游客大厅旁边，没错游客大厅被毁到现在依然没有恢复，其实在景区里依然能看见很多泥石流未修复的山坡。\n\n九寨沟的水，主要来自于冰川流水，在九寨沟山顶有一处湖泊，长海，通过山中的暗流流到九寨沟 144 处。九寨沟的水及其蓝，所有过来的游客都说他们今生都没见过这么蓝的水（他们好没见识啊）。个人感觉其实和三亚的水差不多，基本上如果水中含盐量比较高，并且存在大量藻类，水会因此吸收阳光中大量长波，使得只有短波会被反射出来。不过九寨沟的水尝起来并没那么咸，因为存在的是钙化盐，算是天然碳酸水吧。\n\n因为水中的金属成分多，所以 80 年代在九寨沟被砍伐落入水中的树木都已经钙化看起来好像不腐一样。\n\n九寨沟景区最后一个景点是一个苯教寺庙，当然我也不是很清楚啦，只知道藏传佛教是汉传佛教和苯教的结合，在这个寺庙里面能看到一些类似南传佛教的建筑和雕塑，但是身材上又不是那么苗条，也算是可以猎奇的一个寺庙了。\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/09/27/nb.md","slug":"2020/09/27/nb","body":"# 在三星堆蹭到了NB的讲解\n\n继上次我到成都玩，我就一直想去三星堆看一看，只是相比于同样是古蜀国的金沙遗址，三星堆并不在成都市区里面。但是从成都搭城际只要17块钱就能到达广汉，在广汉火车站乘坐13路公交到终点站三星堆博物馆即可到达。\n\n在景区内支付10元可以在微信上面听讲解，当然，我也蹭了当地小团的讲解，所以我听了两次😂。\n\n三星堆是民国时期农民意外发现大量玉器而引发的古蜀国遗址开发，在建国后又意外发现两处古祭司器的土堆，包括大量象牙青铜器以及玉器。经过碳14检测竟然有6千到8千多年的历史，当然博物馆保守估计，按照青铜器的样式猜测大概是距今3千年左右的商朝。\n\n另外，在玉器的讲解上面，两次内容也发生分歧，比如被发现的大量玉璧，讲解员猜测应该是某种器械装置，因为当时唯一可用的金属就是软软的青铜，如果做轴承，像这种硬度到8的玉石就能派上用场，或许是这种装置的重要性，后来发展成为了一种象征性的祭祀物品，甚至发展到铜钱，从祭祀品又变成货币。\n\n三星堆有大量青铜器，人眼凸起，被现在看作是一种人眼崇拜。但是具体是为什么依然还需要更多论证，三星堆自开采到这两个遗址之后被要求保护性开采，因为当初挖掘出来的象牙已经全部被氧化，去年重新开始的开采又在目前发现的两个遗址附近又发现了6个遗址坑，可能会有更多发现。\n\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/09/28/I-only-remember-one-towering-Yuelou-in-Mianyang.md","slug":"2020/09/28/i-only-remember-one-towering-yuelou-in-mianyang","body":"\n# 在绵阳只记住了一座巍峨的越王楼\n\n因为要从绵阳飞回大连，所以我要在绵阳暂住两天，根据同事推荐，我去了趟绵阳的马家巷。\n\n马家巷是绵阳的小吃街，基本上和成都的差不多，只不过自打盲盒火了以后，在成都吃小吃也可以抽盲盒。不过基本上也都是辣的，看来还是在广汉吃的那一顿成都小吃最得我意。\n\n绵阳市博物馆位于城郊富乐山旁边，提到这个富乐山还是刘备给起的名字，据说刘备到了这个地方说此地人民安居乐业生活富乐。博物馆基本上就是民俗生活介绍、历史介绍、自然情况（正在维护），楼上有铜马馆和摇钱树馆，据说全国 19 座汉代摇钱树，绵阳就有五座。\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/09/30/Talk-about-fraud-during-travel.md","slug":"2020/09/30/talk-about-fraud-during-travel","body":"\n# 谈谈旅行中的骗术\n\n我个人是拒绝出门买纪念品的，因为大部分纪念品产自中国义乌，就算有很多产品真心喜欢也可以通过邮购寄送回家，也不需要自己背着。其实现在旅行能玩的骗术已经不多了，或者很高深，深到你心服口服，比如一杯咖啡卖你小 50 元的星爸爸。我从没想过那些我小学就已经明晰的骗术，现在还依然存在，尤其是在最近这次旅行中还能看见好多人奋不顾身地往坑里面跳，这大概就是我要写这篇文章的原因了吧。\n\n首先珍珠，碳酸钙，没错最常见的结石了，最简单的制作办法就是把一块异物放到珍珠蚌里面，为了防止自己被割伤，蚌会释放一种物质将异物包裹起来，时间久了就产生了珍珠。话说其实也可以把异物塞到你的关节里面也能产珍珠。\n\n然后是银器，我国就没有那么高的产银量，但是我国的产锡量很高，尤其是西南。看了景区那么多金闪闪的银器，我甚至怀疑他们卖的是铝。销售银器的人往往会拿银器滴墨水，马上墨水就被净化了，在场的人无不欢呼喝彩。冷静下来想想这和以前那些净水器骗局有什么区别？这么迅速的化学反应除了酸碱反应单单依靠水中的银离子能有那么高还原性？那是浓硫酸吗？\n\n再就是玉器，我很怀疑缅甸产的翡翠就叫硬玉，中国产的玉石都是软玉这种说法，毕竟中国那么大的地方，而且和缅甸挨得那么近，怎么就会发生这种类似生物隔离的事情？要看软玉这个名称的由来了，这个词来自于英法联军侵华，人们认为中国是弱的，所以把中国产的玉称之为软玉。当然玉的确有硬度的不同，但软的玉和软玉是两码事儿。其实古代的玉指的是石之美者也，和现代这些放到橱窗里拿钱计价的玉石定义是不同的，所以古人「以玉比德」的玉自然也和现代的不同，没必要拿它当什么道德底线的评价标杆。\n\n最坑人的就是那些清水洗不掉的化妆品小样，先给某个阿姨免费洗半张脸，用透明的洗面奶洗出来很多污渍，然后说这些物资正常清水洗不掉要拿他们专业的水来洗。这...我该怎么说，正常人体排泄出来的，就算是毒素吧，会有水洗不掉的？而且那脸都洗得像涂了一层海藻泥一样，这要是真这么多毒素，这人还活着算是奇迹了吧。\n\n其实和很多销售聊天了解到，其实他们也是蒙在鼓里，把这些骗人手段拿来当销售方式来做...我可以理解贫困山区想找一个出入，但显然骗人不算一个合理的方式吧？我最近喝了一杯沙棘汁，其实我一生喝沙棘的机会也不多，却分外喜欢，因为在众多商品里面，我知道，只有它是真的。\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/10/26/Draw-a-circle-in-the-north-of-Xinjiang.md","slug":"2020/10/26/draw-a-circle-in-the-north-of-xinjiang","body":"\n# 在新疆的北面画了一个圈\n\n## 石家庄经传到达严防死守的乌鲁木齐\n\n购买随心飞的目的之一就是前往新疆，但是运气不好赶上乌鲁木齐疫情爆发没能去，终于新疆在十一之前解封，我的新疆旅行计划也排上议程。大概 5 个小时从石家庄前往乌鲁木齐航班，座椅是不能自己选择的，这也使得我不能因为坐到飞机的左侧而看到天山，在飞机的右侧嘛...就是一望无际的戈壁。\n\n## 空空如也的大巴扎\n\n不要太小瞧乌鲁木齐，作为平均工资仅次于南京的城市，乌鲁木齐拥有自己的地铁和高架桥，刚到达乌鲁木齐就直接打破了我对大西北的普遍印象。然而因为这次疫情，显然乌鲁木齐的防疫要比以往更加严格，5 个小时的航班加上将近一个小时的地铁，出门的第一刻我就想摘下口罩，然而街上的人都戴着口罩，所以不久我又把口罩戴回去了。\n\n我住在乌鲁木齐停泊青旅，这是一家新疆的连锁青旅。也许是位置问题，青旅周边都是汉人为主，前往乌市的国际大巴扎还要几公里。大巴扎就是维吾尔语集市的意思，整个乌市的公交站都被围起来，进站台要先量体温，去大巴扎也一样，需要经过比较严格的安检才能进去。然而大巴扎内部可以算是空空如也，一者可能因为不是节假日，二者可以看出这次疫情对乌鲁木齐影响不轻。\n\n## 五彩湾特别好修图\n\n新疆博物馆在维护，去了一趟乌鲁木齐博物馆，只有社会主义建设新疆展馆还在开放。在吃了新疆地质博物馆闭门羹之后我才意识到北疆的室内活动几乎都停止了，包括我之后要去的吐鲁番博物馆和楼兰博物馆。\n\n回到青旅，正好看见有人在找人包车环北疆，算了，跟他们一起去吧。一早我们打包好行李，出发前往第一站，位于昌吉的五彩湾，五彩湾按照介绍，是一片丹霞地貌，夏季的时候有河流流过风景很美。我们可能去得不是时候，喝水也干涸了，石头也没有反射出五彩的光。只有一个空旷的采石场和一望无云的天空。\n\n## 可可托海遇到网红直播，富蕴的高科技厕所\n\n继续往北几百公里，穿过整个准噶尔盆地，终于到达富蕴县。搜索了附近的美食，找到一家哈萨克族的丸子汤，这家丸子汤搭配的油塔子十分推荐，尝起来就像油花卷。非常值得安利的是富蕴的公共厕所，这里的厕所基本上起到了游客中心的作用，里面包括 ATM 机等基础服务，就连取纸的机器都支持人脸识别。\n\n从富蕴县往北走就是可可托海，可可托海内部的风景可以和 Mac 的 El Caption 有一拼。可可托海内还有一个功勋矿坑，行程比较紧就没能去。在可可托海门口碰到两个四川的主播驾着拖车在门口直播，乘机蹭了他们几根烤肠。\n\n## 喀纳斯拍夜景，神仙湾的晨雾好仙呐\n\n又是一天的车程，经过北屯我们决定买一杯奶茶补充能量。\n夜晚到达布尔津，不巧赶上停电，附近的街区都提早歇业了，好在还是找到了一家狗鱼店吃上。\n第二天，经过五彩滩湿地，到达阿勒泰，北方的高山就是喀纳斯。\n喀纳斯内如童话一般，淡蓝的河水从雪山上蜿蜒流入丛林。\n山上天气真的很冷，手机电量在以可见的速度下坠。\n护着手机爬到山顶的观鱼台，期待夜拉开帷幕，这时整个银河流入喀纳斯湖。\n湖水映着银河，整个世界变得安静下来了。\n\n## 白哈巴，中国西北的第一个村落，还有禾木\n\n离开喀纳斯一路向西走到中国西北第一村白哈巴，村子因为白哈巴河而命名，这条河流经的中哈大峡谷就是我国和哈萨克斯坦的天然国境，在白哈巴看完夕阳我们就向东穿越喀纳斯赶往禾木，后来证实这是个明智的决定，因为一早喀纳斯因为下雪被封上了，禾木村也封了一小会儿。\n\n## 五彩的布尔津吃狗鱼\n\n告别喀纳斯一路向南前往布尔津，又吃了狗鱼，又买了一堆囊，又喝了奶茶\n\n## 魔鬼城看恐龙，赛里木湖美丽的夕阳\n\n为了去魔鬼城方便，我们选择就近住在乌尔禾区，整个区只有一条商业街，街对面是以恐龙为主题的公园。\n魔鬼城是地质风化自然形成的土丘群，看似古老文化遗址故称魔鬼城。\n离开魔鬼城一路向西南，到达赛里木湖，夕阳点缀下金灿灿的草原和蔚蓝的湖水真想睡一个懒觉（可惜风太大）。\n夜晚经过阿拉山口，和白哈巴村不同的是，作为通商口岸，对面的哈萨克斯坦有彩灯闪烁，而不是一片荒芜。\n\n## 伊犁是整个行程的高潮\n\n伊犁是整个行程中最友好的一段行程，路途遇到的每个人都在热情地欢迎游客到来。\n在伊宁的喀赞其村吃了两杯冰淇淋之后我们出发前往那拉提草原，\n途中路过「阿热勒托别」镇，倒过来读就是「别脱了热啊」。\n路上大多是哈萨克族人，刚放学的小学生会跑过来和游客喊英语，\n镇子里面的餐馆名字都很有趣，什么「十六块五面馆」「好新疆菜馆」。\n那拉提是一个位于山丘之上的草原，跑到草原上可以看到下面有雪山有丛林有戈壁也有溪流，\n然而秋天的那拉提已经很冷了，手机也不知不觉断了电，后面的丛林和风车的风景都没有拍下来，略微有点可惜\n\n## 巴音布鲁克被风吹出来的九曲十八弯，库尔勒的纹身干尸\n\n到达巴音布鲁克，本来以为冷日子在离开喀纳斯之后就结束了，结果这个位于天山山腰上的景区的寒冷着实也给我吓到了。\n中途听说喀什机场航班都被叫停，前往乌鲁木齐的公路也因为冬天封闭，不管怎样都要去一趟库尔勒。\n正好库尔勒的巴州博物馆还在开放，算是我在新疆逛到的第一个博物馆，\n巴州博物馆的楼兰展区十分值得推荐，不仅仅因为干尸，还看到了一个文化的灿烂和灭亡。\n晚饭后，喀什那边的疫情信息传来，大家决定放弃南疆的旅程离开新疆。\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/10/28/Tama's-spare-tire-Jiuquan-Jinta-Populus-Forest.md","slug":"2020/10/28/tamas-spare-tire-jiuquan-jinta-populus-forest","body":"\n# 塔里木的备胎：酒泉金塔胡杨林\n\n因为喀什疫情的关系，南疆不能去了，作为补偿我们打算去距离酒泉市不远的金塔县去看胡杨林。\n\n金塔县位于酒泉市到酒泉卫星发射基地的路上，发射基地所在地现在归属于内蒙古，距离酒泉市比较远，考虑到去一趟也就只能看一看火箭架子，我们就只去胡杨林好了。\n\n据介绍金塔县这是一片天然胡杨林，到了一看果然如此，完全没有什么美感（有点对不起这张 65 元的票钱），在胡杨林里面有一个绿皮火车做的客栈，因为到了冬天，也没有开放。附近有一个二层小亭子，能看见景区全貌。难怪选择酒泉做发射基地，极目远眺，是一片平原荒地，除了隐隐约约能够看到祁连山的轮廓真的是啥也没有。\n\n另外，酒泉博物馆比较值得去看看，这是一个中午午休长达两个小时，而且和图书馆公用同一建筑的博物馆。\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/10/30/The-Jiaguan-City-Planning-Museum,-which-is-open-for-me.md","slug":"2020/10/30/the-jiaguan-city-planning-museum-which-is-open-for-me","body":"\n# 专门为我开放的嘉峪关城市博物馆\n\n其实酒泉是一片很大的区域，包括了嘉峪关和敦煌，基本上占了甘肃大概一半的地方。\n\n从酒泉市中心到嘉峪关可以坐公交到达，嘉峪关的主要景点就是嘉峪关和旁边的悬臂长城，基本上都是在景区门口就能看完整个景区的景点，所以我就不去了。\n\n搜到我住的位置附近有一个嘉峪关城市博物馆，于是我特地选择一天去，大中午到达博物馆发现才开门，博物馆看门的大姐帮我把每个展厅一个一个打开灯，本来不打算写这篇文章了，不过为了大姐我也要写一下。\n\n博物馆基本上就是嘉峪关的老城新城比较，我比较感兴趣的是一台上世纪 60 年代的活字印刷机，想想上世纪 60 年代还在用铅字印刷，不禁感叹活字印刷术这一发明的伟大。\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/11/01/There-is-no-heating.md","slug":"2020/11/01/there-is-no-heating","body":"\n# 没有暖气的敦煌\n\n原计划从敦煌出发到兰州中转，这样还能在兰州享受一次免费住宿。然而失策在敦煌老城区还在改造，老城区里面还没有暖气...\n\n记得 2016 年去过一次敦煌，已经把鸣沙山和月牙泉逛了，不过这次敦煌之行并不是没有收获，比如上次没有吃到的正宗的驴肉黄面（上次因为封城只吃到了莫高窟门口的那家），这次吃了一次正宗的顺张驴肉黄面，呃，几乎是一样的口感，就是贵一点...\n\n另外，看到了一截敦煌的老城墙，在沙洲乐园里面。敦煌相比嘉峪关虽然没那么城市化，但是沙洲乐园里面的情景还是比嘉峪关更有人气。\n\n再一个就是 4 年前看到敦煌博物馆前言时就好奇它的中日英写的都不一样（不确定韩语的情况，因为看不懂），比如中文提到了张骞，当时以为是处于改动中，这么多年来看，就不是在改动...\n\n在敦煌必须喝的是杏皮茶，这次发现已经可以在敦煌喝甜胚子奶茶了，大赞。\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/11/11/Never-found-that-Shenyang-is-so-prosperous.md","slug":"2020/11/11/never-found-that-shenyang-is-so-prosperous","body":"\n# 从未发现沈阳有这么繁华\n\n发现随心飞从兰州出发能直达沈阳，直接买了票，一来能在沈阳休息一阵子，见一见朋友，二来可以看看完全重建好的辽博。\n\n下了飞机，一如既往的没有地铁，只能大巴到市内，到了市府广场，才发现短短 5 年沈阳发生了很大变化，高楼大厦也多出很多。据朋友说，中街过去半年都在装修，这次我看到中街颇有一点小春熙路的感觉。\n\n回到工大的老校区，现在已经是一片工地，只留下一个综合楼。没想到学校门口的六毛串吧还依然生意兴隆。\n\n在沈阳住了几天 lazyBee 青旅，这家青旅的体验异常的好，每天都有诸如英语角，看电影的活动。附近是沈阳的彩电塔夜市，能吃吃炸串鸡架什么的。安利一个烤冷面卷臭豆腐，很有趣的吃法。\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/11/18/20.md","slug":"2020/11/18/20","body":"\n# 在北海体验 20 度的冬天\n\n逛完新疆、甘肃和沈阳，我意识到我确实需要去一次南方体验一下温暖的感觉。正好从沈阳随心飞到哈尔滨可以从北海中转，而且起降的时间刚刚好，既不是清晨也不是半夜，于是我就买了机票。\n\n从沈阳到北海大概有 4 小时飞行时间，飞机上基本上都是东北的大爷大妈，仿佛进入了东北过冬团的现场。\n\n刚抵达北海，正好是阴天，看天气预报表示南面的三亚正在刮台风，可能会有点影响。问了青旅的老板表示刚刚下雨，果然过了几天白天的温度马上回升到 28 度左右了。\n\n北海的几个景点分别在北海的三个位置上，好在这个城市也不大，买几张单车券基本上半小时都可以抵达这个城市的任何地方。\n\n## 北海老街\n\n北海老街位于北海的北面，是一个沿着巷子口看就能看到海岸的南方骑楼群。作为一个北方海边出生的人，还是比较羡慕南方这种紧沿着海岸线的建筑群的。只不过这个海水真心不敢恭维，北海的旅游还在起步阶段，所以海岸的污水被各种灌入大海中，海水看起来很脏。\n\n老街主要卖的小吃是墨鱼丸子和虾饼，因为都是油炸食品很快就会腻，逛了半天也没看见比较解腻的食品...鉴于比较便宜，还是推荐的。\n\n## 北海银滩\n\n银滩在北海的南面，是一片巨大的天然沙滩，不愧是天下第一滩。沙滩就算最窄的地方也有几百米宽，长度看起来也要几十公里的样子，在海滩上看城市就好像在看沙漠里的绿洲。海水漫过的沙滩就好像一面镜子，也不知道有没有人来这儿拍天空之境。\n\n因为是天然沙滩，踩起来比人工沙滩结实得多，甚至觉得有点像水泥。沙滩有很多小螃蟹，螃蟹会咀嚼沙滩上的沙子并卷成各种小球。涨潮的时候会有很多寄居蟹背着贝壳跑上岸钻到沙子里面，退潮的时候沙滩上会留下沙蚕吐出来得沙管。我看到的就只有小鱼小虾小蟹，不过岸上确实有人能赶海挖到好多好吃的。\n\n另外，岸上还有好多人拿金属探测器各种扫描，不知道是不是之前有人在沙滩上埋了什么。\n\n北海银滩总体来说还是推荐去的，不过游泳的话，就是伸手不见五指，这也使得我不打算去涠洲岛，毕竟光门票和路费也要 300（300 够我飞六个城市了）。\n\n## 侨港街\n\n银滩附近有一个侨港，大多是越南回国得侨民，\n\n## 冠头岭\n\n冠头岭在北海的西面\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/11/24/Beautiful-Harbin.md","slug":"2020/11/24/beautiful-harbin","body":"\n# 美丽的哈尔滨\n\n从北海飞到哈尔滨，惊喜的是进入华北之后就开始万里无云。在夜里每经过一个方形的城市，就会好奇下面是个什么样的城市，好在可以收到 GPS 数据。\n\n哈尔滨的第一个感觉就是，身上的温度瞬间被吸走，当时的温度是零下 13 度。从哈尔滨太平机场出发有到中央大街的客车，我也不知道为什么我对哈尔滨的要求这么不高，到达沈阳的时候还希望它能有铁路交通。大概一个小时的客运，我终于抵达中央大街，时间是十点左右，不过大街上已经没有多少人了。\n\n第一天的时间我都花在买衣服上面，虽然照前同事推荐的，在透笼小商品城买了个帽子，但是大部分的东西我还是在迪卡侬搞到的。在哈尔滨，像是迪卡侬家乐福这种大型超市离中央大街还是比较远的，而且在零下十几度的地方等公交绝对是一个糟糕的体验，所以最好是一下子都买全比较好。\n\n黑龙江省博物馆在哈尔滨火车站的对面，相比于各种省级博物馆，这个博物馆算是小的了，据说它会搬到哈尔滨大剧院那里，是一个很遥远很遥远的地方。虽然黑龙江有很多恐龙的资料以及渤海国的内容，但显然博物馆的介绍还是比不上俄侨的部分，非常推荐了解一下这部分，包括很多俄罗斯俄式建筑，博物馆还特别把它们做成水晶球，显得分外浪漫。\n\n然后就是俄餐，中央大街的俄餐很多，美团上面找了一家，就是烤土豆格瓦斯大拌菜套餐，也没什么特殊的，就是比较胀肚。\n\n晚上走到斯大林公园，旁边就是冻上的松花江。哈尔滨的晚上来的特别早，大概 4 点钟天就黑了，所以想去缆车那边看夕阳要赶早。其实这么美的城市赶上这么短暂的白天真是可惜。\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/12/01/Beibei-punch-card.md","slug":"2020/12/01/beibei-punch-card","body":"\n# 北陲打卡之行\n\n漠河作为随心飞能够到达的地方，我的目标很简单，就是打卡。所以原计划是飞到了漠河县城，然后坐每天两趟 25 元的北极村大巴再住两天就回。不过巧的是，碰到了再新疆时候认识的驴友，所以我们打算包车转一圈。\n\n## 漠河县城\n\n漠河县城原名西林吉，这个名字是慈禧逃亡时起的。据说当时慈禧逃到林子西侧，正好碰到大屠杀，整个东面都被屠杀掉，而西侧安然无恙，因此起名「西林吉」。而现在的漠河县城则因为漠河火车站而得名，有趣的是，后面旅程碰到的很多地方都会和慈禧有关，慈禧每逃到一个地方休息时都叫做「站」，所以后面的地名都以「二十站」「二十八站」这样起名。\n\n漠河县城并不大，也就方圆五公里的样子。县城中间有一个鼎盛商场，算是最繁华的地方。距离商场几百米处，有一个北极星广场，是当地的打卡处，可以登高远眺整个城市。\n\n漠河曾经发生过重大火灾，在鼎盛广场东侧有一个林子，是当时火灾唯一没被烧到的林子，和清真寺、茅厕和坟地一起被称为当地的「四不烧」。在林子一侧是火灾纪念馆，虽然建筑很漂亮，但建议最后去，因为内部还原的火灾场景十分触目惊心。\n\n## 北红村\n\n中国的最北点位于北红村附近，如果不包车的话，去北红村的客车是每个双号日的下午两点。北红村是一个很小的俄罗斯族村子，如果并不是对中国最北的石碑感兴趣的话，其实可以不看。\n\n## 北极村\n\n北极村是漠河最早开发的旅游村，里面设施相对北红村全面的多，甚至还有学校、邮局等。\n\n到达北极村的时候，当时温度已经零下 20 度了，周围的雪雕已经纷纷的建起来了。相比北红村，北极村非常值得去，当然物价比北红村要贵。\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/12/03/I-learned-to-ski.md","slug":"2020/12/03/i-learned-to-ski","body":"\n# 在哈尔滨学会了单板滑雪\n\n从漠河回到哈尔滨，果然就没那么冷了，于是我打算再滑一次雪。在青旅里面普遍都是要去亚布力，个人觉得亚布力太竞技性（还贵），如果是让我去，更加喜欢伏尔加庄园，从城堡上面滑雪还真是神奇的体验。\n\n伏尔加庄园的官方网站已经无人维护了，查了一下飞猪还有账号。原来 12 月 16 号雪场才能开放，我又不能在哈尔滨等到 16 号。其实哈尔滨周边还有很多雪场，在 GoSki 上面还搜到了名都滑雪，公众号上面显示的「准备开放」。于是就像我经常做的，马上去微博看一下，果然有人在滑，询问无果，打算亲自去看看。\n\n从哈尔滨火车站到名都滑雪场，可以坐 338 路直达，到哈尔滨职业技术学院下车，疫情期间要绕过这个学校，在学校后身就是滑雪场了。\n\n雪票很便宜 59 元，另外十元的柜子。目前中级雪道还在铺设中，只可以滑初级雪道。反正我也不会滑单板，就在初级雪道上面练习好了。就按照 B 站上面教的，首先推雪，然后练习单刃，最后再双刃交替，两个小时下来基本就会了。\n\n哈尔滨的日落很快，基本四点就结束了，考虑到如果继续滑下去会很冷，就短暂告别了。本来回去的时候打算乘一下哈尔滨的地铁，但正好碰到 338，地铁也就没坐成。\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/12/06/There-is-really-nothing-to-play-in-Changchun.md","slug":"2020/12/06/there-is-really-nothing-to-play-in-changchun","body":"\n# 长春还真没什么玩的\n\n查了一下，哈尔滨到长春的火车也就43元，所以想去长春看看，来长春之前，路上的驴友基本上都是不推荐去。或者说可以路过长春去长白山。\n\n查了下，去长白山还真便宜，70块钱大巴直达，只不过住宿来看是更倾向于家庭游而不是个人旅行。\n\n再看一眼长春附近的滑雪，除了人比较多的北大湖还有天定山和莲花山。只不过大巴都要7点钟出发，出发地周围还没什么住宿（wtf？），仔细考虑之后还是去沈阳滑好了。\n\n## 吉林省博物院\n\n吉林省博离市区很远要坐城轨到长影世纪城，然后再转车或者徒步到达，周边也没什么共享单车。\n\n博物院内部是东北各民族发展，辽博主要看契丹，黑龙江博物馆看馍鞨，吉博就看高句丽了，不过由于高句丽后来迁都到平壤，但展品不是很多，大部分也是复制品。\n\n吉博虽然是新馆，但是展馆比较乱，也没有什么导引，冬天3点就关了，所以感觉也不是需要特别去看。\n\n## 这有山\n\n长春电影厂旧址在这有山商场对面，门票还是比较贵的，要70元。咬咬牙始终还是没去，这有山商场是一个网红商场。商场内被做成山间小路的样子，有一丝洪崖洞的感觉。","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/12/09/After-skiing,-the-Snail-House-has-finished-watching-the-blade-of-ghosts.md","slug":"2020/12/09/after-skiing-the-snail-house-has-finished-watching-the-blade-of-ghosts","body":"\n# 滑雪之后，蜗居看完鬼灭之刃\n\n本来打算在长春滑雪，但是长春的一日游都要一大早 7 点起床，而沈阳 9 点即可。和客服约好在电报大厦楼下见面，好巧不巧，电报大厦大到一个街区的样子，车停在南面，我在北面，联络了好久才到。\n\n怪坡滑雪场有一个初级道，中级道单双板分开两道，高级道和障碍道还在铺设。说说价钱吧，一日游 84，包括来往车费、滑板、雪靴。上中级道需要花费 30 租一个头盔，柜子 10 元，进雪场需要办卡，走的时候再退。现在滑单板的人真多，一眼望过去双板寥寥无几。\n\n从 10 点一直滑到下午 2 点半，回到市区已经是筋疲力竭，导致第二天基本上是在青旅蹲了一天，把鬼灭之刃的动画和漫画都看完了，期待以后的动画情节。\n","collection":"blog","data":{"type":"post","category":"tv"}},{"id":"2020/12/15/CrossFit.md","slug":"2020/12/15/crossfit","body":"\n# 牛首山、鸡鸣寺和南京的 CrossFit\n\n> 感谢南京同学赠送给我的南京两天白吃白喝之旅~\n\n在南京的前两天基本上就是吃吃吃睡睡睡玩玩玩，新街口的网红鸡腿、网红拌面、网红鸡蛋灌饼、像元宵一样的汤圆。\n\n## 牛首山\n\n赶上南京初雪，从夫子庙坐地铁前往城郊的牛首山，薄薄的白雪压在一片秋景之下，给南京城增加了几分肃穆。\n\n牛首山本是南京郊区的一座形似牛头的山，只不过建国初期开采铁矿被挖去了一部分，08 年新建的万佛殿则依照山形将原来的山顶补回。矿坑内的地宫供养的是原来大报恩寺的佛头舍利，万佛殿里面金碧辉煌，地宫更是只能穿鞋套进入，绝对不虚一行。\n\n据称佛祖涅槃之前曾说自己的身体会变成多个舍利可以给后人供奉，后来本是独立的佛头舍利被散落在西域各国，后来在宋朝被进贡埋藏到建初寺下，后来明朝朱棣建造大报恩寺，供养玄奘尸骨。后来大报恩寺在太平天国运动中被毁，在日本侵略时期，日军因为在此地挖到了玄奘尸骨则没有继续挖掘。虽然后面人们说这个佛骨如何吉祥，参考南京近千年的历史，感觉是大相径庭。不过文物上面的确有很多很值得一说的故事。\n\n## 鸡鸣寺\n\n金鸡寺在玄武湖南边，作为南朝第一寺，可游览的地方有点少...10 元一张门票并送三根香可敬。寺中的药师佛塔 1990 年落成，并用于替代当时并没建成的雷峰塔来拍摄「新白娘子传奇」。\n\n## 六朝 CrossFit\n\n今年多了一个爱好，就是练 CrossFit，一般我会参考邢奇辉的 Youtube 视频，他就是在六朝 CrossFit 的应天店，这次正好看见玄武店在新店促销，定了三次票合计 89。\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/12/18/Don't-rent-the-interpreter-at-the-Zhenjiang-Museum.md","slug":"2020/12/18/dont-rent-the-interpreter-at-the-zhenjiang-museum","body":"\n# 在镇江博物馆就不要租讲解器了\n\n因为疫情想要绕开上海回家，选择从沈阳飞到南京，再从南京到扬州飞回大连。顺便还可以再逛一逛这几个城市。\n\n镇江市相比于南京要清冷很多，尤其是在这个江南的冬季夜晚，大街上空空寥寥，周边的小店也算是门可罗雀，这个小城给我的第一印象就好像是南京的睡都。毕竟南京到镇江的动车还不到半个小时。\n\n我住在八佰伴商场附近，去镇江博物馆大概有 2 公里左右。因为天气冷，干脆走过去好了。离开八佰伴，基本上就没有多少高楼了，完全进入一种江南小城的感觉。\n\n镇江博物馆是老英国领事馆的一部分，可以免费进入，门口有讲解器可以租用，但是藏品也不多，也没与大量有关镇江历史可听，所以个人觉得没必要去租。一楼是青铜器馆瓷器馆，二楼是书画馆和工艺品馆，另外二楼一半都是玻璃穹顶，颇有哈利波特斯普劳特教授的花圃的感觉。\n\n从博物馆出来，是西津渡景区。这是原来三国时期就有的渡口，现在复建为景区，基本上和很多仿古景区差不多，所以也没有多少稀奇。有一些道路会故意挖出来明清唐到更早的砖路，就像很多多手房都覆盖了多层地板一样，也难怪去这个渡口要爬楼梯了。\n\n这大概就是镇江了，明天我就要坐客运去扬州看看。\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/12/20/Yangzhou,-worthy-of-his-city.md","slug":"2020/12/20/yangzhou-worthy-of-his-city","body":"\n# 扬州，不愧是他的城市\n\n> 本来是为了避开浦东疫情绕道南京从扬州回大连，但是既然作为目的地的大连也疫情爆发了，也只好硬着头皮去了。\n\n从镇江到扬州，可以直接乘坐客运前往，相比于城际来说，既便宜也不绕道。镇江和扬州分布于长江南北两岸，向阳的扬州虽然温度一样但体感上绝对比镇江暖和。\n\n## 扬州双博物馆\n\n从客运站乘坐公交到达扬州双博物馆，所谓双博物馆，是一个扬州博物馆和雕版印刷博物馆，扬州博物馆内容绝对比镇江博物馆详细。个人感觉雕版博物馆更像是扬州博物馆的一个展厅，不过是因为扬州目前还存在雕版印刷而存在。更早的时期扬州曾是个沿海城市，北面是黄河出海口、南面是长江出海口，可算是个升级版的上海，但是因为大自然的鬼斧神工，愣是给这个沿海城市填成了内陆城市。\n\n## 东关街\n\n东关街是几乎每个古城都有的小吃一条街，里面包括扬州比较著名的园林。毕竟曾经是个沿海城市，产盐为主业，而盐商又无法从官，多出来的钱只好用来建园子。这和苏杭的园林区别比较大，毕竟那些大部分都是退休养老的园子。比如著名的个园就在东关街，不过我也只是在门口看看，也没有进去。\n\n## 瘦西湖\n\n瘦西湖一定要去！来扬州之前，曾有人不推荐我去，适逢冬季，瘦西湖的风景的确不如往日。但不愧是扬州的代表性景区，刚进景区看到的就是青砖白瓦和杨柳依依，不由得放慢了脚步，这或许就是古代扬州土豪的闲情雅旭吧。\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2020/12/24/Haproxy-nginx-SS.md","slug":"2020/12/24/haproxy-nginx-ss","body":"\n# Haproxy 和 nginx 做 SS 中继\n\n隔离在家最痛苦的莫过于家中网络连接 SS 总是断线，参考网上的[方案](https://sjq597.github.io/2018/05/22/ShadowSocks-Haproxy%E4%B8%AD%E7%BB%A7/)，使用国内云服务作为 TCP 转发即可。\n\n## Haproxy 配置\n\n```\nglobal\n    ulimit-n  51200\n\ndefaults\n    log     global\n    mode    tcp\n    option  dontlognull\n    timeout connect 5000\n    timeout client  50000\n    timeout server  50000\n\nfrontend ss-in\n    bind *: 国内云服务的端口\n    default_backend ss-out\n\nbackend ss-out\n    server sserver_name SS的IP:SS的端口 maxconn 20480\n\n```\n\nhaproxy 可以运行在 docker 容器里\n\n```\ndocker pull haproxy:latest\nsudo docker run -d --name haproxy_6 -v 配置文件目录:/usr/local/etc/haproxy/haproxy.cfg --restart=always -p 云服务端口:配置中的端口 haproxy:latest\n```\n\n接下来在国内的云服务安全组里面打开上面的端口即可，实测大部分应用可用，但是推特上面不能显示图片，google play 也没法更新，vmess 协议目前还不支持，这些就看我以后跟进了。\n\n## nginx 配置\n\n相比之下 nginx 更加简单，在 nginx.conf 里面增加如下内容。\n\n```\nstream {\n    server {\n        listen 云服务端口;\n        proxy_pass SS的IP:SS的端口;\n    }\n}\n```\n\n这样连 Vmess 都可以使用了，不过混淆加密功能还不好使，唉，涉及到 TLS 我就跪了。\n\n测试之后 PC 端都没问题，但是移动端配置都用不了。\n","collection":"blog","data":{"type":"post","category":"tech","tag":["haproxy","shadowsocks"]}},{"id":"2020/12/27/Google.md","slug":"2020/12/27/google","body":"\n# 如何做代码评审\n\n这是[谷歌的代码评审标准笔记](https://google.github.io/eng-practices/review/reviewer/)。\n\n## 代码评审标准\n\n代码评审是为了提高整体代码进步而设定的。\n\n首先，要确保代码以后是可以进一步改进的。代码的评审人员也应该是代码的持有者。\n\n**_总体上，评审者应该允许能够提高总体代码健壮性的代码，即使它不够完美。_**\n\n当然也有限制，如果代码增加的特性不是整个系统想要的，尽管它多么好也要拒绝掉。\n\n评审者可以任意留下评论，如果不是很重要，请增加「Nit:」作为前缀。\n\n### 指导\n\n代码评审对开发人员了解一个语言、框架都有所帮助，留下评论是可以的，但是一定记住要留下「Nit:」作为不强制性改动的标记。\n\n### 原则\n\n- 技术事实，有数据否决的建议和个人配置。\n- 代码风格，代码风格应该和原有代码保持一致，如果源代码没有代码风格则允许提交。\n- 没有纯粹的代码风格，基本上就是个人设定。\n- 评审者应该要求提交代码和现有代码保持一致，这样不会使现有代码健康更加恶化。\n\n### 处理冲突\n\n在冲突上，评审员和代码作者应该达成一致，做好要有一次面对面会议或者线上会议。如果不能达成一致，一定记得升级到更高层次人员处理。\n\n## 应该看什么\n\n### 设计\n\n- 代码和原有代码配合如何？\n- 这段改动是基于代码层面还是库层面？\n- 和系统的其他部分结合的如何？\n- 现在是增加这个功能的最好时机吗？\n\n### 功能\n\n这段代码是否符合作者用意？是否对用户有利？此处「用户」同时指端用户和开发者。\n\n有时，如 UI 改动需要评审查看 demo。\n\n### 复杂度\n\n代码的复杂度即代码是否可以被迅速理解，其它工程师是否可以修改这一段代码。\n\n一个特别案例：过度开发。\n\n### 测试\n\n要求单元测试，或适当的端对端测试。除非紧急任务，测试必须伴随代码一并提交。\n\n确保测试正确，明确和有效。\n\n### 命名\n\n确保命名简单易懂。\n\n### 注释\n\n注释应该解释这段代码为什么存在，而不是它做什么。\n\n### 代码风格\n\n谷歌有对大部分语言提供[风格指导](http://google.github.io/styleguide/)。\n\n| 生词         |            |\n| ------------ | ---------- |\n| disincentive | 妨碍活动的 |\n| mandatory    | 强制性的   |\n| overrule     | 否决       |\n| underlying   | 基本的     |\n| consensus    | 一致同意   |\n| interaction  | 配合       |\n| appropriate  | 适当的     |\n| sensible     | 明确的     |\n","collection":"blog","data":{"type":"post","category":"tech","tag":["code-review","translate"]}}]}