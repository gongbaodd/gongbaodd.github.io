{"posts":[{"id":"2017/11/22/Building.Isomorphic.JavaScript.Apps.md","slug":"2017/11/22/buildingisomorphicjavascriptapps","body":"# Building Isomorphic JavaScript Applications\n\n## 读<构建同构的JavaScript应用>有感\n\n![](https://covers.oreillystatic.com/images/0636920042846/cat.gif)\n\n这本书简单介绍了并实现了前后端js应用方案(Hapj.js)\n\n我更喜欢书后半部分各个公司对前后端同构的优化.\n\n### React\n\nReact的后端渲染存在性能瓶颈(这个我在现实使用时也考虑过,虽然我用的是Preact), 书中通过修改 mountComponent 方法缓存最近渲染的模板, 这种 LRU 算法很大的加快了后端渲染效率. 貌似 Vue 也用的这种方案.\n\n我的做法可能更粗暴点,我直接在服务启动的时候把不会变化的组件渲染出来在内存里使用了,囧. 但这是最快的做法呀(原谅~).\n\n### Angular\n\n其实是 Angular1, 由于过于依赖浏览器, 开发者抽象了很多的浏览器 API. 作者介绍了 Angular2 Universal. 我比较喜欢的是 Preboot 功能, 这个功能能够缓存用户在未渲染完成的页面的操作,并在客户端渲染完成进行操作, 这样能够解决用户过早提交表单的问题.\n\n我的确碰到表单问题了, 但我是直接把表单删了, 依赖 JS 处理 submit 按钮, 这样用户在未渲染之前是不能提交的, 遗憾的是这样就失去了表单的功能了.\n\n### Backbone\n\n没有过多了解, 书里提到后悔使用jQuery, jQuery的确是一个前后同构的 js 库, 刚有 node 的时候我也在用, 然而现在我也不用了.\n\n### C#.Net\n\n有趣的是, 前后端同构并不是 node 独享的, 书里的最后一个例子是 C# 的, 作者找到了 js 和 C# 共有的模板引擎解决了跨语言前后端同构的问题.\n\n## 注意\n\n需要注意的是，做单页面应用的时候，或许不需要考虑太多内存泄漏，毕竟页面关了资源就释放了。而做 server 端并不会。\n\n\n## 总结\n\n这本书很薄, 英文版209页而已, 后面的例子的确有很多可采纳的地方.\n","collection":"blog","data":{"type":"post","category":"fe"}}]}