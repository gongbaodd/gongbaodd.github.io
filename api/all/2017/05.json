{"posts":[{"id":"2017/05/01/The-same-night-sky-Guandi-Temple-Datong-Museum.md","slug":"2017/05/01/the-same-night-sky-guandi-temple-datong-museum","body":"\n好吧，上次说到哪儿了？\n\n话说得补充一下２８号的事情，在我逛清真寺的时候，其实很多讲解是中英文混搭的，没错，是混搭，也就是英文说英文的，中文说中文的，讲得完全不是同一个东西。我挺好奇那个看门大爷为什么就不好奇一句长度不超过３０字的中文翻译成英文竟然是怒长的一段话，不过话说回来，他连康熙千年前留下一块匾都信了。\n\n在读英文的时候，我旁边站着一位大叔，也是一副游者打扮，震惊的看着我，惊叹一句，你也是穆斯林么。。。我很尴尬地解释这是英文。回想起来，大叔究竟为啥震惊呢，是我穿的不清真，还是我长得。。。？\n\n好了，补完上期的尾巴，开始说今天的事。现在是北京时间五一劳动节的凌晨两点十分，我和三波人坐在大同火车站的候车室里，其中两辆是来往东胜西和北京西的，我是第三波，三点钟前往昌平北，抢不着票嘛，地铁也一样，像歌里说的，We are the 昌平。。。反正我也没去过昌平，其实昌平北离十三陵挺近的，但我还是先回家吧，ＰＰＴ没做呢。\n\n说了一堆没用的，还没进入话题呢。今天（确切的说是昨天）的旅途虽说比之前一天更有计划，但依然让我整得很凌乱。\n\n首先，按照原先的计划，我发了微博，ins，把一部分照片传到google photos，然后满怀期待地看一眼点赞情况，果然，一个也没有。然后我按照计划到了小媳妇凉粉那里要了碗凉粉，却被告知他们刚开门，凉粉还没运过来，我靠九点了好么。。。\n\n带着遗憾，我进了古城，找了家肯德基垫了下肚子，其实我想吐槽一下，古城里的小吃，要么是山楂（我去吃完更开胃），要么是碗秃（一种凉拌荞麦面），其他的就没得选了。\n\n早上的古文化街，没了那么多发传单的和“各种十五元，全部十五元”的大喇叭，确实多了些古城的样子。我在城里闲逛了许久，其实是我找不到昨天的关帝庙了，而我的流量也快没了，必须减少不必要的流量开支，（＠某新媒体工作者，所以前天你跟我讨论“互联网已经不是个走流量的时代了”这个话提的时候，我的意思其实是我的手机流量不够了，请别再给我发截图了）。\n\n# 大同关帝庙\n\n终于，找到了关帝庙，好在大同古城真的不大，门票３０，其实我更关心的是门口的戏台到底啥时候开演，所以我在买票的时候特地问了下，售票员给了一个我并不太满意的答案，两点半，这也就意味着，我想一天逛完地方都要在两点半之前逛完，而看完戏之后，我也想不出干啥了。\n\n说说关帝庙吧，内部有一座元时期的庙宇，由于元朝特殊的历史地位，现在留下的元朝建筑真心凤毛麟角，明清木构建筑已经进阶到第二等级了（斗拱结构从支撑功能变成装饰功能），所以想看先人木构上的智慧，就要看明清之前的。\n\n其实我去关帝庙的目的还不在元构，而是那些壁画，据说是惟妙惟肖的描述了三国故事，不过很可惜，壁画都被收起来保养了，留下来了三面空墙被黄布裹着。\n\n先说到这里吧，火车来了～\n\n# doge九龙壁\n\n中国有三处九龙壁，一个在故宫、一个在北海最后一个在大同，《壁下观》提过，大同的九龙壁是三者最好看的。确实，自从我不知哪里看到的日本学者提下的，“清朝的中国龙看起来太瘦，像蚯蚓”之后，我看手上拍下的故宫九龙壁，便觉得这话应该是实话。\n\n但大同这个不同，建于明朝的大同九龙壁，光从高度上就可用壮观来说，龙体也算粗壮有力，表情也很丰富。我最喜欢的是最走的那条，都说鲤鱼跃龙门化身为龙，最左估计是条海doge吧～\n\n# 大同市博物馆\n\n大同市博物馆离古城不远，在九龙壁坐３８路车没几站就到了。其实打算是逛下大同市博和大同美术馆，可惜只有博物馆开放了。博物馆是一个造型很有趣的建筑，不太清楚它的造型，６９?\n\n按照展厅排布，一楼原始展馆，特展（目前是铜镜展），代国展（春秋时期代国位于大同）;二楼北魏艺术展；三楼瓷器书画展。感觉大同博物馆颇有点国家一级博物馆的味道，当然了，也可能是因为是新馆。具体有点记不得了，貌似有个春宫镜印象还蛮深的，我看看回头贴照片的时候补足吧。\n\n大概逛了两个小时，看了看表，我急忙赶回鼓楼吃饭，因为关帝庙的戏台演出要开始了。\n\n# 大同关帝庙戏台\n\n前一天逛古城的时候看到了个“晋商茶庄博物馆”，趁演员准备设备的空隙，我去看了下，怎么说呢，标题党，实际是个卖茶叶的，囧。\n\n说说戏台吧，演的是北路梆子《喜荣归》和《二进宫》。《喜荣归》讲的是状元赵廷玉装成乞丐回来迎娶妻子崔秀英，崔家以貌取人不肯承认亲事，后来得知赵是金科状元羞愧难当，印象最深刻的是秀英大喊的”我的妈唉“，不知道路没录下来。《二进宫》我挺感兴趣的，毕竟是看过两遍《明朝那些事儿》，讲的是万历登基的事，书里讲得极其精彩。戏里我就蒙了，全是代称，十岁的万历变成了襁褓中的孩子。。。总之，我是一脸懵逼地看完了，印象最深刻是李贵妃的一个台词，好像是怎么怎么哭老王（其实是哭先帝的意思）。\n\n# 古城墙、魁星楼、四牌坊和记忆大师\n\n看完戏，已经是傍晚，除了城墙，大部分景区都关门，既然城墙免费，我就有一次登城了。这回我可是打算把整个城墙走了个遍，可惜大同城墙虽然宣传是已经建成，但其实很多还在维护，所以从正西面向南的路还是不通的。默默吐槽一下，这个城的北面防御力明显高于南面嘛～\n\n话说，小小的科普一下，大同人骂人脸皮厚是“城墙里面夹块砖”，我也不知道真的假的，别问我怎么知道的。\n\n打发时间，我还看了记忆大师，不错的电影，我单独写影评吧。出了电影院，已经将近１１点，安静的路上只有鼓楼这一路有路灯，沿着空旷的街道我又拍了几张照片。\n\n# 尴尬的归途\n\n说到大同火车站，其实离古城也很近，走路的距离，路上还能看到老城墙未拆的遗址，大概因此我在一条交叉路口走错了路。到了地图上的”大同站东广场“其实是个工地。。。要想去大同站还需绕行两公里，而且路上非常恐怖，一来是没有路灯，二来是由于城区建设路边基本上也都是正准备拆迁的空楼，吓死宝宝了。\n\n到了大同站，另一个尴尬的事情发生了，居然没有自助取票机，唯独的夜间窗口排着长长的队，队伍后面两个乞丐正在对酒切磋乞术，估计此时此刻最精神的就是他俩了，我从睡眼惺忪的售票员取了票，又经过了睡意朦胧的安检，进入了昏昏欲睡的候车厅，记下了这次略微传奇的旅途。\n","collection":"blog","data":{"type":"post","category":"life"}},{"id":"2017/05/02/Qxf-Qconfig.md","slug":"2017/05/02/qxf-qconfig","body":"# 结合Qxf和Qconfig解决前端热发布\n\n或许篇文章写得有些晚了，如果这篇文章是写koa的话，估计受欢迎程度会很高。\n\n最近正巧有一个前后同构的项目，其实是利用node作渲染层。至于为什么用node作渲染层就不做详述了，节约后端资源，释放前端约束，可能方案并不是通用的，正好我的项目需要。\n\n## Qxf 介绍\n\nQxf是基于express的node服务方案，也就是说很多express的API可以直接使用。确切说并不完全是这样，response.write就被改写了，但并不影响使用。\n\n其实Qxf的出现是给node做了一层兼容于原有去哪儿前后端分离模式的node后端。同时为开发者做了一层脚手架封装，集成包括cluster、logger、handlebars等开源的中间件以及去哪儿私有的异常处理、日志处理、埋点统计以及静态资源版本号的管理中间件。\n\n## QConfig\n\nQConfig是去哪儿内部解决后端热发的方案，简单地说它会依照版本存储```*.properties```或者```*.json```文件，并按需将这些配置文件推送到各个机器，推送之后也可以回滚。\n\n## 解决的问题\n\n前端有很多需求是文案修改、图标修改，相对来说算是比较安全，但每次修改的时候还要测试回归上线，这样流程拖得太长，如果前端也可以利用QConfig实现热发，那自然是很受欢迎的。\n\n## Qxf怎么用\n\n针对Qxf怎么去创建一个工程在此就不多余介绍了，讲一下工作原理吧。\n\n    qxf dev\n\n这个命令会启动Qxf的测试环境，其实就是执行了以下代码\n\n    NODE_ENV=development node ./bin/start.js --l .logs\n\n也就是说，包括server的启动配置都写在这里面了。整个服务都会在```multiprocess.listen(app, opts)```之后执行（注意一个坑点，multiprocess没有暴露server对象，所以用不了reload.js，开发的时候只能手动刷新页面了）。\n\n## QConfig怎么用\n\n讲完Qxf说说QConfig，按照qConfig的文档在Qxf的config.js里面配置好要取的配置，QConfig要在Qxf启动之前执行，也就是还要修改start.js里面的\n\n    multiprocess.listen(app, opts);\n\n为\n\n    qConfigClient.init().then(()=> multiprocess.listen(app, opts));\n\n之后如果需要获取某一个属性文件，则需要执行\n\n    const configs = qConfigClient.getConfig('*.json');\n    const value = configs.get('key');\n\n如果你的配置是json的，获取到的值会直接parse成对象。\n\n***需要注意一点,Qconfig是异步的，也就是说getConfig的执行必须放到某个可抵达的回调里面***\n\n## 结束\n\n执行一下```qxf dev```，服务器访问```localhost:3000```到对应的router下面就可以看到效果了。\n\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/05/03/QxfComponents.md","slug":"2017/05/03/qxfcomponents","body":"# 写啥题目呢\n\n## 回顾一下\n\n去年三月，我分享了一个用riotjs开发前端的方案，既然已经有一年的时间了，就先回顾一下。\n\n这套方案出自2015年，之前一直使用的是公司的QApp解决方案，后来发现使用上存在问题，\n并在试图寻找一套可行的替代方案。\n\n### 组件化方案\n\nQApp的最小单位是View(大概可以理解为页面)，\nView里面大到一个轮播图小到一个按钮的操作逻辑都和view耦合，\n假设我想使用某一个View里面的某一个组件，想直接拆出来是不太可能的。\n\n* 以前的写法\n\n        QApp.defineView({\n            html: `\n            <div node-type=\"vcode\">\n                <input action-type=\"input\">\n                <button action-type=\"vcode\">发送短信</button>\n            </div>\n            <button action-type=\"submit\">提交</button>\n           `\n            actions: {\n                // 这里的this指向整个view\n                \"input:input\": () => this.doInput(),\n                \"submit\": () => this.doSubmit(),\n                \"vcode\": () => this.doVcode(),\n            },\n            init: {\n                doInput() {},\n                doSubmit() {},\n                doVcode() {},\n            }\n        });\n        QApp.config({...});\n\n* 新的写法\n\n        riot.tag('pay-input',`\n            <input oninput=\"oninput\">\n        `, ()=> {\n            // 这里的this指向整个pay-input\n        });\n        riot.tag('pay-submit', `\n            <submit ontap=\"onsubmit\">\n                <yield/>\n            </submit>\n        `, ()=> {\n            // 这里的this指向整个pay-submit\n        });\n        riot.tag('pay-vcode', `\n            <pay-input></pay-input>\n            <pay-submit>发送短信</pay-submit>\n        `, ()=> {\n            // 这里的this指向整个pay-vcode\n        });\n        riot.tag('pay-view',`\n            <pay-vcode></pay-vcode>\n            <pay-submit>提交</pay-submit>\n        `, ()=>{\n            // 这里的this指向整个pay-view\n        });\n        riot.mount('pay-view');\n\n### 基于发布订阅的统一事件管理模式\n\n有很多时候，我们要处以理一些“这些东西，我们不要了”之类的需求，\n当我们回头去翻代码的时候，惊奇的发现它被封装了，\n那么后面的故事就是要和“xxx function is undefined”做长期斗争了。\n\n* 之前的调用方式\n\n        QApp.defineView({\n            init: {\n                doSomething: ()=> {}// 删我貌似很困难\n                doSomethingElse: ()=>this.doSomething()\n            },\n            ready() {\n                this.doSomething();\n            }\n        });\n\n* 之后的调用方式\n\n        riot.tag('pay-view',`...`, ()=>{\n            this.on('doSomething', ()=> doSomething()); // 不要就删掉吧\n\n            this.doSomethingElse = () => this.trigger('doSomething');\n            this.on('mount', () => {\n                this.trigger('doSomething')\n            });\n        });\n\n### 基于状态基的异步流程处理\n\n其实2015年，是异步流程处理比较混乱的一年，Promise刚出来，没多少人敢用，\n更别提generator还有async之类的东西了，\n这套方案正好利用了发布订阅的优点，\n只要在异步事件触发之前订阅上就没问题了\n\n* 之前\n\n        QApp.defineView({\n            ...,\n            ready() {\n                this.ajax({\n                    ...,\n                    success() {\n                        foo(..., () => {\n                            bar( ..., () => {\n                                ...\n                            });\n                        })\n                    }\n                });\n            }\n        });\n\n* 之后\n\n        riot.tag('pay-view', '...', () => {\n            this.on('ajaxDone', () => {\n                ...\n                this.trigger('foo');\n            });\n\n            this.on('fooDone', () => {\n               ...\n               this.trigger('bar');\n            });\n\n            this.on('barDone', () => {\n               ...\n            });\n\n            this.on('mount', () => this.trigger('ajax'));\n        });\n\n### 利用组件树检索组件\n\n项目组件化（Component）+ 事件化（Reactive）之后，\n一个页面的运行方式就成为某一个组件监控某一个组件的某一事件并对其造成的处理。\n那么需要利用祖组件树解决一下检索问题。\n\n    require(\"pay-input\");\n    require(\"pay-submit\");\n\n    riot.tag('pay-vcode', `\n        <pay-input></pay-input>\n        <pay-submit>发送短信</pay-submit>\n    `, ()=> this.tags[\"pay-submit\"].on('subimit', () => {\n        this.trigger('vcodeSent');\n    }) );\n\n    riot.tag('pay-view', `\n        <pay-vcode></pay-vcode>\n        <pay-submit></pay-submit>\n    `, () => this.tags['pay-vcode'].on('vcodeSent', ()=> {\n        this.tags['pay-submit'].trigger('enabled');\n    }));\n\n\n* pay-view\n  * parent: null\n  * tags\n    * pay-vcode\n      * parent: pay-view\n      * tags\n        * pay-input\n        * pay-submit\n        * parent: pay-vcode\n      * pay-submit\n        * parent: pay-view\n\n\n### 利用mixin实现继承\n\necmascript2015之前，js一直都没有一个像样的类的表达方式，\n所以我们其实也没有一个像样的继承方式，\n混淆是目前用的最多的一种继承，大概是源自$.extend吧。\n\n* ajaxApi1\n\n        module.exports = {\n            init: {\n                this.on('ajaxApi1', () => ajax(...) );\n                this.on('ajaxApi1Done', ()　=> ... );\n            }\n        };\n\n* ajaxApi2\n\n        module.exports = {\n            init: {\n                this.on('ajaxApi2', () => ajax(...) );\n                this.on('ajaxApi2Done', () => ... );\n            }\n        };\n\n* pay-view\n\n        riot.tag('pay-view', '...', () => {\n            this.mixin(require('ajaxApi1.js'));\n            this.mixin(require('ajaxApi2.js'));\n\n            this.on('mount', () => this.trigger('ajaxApi1 ajaxApi2') );\n        });\n\n### 结合velocity和yield实现首屏渲染\n\n首屏渲染，SPA一直有这个问题。\n因为在html加载到js加载完成（甚至是一些ajax返回）之前，\n页面都是白屏，其实vm可以完成一部分后端的渲染，并替代第一个ajax。\n\n* vm之中\n\n        #set($description = \"这里会代替<yield/>\")\n        <pay-view>\n            <span if=\"$!description\">$description</span>\n        </pay-view>\n        <script>\n            window.vmData = \"$!vmData\";\n        </script>\n\n* js里面\n\n        riot.tag('pay-view', `\n            <pay-vcode></pay-vcode>\n            <pay-submit></pay-submit>\n            <yield/>\n        `, () => {\n            const vmData = window.vmData;\n        });\n\n### SPA的路由（这部分本文不涉及，忽略）\n\n## 希望优化的点\n\n### 发布订阅解决函数调用问题是存在缺陷的\n\n这套方案会产生冗余代码，其实最好使用typescript编写代码，\n这样在编译环境下就能查出哪个函数调用了删除的方法。\n\n* util.ts\n\n            export const a = {\n                    // foo() { 假设我删除了foo }\n                    ...\n            };\n\n* xxx.ts\n\n            import { a } from \"util\"\n\n            class xxx {\n                constructor() {\n                    a.foo(); // 编译时会报错foo这个方法不存在，终止编译\n                }\n            }\n\n### 使用面向对象的语法\n\n* html\n\n        <body>\n            <pay-view></pay-view>\n        </body>\n\n* ES5\n\n        require(\"pay-input\");\n        require(\"pay-submit\");\n        require(\"pay-vcode);\n\n        riot.tag(\"pay-view\", '<span>{ title }</span><pay-vcode></pay-vcode><pay-submit>提交</pay-submit>', function(opts) {\n            this.title = opts.title;\n        });\n\n        riot.mount(\"pay-view\", {});\n\n* TypeScript\n\n        import {PaySubmit} from \"pay-submit\";\n        import {PayVcode} from \"pay-vcode\";\n\n        @tag({\n            name: \"pay-view\",\n            tmpl: `\n            <span>{ title }</span>\n            <pay-vcode></pay-vcode>\n            <pay-submit>提交</pay-submit>\n            `\n        })\n        class PayView extends TagCore {\n            onCreate(tag) {\n                tag.title = opts.title;\n            }\n            constructor() {\n                this.submit = new PaySubmit();\n                this.vcode = new PayVcode();\n            }\n            submit: PaySubmit;\n            vcode: PayVcode;\n        }\n\n        PayView.mount({});\n\n### 利用发布订阅模式控制流程并不是最好的流程控制\n\n目前来说原生的Promise支持已经很不错了，\nasync虽然是个实验特性，\n但发明C#的微软明显推荐用这个特性。\n\n* 发布订阅\n\n        riot.tag('pay-view', '...', () => {\n            this.on('fooDone', ()=> this.bar());\n            this.on('barDone', ()=> this.blah());\n            this.bar = () => {\n                ...\n                this.trigger('barDone');\n            };\n            this.blah = () => xxx;\n            this.on('mount', () => this.trigger('fooDone'));\n        });\n\n* Promise\n\n        @tag({\n            name: \"pay-view\",\n            tmpl: \"...\",\n        });\n        class PayView extends TagCore {\n            onCreate(tag, opts) {\n                tag.on('mount', () => this.foo.then(()=> {\n                    return this.bar()\n                }).then(()=> {\n                    this.blah();\n                }));\n            }\n            foo = ()=> new Promise(resolve => resolve());\n            bar = ()=> new Promise (resolve => resolve())\n            blah = () => {...}\n            ...\n        }\n\n* async & await\n\n        @tag({\n            name: \"pay-view\",\n            tmpl: \"...\",\n        });\n        class PayView extends TagCore {\n            onCreate(tag, opts) {\n                tag.on('mount', async () => {\n                    await this.foo();\n                    await this.bar();\n                    this.blah();\n                });\n            }\n            foo = ()=> new Promise(resolve => resolve());\n            bar = ()=> new Promise (resolve => resolve())\n            blah = () => {...}\n            ...\n        }\n\n### 没有完善的广播机制\n\n其实之前的方案是可以广播的，但需要选中需要的组件，如\n\n    [tagA,tagB,tagC].forEach(tag => tag.trigger('foobar'));\n\n但是我希望的广播是每一个页面里面的tag无需选中就可以接收到。\n其实在每个tag加载之后都会传进一个opts对象，\n这个对象或者是执行mount函数传入的值，或者是模板标签上的变量\n\n    XXX.mount({ aaa: 1 });\n    // opts == {aaa: 1}\n\n    <xxx aaa=1 ></xxx>\n    // opts == {aaa：１}\n\n所以只要把一个obersable的对象传到opts里面就行了.\n\n### 需要一个更好的mixin\n\ntypescript对mixin支持很好，\n配合vscode的输入提醒代码体验十分完美，\n所以几乎可以放弃riot的mixin了\n\n* riot.mixin\n\n        // ajaxApi.js\n        {\n            init() {\n                this.on('ajaxApi', ()=> ...);\n            }\n        }\n        // xxxtag\n        riot.tag('xxx', '...', ()=> {\n            this.mixin(require('ajaxApi.js'));\n            this.trigger(\"ajaxApi\");\n        });\n\n* @mixin(any[])\n\n        class AjaxApi {\n            ajaxApi() {\n                ...\n            }\n        }\n\n        @tag({ name: \"xxx\", tmpl: \"...\" });\n        @mixin([AjaxApi])\n        class XxxTag extends TagCore implement AjaxApi {\n            onCreate( tag, opts ) {\n                this.ajaxApi();\n            }\n            ajaxApi: () => void;\n        }\n\n### velocity模板语法太次了\n\n改用node渲染，Qxf使用的是handlebars，riot自身也支持后端渲染。\n\n## 介绍点儿常识\n\n### typescript的语法\n\n#### 类型化声明\n\n        const a:string = \"这是一个不可变的字符串\";\n        let b:string; // b只能赋字符串\n        let c:any; // c可以赋任一值\n        let d: () => void; // d只能赋空参数且返回为空的函数\n\n#### class语法糖\n\n        class a extends b {\n            constructor() {\n                super();//执行b的构造函数\n            }\n            public foo() {\n                super.foo();//执行b的原型上的foo函数\n                console.log(`\n                    我在ａ的prototype上\n                    this指向context\n                `);\n            }\n            public bar =　() => {\n                cosnole.log(`\n                    我在a的实例里,\n                    this指向a的实例\n                `)\n            }\n            public blaha = function() {\n                cosnole.log(`\n                    tslint默认禁止使用\n                    我在a的实例里,\n                    this指向context\n                `)\n            }\n        }\n\n#### async await 上面提过了\n\n#### Object解构\n\n        const obj = { a: 1 };\n        const name = \"name\";\n        const data = { ...obj, b: 2, name }; // { a: 1, b : 2, name: \"name\" }\n        const { a:xxx } = obj; // xxx===1\n        const data1 = {[xxx]: 'data1'}; // {1: 'data1'}\n\n#### 接口\n\n        interface Ia { foo: () => void; }\n        interface Ib { bar: () => string; }\n        interface Ic { name: string; }\n        class D { doSomeThing() { .... } }\n        class E implements Ia,Ib,D {\n            doSomeThing: () => any;// 如果实现的是类内元素，可以只声明，不实现\n            foo = () => {...} // 如果实现的是接口内元素，必须按照类型定义\n            bar = () => {...} // 必须把要实现的所有接口内的元素声明\n            constructor(param: Ic) {\n                const { name } = param;// param 必须是只含有name的对象\n            }\n        }\n\n### 装饰器\n\n就是前面类似于@tag,@mixin的东西，\n这个有点复杂，只说在class前面的装饰器吧,\n是用来处理对象原型的函数，\n会在构造函数执行结束后执行\n\n### Qxf router的使用(其实是express4 router的使用)\n\n#### 三种获取请求参数的方式\n\n假设一个接口是 'api/default/index?a=1'\n\n        router.param('solution', (req, res, next, value) => {\n            console.log(value); => 'default'\n            next();\n        })\n\n        router.get('api/:solution/:page', (req, res, next) => {\n            console.log(req.params) => { solution: 'default', page: 'index' }\n            console.log(req.query.a) => 1\n\n            res.write('111');// 返回111但是请求并不结束\n            res.end();　// 返回结束\n        });\n\n        router.post('api/:solution/:page', (req, res, next) => {\n            console.log(req.params) => { solution: 'default', page: 'index' }\n            console.log(req.body.a) => 1\n            res.json({aaa: 1}); //　返回　{aaa: 1}\n        });\n\n#### 中间件\n\n        router.use(`api`, (req, res, next) => {\n            req.xxx = 'xxx';\n            next();\n        });\n\n### 核心的几个类和接口\n\n#### 状态机存储器：　Store\n\n```new Store()```可以订阅```on```或者触发```trigger```几种事件，\n没错```riot.tag```函数里面的```this```就继承自```Store```;\n\n    const a = new Store();\n    a.on('sayHi', () => console.log('hello'));\n    a.trigger('sayHi'); // hello\n\n#### 广播控制器：　Control\n\n是一个状态机的集合，方法```addStore```可以添加状态机存储器，\n```trigger```可以广播触发存储器的事件。\n\n    const store1 = new Store();\n    store1.on('sayHi', () => console.log('hello,I'm store1'));\n    const store2 = new Store();\n    store2.on('sayHi', () => console.log('hello,I'm store2'));\n    const ctrl = new Control();\n    ctrl.addStore(store1);\n    ctrl.addStore(store2);\n    ctrl.trigger('sayHi');//hello,I'm store1hello,I'm store2\n\n#### 标签生成器：TagCore虚基类\n\n必须搭配@tag装饰器，```new```一个TagCore的子类（构造函数必须传一个Control），\n跟执行了一下```riot.tag```是一样的。\n执行```mount```方法就能在页面空标签里挂在上标签的实现，相当于执行了```riot.mount```。\n\n    @tag({\n        name: 'x-tag',\n        tmpl: `<span>{content}</span>`\n    })\n    class XTag extends TagCore {\n        onCreate(tag: IriotTag, opts: IriotOpts) {\n            this.on('mount', () => opts.ctrl.trigger('xTag_Mounted') );\n            tag.content = opts.content;\n        }\n        mount: (opt: { content: string }) => void;\n    }\n\n    const store = new Store();\n    store.on('xTag_Mounted', () => console.log('prodCasted') );\n\n    const ctrl = new Control();\n    ctrl.addStore(store);\n\n    const xTag = new XTag(ctrl);\n    xTag.mount({ content: '我就是content' });\n\n    // 页面里面的<x-tag></x-tag> 变成　<x-tag><span>我就是content</span></x-tag>\n    // 控制台打印出 prodCasted\n\n### node-fetch\n\n一个开源的项目，可以让node端使用fetch，使用方法和whatwg里面的API是一样的，在此就不多嘴了。\n\n### 前后端同构初阶\n\n如果看网上的一些前后端同构的资料，他们会给你如下的方案。\n\n    if (isServer) {\n        doNodeThings();\n    } else {\n        doClientThings();\n    }\n\n我可以告诉你，他们都抄自同一个骗纸。。。\n\n原因是很多前端的modules会操作window对象，\nnode端的module更牛，有一些都是二进制的，\n如果用webpack1的话，如何bundle到一个js里面?\n\n#### TreeShaking\n\n树摇（字面翻译）是个es6对module的定义，\n简单地说js代码编译的时候会解析成AST语法树，\n通过分析这个语法树可以知道某一个js里面的某一个函数是多余的，\n打包的时候就可以把它剔除。","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/05/04/0-riotjs.md","slug":"2017/05/04/0-riotjs","body":"# 回顾一下以前的Riot.js方案\n\n2015年我开始从事前端工作，开始公司正在用QApp作为前端SPA框架，\n可是在我看来QApp比较笨重(130+KB)，另外还需要引入kami做组件(100+KB)，一直想找一个轻一点的框架代替，最后选择了riot.js(76KB)来代替这两个，主要基于以下几个需求。\n\n## 大量组件化的需求\n\nQApp的最小单位是View，也就是单一页面，而我接到的需求，要么是对某个按钮做改动，要么是连做几个页面，里面的某个输入框逻辑相同。QApp中的this指向View使得这些部分既不能从View里解构出来，对部分的修改也会造成挣个View的影响。\n\n* 以前的写法\n\n        QApp.defineView({\n            html: `\n            <div node-type=\"vcode\">\n                <input action-type=\"input\">\n                <button action-type=\"vcode\">发送短信</button>\n            </div>\n            <button action-type=\"submit\">提交</button>\n           `\n            actions: {\n                // 这里的this指向整个view\n                \"input:input\": () => this.doInput(),\n                \"submit\": () => this.doSubmit(),\n                \"vcode\": () => this.doVcode(),\n            },\n            init: {\n                doInput() {},\n                doSubmit() {},\n                doVcode() {},\n            }\n        });\n        QApp.config({...});\n\n* 新的写法\n\n        riot.tag('pay-input',`\n            <input oninput=\"oninput\">\n        `, ()=> {\n            // 这里的this指向整个pay-input\n        });\n        riot.tag('pay-submit', `\n            <submit ontap=\"onsubmit\">\n                <yield/>\n            </submit>\n        `, ()=> {\n            // 这里的this指向整个pay-submit\n        });\n        riot.tag('pay-vcode', `\n            <pay-input></pay-input>\n            <pay-submit>发送短信</pay-submit>\n        `, ()=> {\n            // 这里的this指向整个pay-vcode\n        });\n        riot.tag('pay-view',`\n            <pay-vcode></pay-vcode>\n            <pay-submit>提交</pay-submit>\n        `, ()=>{\n            // 这里的this指向整个pay-view\n        });\n        riot.mount('pay-view');\n\n## XX function is undefined\n\n报错邮件以前经常会有这样的报错，究其原因，很多是由“xxx功能”我不要了这种需求造成。\n\n* 之前的调用方式\n\n        QApp.defineView({\n            init: {\n                doSomething: ()=> {}// 删我貌似很困难\n                doSomethingElse: ()=>this.doSomething()\n            },\n            ready() {\n                this.doSomething();\n            }\n        });\n\n* 之后的调用方式\n\n        riot.tag('pay-view',`...`, ()=>{\n            this.on('doSomething', ()=> doSomething()); // 不要就删掉吧\n\n            this.doSomethingElse = () => this.trigger('doSomething');\n            this.on('mount', () => {\n                this.trigger('doSomething')\n            });\n        });\n\n## 基于状态基的异步流程处理\n\n其实2015年，是异步流程处理比较混乱的一年，Promise刚出来，没多少人敢用，\n更别提generator还有async之类的东西了，\n这套方案正好利用了发布订阅的优点，\n只要在异步事件触发之前订阅上就没问题了\n\n* 之前\n\n        QApp.defineView({\n            ...,\n            ready() {\n                this.ajax({\n                    ...,\n                    success() {\n                        foo(..., () => {\n                            bar( ..., () => {\n                                ...\n                            });\n                        })\n                    }\n                });\n            }\n        });\n\n* 之后\n\n        riot.tag('pay-view', '...', () => {\n            this.on('ajaxDone', () => {\n                ...\n                this.trigger('foo');\n            });\n\n            this.on('fooDone', () => {\n               ...\n               this.trigger('bar');\n            });\n\n            this.on('barDone', () => {\n               ...\n            });\n\n            this.on('mount', () => this.trigger('ajax'));\n        });\n\n## 利用组件树检索组件\n\n项目组件化（Component）+ 事件化（Reactive）之后，\n一个页面的运行方式就成为某一个组件监控某一个组件的某一事件并对其造成的处理。\n那么需要利用祖组件树解决一下检索问题。\n\n    require(\"pay-input\");\n    require(\"pay-submit\");\n\n    riot.tag('pay-vcode', `\n        <pay-input></pay-input>\n        <pay-submit>发送短信</pay-submit>\n    `, ()=> this.tags[\"pay-submit\"].on('subimit', () => {\n        this.trigger('vcodeSent');\n    }) );\n\n    riot.tag('pay-view', `\n        <pay-vcode></pay-vcode>\n        <pay-submit></pay-submit>\n    `, () => this.tags['pay-vcode'].on('vcodeSent', ()=> {\n        this.tags['pay-submit'].trigger('enabled');\n    }));\n\n\n* pay-view\n  * parent: null\n  * tags\n    * pay-vcode\n      * parent: pay-view\n      * tags\n        * pay-input\n        * pay-submit\n        * parent: pay-vcode\n      * pay-submit\n        * parent: pay-view\n\n## 利用mixin实现继承\n\necmascript2015之前，js一直都没有一个像样的类的表达方式，\n所以我们其实也没有一个像样的继承方式，\n混淆是目前用的最多的一种继承，大概是源自$.extend吧。\n\n* ajaxApi1\n\n        module.exports = {\n            init: {\n                this.on('ajaxApi1', () => ajax(...) );\n                this.on('ajaxApi1Done', ()　=> ... );\n            }\n        };\n\n* ajaxApi2\n\n        module.exports = {\n            init: {\n                this.on('ajaxApi2', () => ajax(...) );\n                this.on('ajaxApi2Done', () => ... );\n            }\n        };\n\n* pay-view\n\n        riot.tag('pay-view', '...', () => {\n            this.mixin(require('ajaxApi1.js'));\n            this.mixin(require('ajaxApi2.js'));\n\n            this.on('mount', () => this.trigger('ajaxApi1 ajaxApi2') );\n        });\n\n## 结合velocity和yield实现首屏渲染\n\n首屏渲染，SPA一直有这个问题。\n因为在html加载到js加载完成（甚至是一些ajax返回）之前，\n页面都是白屏，其实vm可以完成一部分后端的渲染，并替代第一个ajax。\n\n* vm之中\n\n        #set($description = \"这里会代替<yield/>\")\n        <pay-view>\n            <span if=\"$!description\">$description</span>\n        </pay-view>\n        <script>\n            window.vmData = \"$!vmData\";\n        </script>\n\n* js里面\n\n        riot.tag('pay-view', `\n            <pay-vcode></pay-vcode>\n            <pay-submit></pay-submit>\n            <yield/>\n        `, () => {\n            const vmData = window.vmData;\n        });\n\n## SPA的路由（忽略）\n\n## 视频地址\n\nhttp://v.youku.com/v_show/id_XMTUxMjMyMzM0OA==.html?from=s1.8-1-1.2&spm=a2h0k.8191407.0.0","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/05/04/1TypeScript.md","slug":"2017/05/04/1typescript","body":"# TypeScript干货\n\n## 类型化声明\n\n        const a:string = \"这是一个不可变的字符串\";\n        let b:string; // b只能赋字符串\n        let c:any; // c可以赋任一值\n        let d: () => void; // d只能赋空参数且返回为空的函数\n\n## 接口\n\n        interface Ia { foo: () => void; }\n        interface Ib { bar: () => string; }\n        interface Ic { name: string; }\n        class D { doSomeThing() { .... } }\n        class E implements Ia,Ib,D {\n            doSomeThing: () => any;// 如果实现的是类内元素，可以只声明，不实现\n            foo = () => {...} // 如果实现的是接口内元素，必须按照类型定义\n            bar = () => {...} // 必须把要实现的所有接口内的元素声明\n            constructor(param: Ic) {\n                const { name } = param;// param 必须是只含有name的对象\n            }\n        }\n\n## class语法糖\n\n        class a extends b {\n            constructor() {\n                super();//执行b的构造函数\n            }\n            public foo() {\n                super.foo();//执行b的原型上的foo函数\n                console.log(`\n                    我在ａ的prototype上\n                    this指向context\n                `);\n            }\n            public bar =　() => {\n                cosnole.log(`\n                    我在a的实例里,\n                    this指向a的实例\n                `)\n            }\n            public blaha = function() {\n                cosnole.log(`\n                    tslint默认禁止使用\n                    我在a的实例里,\n                    this指向context\n                `)\n            }\n        }\n\n## 装饰器\n\n类似于@tag,@mixin的东西，\n这个有点复杂，只说在class前面的装饰器吧,\n是用来处理对象原型的函数，\n会在构造函数执行结束后执行\n\n## Object解构\n\n        const obj = { a: 1 };\n        const name = \"name\";\n        const data = { ...obj, b: 2, name }; // { a: 1, b : 2, name: \"name\" }\n        const { a:xxx } = obj; // xxx===1\n        const data1 = {[xxx]: 'data1'}; // {1: 'data1'}\n\n## 一个更好的mixin\n\ntypescript对mixin支持很好，\n配合vscode的输入提醒代码体验十分完美，\n所以几乎可以放弃riot的mixin了\n\n* riot.mixin\n\n        // ajaxApi.js\n        {\n            init() {\n                this.on('ajaxApi', ()=> ...);\n            }\n        }\n        // xxxtag\n        riot.tag('xxx', '...', ()=> {\n            this.mixin(require('ajaxApi.js'));\n            this.trigger(\"ajaxApi\");\n        });\n\n* @mixin(any[])\n\n        class AjaxApi {\n            ajaxApi() {\n                ...\n            }\n        }\n\n        @tag({ name: \"xxx\", tmpl: \"...\" });\n        @mixin([AjaxApi])\n        class XxxTag extends TagCore implement AjaxApi {\n            onCreate( tag, opts ) {\n                this.ajaxApi();\n            }\n            ajaxApi: () => void;\n        }\n\n\n## async await 处理异步流程\n\n目前来说原生的Promise支持已经很不错了，\nasync虽然是个实验特性，\n但发明C#的微软明显推荐用这个特性。\n\n* 发布订阅\n\n        riot.tag('pay-view', '...', () => {\n            this.on('fooDone', ()=> this.bar());\n            this.on('barDone', ()=> this.blah());\n            this.bar = () => {\n                ...\n                this.trigger('barDone');\n            };\n            this.blah = () => xxx;\n            this.on('mount', () => this.trigger('fooDone'));\n        });\n\n* Promise\n\n        @tag({\n            name: \"pay-view\",\n            tmpl: \"...\",\n        });\n        class PayView extends TagCore {\n            onCreate(tag, opts) {\n                tag.on('mount', () => this.foo.then(()=> {\n                    return this.bar()\n                }).then(()=> {\n                    this.blah();\n                }));\n            }\n            foo = ()=> new Promise(resolve => resolve());\n            bar = ()=> new Promise (resolve => resolve())\n            blah = () => {...}\n            ...\n        }\n\n* async & await\n\n        @tag({\n            name: \"pay-view\",\n            tmpl: \"...\",\n        });\n        class PayView extends TagCore {\n            onCreate(tag, opts) {\n                tag.on('mount', async () => {\n                    await this.foo();\n                    await this.bar();\n                    this.blah();\n                });\n            }\n            foo = ()=> new Promise(resolve => resolve());\n            bar = ()=> new Promise (resolve => resolve())\n            blah = () => {...}\n            ...\n        }\n\n## 用TypeScript写一个Riot组件\n\n* html\n\n        <body>\n            <pay-view></pay-view>\n        </body>\n\n* ES5\n\n        require(\"pay-input\");\n        require(\"pay-submit\");\n        require(\"pay-vcode);\n\n        riot.tag(\"pay-view\", '<span>{ title }</span><pay-vcode></pay-vcode><pay-submit>提交</pay-submit>', function(opts) {\n            this.title = opts.title;\n            this.mixn(require('ajax1.js'));\n\n            this.trigger('ajax1');\n        });\n\n        riot.mount(\"pay-view\", {});\n\n* TypeScript\n\n        import {PaySubmit} from \"pay-submit\";\n        import {PayVcode} from \"pay-vcode\";\n\n        @tag({\n            name: \"pay-view\",\n            tmpl: `\n            <span>{ title }</span>\n            <pay-vcode></pay-vcode>\n            <pay-submit>提交</pay-submit>\n            `\n        })\n        @mixin([Ajax1])\n        class PayView extends TagCore implement Ajax1 {\n            onCreate(tag) {\n                tag.title = opts.title;\n                this.ajax1();\n            }\n            constructor() {\n                this.submit = new PaySubmit();\n                this.vcode = new PayVcode();\n            }\n            submit: PaySubmit;\n            vcode: PayVcode;\n            ajax1: () => void;\n        }\n\n        PayView.mount({});","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/05/04/2WebPack2-treeShaking-extTextPlugin.md","slug":"2017/05/04/2webpack2-treeshaking-exttextplugin","body":"# webpack2\n\n## tree-shaking（树摇）\n\nes6 module里面详述了树摇的的实现，但是webpack1始终没能实现，后来rollup实现了，于是大量框架转用rollup，去年webpack2发布，带来的就是这个tree-shaking功能。\n\n### AST树\n\n所有的代码，编译或者执行之前都会被转义成AST树，\n那么AST树是啥\n\n    let a;\n    let b = 1 + 1;\n\n* 代码\n    + 声明表达式\n        - let 声明\n        - 变量名 a\n    + 赋值表达式\n        - 加法运算\n            * 常量1\n            * 常量1\n        - 声明表达式\n            - let 声明\n            - 变量名 b\n\n### module的解析\n\n    // module a\n\n    export function foo() {...}\n    export function bar() {...}\n\n    // js\n\n    import { foo, bar } from a;\n\n    foo();\n\nwebpack会将代码解析成AST树，并发现bar并没有用过，就不会被打包进去。\n\n## extTextPlugin\n\n这是webpack的一个插件，可以解析出代码里面的css单独打包。这样css可以和组件放在一起了。\n\n    declare const require;\n    require(\"./style.scss\");\n\n    @tag({\n        name: \"pay-toast\",\n        tmpl: `\n        <div class=\"pay-toast\">{content}</div>\n        `,\n    })\n    export class PayToast extends TagCore {\n        public name: string = payToastConsts.name;\n        public onCreate(tag: ItoastTag, opts: ItoastRiotOpts) {\n            tag.update(opts);\n        }\n       public appendTag() {\n           const document = window.document;\n           const elem = document.createElement(this.name);\n           document.body.appendChild(elem);\n       }\n    }\n\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/05/04/3postcss-cssnext-cssnano.md","slug":"2017/05/04/3postcss-cssnext-cssnano","body":"# postcss干货\n\n上文说过，借助extTextPlugin可以把多个组件的css抽取成一个css，但webpack做的只是简单的文件拼接。处理css的地方要交给postcss。\n\n## cssnext\n\ncssnext使用caniuse.com的数据判断css需要支持到哪些浏览器，并自动做出可行的css解决方案（当然让ie6支持flex还是不行的）。\n\n    browsers: [\"> 0.1% in CN\", \"last 2 versions\"]\n\n登入 http://browserl.ist/ 可以查看上面的语句能支持的浏览器\n\n## cssnano\n\npostcss也是把css代码解析成ast树，解析之后可以看到冗余代码并对它进行压缩。\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/05/04/4Qxf-bigPipe.md","slug":"2017/05/04/4qxf-bigpipe","body":"# Qxf上的BigPipe的实现和优化原理\n\n![](http://i2.muimg.com/588926/2400354de719507f.jpg)\n\nQxf其实是express下的一堆中间件的集合，所以其实我在介绍express的BigPipe实现。\n\n简单的来说，当一个html开始下载的同时浏览器就开始渲染html了（而不是等html下载完成再渲染）。\n所以，返回给用户的页面可以一上一行地写出来（用我们学生时代老师的话来说就是挤牙膏）。\n\n## server => client (以前)\n\n1. 接到用户请求 => 白屏\n2. 请求接口，或者查数据库，处理数据，不拉不拉不拉 => 白屏\n3. 渲染出数据为state => 白屏\n4. 渲染模板为html => 白屏\n5. 返回html并结束请求 => 收到html并渲染，可能会下载css\n6. 空闲 => 下载js\n7. 空闲 => 渲染js，如果有ajax请求就请求\n\n## server => client (BigPipe)\n\n1. 接到用户请求 => 白屏\n2. 返回html的head => 收到head，下载css，核心js\n3. 请求接口，或者查数据库，处理数据 => 等待返回，如果有与UI无关的逻辑可以在下载完js后先执行\n4. 页面首部分的数据返回，生成state（组合成script标签） => 等待返回，如果有与UI无关的逻辑可以在下载完js后先执行\n5. 按照state生成模板一并返回，如果后面的接口也返回了数据重复3-5 => 渲染收到的html碎片\n6. 全部页面加载完成，结束请求 => 页面加载完成\n\n但是实际上按照BigPipe的做法，屏幕上面依赖的请求会阻塞，所以我对这一方案做了修改\n\n## server => client (BigPipe+)\n\n1. 接到用户请求 => 白屏\n2. 返回html的head + 按照默认state渲染的页面 + 默认state拼成的script标签 => 渲染出页面，下载css、js，js下载完成后可以操作了\n3. 请求接口，或者查数据库，处理数据 => 等待返回，或者直接操作页面\n4. 如果有接口返回，渲染出state并以script标签返回 => 根据收到的state二次渲染已经在dom树的组件\n5. 全部接口返回，结束请求 => 页面加载完成\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/05/04/5IsomophicApp.md","slug":"2017/05/04/5isomophicapp","body":"# Isomophic App\n\n如果你已经了解过前后端同构的话，你一定知道如下的方案\n\n    if (isServer) {\n        doServer();\n    } else {\n        doClient();\n    }\n\n那你看的文档应该都转发自同一个人。\n\n这种做法很有局限性\n\n* 你引用的module必须是umd打包的\n* 你引用的module必须不存在二进制包\n\n这回你知道为啥react要用全家桶了吧？\n\n## 换一种想法\n\n首先看一下node层和client层的不同点\n\n* node\n\n    接到用户Get请求 =>\n    node-fetch异步获取后端数据 =>\n    初始化Riot标签 =>\n    渲染页面为html =>\n    返回给用户 =>\n    收到接口元数据 =>\n    将元数据处理成state =>\n    以script标签形式返回用户 =>\n    res.end\n\n* client\n\n    收到渲染好的html并进行渲染 =>\n    加载js代码 =>\n    初始化Riot标签 =>\n    收到并运行script标签 =>\n    更新state =>\n    页面渲染完成\n\n可见，涉及到node像后端取数据并处理成state这部分逻辑是没必要加到client里面的，\n那么可以做两个文件实现node和client不同状态的处理。\n\n## 之前先介绍几个名词\n\n* 状态机存储器：　Store\n\n    ```new Store()```可以订阅```on```或者触发```trigger```几种事件，\n    没错```riot.tag```函数里面的```this```就继承自```Store```;\n\n* 广播控制器：　Control\n\n    是一个状态机的集合，方法```addStore```可以添加状态机存储器，\n    ```trigger```可以广播触发存储器的事件。\n\n* 标签生成器：TagCore虚基类\n\n* server.js\n\n        class RouteStore extends Store {\n            constructor(control) {\n                super()\n                this.on('apiFetched', () => ...)\n                this.on('serverStarted', () => ...)\n                ...\n            }\n        }\n\n        const control = new Control();\n        const routeStore = new RouteStroe(control);// 前后端不同的状态机\n        const someStore = new SomeStore(control);// 前后端一样的状态机\n\n        control.addStore(routeStore);\n        control.addStore(someStore);\n\n        const app = new App(control);\n\n* client.js\n\n        class ClientStore extends Store {\n            constructor(control) {\n                super()\n                this.on('DOMonLoad', () => ...)\n                ...\n            }\n        }\n\n        const control = new Control();\n        const clientStore = new ClientStore(control);// 前后端不同的状态机\n        const someStore = new SomeStore(control);// 前后端一样的状态机\n\n        control.addStore(clientStore);\n        control.addStore(someStore);\n\n        const app = new App(control);\n\n这样App、someStore这部分可以同构，clientStore和routeStore分别针对运行环境处理就可以了","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/05/04/6.md","slug":"2017/05/04/6","body":"# 项目完成情况\n\n## 封装完成但还没有上传npm\n\n1. QunarSniff中间件\n2. QunarLogin中间件\n3. TagCore，Control，Store\n4. fetch（用于合并请求，基于node-fetch）\n5. hysdk、QConfig-client-node， Qxf, PayGa 等的TypeScript封装\n6. 完成公用组件： yo-header, yo-logo, pay-toast\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/05/14/nas.md","slug":"2017/05/14/nas","body":"\n# 树莓派搭建 NAS\n\n好忙啊，写个大纲好了\n\n## 安装 RPI-Monitor\n\n## 安装吸血迅雷\n\n## Samba 共享文件\n\n## ssh 端口映射\n","collection":"blog","data":{"type":"post","category":"tech"}},{"id":"2017/05/15/Riot-Preact.md","slug":"2017/05/15/riot-preact","body":"# 弃坑Riot转投Preact\n\n![换个坑继续趟](http://i4.buimg.com/588926/431151959544ded0.jpg)\n\n## 回顾一下为什么用Riot\n\n### 1. 对ES5最友好的组件化MVP框架\n\n> 吐槽一下现在的前端，gulp + webpack + rollup +　babel + ... 用gcc的同学都看哭了好么\n\nriot.js虽然官网上给出的语法是ES6的，但是可以直接使用ES5的语法，虽然react也可以，但是没人会想用ES5写JSX吧。\n\n相比于其它框架，使用ES5的riot.js不用写gulpfile，不用谢webpack.config.js，不用写babelrc，想想，直接上去就开始写逻辑还是件挺爽的事情哈。\n\n当时公司大量使用Fekit作为发布工具，因为Fekit只是简单地commonjs实现，所以使用Riot.js就是件理所当然的事情了。\n\n### 2. 十分轻量的框架\n\nriot.js的源码70+KB，混淆之后是10+KB，大概一个handlebars或者是大一点的arctemplate的大小，里面包括组件化、observable的事件机制、路由器、SSR这些功能。\n\n用riot.js开发之后的逻辑代码（移动端）大小也没有比vue的核心代码库大。\n\n所以如果有一个项目想要快速开发，代码量又不想太大，riot.js会是我推荐的，而且不必担心性能问题（可以参考我之前vue、react和riot的对比，分明react是性能最差的）。\n\n之前写过riot.js的最佳实践，没在公众号里面推，后面补上哈～\n\n----\n<center>\n    <h3>蛋是</h3>\n    <h2>你还是一个好<s>人</s>框架</h2>\n    <h3>而我已经不是那个骚年了</h3>\n</center>\n\n---\n\n## Preact的出现\n\n去年我录制了一个Riot.js的分享视频（在youku可以搜到哦），Preact大概在那时出现在了hackernews的首页，我记得当时hackernews下面的回复都是很轻蔑的“呵呵，又一个“。\n\n等了大概一年，这个项目居然没死，要知道这一年很多类react的项目过得可不是那么好啊。这个项目的Twitter帐号都发会议邀请函了。\n\n## 那么引入Preact是为什么\n\n### 1. Typescript对JSX的支持好过template\n\ntypescript能够做静态类型检查，简单地说，如果我的代码里面有什么拼写错误或者什么包没引入，编译器都能查出来。\n\n蛋是，如果我写的代码在模板里面，编译器就无能为力了，毕竟模板就只是字符串啊。而jsx不同，它是一种DSL，编译器自然会检查里面的代码。\n\n### 2. Preact真的太TM小了\n\n当时使用riotjs的原因很大的比重在减负，在我的哲学里面，一个框架只需要完成我需要它完成的东西，其他的不要多。preact相比riot减负了大概50k（源代码），当然功能上也少了（observable，router）。\n\n### 3. 真的能堵住很多人的嘴\n\nPreact和React用的是同一套API，JSX语法又一样，用这套框架估计没有人吐槽难用了吧？（这一条真的很无力，好多人连react都没用过，就说我用一冷门框架不好维护，就像我用了react你就能来维护一样）\n\n## 所以我会用Preact吗？\n\n我会在最近的一次优化把我的项目进行优化改造，最后我在根据它的性能（ssr+browser）、最终的业务代码大小、是否可以多人合作开发等多方面分析考虑是否切换。\n\n当然，也有别的可能，毕竟当初说好用vim的我现在竟用着vscode。\n\n","collection":"blog","data":{"type":"post","category":"fe"}},{"id":"2017/05/21/Go-to-Luoyang-Summer-to-avoid-the-summer.md","slug":"2017/05/21/go-to-luoyang-summer-to-avoid-the-summer","body":"\n# 到洛阳避暑\n\n没错，题目就是这样，今年的北京天气可真不咋样，先是疯狂的柳絮，然后莫名其妙的刮起了多年不刮的沙尘暴，最可怕的是这个周末的温度直接飙升到 38 度。\n\n洛阳是我一直打算去的城市，我第一次去西安的时候，原打算是从洛阳返程，结果没想到被西安的人群吓到了，真的，之前我还没过那么多人。\n\n从北京到洛阳的火车票其实非常难买，我本打算清明节前往，但是因为忙活工作没来得及买票，去了大同。也不算是个坏事，我在大同博物馆了解到了一些北魏孝文帝南迁的故事，正好相当于预习了。\n\n我打算端午节去洛阳，可惜票也不好买，无奈选了这个周末，好在洛阳只有 30 度。\n\n## 晚点三个小时的火车\n\n我早早地下了班，因为我买的火车票是六点半的，其实我想买九点的票，可惜九点的票也没了。但这并不耽误我坐一辆九点的火车，因为我的火车晚点了两个小时。\n\n在火车上的一夜，我感觉这辆车一直在赶时间，最后当乘务员告诉我到洛阳的时间的时候，是八点半，比原计划晚了两个小时。\n\n出站，伴随着五环之歌的旋律，我找到火车站肯德基蹭了一会儿网，确定接下来的路线（我的全国流量已经用完了）。\n\n## 洛阳市博物馆\n\n洛阳火车站到市博物馆其实很好找，出站直走 3km 左右，右拐一个街区，再左拐穿过洛水（应该是洛水）就是了。我找到一辆 ofo，这么好找的路我觉得没必须要依靠更高端的设备，然而我错了，路途中我碰到了天子六驾广场，我意识到我拐早了，因为当时定路线的时候显然不应该到这里。\n\n天子六驾，其实是个车马坑，就是周天子当时的礼仪，没啥好看的，是我第一个从行程上划掉的地方。到门口，我叹了口气又继续到我原定的目的地去了，话说洛阳的电动车还真多，我一下子认识了好多品牌，鉴于他们都没给我赞助我就不提了。\n\n经过多次误打误撞，我终于到了博物馆。洛阳市博物馆新馆貌似在新区，周围一片拆迁或者城镇，我也不敢往里走，大概 6 公里左右的行程我骑了一个小时。\n\n洛阳市博，门口一个大柱子，我猜一下，应该是个地动仪雕塑，也许我猜错了，内部是两层。一楼和很多博物馆一样，是此地的历史介绍，毕竟从夏开始，帝王们就开始在洛阳建都，从茅草屋，到巍峨的木构。史书上把这些地方描述的宏伟大气，可惜现在看到的，只有那些建筑的基址了。\n\n一个有趣的设计，前文提到，北魏孝文帝从平成（大同）搬迁到洛阳，装修洛阳城，设计了这个城的中轴线（都说是中轴线，但我看来明显偏好多），一条大路从龙门直接连上了邙山上东汉光武帝的墓。现在这条路貌似还在，其实更像是巧合，一千年过去了，这个老城在地理上移了位置，就连新城也相对那时旋转了几度。但是链接邙山和龙门的路竟然还在，定鼎路，只不过这回，链接刘秀的墓和龙门是一个 Z，或者是个手写的大写 I。\n\n## 洛阳古墓博物馆，闭馆，sad\n\n古墓博物馆其实我一直想去，就是东汉光武帝的墓，后来原址上有很多唐墓和宋墓。其实国内有很多墓地是可以观光的，不过这个貌似是唯一一个可以进墓穴的，据说内部复原了汉、唐、宋时期的墓穴。\n\n遗憾的是这一天它断电了（哭）。由于在邙山上，骑车上去很痛苦，但下来就爽了。另外说说公交，虽然我看到了公交站，但我并没有遇到过公交。。。\n\n## 明堂和天堂遗址（强烈不推荐）\n\n来洛阳之前，我特别看了一下央视的纪录片，貌似叫《天地洛阳》。纪录片介绍过明堂，就是祭祀场所一样的地方，职责类似于，或者就是北京的天坛，武周时是 96m，我的天，平原立起来一个将近 100m 的木头，果然招雷劈，不久毁于大火，然后有重建了。当时弹幕飘过，说明堂已经重建，据说跑男还去拍过节目。\n\n新的天堂在洛阳还是蛮高的，跟旁边的电视塔遥相辉映，很像慈寿寺和北京电视塔的感觉，或者加一点想象力，像《攻壳机动队》里面的日本。突然想起来，日本很多城市就是照搬洛阳，日本的历史对洛阳的描绘也衬得上神都了，虽然我在洛阳看到的日本人并没有西安得多。\n\n这些东西还都是想象，来洛阳之前，我曾梦过这个古城，我会找一个古城内的青旅，我会在日出之前赶到屋顶，远远地看到明堂那面的灯光和星空相映。这些泡影全在我到了洛阳破灭。\n\n明堂在外面看看可以尽情想象，进去之后，就是一个无比俗气堂皇的大殿。所谓的大唐表演，就好像大学话剧团的表演，里面确实有介绍唐朝生活的部分，但是莫名其妙，本来还在说武器，突然就讲起来女人的发髻。八角形的建筑最难做展览，因为进去像迷宫一样，果然如此，我的体验就是每进一个门，都是个挑战，你不知道这屋子你进没进去过，还是特么的就是个出口，再提一个尴尬的事情，如果你出去了，就别想回来，景区里面的每个楼（其实就两栋）都只能进去一次，我和天堂门口的服务员理论了半天，她才放我进去，只因为我进去之后啥也没看着就莫名其妙地出来了。\n\n我很怀疑明堂和天堂的重构者是否是清华大学建筑系的，这两栋建筑简直是利用钢筋混凝土完美的把木构建筑的一切缺点实现了。\n\n另外提一下，逛完天堂，夜色已完，景区内的灯居然都灭了，留下来的只有里面的游乐场的灯光和跑男的广告牌。。。\n\n## 丽景门\n\n回到古城区，丽景门和前面的老街还热闹着。我看门上还有人游览，便买了票。不太清楚丽景门是不是复建的建筑，城墙都貌似是水泥铸好然后画的缝。但是上面还是有一个寺庙，还是个木构，我有点迷惑。但我并不多想，经过明堂那次糟糕的经历，我只想让新的感受把无奈覆盖掉。\n\n丽景门夜景很美，上面还有很多洛阳老氏族的来历，外面还有几个接头艺人唱着民谣，很好奇他们为什么没串味。\n\n## 安喜门青旅楼上\n\n我还是大清早到了青旅楼上，装饰很有感觉，这里是一只猫的地盘，我和它周旋很久才没让它进屋吹空调。\n\n## 龙门石窟\n\n还是定鼎路，只不过在另一个方向上，大概一个小时的车程到达目的地，我在网上订了电子导游。遗憾的是景区 WiFi 永远连不上，我还租了一个导游器。\n\n龙门石窟，作为四大石窟之一，其实招我体验，我感觉是最差的一个（当然我更喜欢硬朗的雕塑线条和更有故事性的内容）。也许是因为太出名了，破坏也是最严重的。\n\n保存最好的，是庐舍娜大佛，或许破坏的也不轻，毕竟人家以前是有房人士。旁边的迦叶，感觉像没雕完，或者被破坏了，或者当时就想雕成这样，毕竟是苦行僧嘛。然而讲解器没讲，旁边的导游也没说。\n\n龙门石窟主要是西山石窟很多，河对岸东山上也有几个石窟，联票里面有，我就游览了几个。另外联票里面还有香山寺、白园（跟白居易有关），蒋宋故居（民国时期的地区谄媚中央工程，估计蒋介石都没住过多久）。\n\n回去的路上有龙门石窟博物馆，时间还有富余，我便游览了几分。博物馆四层，负二层错乱的摆着很多石窟里面或是已经破坏、或是修复的时候发现的墓碑之类的石刻。负一主要是丝绸之路的展品。一二层有一些追回的石窟像，也找不到原来的佛位，或者是复原不了就放到这里了。\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2017/05/28/Second-screen.md","slug":"2017/05/28/second-screen","body":"# 第二块屏幕\n\n作为一个前端程序员，13寸的屏幕显然不够工作，尤其是当你写代码的时候还想看美剧的时候。\n\n我有一个屏幕，15寸的联想800x600 VGA屏幕，以前为了玩树莓派在旧货市场淘来的，分辨率实在太低了。如果连我家的投影的话，为了使用自由，我只会使用无线连接，但是linux下面还没有一个完备的无线连接方案。\n\n## 拆掉我的旧电脑\n\n年前我提到过，我把我的老电脑拆了，硬盘用来接树莓派，当然我也把屏幕拆过来了。我在淘宝上搜了一下五合一屏幕驱动板，加上电源大概100块搞定，卖家比较热心，问好型号之后整块驱动板基本上是连接好就寄过来了。\n\n## 做一个比较好的壳\n\n基本上只能拿垃圾做一个壳了，在北京的家里面，没有螺丝，所以我只能把驱动板缝在巧克力盒包装上。大概如图（如果我传图了）。\n\n## linux处理第二块屏幕\n\n其实连接好屏幕就可以玩了，但是由于我的笔记本是4K的，老屏幕虽然是14寸，但其实只能显示我现在笔记本的1/4.需要xrandr处理缩放。\n\n    xrandr --output eDP1 --auto --scale 1x1 --output DP1 --auto --scale 1.8x1.8 --right-of eDP1\n\n> 为什么不是 2x2 ? 其实我尝试过，可是很快就能挂掉，所以我改成 1.8x1.8 \n\n还有一个bug，屏幕虽然能够显示了，但鼠标能够控制的地方还是1/4。ArchWiki里面说是一个bug，看了一下。貌似还没解决。。。\n\n好吧，最后我选择了妥协，毕竟已经可以美美哒地看美剧了～\n\n---\n\n<p style=\"float:right;\">\n宫不上，2017/05/28【端午节】，在北京9㎡的家中。\n</p>\n","collection":"blog","data":{"type":"post","category":"tech"}},{"id":"2017/05/29/Conquest-Line-2.md","slug":"2017/05/29/conquest-line-2","body":"\n# 征服二号线\n\n去年我征服十号线的时候，最后一句说如果有机会还是考虑一下二号线吧，所以这把我就来征服二号线了。\n\n开始是听《壁下观》说积水潭医院以前是棍贝子府，现在后花园还在，所以我就去看了一眼，后来大概就是我到了德胜门，然后就想干脆跑一圈吧，所以跑了一圈。\n\n![](http://wx2.sinaimg.cn/mw1024/89d0a2e1ly1fg2lvsu9qaj20qo0qojvb.jpg)\n\n## 一路上\n\n西直门北面是长河+北京北站，所以从北面跑到 1 西直门简直是噩梦；\n\n积水潭医院中心是棍贝子府的后花园，挺不错的下沉花园，不知道当初是不是这么设计的；\n\n德胜门到鼓楼全是人，主要是南锣鼓巷和五道营的游客，但是有林荫路可以跑；\n\n从鼓楼到北京站中间基本上没有多少卖水的，全是大饭店和银行；\n\n北京站北面是建国门，我总算找到了一家麦当劳，吃了新推出的那么大甜筒，真心不好吃；\n\n建国门有古观景台，门票 20，手机快没电了，没去；\n\n从建国门到东交民巷是最好跑的，人少，其实是因为前面是天安门，人都在那儿呢；\n\n前门比较混乱，因为还在修地铁，游客也很多，再加上天安门封路，差点出不来；\n\n前门往西都是北京最破的胡同，但是谁让人家地价高呢；\n\n西便门有一个明城墙遗址，有点西安城墙的意思，但是小的可怜，上面有个石观音像；\n\n西便门往北都是居民，路过月坛就快到终点了。\n","collection":"blog","data":{"type":"post","category":"travel"}},{"id":"2017/05/30/sad-WPS4linux.md","slug":"2017/05/30/sad-wps4linux","body":"# sad,WPS4Linux停止开发\n\n默哀三分钟","collection":"blog","data":{"type":"post","category":"tech"}}]}