{"posts":[{"id":"2020/02/01/Summary-and-February-Plan-in-January.md","slug":"2020/02/01/summary-and-february-plan-in-january","body":"\n# 一月总结和二月计划\n\n话说这个月吃瓜不少。\n\n1. 长江白鳍豚灭绝\n2. 澳洲大火\n3. 戈恩逃离日本\n4. 川普一炮炸了伊朗二号人物\n5. 湾湾大选\n6. 伊朗炸加拿大飞机，伊朗道歉\n7. 患者家属砍死医生，医院道歉\n8. 木兰编程语言抄袭，实验室道歉\n9. 警方诬告 8 名医生造谣 SARS 传播，没有道歉\n10. 中美贸易协议签订\n11. 冠状病毒爆发\n12. 英国正式脱欧\n13. 人民网半夜带货双黄连\n\n不说气人的了，谈谈自己的事情。\n\n## 一月总结\n\n这个月我的生活也很充分\n\n1. 个人网站域名通过 Cloudflare 转发，但是备案没通过，算了，以后放点实验性的东西好了。\n2. 看了巴黎圣母院歌剧。\n3. 完成三本书「Website Scraping with Python」「rust 编程之道」「Unity 游戏设计与实现」\n4. 完成美剧爬虫上线 scrapinghub\n\n一月发现的新事物\n\n1. YouTube 栏目，老高&小茉，将一些奇闻异事很有趣，晚上烦的时候看一看很轻松。\n2. YouTube 栏目，自说自话的总裁，很有个人观点的历史频道。\n3. 网站[田间小站](https://www.tianfateng.cn/)，英语资源站。\n4. monect 键盘鼠标模拟器。\n\n## 二月计划\n\n1. 我的蛋白粉没了。\n2. 要整理出来一篇 Windows 下面开发 scrapy 爬虫（并单元测试）\n3. 使用 rust 开发前端页面\n4. 写第一个 flutter 应用\n5. 空闲时间整理一下旅游计划\n6. 报名 4-5 月雅思考试\n","collection":"blog","data":{"type":"post","category":"plan"}},{"id":"2020/02/04/Powershell-Windows.md","slug":"2020/02/04/powershell-windows","body":"\n# 用 Powershell 更新 Windows\n\n发现已经半个月没有被 Windows 更新打扰了，原来是一个累积更新挂了，我发现在图形界面下面怎么更新都失败，于是寻思在命令行执行。\n\n在 powershell 中有一个包 PSUpdateWindows 可以派上用场。\n\n```powershell\nInstall-Module PSUpdateWindow\n\nGet-WindowsUpdate #下载更新\n\nInstall-WindowsUpdate #安装更新\n```\n","collection":"blog","data":{"type":"post","category":"tech","tag":["powershell"],"series":{"slug":"windows-howto","name":"Windows舒适指南"}}},{"id":"2020/02/04/Windows-scrapy.md","slug":"2020/02/04/windows-scrapy","body":"\n# Windows 上使用 scrapy 抓取网页\n\n过去一周，我在尝试在 Windows 上面使用 python，我会在这一篇文章中总结一下这一次体验的经验，代码已经发布到[GitHub](https://github.com/gongbaodd/webScrapingStudy)上面。\n\n## 安装 python\n\n本身 python 的版本就比较混乱，Windows 又提供了商店版，而且 WSL 下面也可以安装 Linux 的 python，我都体验了一下。\n\n- Windows 商店版，这个貌似就是为了教学使用，因为 Windows 目前比较尴尬，全局安装的包可能会有兼容性问题，但是因为商店版都运行在沙盒之下，基本上就没多少修改的可能了。\n- WSL 版本，这个版本体验的是纯正的 Linux，但是一定要注意，如果没安装 Xserver 就相当于没有图形界面。\n- x64 版本，这个问题在于安装文件的地址都跟了个 x64。\n- win32 版本，这个版本的问题比较小，除了 pyenv 需要单独下载 Windows 版和[jupyter 报错](https://gongbaodd.github.io/tech/2020/01/06/%E4%BF%AE%E5%A4%8DWindows%E4%B8%8B%E6%89%93%E5%BC%80Jupyter%E6%97%B6%E6%8A%A5NotImplementError.html)，还没碰到其他问题。\n\n## pyenv\n\n介于 python 大版本兼容性，个人认为要安装一个版本管理器。因为习惯于 JavaScript 工作环境，我肯定会寻找类似于 nvm 的映射就是 pyenv，在 Windows 下面可以通过 chocolatey 安装。\n\n```shell\nsudo choco install pyenv-win\n```\n\n下面几个命令是最常用的。\n\n- `pyenv install -l`查看可以安装的 python 版本号。\n- `pyenv local install 3.8.0`在项目中安装 3.8.0 版本（会在项目目录增加.python-version 文件）。\n- `pyenv version`查看现在的 python 版本。\n- `pyenv versions`查看安装过的 python 版本。\n\nwin10 上了一个新功能，控制台会引导 python 到应用商店，在“设置>应用和功能>应用执行名”中可以勾掉这个功能\n\n## virtualenv\n\npython 的包管理其实很差，都是放到 global 下面，这就导致多个项目可能都用同一个依赖。那么如何实现每个项目都有自己的依赖呢？这就靠 virtualenv。\n\n```shell\npip install virtualenv\n```\n\n如下命令最常用\n\n- `virtualenv [venv folder name]`新建虚拟环境文件夹。\n- `source [venv folder name]/Scripts/activate`启动虚拟环境（在 Linux 下面是 bin/activate）。\n- `deactivate`关闭虚拟环境（这个在 Linux 会比较常用）。\n\n## scrapy\n\nscrapy 是一个 python 的爬虫框架，使用 pip 可以安装 scrapy。\n\n```shell\npip install scrapy\n```\n\n下面是 scrapy 用的比较多的几个命令\n\n- `scrapy startproject [project name]`新建项目。\n- `scrapy crawl [spider name] -o [output file]`爬取页面并输出结果到文件。\n\nscrapy 的概念比较多，包括 spider、pipeline、middleware 等等，但个人看来基本上看完[tutorial](https://docs.scrapy.org/en/latest/intro/tutorial.html#our-first-spider)就可以上手了。\n\n### scrapy shell\n\n执行`scrapy shell [url]`可以以命令形式使用 scrapy。\n\n- `fetch('http://xxx.com')`爬取页面\n- `view(response)`浏览爬取的页面\n- `response.css('a::text').extract()`析取页面中链接的文字列表\n- `response.css('a::attr(href)')`析取页面中链接列表\n\n### 发起 Xmlhttp 请求\n\n使用[Scrapy.FormRequest](https://docs.scrapy.org/en/latest/topics/request-response.html#scrapy.http.FormRequest)发起请求，接收到结果可以使用[response.body_as_unicode()]解析 JSON 为字典。\n\n### splash\n\n截至目前，scrapy 都只能渲染非 JavaScript 运行的页面，但是借助 splash 就可以解析 JavaScript 了。我们使用 docker 可以尝试一下 splash。\n\n```shell\ndocker pull scrapinghub/splash\ndocker run -p 8050:8050 scrapinghub/splash\n```\n\n访问 localhost:8050 即可访问 splash。通过安装`scrapy-splash`可以在 scrapy 中使用 splash，具体安装步骤[官网](https://github.com/scrapy-plugins/scrapy-splash)已经很详细在此不做赘述。\n\n## Scrapinghub\n\nScrapinghub 是一个基于 scrapy 的云服务，可以将自己的爬虫部署到该平台。[这里](https://support.scrapinghub.com/support/solutions/articles/22000200667-running-a-scrapy-spider)有个工具可以帮助部署（当然通过链接 GitHub 可以做到 master 部署）。\n\n```shell\npip install shub\n```\n\n### 解决依赖\n\n爬虫上传到 Scrapinghub 之后，会部署失败，可能源于以下两点。\n\n- scrapinghub 使用的是 python2\n- 部份依赖没有安装\n\n以上两点可以通过修改 scrapinghub.yml 完成\n\n```yaml\nprojects:\n  default: 427692\nstacks:\n  default: scrapy:1.8-py3\nrequirements:\n  file: requirements.txt\n```\n\n通过`pip freeze`能够列举出目前环境下的所有包，需要挑出可能缺少的依赖写在 requirements.txt 里面（没错这一步只能人工完成，不要妄想把所有包都写进去）。\n\n```\nbeautifulsoup4==4.8.2\nfeedparser===5.2.1\nscrapy-splash==0.7.2\n```\n\n## 单元测试\n\n使用 python 自带的 unittest 模块以及 pytest 可以对代码进行单元测试。可以参考我代码中的[测试](https://github.com/gongbaodd/webScrapingStudy/tree/master/test/test_spider)。\n\n执行 pytest 的时候会出现找不到模块的问题，可以按照如下方式重置根地址位置。\n\n```\npython -m pytest [file path]\n```\n\n## 代码优化和格式化\n\n这里比较爽了，如果用的是 vscode，在第一次格式化代码的时候，vscode 就会安装格式化工具。\n\n## pre-commit\n\npre-commit 是一个 git 钩子工具，简单说，当本地代码不满足要求的时候，利用这个工具自动格式化代码或者阻止用户提交代码。可以参考[官网配置](https://pre-commit.com/)。\n\n## 包健康检查\n\n目前没在 python 找到一个类似于 yarn audit 的东西，到那时找到了一个[SNYK](https://snyk.io)是一个跨语言的包健康检查工具，但是貌似还有 bug，暂时先裸奔好了。\n\n## 持续集成\n\n目前我是用 Travis 做集成，配置文件可参考[此文件](https://github.com/gongbaodd/webScrapingStudy/blob/master/.travis.yml)。\n\n## 兼容性处理\n\n另外还找到一个 python 版本兼容测试工具，考虑到使用 python 命令的人自己的 python 版本并不确定，[tox](https://pypi.org/project/tox/)则是用来测试 py 是否兼容某些 python 的版本。\n","collection":"blog","data":{"type":"post","category":"tech","tag":["scrapy","python"]}},{"id":"2020/02/06/git-CRLF-LF.md","slug":"2020/02/06/git-crlf-lf","body":"\n# Git 中的 CRLF 和 LF\n\n跨平台开发的时候，如果是在 Windows 下面上传代码，git 会提醒部分文本文件的 CRLF 会改为 LF。\n\n原因是在 Windows 下面，文本文件会以 CRLF（回车换行）结尾，而 Linux 和 Mac 会以 LF（换行）结尾。其实想想打字机，回车换行是一个正确的做法，但是为了保持兼容性，git 会把 Windows 上传的 CRLF 都改成 LF。\n\n如果只在 Windows 下面开发，可以关掉这个功能。\n\n```shell\ngit config --global core.autocrlf false\n```\n","collection":"blog","data":{"type":"post","category":"tech","tag":["git"]}},{"id":"2020/02/09/1917.md","slug":"2020/02/09/1917","body":"\n# 电影补档计划：1917\n\n![1917](https://img1.doubanio.com/view/photo/l/public/p2570243317.webp)\n\n一战时期英国两名士兵接到命令去前线停止一场冲进圈套的进攻的故事。\n\n故事肯定是比较感人了，长镜头的运用说实话，如果没有对比，完全没意识出来...\n","collection":"blog","data":{"type":"post","category":"movie"}},{"id":"2020/02/10/actix-web-rust-web.md","slug":"2020/02/10/actix-web-rust-web","body":"\n# 利用 actix_web 使用 rust 编写 web 应用\n\n最近我一直在实践 rust 相关的内容，本来想写一篇类似于[scrapy 的文章](http://gongbaodd.github.io/tech/2020/02/04/Windows%E4%B8%8A%E4%BD%BF%E7%94%A8scrapy%E7%88%AC%E7%BD%91%E9%A1%B5.html)，后来发现内容有点多，仅仅一篇文章兜不住，干脆写一个系列好了。\n\n## 使用 Rust 的工具\n\n### rustup\n\n使用 chocolatey 安装，安装好以后只是处理好了 rustup，后面的工具链还要用再次处理。\n\n```shell\nchoco install rust\n```\n\n关于 rustup 的使用，可以查看[文档](https://github.com/rust-lang/rustup/blob/master/README.md)，包括如何做交叉编译都可以使用这个工具完成。\n\n```shell\nrustup toolchain install stable-msvc\n```\n\n### crates.io\n\n[crates.io](https://crates.io/) 是 rust 的模块库，没啥可说的。\n\n### cargo\n\ncargo 是 rust 的包管理工具。以下是几个 cargo 经常使用的命令。\n\n- `cargo new [project name]`，新建一个项目。\n- `cargo init`，初始化一个项目。\n- `cargo clean`，清理编译文件（相信我，这个会经常用）。\n- `cargo run`，编译并运行 main 文件。\n- `cargo run --bin [helper file name]`，直接执行 bin 文件夹下的文件。\n- `cargo build`，编译文件。\n- `cargo install [tools name]`，安装工具。\n\n### cargo-edit\n\n执行`cargo init`之后，项目根目录会生成一个`Cargo.toml`文件本项目的依赖模块都会放到这里，然而手动编写这个文件对于像我这样的懒人显然是无法接受的。因此可以借助`cargo-edit`完成。\n\n```shell\ncargo install cargo-edit\n```\n\n记住`cargo-edit`如下命令即可。\n\n- `cargo add [module name]` 安装一个模块。\n- `cargo rm [module name]` 删除一个模块。\n\n## rust 项目结构\n\n```shell\n- Cargo.toml\n- Cargo.lock\n- src\n-- main.rs # 项目入口文件\n-- lib.rs # 如果作为封装成一个crate，这里配置可以暴露的模块\n-- bin/ # 项目工具文件\n--- helper.rs\n```\n\n## 语法速记\n\n### 函数\n\nrust 的函数还比较有趣，它的`return`关键字是默认省略的，如果这个函数没有中断，这个函数的最后一行就是返回值，且这一行不带分号。\n\n```rust\npub async fn index() -> impl Responder {\n    format!(\"hello\")\n}\n```\n\n如果这个函数没写返回值，其实编译器还会让这个函数返回一个`()`。\n\n```rust\nfn main() {\n    println!(\"hello world\");\n    () // 此处不加()编译器还是会默认理解为返回()。\n}\n```\n\n这么做确实比较符合函数编程的概念，但是一般 rust 库里面的函数都会返回 Result 或者 Option 类型，就用 Result 类型做例子，一般会有四种处理方式。\n\n```rust\nlet bar = foo().expect(\"Panic!\"); // 直接中断程序\nlet bar = match foo() {\n    Ok(value) => Some(value),\n    Err(_) => Some(someError)\n}; // 通过match判断处理错误， 类似于其他语言的switch-case\nlet bar = foo()?; // 把错误处理交给bar\nlet bar = foo().unwrap_or(); // 成功返回成功值，失败返回unwrap_or的值\n```\n\n### 模块\n\n通常想要使用一个模块，只需要使用`use`关键字。\n\n```rust\nuse std::env;\n\nfn main() {\n    let db_url = match env::var(\"DB_URL\") {\n        Ok(_) => { \"OK\".to_owned() }\n        Err(_) => { \"Err\".to_owned() }\n    };\n\n    println!(\"{}\", db_url);\n}\n```\n\n如果引用的这个包是个非 rust 标准包（一个 crate，这里说的是我的理解，如果有个官方中文说法，以它为准），需要在添加`extern crate`关键字，如果还引用了宏，还要加上`#[macro_use]`（这就比较坑了，我哪知道到底用没用上宏，所以一般我都靠编辑器帮我编译一下...）。\n\n```rust\n#[macro_use]\nextern crate log;\n\nfn main() {\n    info!(\"debug\")\n}\n```\n\n如果只是引用本项目相对地址的文件，使用`mod`关键字就好，可以看我的[actix_log](https://github.com/gongbaodd/rust_webAssembly_study/tree/master/actix_log)。\n\n#### 为啥 rust 的模块这么复杂\n\n我猜测毕竟 rust 是对标 C 语言的，相比于很多高级语言的链接工作是在虚拟机里面做的，rust 则全部下放到语言里面，所以一起用起来就会比较复杂。\n\n## trait\n\ntrait 是 rust 上面的一个新概念，类似于 JS 的 mixin 和 Java 的接口，后面我会按例子来讲。\n\n很多库的 trait 需要单独引用，否则会编译失败，这些库往往会封装成一个 prelude 使用。\n\n```rust\nuse gtk::prelude::*;\n```\n\n## rust command\n\nrust 是个系统级语言，可以互相访问其他程序语言分享的堆内存空间，FFI 依靠的是 Box，但是本篇暂时不提及，这个[代码](https://github.com/gongbaodd/rust_webAssembly_study/tree/master/command)实现的是读取并处理其它语言的 std 输出。\n\n## Actix_web\n\n[actix-web](https://actix.rs/)是 Rust 的 web 框架之一，试用了一下，很好上手，有一点 Express 的味道。\n\n```shell\ncargo add actix-web\ncargo add actix_rt\n```\n\n官网首页的例子即是一个简单的应用。\n\n```rust\nuse actix::{\n    web,\n    App,\n    HttpServer,\n    Responder,\n    HttpRequest,\n};\n\nasync fn greet(req: HttpRequest) -> impl Responder {\n    let name = req.match_info()\n        .get(\"name\")\n        .unwrap_or(\"World\");\n\n    format!(\"Hello {}!\", name)\n}\n\n#[actix_rt]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new(\n        || {\n            App::new()\n                .route(\"/\", web::get().to(greet))\n                .route(\"/{name}\", web::get().to(greet))\n        }\n    )\n    .bind(\"127.0.0.1:8080\")?\n    .run()\n    .await\n}\n\n```\n\n当然，如果觉得路由的部分比较难写，还可以使用宏来修改。\n\n```rust\n#[get(\"/\")]\nasync fn greet(req: HttpRequest) -> impl Responder {\n    let name = req.match_info()\n        .get(\"name\")\n        .unwrap_or(\"World\");\n\n    format!(\"Hello {}!\", name)\n}\n\nApp::new().route(greet);\n```\n\n### 利用中间件处理日志和错误\n\nlog 和 env_logger 是 rust 的日志工具，基本上都是宏。\n\n```\ncargo add log\ncargo add env_logger\n```\n\nactix-web 使用 wrap 方法添加中间件，如添加 Logger 打出标准访问日志。\n\n```rust\nuse actix_web::middleware::Logger;\nasync fn main() -> std::io::Result<()> {\n    std::env::set_var(\"RUST_LOG\", \"actix_web=info,info\");\n    env_logger::init();\n\n    let url = \"127.0.0.1:8080\";\n    let app = || {\n        App::new()\n            .wrap(Logger::default())\n            .wrap(Logger::new(\"%a %{User-Agent}i\"))\n            .wrap(middleware::DefaultHeaders::new().header(\"X-Version\", \"0.2\"))\n            .wrap(ErrorHandlers::new().handler(http::StatusCode::INTERNAL_SERVER_ERROR, render_500))\n            .service(routes::index::index)\n    };\n\n    let server = HttpServer::new(app).bind(url);\n    let wait_server = server?.run();\n\n    info!(\"Running Server on {}\", url);\n    wait_server.await\n}\n```\n\n错误处理，详细代码可以查看[actix-log](https://github.com/gongbaodd/rust_webAssembly_study/tree/master/actix_log)。\n\n```rust\nfn render_500<B>(mut res: dev::ServiceResponse<B>) -> Result<ErrorHandlerResponse<B>> {\n    res.response_mut().headers_mut().insert(\n        http::header::CONTENT_TYPE,\n        http::HeaderValue::from_static(\"Error\"),\n    );\n    Ok(ErrorHandlerResponse::Response(res))\n}\n```\n\n### 使用 serde 返回 JSON\n\n想要制作 Restful API，JSON 支持是少不了的。\n\n```shell\ncargo add serde\n```\n\n由于 actix-web 对路由回应格式的支持，一个 json 文件可以这么写。\n\n```rust\nuse acrix_web:{\n    HttpResponse,\n    Responder,\n    get,\n};\nuse serde::{\n    Serialize,\n    Deserialize,\n};\n\n#[derive(Serialize, Deserialize)]\nstruct MyObj {\n    message: String,\n}\n\n#[get(\"/hello\")]\nasync fn hello() -> impl Responder {\n    HttpResponse::Ok().json(MyObj {\n        message: \"SUCCESS\"\n    })\n}\n\n```\n\n更多详细的代码可以查看我的[github](https://github.com/gongbaodd/rust_webAssembly_study/tree/master/actixweb)。\n\n## diesel 处理 ORM(sqlite)\n\n强烈安利大家去看一下 diesel 的[Get Start](http://diesel.rs/guides/getting-started/)，确实是一种下一代 ORM 的感觉。\n\n```shell\ncargo add diesel\n```\n\n### diesel_cli\n\ndiesel_cli 是 diesel 的命令行工具，提供数据部署和 schema 生成的功能，如果不指定 feature 的话，安装时会同时编译 sqlite、postgreSQL 以及 MySQL。\n\n```shell\ncargo install diesel_cli --no-default-features --features sqlite\n```\n\n第一次编译的时候，在 Windows 下面失败了，翻了一下[issue](https://github.com/diesel-rs/diesel/issues/487)找到了解决方案。\n\n首先安装 Visual Studio（反正现在免费安），使用 VS 的终端打开 sqlite 文件夹。\n\n```batch\ncd C:\\ProgramData\\chocolatey\\lib\\SQLite\\tools\nlib /def:sqlite3.def /out:sqlite3.lib\n```\n\n然后记得把`C:\\ProgramData\\chocolatey\\lib\\SQLite\\tools`放到环境变量 PATH 里面。\n\n再次编译即可，具体如何使用 diesel 的 get start 已经足够了，在此不做赘述，可以查看[源码](https://github.com/gongbaodd/rust_webAssembly_study/tree/master/diesel_demo)。\n\n这里列举一下经常用的命令\n\n- `diesel setup` 初始化。\n- `diesel migration generate [step name]` 生成 down.sql 和 up.sql。\n- `diesel migration run` 按照 SQL 文件部署数据库和 schema 文件（目前发现一个 bug，生成的 schema 不完全，没能完全复现）。\n- `diesel migration revert` 撤回数据库操作。\n\n### 补充一下 rust 语法里面的生命周期\n\ndemo 里面的 lib 文件 create_post 语法很奇怪。\n\n```rust\npub fn create_post<'a>(conn: &SqliteConnection, title: &'a str, body: &'a str) -> usize {\n    use schema::posts;\n\n    let new_post = NewPost {\n        title: title,\n        body: body,\n    };\n\n    diesel::insert_into(posts::table)\n        .values(&new_post)\n        .execute(conn)\n        .expect(\"Error saving new post\")\n}\n```\n\n`<'a>`的写法是指明函数的生命周期标注，因为 rust 没有垃圾回收机制，所有申请的堆内存在一个函数执行结束后就会回收。所以当一个函数的输入值是堆内存的变量，就发生「借用」，如这个函数里面的三个参数，借用都用`&`来标注。\n\n假设一个变量借出给另一个函数，而在借用变量的函数执行阶段借出函数就结束并销毁变量，程序就会出错，因此生命周期就是用来确定一个借出的变量必须还回后才能被销毁。默认 rust 都会给一个生命周期，然而当出现两个以上生命周期时，如`create_post`则需要程序员指定参数必须在一个生命周期内。\n\n## juniper 实现 graphql\n\n写一个 Query 的方法\n\n```rust\n#[derive(juniper::GraphQLObject)]\nstruct MyObj {\n    name: String,\n}\n\nstruct QueryRoot;\n#[derive(juniper::object)]\nimpl QueryRoot {\n    fn myObj() -> juniper::FieldResult {\n        Ok(MyObj {\n            name: \"World\"\n        })\n    }\n}\n```\n\nMutation 也类似，基本很简单，可以查看[代码](https://github.com/gongbaodd/rust_webAssembly_study/blob/master/graphql_only)了解。\n\n### rust 语法里面闭包里面 move 的使用\n\n前面说过，如果一个函数想调用另一个函数的堆内存，可以借用。但是还有另一种函数，闭包，理论上闭包可以处理闭包所在词法作用域下的所有变量。在动态执行时如果闭包中依赖的一个变量已经销毁也是很危险的事儿，所以这里可以用 move 关键字将变量所有权交给闭包，在闭包外则无权再次处理已经 move 的变量。\n\n```rust\nasync fn main() -> io::Result<()> {\n    let schema = std::sync::Arc::new(create_schema());\n\n    let app = move || {\n        App::new()\n            .data(schema.clone())\n            .wrap(middleware::Logger::default())\n            .service(graphql)\n            .service(graphiql)\n    };\n\n    HttpServer::new(app)\n        .bind(\"127.0.0.1:8080\")?\n        .run()\n        .await\n}\n```\n\n当然 graphql 的代码里面还有 RC 和 ARC 的概念，现在暂时了解他们时 Rust 下面的引用计数的一种实现，RC 用于单线程，ARC 用于多线程。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["rust","actix_web"]}},{"id":"2020/02/11/Movie-supplementary-plan-Hollywood-past.md","slug":"2020/02/11/movie-supplementary-plan-hollywood-past","body":"\n# 电影补档计划：好莱坞往事\n\n![Once upon a time in Hollywood](https://img1.doubanio.com/view/photo/l/public/p2571312408.webp)\n\n全片只看最后面半个小时，就是一部完美的电影。然而必须要看完前面两个小时冗长而又莫名其妙的故事（毕竟我对好莱坞的历史一无所知，所有格梗都看不出来）。\n\n大概故事是一个刚有起色的电视演员带着他的替身去好莱坞找电影工作，却发现西部电影已经不再受欢迎，演员住在很多著名演员附近，想借他们一步登天。\n\n有制片人看到演员的戏感到有趣，邀请他去意大利拍西部电影。在意大利抱得美人的演员在回程时提出因为西部电影不再受欢迎，以后不会在和替身合作。\n\n当天晚上，演员在泳池游泳，替身在客厅吸毒，演员妻子还在我是倒时差。一群嬉皮士闯入，造成一片混乱。\n\n混乱引起演员邻居注意，演员因此结实各种名流。\n","collection":"blog","data":{"type":"post","category":"movie"}},{"id":"2020/02/12/Windows-Rust-GTK.md","slug":"2020/02/12/windows-rust-gtk","body":"\n# Windows 下为 Rust 提供 GTK 环境\n\nWindows 下面安装 GTK 环境有两种方法，借助 msys2 的 linux 环境，或者借助 VCPKG 安装 Windows 的 GTK 依赖。\n\n尝试了一下，msys2 并没有成功，只能使用 VCPKG，参考[gnome 编译指南](https://www.gtk.org/download/windows.php)。\n\n```batch\ngit clone https://github.com/Microsoft/vcpkg\ncd vcpkg\n.\\bootstrap-vcpkg.bat\nvcpkg install gtk:x64-windows\n```\n\n安装的时候发现不能编译成功，此时需要祭出 Visual Studio 大法，找到 Visual Studio Installer，安装 C 工具链，再重新执行上面的代码即可。\n\n然后再环境变量中增加`GTK_LIB_BASE`值为`c:\\MyWorks\\github\\vcpkg\\installed\\x64-windows\\lib`(就是 vcpkg 下载依赖包的位置)\n\n环境变量中的 PATH 的第一个值也要配上`c:\\MyWorks\\github\\vcpkg\\installed\\x64-windows\\bin`。\n\n如果 rust 项目还编译不成功，尝试将 vcpkg 里面的/lib/gdk-3.lib 和/lib/gtk-3.lib 连接到/lib/gdk-3.0.lib 和/lib/gtk-3.0.lib，bin 文件夹下的 dll 文件也一样处理。\n\n再次运行`cargo run`即可，[相关代码](https://github.com/gongbaodd/rust_webAssembly_study/tree/master/rust_gtk)。\n\n最初想试一下 rust-gtk 的原因是，想试试这个跨平台框架如何，但是在 Windows 下面效果并不怎么样，而且还有 HIDPI 的问题，Reddit 里面讨论感觉 gtk 这边也没有很着力于 rust，所以对 GTK 的探究就暂时到此为止了。\n","collection":"blog","data":{"type":"post","category":"tech","tag":["rust","gtk"]}},{"id":"2020/02/13/Windows-Rust-QT.md","slug":"2020/02/13/windows-rust-qt","body":"\n# Windows 下为 Rust 提供 QT 环境（弃）\n\nQT 的部署要比 GTK 容易一些，然而由于最近我的机场流量用尽，所以最大的困难就是网络。\n\n参考[Rust-qt](https://github.com/rust-qt/examples)，有比较详细的环境配置。需要下载完整的[Qt 安装包](https://www.qt.io/download)和[Visual Studio 2017](https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15)（最好用 2017，能少踩不少坑）。\n\n安装成功后，在环境变量 PATH 里面增加`C:\\Qt\\Qt5.14.1\\5.14.1\\msvc2017_64\\bin`然后找到 VS2017 的命令行，只有这个命令行能准确编译 QT5。\n\n虽然按照 Rust-qt 的做法，C++的 QT 可以完美运行，但是编译的时候要使用 gcc，所以还是要安装 msys2，而且对 QT 要求的版本也比较苛刻，因此我决定就此放弃 QT（即使 QT 已经能跑在 web-assembly 上面了）。\n\n## Rust 相关的 UI 框架\n\n其实还有一篇文章关于 Rust 的 UI 编程的，可以查看[这篇文章](https://gitlab.com/bloom42/research/rust_gui_ecosystem)。\n","collection":"blog","data":{"type":"post","category":"tech","tag":["rust","qt"]}},{"id":"2020/02/14/Movie-supplementary-plan-Qiao-Qiao-Rabbit.md","slug":"2020/02/14/movie-supplementary-plan-qiao-qiao-rabbit","body":"\n# 电影补档计划：乔乔兔\n\n![jojo rabbit](https://img3.doubanio.com/view/photo/l/public/p2567973073.webp)\n\n乔乔是个小纳粹热爱者，参加童子兵的时候因为不忍心杀死兔子被同伴嘲笑为乔乔兔，因为不小心被炸伤而不能参加二战。\n\n在家休养的乔乔发现家里躲着一个犹太女孩，担心自己和母亲被连累，他没有告发这个女孩。随着互相了解，乔乔逐渐喜欢上这个女孩。乔乔发现母亲其实暗中参与阻止纳粹活动，并被杀害。随着德军战败，乔乔重回家里找到躲着的犹太女孩，并战胜心中臆想的希特勒。\n\n很温暖的喜剧，适合一家看，特适合在家隔离的时候看。\n","collection":"blog","data":{"type":"post","category":"movie"}},{"id":"2020/02/14/Movie-supplementary-program-marriage-story.md","slug":"2020/02/14/movie-supplementary-program-marriage-story","body":"\n# 电影补档计划：婚姻故事\n\n![Marriage Story](https://img1.doubanio.com/view/photo/l/public/p2571760178.webp)\n\n开罗人和寡姐的离婚故事。\n\n开罗人和寡姐和儿子住在纽约，寡姐发现开罗人有外遇，要离婚，带孩子去 LA，开罗人去索要抚养权。\n\n一个开始让人惧怕离婚，后来让人惧怕婚姻的剧。\n","collection":"blog","data":{"type":"post","category":"movie"}},{"id":"2020/02/15/Github.md","slug":"2020/02/15/github","body":"\n# Github 项目徽章地址\n\n在https://shields.io/可以为Github项目添加徽章。\n","collection":"blog","data":{"type":"post","category":"tech","tag":["github"]}},{"id":"2020/02/15/Movie-supplement-plan-sharp-blade-out-of-the-sheath.md","slug":"2020/02/15/movie-supplement-plan-sharp-blade-out-of-the-sheath","body":"\n# 电影补档计划：利刃出鞘\n\n![Knives out](https://img9.doubanio.com/view/photo/l/public/p2575381156.webp)\n\n双男主海报一出来就知道谁是凶手了。\n\n一个富豪老爷生日晚上，护士误将吗啡打错剂量，却找不到解药，老爷通过制造自杀现场保护护士。宣读遗书时众人得知老爷将财产全部转交给护士。但其实护士并没有打错药，老爷的孙子偷偷的把药物对调，并将罪行陷害给护士。最终在侦探观察下，真相大白。\n\n基本上看的是演员的演技，画面也很精致。\n","collection":"blog","data":{"type":"post","category":"movie"}},{"id":"2020/02/17/Movie-supplementary-program-time-and-space-love-traveler.md","slug":"2020/02/17/movie-supplementary-program-time-and-space-love-traveler","body":"\n# 电影补档计划：时空恋旅人\n\n![about time](https://img9.doubanio.com/view/photo/l/public/p2070153774.webp)\n\n男主 21 岁的时候从父亲那里得知家族的男性有回到过去的能力，男主利用这个能力去追初恋，却没能成功。男主又利用这个能力挽救了一场演出的灾难以帮助他的朋友，却错失自己的真爱。经过努力，男主又找回真爱，结婚生子。\n\n男主妹妹婚姻不幸福，吵架后发生车祸。男主为了拯救妹妹的婚姻回到过去，妹妹的婚姻被拯救了，可是也影响到自己的孩子。男主只能回到妹妹车祸后，教会妹妹放弃这场婚姻重新开始。\n\n男主父亲癌症去世，父亲告诉男主，可以尝试平凡度过一天，然后利用这个能力再重新来过一次。\n","collection":"blog","data":{"type":"post","category":"movie"}},{"id":"2020/02/21/Windows-flutter.md","slug":"2020/02/21/windows-flutter","body":"\n# Windows 安装 flutter 开发环境\n\n从 chocolatey 可以直接安装 flutter。\n\n```shell\nsudo choco install flutter\n```\n\n运行成功后可以运行`flutter doctor`检查环境是否完备，比如我会有`X Android license status unknown.`报错，可以运行以下命令检查详情。\n\n```shell\nflutter doctor --android-licenses\n```\n\n发现 SDK 管理的问题，进而发现要把 JDK 降级到 8.0，好在有 chocolatey，很快就解决了。\n\n```shell\nsudo choco install ojdkbuild8\n```\n\n然后修改.bashrc 设置代理\n\n```shell\nexport HTTP_PROXY=127.0.0.1:1080\nexport HTTPS_PROXY=127.0.0.1:1080\nexport NO_PROXY=127.0.0.1,localhost\n```\n\n打开 VScode，安装 flutter，打开命令面板输入`flutter new`，就可以创建工程了（然后下载了巨多文件，感觉如果写个 hello world 都要加载这么多文件真是比较坑）。\n\n打开模拟器，在 VSCode 里面按 F5 就能实时 debug 了。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["flutter","dart"]}},{"id":"2020/02/22/Windows-strokesPlus.md","slug":"2020/02/22/windows-strokesplus","body":"\n# 分享一个 Windows 下面的鼠标手势工具 StrokesPlus\n\n我终于还是妥协了，在使用 windows 的情况下最好还是配备一个鼠标。尤其是当你在编程的时候。并不是说触摸屏不好，在很多时候，触摸屏可以在可以帮你记录一些东西。比如让你写一些算法的时候，你可以在旁边画一画。\n\n但是不得不说，编辑器就像 VS code。他对触摸屏的交互其实是很反人类的。另外由于我现在是三台设备。所以我的键盘是同时连着三台设备。。这说明当我要操作我的笔记本的时候，身体要跨过两个键盘的距离。这个动作幅度是比较大的。\n\n所以我在网上买了这个科大讯飞的鼠标，他有一个最大的好处就是，我可以说话打字。这样我就不需要操作键盘了。但是 windows 上面还有另外一个问题，就是鼠标，还有触摸屏和触摸板，三者都没有统一的交互体验。所以我又安装了这个鼠标手势工具。\n\nStrokesPlus 安装很简单，依然使用的是 chocolatey。\n\n```shell\nsudo choco install strokesplus\n```\n\n其实我的需求很简单，就是需要鼠标手势来操作切换桌面。安装好 strokePlus，打开 action 菜单即可添加手势。\n\n- @：代表\"Win\"键\n- +：代表“Shift”键\n- ^：代表“Ctrl”键\n- %：代表“Alt”键\n\n如进入右边桌面的命令为`acSendKeys(\"^@{RIGHT}\")`。\n\n添加\n\n- `acSendKeys(\"^@{RIGHT}\")` 进入右桌面\n- `acSendKeys(\"^@{LEFT}\")` 进入左桌面\n- `acSendKeys(\"@{TAB}\")` 全部桌面\n\n配合 GestureSign，终于触摸屏，触摸板和鼠标手势统一了。\n","collection":"blog","data":{"type":"post","category":"tech","tag":["windows"],"series":{"slug":"windows-howto","name":"Windows舒适指南"}}},{"id":"2020/02/22/hoisting.md","slug":"2020/02/22/hoisting","body":"\n# 我也谈谈 hoisting\n\n最近在看 getify 的[You-Dont-Know-JS](https://github.com/getify/You-Dont-Know-JS)，第二版里面相对于第一版增加了很多个人认为比较硬核的东西。第二版貌似对 var 关键字进行了洗白，就目前来看还是比较争议的，毕竟这几年来我基本上已经用 let 完全替代 var 了。\n\n最近我正好是在学习 Rust，首先说明一下 Rust 的确是一个不太好学习的语言，但是学会了之后就会对编译原理有更高更深一层次的认识（同样学会了 typescript，也会有类似的感觉）。\n\n那也许是时代的问题。人们发现面向对象并不是万能的，面向函数逐渐的从原来不受人注意，变的受人理解。尤其是最近我还跟一些人在讨论到一些面向对象的继承属性。以后的以后的继承，将逐渐被组合所替代。甚至是 rust，里面已经没有了继承关系。而最受欢迎的前端框架 react 框架也逐渐的使用函数来替代对象。\n\n那么我们现在回顾一下，2015 年，那年 TC39 发布了 ECMA2015，包括块级作用域，let，class 等关键字。当时 JavaScript 的作者，Brendan Eich 就说他不赞成这个对象的设计，但是显然很多人没有理解，当然后来还发生了关于 class 成员是否跟分号的 bug。\n\n那么现在我们把当年的事情再拿出来看一看。Hoisting 这个 JavaScript 独有的特性，是不是一个鸡肋的 bug。\n\n参考 BrendanEich 老爷子自己的[话](https://twitter.com/brendaneich/status/562313394431078400)\n\n> function declaration hoisting is for mutual recursion & generally to avoid painful bottom-up ML-like order\n\n> `var` hoisting was an implementation artifact. `function` hoisting was better motivated.\n\n首先是 ML 这个语言呢也是一个基于函数的语言。但是跟 js 不太一样的是，这个语言就没有 hoisting，所以呢，看代码就只能是一行一行的看下去，比较麻烦。\n\n至于 var 的提升，则是实现 function 带来的人工产物。\n\n想一想 2015 年之前我们写前端 js 代码的时候，往往会把依赖的 function 放到最底下。\n\n```javascript\nfunction foo() {\n  bar1();\n  bar2();\n  bar3();\n\n  return;\n\n  function bar1() {}\n\n  function bar2() {}\n\n  function bar3() {}\n}\n```\n\n其实就像你现在这个角度来观察这个代码，也会觉得。这个语言的确有它的独到之处。这样的写法，直接通过 return 关键字，把一个函数分成了构造函数部分和他的私有成员。如果想要了解这个函数的功能的话，大可不必把所有的函数都看一遍。\n\n自从有了块级作用域，JavaScript 就必须要考虑，同时存在块级作用域和函数作用域的情况，就出现了 TDZ 的情况。简单讲就是说，就是块级作用域，变量不能被重复声明，即使是使用函数声明，而以前的 var 关键字是可以重新定义的（当然重新定义的时候没有重新赋值，因为提升的关系重新定义，并不存在）。\n\n```javascript\n{\n  let foo = \"foo\";\n  var foo; // wrong\n}\n```\n\n```javascript\n{\n  var foo = \"foo\";\n  let foo; // wrong\n}\n```\n\n那么块级作用域有没有提升呢？那肯定是有的，因为如果你想判断这个作用域下面的变量是不是被重新定义了，还是要预先申请内存的。只不过在他声明之前被使用的话，相比于函数变量返回未定义的值，块级作用域会报错。\n\n所以我们一般会把块级作用域变量定义放在这个块儿的最上面，来消除 TDZ。\n\n但是把定义放在最上面的话，就如之前所说的失去了 JavaScript 初衷的优雅。所以 function 和 var 关键字并不一定被宣判死刑，而是在特定的情况下还能被拿出来使用。\n\n不过，话说回来，优雅的东西不一定就是所有人喜欢的。块级作用域对 C 语言使用者来说没有学习障碍，工程上还是少数服从多数，选择最简单的而不是选择最对也存在合理性，所以即使现在面向对象逐渐失宠也不一定将来也会被摒弃。\n\n另外，Eich 和 Crockford 还有一篇访谈，可以看一下。\n\n[Eich and Crockford on the Future of JavaScript: Insight from the Creators of JavaScript and JSON](https://www.infoq.com/news/2018/07/eich-crockford-js-future/)\n","collection":"blog","data":{"type":"post","category":"fe","tag":["JavaScript"]}},{"id":"2020/02/23/Mouse-without-borders.md","slug":"2020/02/23/mouse-without-borders","body":"\n# Mouse without borders 让鼠标同时连接 4 台 PC\n\n既然已经给我的 PC 买上了鼠标，那我肯定希望，三台 PC 能够共用这一个鼠标。在网上查询了一下，发现需要这个需求的人不止我一个。所以微软有一个项目叫做[mouse without border](https://www.microsoft.com/en-us/download/details.aspx?id=35460)。\n\n只要三台设备在同一个域下，我就可以通过这一个软件，让三台设备共享鼠标。\n\n今天忙活了半天这个软件，主要是自如的 wifi 5GHz 设置了防火墙，但是 2.4GHz 没有...所以只要有一台设备连接的是 2.4G 赫兹的网络。就可以进入内网，跟其他的设备交互共享鼠标了。\n","collection":"blog","data":{"type":"post","category":"tech","tag":["windows"],"series":{"slug":"windows-howto","name":"Windows舒适指南"}}},{"id":"2020/02/25/stryker-mutation test.md","slug":"2020/02/25/stryker-mutation-test","body":"\n# 使用 stryker 做 mutation test\n\n今年年初的时候，我整理了一下前端测试现状，有一项就是 mutation test。本文将会讲一下如何给 typescript 项目添加 mutation test。\n\n## Stryker-mutator\n\n首先，为项目安装 stryker 全家桶。\n\n```shell\nyarn add -D stryker-typescript stryker-jest-runner stryker-html-reporter stryker-api stryker\n```\n\n你可能会接到升级的警告，我发现最新版本（以@stryker-mutator 做域）会有 bug，而且 github 上面显示 CI 编译失败，保守起见，还是使用老版本比较好。\n\n执行`yarn stryker init`初始化项目，修改 stryker.conf.js，详细的参数说明可以参考[这里](https://github.com/stryker-mutator/stryker/tree/master/packages/core)。\n\n```javascript\nmodule.exports = function stryker(config) {\n  config.set({\n    mutator: \"typescript\",\n    mutate: [\"src/linked_node/**/*.ts\", \"!src/**/*.spec.ts\"],\n    packageManager: \"yarn\",\n    reporters: [\"clear-text\", \"dashboard\", \"progress\", \"html\"],\n    testRunner: \"jest\",\n    coverageAnalysis: \"off\",\n    tsconfigFile: \"tsconfig.json\",\n    dashboard: {\n      reportType: \"full\",\n    },\n  });\n};\n```\n\n注意，官网的 tutorial 会要求添加 transpilor 为 typescript，这里因为我们的测试 runner 是已经配置好的 jest，所以不能再添加一次编译。\n\n执行`yarn stryker run`就能执行测试，这个测试很占用性能，我这 10 代 i7 的本都要跑 8 分钟左右，执行成功会生成报告存储在 reports 文件夹下。\n\n## 配置 travis\n\nstryker 官方提供[dashboard](https://dashboard.stryker-mutator.io)，登入配置好环境变量即可生成 stryker 的徽章，可以把它贴到 github 的 readme 中。这样，每次 travis 执行好 mutation test 后都能更新徽章分数。\n\n关于 dashboard 如何配置可以参考[handbook](https://github.com/stryker-mutator/stryker-handbook/blob/master/dashboard.md)。\n\n但是我没能成功上传 report，只能显示出分数，并不确定哪里出了问题，还是看官方如何更新吧。\n\n## 原理\n\n如果我有以下函数，并配合 100%测试覆盖的单元测试。\n\n```typescript\nfunction isGe18(num: number) {\n  return num >= 18;\n}\n\ndescribe(\"the input is 1\", () => {\n  it(\"should return false\", () => {\n    expect(isGe18(1)).toBe(false);\n  });\n});\n```\n\n显然以上的测试是不完备的，那么 stryker 如何找到它不完备的地方？首先修改函数的返回值，如生成如下四个函数。\n\n```typescript\nfunction isGe18_1(num: number) {\n  return num > 18;\n}\nfunction isGe18_2(num: number) {\n  return num < 18;\n}\nfunction isGe18_3(num: number) {\n  return true;\n}\nfunction isGe18_3(num: number) {\n  return false;\n}\n```\n\n分别用他们重新跑测试，只要有一个测试失败，就称这个 mutate 被 killed，如果测试全部通过，则称 mutate 被 survived。\n则对应上面例子：\n\n- isGe18_1 => survived\n- isGe18_2 => killed\n- isGe18_3 => killed\n- isGe18_3 => survived\n\n则此时需要增加测试\n\n```typescript\ndescribe(\"the input is 19\", () => {\n  it(\"should return true\", () => {\n    expect(isGe18(19)).toBe(true);\n  });\n});\n\ndescribe(\"the input is 18\", () => {\n  it(\"should return true\", () => {\n    expect(isGe18(18)).toBe(true);\n  });\n});\n```\n\n重新跑测试\n\n- isGe18_1 => killed（最后一个测试未通过）\n- isGe18_2 => killed\n- isGe18_3 => killed\n- isGe18_3 => killed（新增加的 2 个测试未通过）\n\n此时测试才是完备的。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["test","stryker","javascript"]}},{"id":"2020/02/26/WSL-ruby.md","slug":"2020/02/26/wsl-ruby","body":"\n# WSL 安装 ruby 环境\n\n虽然我这个博客是基于 jekyll 的，但是因为国内整 ruby 的环境实在痛苦，但是最近不得不又重新搞起来了，只能在这里记录一下。\n\n首先安装环境\n\n```shell\nsudo apt install ruby ruby-dev build-essential\n```\n\n然后修改 gem 的环境变量\n\n```shell\nexport GEM_HOME=$HOME/gems\nexport PATH=$HOME/gems/bin:$PATH\n```\n\n修改 source 为 ruby-china\n\n```shell\ngem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/\n```\n\n接着安装 jekyll 即可\n\n```shell\ngem install jekyll bundler\n```\n","collection":"blog","data":{"type":"post","category":"tech","tag":["ruby"]}},{"id":"2020/02/27/rust-webassembly-game-of-life.md","slug":"2020/02/27/rust-webassembly-game-of-life","body":"\n# 使用 rust 和 webassembly 开发 game of life\n\n这是一篇翻译，[原文](https://github.com/rustwasm/book.git)，这可能是第一篇系统讲解 rustwasm 的文章了。\n\n## 这本书适合谁？\n\n这本书适合任何对快速编译 Rust 和 Webassembly 感兴趣的人，相关的代码已经发布在网上。你应该已经了解一些 Rust 的知识，对 JavaScript HTML 和 css 很熟悉，但你不需要是在这些方面的专家。\n\n还不了解 rust？请先参阅[开始使用 rust 语言](https://doc.rust-lang.org/book/)。\n不了解 JavaScript 的 html 或者是 css？请参阅[MDN](https://developer.mozilla.org/en-US/docs/Learn)\n\n## 为什么用 rust 和 webAssembly\n\n### 底层支持和高效(Low-Level Control with Hign-Level Ergonomics)\n\nJavascript 的应用，纠结于如何保持高效运作。但是 JavaScript 的动态类型系统和垃圾回收机制，使他们不能高效。看起来很小的修改，如果不小心走出了 JIT 的舒适区，看起来很小的修改都会导致很严重的错误。\n\n### .wasm 文件大小\n\n因为要通过网络下载，代码的大小就变得异常重要。Rust 不需要运行环境，使得编译文件不需要包括垃圾回收器。这些文件包括的只有真正需要的函数。\n\n### 不要重写所有的东西\n\n现有的代码不需要被扔走，你可以把性能最严重的 JavaScript 函数，交给 rust 去执行。\n\n### 和其他工具交互融洽\n\nRust 和 WebAssembly 支持现有的工具链，它支持 ecmascript 模块，并且你依然可以使用现有的工具链如 NPM，webpack 和 greenkeeper。\n\n## 背景和相关概念\n\n### 什么是 WebAssembly\n\nWebAssembly（wasm）是一个简单的机器模块拥有大量的[定义](https://webassembly.github.io/spec/)。它被设计得以相近于原生的速度便携紧密地执行。\n\n作为一个开发语言，尽管是以两种方式展示的格式，wasm 依然表示于同样的结构。\n\n- `.wat`文本格式（叫做 WebAssembly Text），使用[S-expression](https://en.wikipedia.org/wiki/S-expression)，有点类似于 Lisp 家族，像是 Scheme 和 Clojure。\n- `.wasm`二机制格式，是一个底层的目标是让 wasm 虚拟机使用的格式，有些类似于 ELF 和 Mach-O。\n\n以`.wat`书写的斐波那契数列如下：\n\n```wasm\n(module\n  (func $fac (param f64) (result f64)\n    get_local 0\n    f64.const 1\n    f64.lt\n    if (result f64)\n      f64.const 1\n    else\n      get_local 0\n      get_local 0\n      f64.const 1\n      f64.sub\n      call $fac\n      f64.mul\n    end)\n  (export \"fac\" (func $fac)))\n```\n\n如果感兴趣的话，可以使用[此工具](https://webassembly.github.io/wabt/demo/wat2wasm/)执行上面的代码。\n\n#### 线性内存\n\nWasm 使用的[内存模式](https://webassembly.github.io/spec/core/syntax/modules.html#syntax-mem)很简单。一个 wasm 模块，可以访问的一系列内存，被限制于一个字节数组中。这些内存会[增长](https://webassembly.github.io/spec/core/syntax/instructions.html#syntax-instr-memory)为多个页（64K）不会收缩。\n\n#### Wasm 是仅仅为 web 开发的吗？\n\n尽管在 JavaScript 和 web 社区中有很多讨论。WASM 并没有考虑过它的运用环境。所以目前只能定义它为将来可以使用的便携运行格式。但就目前而言，wasm 仍然在很多方面与 JavaScript 有关。不仅仅是浏览器，还有 Node.js。\n\n## 关于本书\n\n这一部分开始使用 Rust 和 WebAssembly 开发[Conway 的 Game of Life](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life)。\n\n本章会讲到以下内容。\n\n- 如何搭建编译 WebAssembly 的 Rust 工具链。\n- 一个支持开发多语言程序（Rust、wasm、JavaScript、HTML 和 CSS）的工作流。\n- 设计最大利用 rust 和 wasm 的优势配合 JavaScript 的优点的 API。\n- 如何调试 wasm 模块。\n- 如何查看 wasm 的时间日志（time profile）。\n- 如何减少生成的二进制文件包大小。\n\n## 安装工具\n\n本节将会介绍编译 Rust 编译 WASM 并和 JavaScript 集成的工具链。\n\n### Rust 工具链\n\n你需要安装 rust 的标准工具链，[rustup，rustc 和 cargo](https://www.rust-lang.org/tools/install)（强烈建议你们在 WSl 的环境下面工作）。\n\nWASM 已经推动 Rust 新特性进入稳定版，所以我们需要有 1.30 或更新版本。\n\n### wasm-pack\n\n`wasm-pack`是一站式的建造测试以及发布 rust 相关的 wasm 应用工具。\n\n```shell\ncargo install wasm-pack\n```\n\n### cargo-generate\n\n`cargo-generate`帮助你使用现存的 Git 仓库作为模板新建 Rust 项目。\n\n```shell\ncargo install cargo-generate\n```\n\n### NPM\n\n`npm`是 JavaScript 的包装管理器。我们将利用它，去安装和运行 JavaScript 的打包和测试部署。我们将把我们编译好的`.wasm`文件放到 npm 的包中。\n\n如果你已经安装了 NPM 可以执行以下命令，安装最新版。\n\n```shell\nnpm install npm@latest -g\n```\n\n## 你好，世界\n\n通过本部分可以创建一个 Rust+WASM 页面，并能在页面弹窗展示`\"Hello, World!\"`。\n\n### 复制项目模板\n\n这个项目的模板已经提前编译好，可以借此快速绑定、集成和打包成 Web 项目。\n\n利用模板创建项目的命令：\n\n```shell\ncargo generate --git https://github.com/rustwasm/wasm-pack-template\n```\n\n它会提醒你新建一个项目名称，这里我们先使用\"wasm-game-of-life\"。\n\n### 文件结构\n\n进入项目文件夹。\n\n```shell\ncd wasm-game-of-life\n```\n\n以下是项目文件夹：\n\n```\nwasm-game-of-life/\n├── Cargo.toml\n├── LICENSE_APACHE\n├── LICENSE_MIT\n├── README.md\n└── src\n    ├── lib.rs\n    └── utils.rs\n```\n\n接下来详细看一下：\n\n#### wasm-game-of-life/Cargo.toml\n\n`Cargo.toml`文件描述`cargo`的依赖和源文件，Rust 的包管理工具和编译工具。这个包括`wasm-bindgen`依赖，我们会稍后了解其他的依赖，还有一些用来初始化`.wasm`的`crate-type`库。\n\n#### wasm-game-of-life/src/lib.rs\n\n`src/lib`文件放在 Rust 项目的更目录下面。它使用`wasm-bindgen`去和 JavaScript 链接。它能引入`window.alert`这个 JavaScript 函数，并暴露`greet`函数，并弹出弹框。\n\n```Rust\nmod utils;\nuse wasm_bindgen::prelude::*;\n\n// 当wee_alloc特性被打开，将会使用wee_alloc作为全局分匹配器\n#[cfg(feature = \"wee_alloc\")]\n#[global_allocator]\nstatic ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;\n\n#[wasm_bindgen]\nextern {\n    fn alert(s: &str);\n}\n\n#[wasm_bindgen]\npub fn greet() {\n    alert(\"Hello, wasm-game-of-life!\");\n}\n```\n\n#### wasm-game-of-life/src/utils.rs\n\n`src/utils`模块为编译 Rust 到 WASM 提供工具函数，我们后面会在调试时提到它，现在先忽略。\n\n### 编译项目\n\n使用`wasm-pack`依赖以下工具：\n\n- 保证 Rust 版本在 1.30 以上，且已经通过`rustup`安装`wasm32-unknown-unknown`工具链。\n- 使用`cargo`编译 Rust 到 WASM。\n- 使用`wasm-bindgen`去生成 JavaScript 的 API。\n\n为了完成以上内容，需要在根目录执行以下命令：\n\n```shell\nwasm-pack build\n```\n\n编译完成后，我们可以看到`pkg`里面的结构，里面应该有如下文件。\n\n```\npkg/\n├── package.json\n├── README.md\n├── wasm_game_of_life_bg.wasm\n├── wasm_game_of_life.d.ts\n└── wasm_game_of_life.js\n```\n\n`README.md`文件是直接从根目录复制的，但是其他文件完全是新生成的。\n\n#### wasm-game-of-life/pkg/wasm_game_of_life_bg.wasm\n\n`.wasm`文件是 Rust 工具链使用 Rust 源代码生成的 WASM 的二进制文件，它包括全部的函数和数据，比方说，爆露出来的`greet`函数。\n\n#### wasm-game-of-life/pkg/wasm_game_of_life.js\n\n这个`.js`文件是`wasm-bindgen`引入 DOM 和 JavaScript 方法到 Rust 中，并油耗地暴露 WASM 的 API 到 JavaScript 中。举个例子，这里个`greet`函数包裹了 WASM 中的`greet`函数，目前，这个粘合还没做任何功能，当我们逐渐从 WASM 和 JavaScript 中传输数据，他会提供帮助。\n\n```javascript\nimport * as wasm from \"./wasm_game_of_life_bg\";\n\nexport function greet() {\n  return wasm.greet();\n}\n```\n\n#### wasm-game-of-life/pkg/wasm_game_of_life.d.ts\n\n这个`.d.ts`是 TypeScript 链接 JavaScript 的文件。如果你的项目中使用了 TypeScript，你可以让你的 WebAssembly 项目被类型检查，并且你的 IDE 会提供代码提醒和自动完成功能。\n\n```TypeScript\nexport function greet(): void;\n```\n\n#### wasm-game-of-life/pkg/package.json\n\n这个文件包括了所有生成的文件描述，并使得这个项目能够作为一个使用 WebAssembly 的 NPM 包，能够集成到 JavaScript 工具链并发布至 NPM。\n\n```json\n{\n  \"name\": \"wasm-game-of-life\",\n  \"collaborators\": [\"Your Name <your.email@example.com>\"],\n  \"description\": null,\n  \"version\": \"0.1.0\",\n  \"license\": null,\n  \"repository\": null,\n  \"files\": [\"wasm_game_of_life_bg.wasm\", \"wasm_game_of_life.d.ts\"],\n  \"main\": \"wasm_game_of_life.js\",\n  \"types\": \"wasm_game_of_life.d.ts\"\n}\n```\n\n### 开始加入页面\n\n想要`wasm-game-of-life`能够展示到页面中，需要使用[`create-wasm-app` JavaScript 模板](https://github.com/rustwasm/create-wasm-app)。\n\n在项目根目录执行以下命令：\n\n```shell\nnpm init wasm-app www\n```\n\n这是`wasm-game-of-life/www`文件夹包括的文件。\n\n```\nwasm-game-of-life/www/\n├── bootstrap.js\n├── index.html\n├── index.js\n├── LICENSE-APACHE\n├── LICENSE-MIT\n├── package.json\n├── README.md\n└── webpack.config.js\n```\n\n#### wasm-game-of-life/www/package.json\n\n这个文件包括已经配置好的`webpack`和`webpack-dev-server`依赖，和`hello-wasm-pack`，版本号为已经发布到 NPM 上面的版本号。\n\n#### wasm-game-of-life/www/webpack.conf.js\n\n这个是用来配置 webpack 和开发服务器的文件。该文件已经提前布置好，如果只是开发则无需过多关心这个文件。\n\n#### wasm-game-of-life/www/index.html\n\n这是页面的 HTML 文件，它是来调用`bootstrap.js`的。\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\" />\n    <title>Hello wasm-pack!</title>\n  </head>\n  <body>\n    <script src=\"./bootstrap.js\"></script>\n  </body>\n</html>\n```\n\n#### wasm-game-of-life/www/index.js\n\n这是 JavaScript 的入口文件，他引入了`hello-wasm-pack`，并带哦用了 greet 函数。\n\n```JavaScript\nimport * as wasm from \"hello-wasm-pack\";\n\nwasm.greet();\n```\n\n#### 安装 NPM 依赖\n\n首先保证已经在`www`文件夹下面执行过`npm i`，这个命令会安装好现有依赖包括 webpack 和开发服务器。\n\n> 注意 webpack 并不是必须的，他只是个打包器并提供了开发服务器，这是我们选择它的原因。Parcel 和 Rollup 一样支持 WebAssembly 模块。你也可以选择[不使用打包器](https://rustwasm.github.io/docs/wasm-bindgen/examples/without-a-bundler.html)。\n\n#### 在 www 文件夹中使用本地 wasm-game-of-life 包\n\n相比于使用 NPM 线上的`hello-wasm-pack`，使用本地文件会提高我们的开发舒适度。\n\n打开`www/package.json`，找到`devDependencies`，在兄弟节点增加`dependencies`字段，并在里面增加`\"wasm-game-of-life\": \"file:../pkg\"`。\n\n```JSON\n{\n  // ...\n  \"dependencies\": {                     // Add this three lines block!\n    \"wasm-game-of-life\": \"file:../pkg\"\n  },\n  \"devDependencies\": {\n    //...\n  }\n}\n```\n\n接下来修改`www/index.js`引入 greet 函数。\n\n```JavaScript\nimport * as wasm from \"wasm-game-of-life\";\n\nwasm.greet();\n```\n\n既然修改了 package.json，则需要重新安装他。\n\n```shell\nnpm install\n```\n\n好了，现在服务器可以成功运行了。\n\n#### 启动本地服务\n\n接下来，打开一个新终端来在后台运行服务器，请在`www`文件夹下执行如下命令。\n\n```shell\nnpm run start\n```\n\n打开http://localhost:8080，应当会弹出如下弹窗。\n\n![弹窗](https://rustwasm.github.io/book/images/game-of-life/hello-world.png)\n\n### 练习\n\n修改 greet 函数，引入参数`name: &str`，重新执行`wasm-pack build`，并刷新页面使得弹窗中能够显示\"Hello, {name}\"。\n\n**_答案，不许看！_**\n\n修改`src/lib.rs`\n\n```Rust\n#[wasm_bindgen]\npub fn greet(name: &str) {\n    alert(&format!(\"Hello, {}!\", name));\n}\n```\n\n再修改 JavaScript 绑定`www/index.js`\n\n```JavaScript\nwasm.greet(\"Your name\");\n```\n\n## Conway 的生命游戏的游戏规则\n\n如果你已经了解[Conway 的生命游戏](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life)，可以跳过这部分。\n\n整个 Conway 的生命游戏是在一个无限的二维的正交格子宇宙中，每一个细胞拥有两种生命状态，生或者死。或者说可增殖或者不可增殖。每一个细胞都和它的 8 个邻居交互，它们分别是纵向的，斜向的，横向的相邻。并且每一步都会发生如下的变化。\n\n1. 任何一个活着的细胞，如果有少于两个邻居就会死亡。\n2. 任何一个活细胞拥有两个或三个活着的邻居，则会继续增殖。\n3. 任何一个活着的细胞拥有三个以上活着的的邻居，则会死亡。\n4. 任何一个死掉的细胞，如果有三个活着的邻居，则会重生。\n\n最初的图案组成了最初的世界。第 1 代是按照以上的规则生成的，每一个细胞的生成和死亡都是同时的。他们的生存和死亡这一个时间我们称之为一刻。用程序的语言来说，这一刻是上一次生成的纯函数。这个规则一直有效。\n\n考虑设置如下的初始宇宙：\n\n![初始宇宙](https://rustwasm.github.io/book/images/game-of-life/initial-universe.png)\n\n我们可以通过考虑每一个细胞来确定下一代。最左上角的细胞已经死亡，第 4 条规则是唯一一个能够处理死亡细胞的规则。所以第 1 排的所有细胞都有相同的规则。他们都没有三个活着的邻居。只能保持死亡。\n\n当我们看到最上面的活着的细胞时，这个游戏开始变得有趣了。在第 2 排第 3 列。对于活着细胞前三个规则都可以应用。对于这一个细胞，他只有一个活着的邻居，所以规则一可用。这个细胞会在下一次争执死亡。下面那几个活着的细胞也是有一样的命运。\n\n中间的活着的细胞，还有两个邻居，上面的和下面的，这就意味着它符合规则二，他可以活到下一次增值。\n\n最后一个比较有趣的例子，就是当我们看到死掉的细胞。嗯。在中间这活着的细胞的左边和右边。这三个活着的细胞都是他们的邻居。这使得他们按照规则是可以在下一轮重生。\n\n将这些规则放在一起，我们可以获得下一刻的世界。\n\n![下一刻的世界](https://rustwasm.github.io/book/images/game-of-life/next-universe.png)\n\n根据这个例子，和确定的规则。不去并精彩的事情将会发生。\n\n![Gosper's glider gun](https://upload.wikimedia.org/wikipedia/commons/e/e5/Gospers_glider_gun.gif)\n\n![Pulsar](https://upload.wikimedia.org/wikipedia/commons/0/07/Game_of_life_pulsar.gif)\n\n![Space ship](https://upload.wikimedia.org/wikipedia/commons/3/37/Game_of_life_animated_LWSS.gif)\n\n### 练习\n\n手动计算出下一刻，宇宙应该是什么样\n\n**_答案，不许看！_**\n\n![下一刻宇宙](https://rustwasm.github.io/book/images/game-of-life/initial-universe.png)\n\n你能找到一个稳定的没有变化的宇宙吗？\n\n**_答案，不许看！_**\n\n这个答案，不许看！其实有无数个，最平凡的答案，不许看！就是它是一个空宇宙。如果是一个 2×2 的方格，也可以形成一个稳定的宇宙。\n\n## 实现 Conway 的生命游戏\n\n### 设计\n\n在开始之前呢，我们要先考虑以下几种设计模式。\n\n#### 无限宇宙\n\n生命游戏是在一个无限宇宙中玩的。但是我们没有无限的内存和计算能力。在这种情况下，我们往往会有三个选项。\n\n1. 始终追踪这个宇宙的发展，并适当的扩展宇宙。这个扩张是无限的，所以这个实现实现了就会逐渐逐渐的变得越来越慢，直到把内存全部用完。\n2. 创建一个固定的宇宙，当细胞碰到宇宙的边缘的时候，将会有更少的邻居。更简单的策略就是当他们已经达到边缘的时候，直接被宇宙剪掉。\n3. 创建一个固定的宇宙，当细胞达到边缘的时候，将会从另外一边滑入这样，我的我们的应用就可以一直跑下去。\n\n我们会按照第 3 个选项来实现。\n\n#### 连接 Rust 和 JavaScript\n\n> 此部分是本人最重要的一节。\n\nJavaScript 的垃圾回收堆内存，是用来调用 Object 和 Array 还有 DOM 结点的。而 Rust 存在的 WebAssembly 线性内存和它是截然不同的。WebAssembly 目前还不能直接操作垃圾回收堆内存（在 2018 年 4 月，一个关于[接口类型（Interface Type）](https://github.com/WebAssembly/interface-types/blob/master/proposals/interface-types/Explainer.md)的提案将会改变这一局面）。JavaScript 却可以读写 WebAssembly 的线性内存，但仅限于 ArrayBuffe 支持的标量（u8, i32, f64 等等）。WebAssembly 行数一样能处理和返回这些标量。以下讲解 WebAssembly 和 JavaScript 如何链接。\n\nwasm_bindgen 定义了如何穿过这段链接计算数据结构的方法。它包括装箱 Rust 结构，并包装指针成为一个 JavaScript 类以供使用，或者提供 JavaScript 对象给 Rust 使用。wasm_bindgen 非常便利，但并不是无需考虑怎样在这个链接上传输数据结构。你应该把它当作一个实现接口的工具。\n\n当设计 WebAssembly 和 JavaScript 的接口时，我们需要考虑到以下内容。\n\n1. **减少复制到和移出 WebAssembly 线性内存中的值**，无效的复制会造成无用的性能损耗。\n2. **最小的序列化和解序列化**，和复制类似，序列化和解序列化一样造成性能损耗，如果想要把数据无副作用地从一端传到另一端，与其说在一端序列化，到另一端解序列化，不如使用 wasm_bindgen 帮助我们将 JavaScript 的 Object 装箱成 Rust 的 structure。\n\n一个结论，处理 JavaScript 和 WebAssembly 接口设计时，经常将大的、生命周期长的数据结构作为 Rust 类型，存储在 WebAssembly 线性内存中，并给 JavaScript 暴露一个处理方法，JavaScript 调用 WebAssembly 转换文件，处理运算，并最终得到一个小的，可复制的结果。通过只返回计算结果，我们可以躲过复制和序列化数据的过程。\n\n#### 在生命游戏中链接 Rust 和 JavaScript\n\n接下来结局几个要规避的问题。我们不想每刻都复制整个宇宙到 WebAssembly 的内存中，我们不想处理宇宙中所有的细胞，也不想在每次读写细胞的时候都穿过 WebAssembly 和 JavaScript 的分界。\n\n这是我们的 4x4 宇宙在内存中的结构。\n\n![4x4宇宙在内存中的结构](https://rustwasm.github.io/docs/book/images/game-of-life/universe.png)\n\n为了寻找细胞在内存中的位置，我们可以使用下面的公式。\n\n```\nindex(row, column, universe) = row * width(universe) + column\n```\n\n我们有很多方法来给 JavaScript 暴露宇宙中的细胞。开始我们要为宇宙实现一个`std::fmt::Display`。我们可以使用一个 Rust 的 String，每个字符代表一个细胞。这个 Rust 的 string 将会从 WebAssembly 的内存中复制到 JavaScript 的内存里，并接下来作为 textContent 展示到 HTML 里面。本节的后面，将会讲到如何把细胞展示到 canvas 中。\n\n> 另一种设计是让 Rust 返回每个细胞的生存状态列表，这样 JavaScript 就不需要在渲染时解析整个宇宙，这不过这个是先更加复杂些。\n\n#### Rust 的实现\n\n上一章，我们复制了初始化模板，我们现在要修改这个模板。\n\n从删除 greet 函数，并定义宇宙中的细胞开始。\n\n```Rust\n#[wasm_bindgen]\n#[repr(u8)]\n#[derive(Clone, Copy, Debug, PartialEq, Eq)]\npub enum Cell {\n    Dead = 0,\n    Alive = 1,\n}\n```\n\n`#[repr(u8)]`很重要，这样每个细胞都会以一个字节存储，另外 Alive 为 1，Dead 为 0 也很重要，这样我们就可以使用加法计算邻居数目。\n\n接下来定义宇宙，一个宇宙包括宽度，高度和一个向量的细胞。\n\n```Rust\n#[wasm_bindgen]\npub struct Universe {\n    width: u32,\n    height: u32,\n    cells: Vec<Cell>,\n}\n```\n\n访问并转换细胞的实现如下。\n\n```Rust\nimpl Univers {\n    fn get_index(&self, row: u32, column: u32) -> usize {\n        (row*self.width + column) as usize\n    }\n}\n```\n\n为了计算细胞接下来的状态，我们要统计某个细胞有多少个邻居存活。\n\n```Rust\nimpl Univers {\n    fn live_neighbor_count(&self, row: u32, column: u32) -> u8 {\n        let mut count = 0;\n        for delta_row in [self.height - 1, 0, 1].iter().cloned() {\n            for delta_col in [self.width - 1, 0, 1].iter().cloned() {\n                if delta_row == 0 && delta_col ==0 {\n                    continue;\n                }\n\n                let neighbor_row = (row + delta_row) % self.height;\n                let neighbor_col = (column + delta_col) % self.width;\n                let idx = self.get_index(neighbor_row, neighbor_col);\n                count += self.cells[idx] as u8\n            }\n        }\n        count\n    }\n}\n```\n\n这个函数使用取余处理边界问题。现在我们已经有所有的必须函数了，最后只需要生成下一刻的状态即可（记住，每个函数必须在`#[wasm_bindgen]`属性之下，这样 JavaScript 才能接到暴露的函数）。\n\n```Rust\n#[wasm_bindgen]\nimpl Universe {\n    pub fn tick(&mut self) {\n        let mut next = self.cells.clone();\n\n        for row in 0..self.height {\n            for col in 0..self.width {\n                let idx = self.get_index(row, col);\n                let cell = self.cells[idx];\n                let live_neighbors = self.live_neighbor_count(row, col);\n\n                let next_cell = match (cell, live_neighbors) {\n                    (Cell::Alive, x) if x < 2 => Cell::Dead,\n                    (Cell::Alive, 2) | (Cell::Alive, 3) => Cell::Alive,\n                    (Cell::Alive, x) if x > 3 => Cell::Dead,\n                    (Cell::Dead, 3) => Cell::Alive,\n                    (otherwise, _) => oterwise,\n                };\n\n                next[idx] = next_cell;\n            }\n        }\n        self.cells = next;\n    }\n}\n```\n\n目前为止，一个宇宙的状态就都被存储在 cell 这个向量里面了。为了提高它的可读性，让我们实现一个文本渲染器，目的是将整个宇宙按行输出为文字，每一个活着的细胞标注为 Unicode 符号“■”，死掉的细胞则为“□”。\n\n通过实现 Rust 标准库中的`Display`trait，我们可以将数据结构以一种用户交互方式输出，它也提供了一个`to_string`方法。\n\n```Rust\nuse std::fmt;\n\nimpl fmt::Display for Universe {\n  fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n    for line in self.cells.as_slice().chunks(self.width as usize) {\n      for &cell in line {\n        let symbol = if cell == Cell::Dead {\"□\"} else {\"■\"};\n        write!(f, \"\\n\")?;\n      }\n    }\n\n    Ok(())\n  }\n}\n```\n\n最后，我们定义一个构造器去初始化一个有趣的图案和一个渲染函数。\n\n```Rust\n#[wasm_bindgen]\nimpl Universe {\n  pub fn new() -> {\n    let width = 64;\n    let height = 64;\n\n    let cells = (0..width * height)\n      .map(|i| {\n        if i%2 == 0 || i%7 == 0 {\n          Cell::Alive\n        } else {\n          Cell::Dead\n        }\n      }).collect();\n\n    Universe {\n      width,\n      height,\n      cells,\n    }\n  }\n\n  pub fn render(&self) -> String {\n    self.to_string()\n  }\n}\n```\n\n以上，Rust 部分已经完工。\n\n#### 使用 JavaScript 渲染\n\n首先在 HTML 中插入<pre>标签用来展示整个宇宙。\n\n```html\n<body>\n  <pre id=\"game-of-life-canvas\"></pre>\n  <script src=\"./bootstrap.js\"></script>\n</body>\n```\n\n另外我们希望<pre>标签能处于页面中央。我们可以通过 CSS flex box 实现这个任务，在 html 中增加<style>标签。\n\n```css\nbody {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n}\n```\n\n修改 JavaScript 入口文件，将原来引入的 greet 函数改为 Universe。\n\n```JavaScript\nimport { Universe } from \"wasm-game-of-life\";\n```\n\n让我们在那个<pre>标签中增加新的宇宙实例吧。\n\n```JavaScript\nconst pre = document.getElementById(\"game-of-life-canvas\");\nconst universe = Universe.new();\n```\n\n使用 JavaScript 创建一个 requestAnimationFrame 循环，每一次循环，就在<pre>标签中绘制一遍宇宙，并执行一次`Universe::tick`。\n\n```JavaScript\nfunction renderLoop() {\n  pre.textContent = universe.render();\n  universe.tick();\n\n  requestAnimationFrame(renderLoop);\n}\n```\n\n想要实现渲染，只需执行`requestAnimationFrame(renderLoop)`。\n\n确保你的本地服务任然在运行，此时你的页面应该如下所示。\n\n![浏览器页面](https://rustwasm.github.io/book/images/game-of-life/initial-game-of-life-pre.png)\n\n#### 渲染到 Canvas 上\n\n在 Rust 中生成字符串并通过 wasm-bindgen 拷贝到 JavaScript 中做了很多无关的复制。既然 JavaScript 已经知道宇宙的长度和宽度，而且 JavaScript 本来可以直接读 WebAssembly 的内存，我们将要修改 render 方法，直接返回细胞向量的指针。\n\n同时，与其渲染 Unicode 字符，不如开始用 Canvas API。接下来我们会开始设计这些。\n\n在 html 中，修改<pre>为<canvas>。\n\n```html\n<body>\n  <canvas id=\"game-of-life-canvas\"></canvas>\n  <script src=\"./bootstrap.js\"></script>\n</body>\n```\n\n为了能拿到 Rust 中的相关数据结构，我们需要为宇宙增加 getter 函数，暴露宇宙的宽度、高度和细胞的向量。增加如下函数。\n\n```Rust\n#[wasm_bindgen]\nimpl Universe {\n  pub fn width(&self) -> u32 {\n    self.width\n  }\n\n  pub fn height(&self) -> u32 {\n    self.height\n  }\n\n  pub fn cells(&self) -> *const Cell {\n    self.cells.as_ptr()\n  }\n}\n```\n\n接下来，在 JavaScript 中，引入 Cell，并设置几个渲染画布的常量。\n\n```JavaScript\nimport { Universe, Cell } from \"wasm-game-of-life\";\n\nconst CELL_SIZE = 5;\nconst GRID_COLOR = \"#CCCCCC\";\nconst DEAD_COLOR = \"#FFFFFF\";\nconst LIVE_COLOR = \"#000000\";\n```\n\n接下来修改实现 canvas 的部分。\n\n```JavaScript\nconst universe = Universe.new();\nconst width = universe.width();\nconst height = universe.height();\n\nconst canvas = documnet.getElementById(\"game-of-life-canvas\");\ncanvas.height = (CELL_SIZE+1)*height + 1;\ncanvas.width = (CELL_SIZE+1)*width + 1;\n\nconst ctx = canvas.getContext(\"2d\");\n\nfunction renderLoop() {\n  universe.tick();\n\n  drawGrid();\n  drawCells();\n\n  requestAnimationFrame(renderLoop);\n}\n```\n\n世界的网格，是一系列等宽的竖线和横线。\n\n```JavaScript\nfunction drawGrid() {\n  ctx.beginPath();\n  ctx.strokeStyle = GRID_COLOR;\n\n  for(let i =0; i <= width; i+=1) {\n    ctx.moveTo(i*(CELL_SIZE+1) + 1, 0);\n    ctx.lineTo(i*(CELL_SIZE+1) + 1, (CELL_SIZE+1)*height+1);\n  }\n\n  for(let i=0; i<=height; j++) {\n    ctx.moveTo(0, i*(CELL_SIZE+1)+1);\n    ctx.lineTo((CELL_SIZE+1)*width+1, i*(CELL_SIZE+1)+1);\n  }\n\n  ctx.stroke();\n}\n```\n\n我们可以直接访问 WebAssembly 的内存，他是直接定义在`wasm_game_of_life_bg`。为了画细胞，我们先找到一个细胞的指针，并将它们转换成 Unit8Array，迭代这些细胞，并按照他们的生命状态绘制白色和黑色方块。计量避免复制所有细胞。\n\n```JavaScript\nimport { memory } from \"wasm-game-of-life/wasm_game_of_life_bg\";\n\nfunction getIndex(row, column) {\n  return row*width+column;\n}\n\nfunction drawCells() {\n  const cellsPtr = universe.cells();\n  const cells = new Unit8Array(\n    memory.buffer,\n    cellPtr,\n    width*height,\n  );\n\n  ctx.beginPath();\n\n  for(let row=0; row<height; row+=1) {\n    for (let col=0; col<width; col+=1) {\n      const idx = getIndex(row, col);\n\n      ctx.fillStyle = cells[idx] === CellDead\n        ? DEAD_COLOR\n        : LIVE_COLOR;\n\n      ctx.fillRect(\n        cell*(CELL_SIZE+1) + 1,\n        row*(CELL_SIZE+1) + 1,\n        CELL_SIZE,\n        CELL_SIZE,\n      );\n    }\n  }\n\n  ctx.stroke();\n}\n```\n\n开始渲染，需要添加以下表达式。\n\n```JavaScript\ndrawGrid();\ndrawCells();\nrequestAnimationFrame(renderLoop);\n```\n\n注意 drawGrid 和 drawCell 必须要在 requestAnimationFrame 之前执行。\n\n#### 成功了！\n\n重建 WebAssembly 绑定。\n\n```shell\nwasm-pack build\n```\n\n确定开发服务器还在运行，如果不是，需要执行以下命令。\n\n```shell\nnpm run start\n```\n\n刷新`http://localhost:8080/`，你应该能看到如下结果。\n\n![页面](https://rustwasm.github.io/docs/book/images/game-of-life/initial-game-of-life.png)\n\n结束之前，这里还有一个不错的实现生命游戏的算法，[hashlife](https://en.wikipedia.org/wiki/Hashlife)。它使用缓存，使得程序有指数级性能提升！但是为什么我们不实现它呢？它已经超出本文涉及的范围了，本文只是专注于 Rust 和 WebAssembly 集成，但是我们强烈期望你能实现这一算法。\n\n### 练习\n\n#### 实现一台宇宙飞船\n\n#### 生成一个随机的初始环境，每个细胞有 50%的生存可能\n\n**_答案，不许看！_**\n\n先增加 js-sys 依赖\n\n```toml\n[dependencies]\njs-sys=\"0.3\"\n```\n\n接下来使用 js 的随机函数\n\n```Rust\nextern crate js_sys;\n\nif js_sys::Math::random() < 0.5 {\n\n} else {\n\n}\n```\n\n#### 以 bit 形式存储每个 cell\n\n**_答案，不许看！_**\n\n在 Rust 中，使用 fixedbitset 代替`Vec<Cell>`;\n\n```Rust\nextern crate fixedbitset;\nuse fixedbitset::FixedBitSet;\n\n#[wasm_bindgen]\npub struct Universe {\n  width: u32,\n  height: u32,\n  cells: FixedBitSet,\n}\n```\n\n宇宙的构造器应该这么修改。\n\n```Rust\npub fn new() -> Universe {\n  let width = 64;\n  let height = 64;\n\n  let size = (width*height) as usize;\n  let mut cells = FixedBitSet::with_capacity(size);\n\n  for i in 0..size {\n    cells.set(i, i%2==0 || i%7==0);\n  }\n\n  Universe {\n    width,\n    height,\n    cells,\n  }\n}\n```\n\n使用 FixedBitSet 的 set 方法更新宇宙的下一刻。\n\n```Rust\nnext.set(idx, match (cell, live_neighbors) {\n  (true, x) if x<2 => false,\n  (true, 2) | (true, 3) => true,\n  (true, x) if x>3 => false,\n  (false, 3) => true,\n  (otherwise, _) => otherwise\n});\n```\n\n传输指针的时候，需要返回 slice。\n\n```Rust\n#[wasm_bindgen]\nimpl Universe {\n  pub fn cells(&self) -> *const u32 {\n    self.cells.as_slice().as_ptr()\n  }\n}\n```\n\n在 JavaScript 中，构造 Unit8Array 的时候需要除以 8，以为我们是以 bit 存储细胞的。\n\n```JavaScript\nconst cells = new Unit8Array(\n  memory.buffer,\n  cellsPtr,\n  width*height/8\n);\n```\n\n通过判断 Unit8Array 是否被赋值而判断细胞是否是活着的。\n\n```JavaScript\nfunction bitIsSet(n, arr) {\n  const byte = Math.floor(n/8);\n  const mask = 1<<(n%8);\n  return (arr[byte] & mask) == mask;\n}\n```\n\n根据以上变化，新版本的 drawCells 如下。\n\n```JavaScript\nfunction drawCells() {\n  const cellsPtr = universe.cells();\n  const cells = new Unit8Array(\n    memory.buffer,\n    cellsPtr,\n    width*height/8\n  );\n\n  ctx.beginPath();\n\n  for (let row=0; row<height; row+=1) {\n    for(let col=0; col<width; col+=1) {\n      const idx = getIndex(row, col);\n\n      ctx.fillStyle = bitIsSet(idex, cells)\n        ? LIVE_COLOR\n        : DEAD_COLOR;\n\n      ctx.fillRect(\n        col*(CELL_SIZE+1)+1,\n        row*(CELL_SIZE+1)+1,\n        CELL_SIZE,\n        CELL_SIZE,\n      );\n    }\n  }\n\n  ctx.stroke();\n}\n```\n\n## 测试\n\n现在我们已经实现了 Rust 的实现，并成功渲染在浏览器中。现在来谈谈测试 WebAssembly 中的 Rust 函数。\n\n我们将要测试 tick 函数，确保它能返回正确的值。\n\n接下来，我们将处理 Universe 的 setter 函数，让我们能构造不同大小的 universe。\n\n```Rust\n#[wasm_bindgen]\nimpl Universe {\n  pub fn set_width(&mut self, width: u32) {\n    self.width = width;\n    self.cells = (0..width * self.height).map(|_| Cell::Dead).collect()\n  }\n\n  pub fn set_height(&mut self, height: u32) {\n    self.height = height;\n    self.cells = (0..self.width * height).map(|_| Cell::Dead).collect()\n  }\n}\n```\n\n我们将会创建另一个不需要`#[wasm_bindgen]`的`impl Universe`实现，因为我们不能把所有的 WebAssembly 函数暴露给 JavaScript，Rust 生成的 WebAssembly 函数是不能返回引用的。可以尝试让 Rust 返回一个引用，查看一下编译结果中是什么错误。\n\n接下来我们要写一个 get_cells 来获得细胞，和一个 set_cells 来设置哪些细胞是活的，哪些是死的。\n\n```Rust\nimpl Universe {\n  pub fn get_cells(&self) -> &[Cell] {\n    &self.cells\n  }\n\n  pub fn set_cells(&mut self, cells: &[(u32, u32)]) {\n    for (row, col) in cells.iter().cloned() {\n      let idx = self.get_index(row, col);\n      self.cells[idx] = Cell::Alive;\n    }\n  }\n}\n```\n\n现在我们将创建测试文件`tests/web.rs`。\n\n在这之前，测试环境已经配置好，请确定`wasm-pack test --chrome --headless`能够在根目录下运行。你也可以使用`--firefox`，`--safari`和`--node`选项来在其他浏览器测试你的代码。\n\n在`test/web.rs`中，我们需要到处 Universe 类型。\n\n```Rust\nextern crate wasm_game_of_life;\nuse wasm_game_of_life:Universe;\n```\n\n在测试文件中，我们要创建一个飞船构造函数。\n\n我们要构造一个 tick 函数执行之前的飞船，和一个 tick 函数执行后的期望值。\n\n```Rust\n#[cfg(test)]\npub fn input_spaceship() -> Universe {\n  let mut universe = Universe::new();\n\n  universe.set_width(6);\n  universe_set_height(6);\n  universe_set_cells(\n    &[\n      (1,2),\n      (2,3),\n      (3,1), (3,2),(3,3)\n    ]\n  );\n\n  universe\n}\n\n#[cfg(test)]\npub fn expected_spaceship() -> Universe {\n  let mut universe = Universe::new();\n\n  universe.set_width(6);\n  universe_set_height(6);\n  universe_set_cells(\n    &[\n      (2,1), (2,3),\n      (3,2), (3,3),(4,2)\n    ]\n  );\n\n  universe\n}\n```\n\n现在我们写一个 test_tick 函数，创建以上的两个飞船。最后使用`assert_eq!`宏比较 expected_ship 来确保 tick 函数运行正确。我们添加`#[wasm_bindgen_test]`属性保证这个函数可以在 WebAssembly 环境下测试。\n\n```Rust\n#[wasm_bindgen_test]\npub fn test_tick() {\n  let mut input_universe = input_spaceship();\n  let expected_universe = expected_spaceship();\n\n  input_universe.tick();\n  assert_eq!(\n    &input_universe.get_cells(),\n    &expected_universe.get_cells(),\n  )\n}\n```\n\n测试这个测试函数使用`wasm-pack test --firefox --headless`。\n\n## 调试\n\n写这么多代码之前（虽然上面都写完了，我也不知道原作者抽什么风），先看一看 Rust 的调试工具。\n\n### 调试工具\n\n此部分将会介绍 WebAssembly 的调试工具。\n\n#### 使用 debug 标记编译\n\n如果没有打开 debug 标记，\"name\"这个部分就不会被编译到二进制程序中，错误栈也不会显示函数名，你会收到`wasm-functions[42]`而不是`wasm_game_of_file::Universe::live_neighbor_count`。\n\n调试编译，`wasm-pack build --debug`或者`cargo build`总是会默认打开 debug 标记。\n\n版本编译（release build），debug 标记是默认关闭的，要打开 debug 标记，需要声明`debug=true`。\n\n```toml\n[profile.release]\ndebug = true\n```\n\n#### 使用 console API 打印日志\n\n打印日志是最好的判断程序是否是有错的方式。在浏览器中，`console.log`函数可以将日志打印到浏览器的 dev 工具里。\n\n我们可以使用 web-sys 包去调用 console API。\n\n```Rust\nextern crate web_sys;\n\nweb_sys::console::log_1(&\"Hello, world!\".into());\n```\n\n相应的`console.error`函数用法一致，但是浏览器的调用栈还是按照`console.error`来打印。\n\n使用`console.log`：\n\n- [`web_sys::console::log`，接受一个向量的数据做参数](https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.log.html)。\n- [`web_sys::console::log_1`，接受一个数据做参数](https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.log_1.html)。\n- [`web_sys::console::log_2`，接受两个数据做参数](https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.log_2.html)。\n- ...\n\n使用`console.error`：\n\n- [`web_sys::console::error`，接受一个向量的数据做参数](https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.error.html)。\n- [`web_sys::console::error_1`，接受一个数据做参数](https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.error_1.html)。\n- [`web_sys::console::error_2`，接受两个数据做参数](https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.error_2.html)。\n- ...\n\n#### 打印崩溃日志\n\n[`console_error_panic_hook`包能通过`console.error`打印崩溃日志](https://github.com/rustwasm/console_error_panic_hook)。他能打印出格式化的崩溃信息而不是难以理解的`RuntimeError: unreachable executed`。\n\n你只需要增加调用这个钩子函数。\n\n```Rust\n#[wasm_bindgen]\npub fn init_panic_hook() {\n  console_error_panic_hook::set_once();\n}\n```\n\n#### 使用调试器\n\n不幸的，WebAssembly 的调试器依然不成熟，在很多 unix 系统中，DWARF 是用来解析调试程序需要的数据的工具。虽然，Windows 上面也有一个类似的工具。但还没有相当的工具提供给 WebAssembly。所以，调试器目前能给予的功能有限，我们只能收到 WebAssembly 的错误而不是 Rust 源代码的错误。\n\n> 这里有一个故事是[跟踪 WebAssembly 的调试](https://github.com/WebAssembly/debugging)的，我们希望它将来会有所改善！\n\n尽管如此，调试器还是能够给调试 JavaScript 方面提供效力。\n\n#### 一开始就规避在 WebAssembly 上面使用调试\n\n如果错误和交互 JavaScript 和 Web API 有关，则使用`wasm-bindgen-test`写测试。\n\n如果和 JavaScript 和 Web API 无关，这是用默认的`#[test]`属性。使用[`quickcheck`包](https://crates.io/crates/quickcheck)可以减少写测试上面的时间。\n\n为了避免`#[test]`编译器出现连接错误，你需要一个 rlib 依赖，在`Cargo.toml`文件按照如下修改。\n\n```toml\n[lib]\ncrate-type [\"cdylib\", \"rlib\"]\n```\n\n### 在生命游戏中打开崩溃日志\n\n如果程序崩溃，最好是能够在审查工具中看到日志。\n\n在``src/utils.rs`里面有一个可选的 console_error_panic_hook 包，可以在 Universe 初始化的时候调用它。\n\n```Rust\npub fn new() -> Universe {\n  utils::set_panic_hook();\n}\n```\n\n### 为生命游戏增加日志\n\n让我们在 Rust 中利用 web-sys 调用 console，打印出每一刻的细胞状态。\n\n首先在以来中增加 web-sys，修改 Cargo.toml。\n\n```toml\n[dependencies.web-sys]\nversion = \"0.3\"\nfeatures = [\n  \"console\",\n]\n```\n\n为了高效，我们把`console.log`函数封装到`println!`一样的宏中。\n\n```Rust\nextern crate web_sys;\n\nmacro_rules! log {\n  ($( $t:tt )*) => {\n    web_sys::console::log_1(&format!( $( $t )* ).into());\n  }\n}\n```\n\n现在可以通过调用 log 发送日志了。\n\n```Rust\nlog!(\n  \"cell[{}, {}] is initially {:?} and has {} live neighbors\",\n  row,\n  col,\n  cell,\n  live_neighbors,\n)\n```\n\n### 使用调试器\n\n浏览器的调试器在调试 JavaScript 和 Rust 生成的 WebAssembly 很有效。\n\n举个例子，在 renderLoop 函数中增加`debugger;`可以暂停页面执行的某一刻。\n\n者给予我们查看每一刻细胞状态的能力。\n\n![调试画面](https://rustwasm.github.io/docs/book/images/game-of-life/debugging.png)\n\n### 练习\n\n1. 给 tick 方法增加 log，查看细胞状态。\n2. 加入`panic!()`查看打印出来的崩溃日志。\n\n## 增加交互\n\n接下来我们要给这个游戏增加一些交互，我们会允许用户选择细胞的生死，并且允许暂停游戏，并使绘制初始图案更加简单。\n\n### 暂停和继续游戏\n\n首先修改 html，在画布上面增加一个<button>标签。\n\n```html\n<button id=\"play-pause\"></button>\n```\n\n在 JavaScript 中，我们要做以下几点改动。\n\n- 追踪调用 requestAnimationFrame 的标识符，这样我们就能通过调用 cancelAnimationFrame 来终止动画。\n- 当点击播放或者暂停键的时候，先检查标识符是否存在，一旦存在，则表示动画正在运行，我们需要取消动画以保证 renderLoop 不再被调用。如果标识符不存在，我们需要调用 requestAnimationFrame 以保证动画继续运行。\n\n因为是 JavaScript 控制着 Rust 和 WebAssembly，我们不需要修改 Rust 部分。\n\n我们引入 animationId 变量，保存 requestAnimationFrame 的结果。当没有排队的动画时，这个变量值为 null。\n\n```JavaScript\nlet animationId = null;\n\nfunction renderLoop() {\n  drawGrid();\n  drawCells();\n\n  universe.tick();\n\n  animationId = requestAnimationFrame(renderLoop);\n}\n```\n\n任何一个时间，我们可以通过判断 animationId 来判断这个动画是否被暂停。\n\n```JavaScript\nfunction isPaused() {\n  return animationId === null;\n}\n```\n\n现在，当播放暂停键被点击，当正在播放时，暂停动画。并把按钮的状态改为播放。\n\n```JavaScript\nconst playPauseButton = document.getElementById(\"play-pause\");\n\nfunction play() {\n  playPauseButton.textContent = \"⏸\";\n  renderLoop();\n};\n\nfunction pause() {\n  playPauseButton.textContent = \"▶\";\n  cancelAnimationFrame(animationId);\n  animationId = null;\n};\n\nplayPauseButton.addEventListener(\"click\", function playBtnListener(event) {\n  if (isPaused()) {\n    play();\n  } else {\n    pause();\n  }\n});\n```\n\n最后我们把之前的 requestAnimationFrame 函数封装成`play()`。刷新本地服务器，可以看到网页上已经有暂停按钮了。尝试点击一下它吧。\n\n### 修改一个细胞的状态\n\n现在我们能暂停这个游戏了，是时候增加一个修改细胞的功能了。\n\n想控制细胞的生死，需要给`src/lib.rs`下的 Cell 增加一个 toggle 函数。\n\n```Rust\nimpl Cell {\n    fn toggle(&mut self) {\n        *self = match *self {\n            Cell::Dead => Cell::Alive,\n            Cell::Alive => Cell::Dead,\n        };\n    }\n}\n```\n\n想要修改在宇宙中的细胞需要获得细胞的行纵值，并转换为细胞的序号。\n\n```Rust\n#[wasm_bindgen]\nimpl Universe {\n    pub fn toggle_cell(&mut self, row: u32, column: u32) {\n        let idx = self.get_index(row, column);\n        self.cells[idx].toggle();\n    }\n}\n```\n\n这个方法增加第 1 行的属性声明是为了能够在 JavaScript 环境里面直接调用。在 JavaScript 文件中，监听<canvas>标签，将页面上的点击事件转换成画布上的点击事件，并调用 toggle_cell 方法重绘场景。\n\n```Rust\ncanvas.addEventListener(\"click\", function canvasClickListener(event) {\n  const boundingRect = canvas.getBoundingClientRect();\n\n  const scaleX = canvas.width / boundingRect.width;\n  const scaleY = canvas.height / boundingRect.height;\n\n  const canvasLeft = (event.clientX - boundingRect.left) * scaleX;\n  const canvasTop = (event.clientY - boundingRect.top) * scaleY;\n\n  const row = Math.min(Math.floor(canvasTop/(CELL_SIZE + 1)), height - 1);\n  const col = Math.min(Math.floor(canvasLeft/(CELL_SIZE + 1)), width - 1);\n\n  universe.toggle_cell(row, col);\n\n  drawGrid();\n  drawCells();\n});\n```\n\n使用`wasm-pack build`重新编译，刷新网页，并更新细胞状态。\n\n### 练习\n\n- 新建一个<input>标签来处理每帧更新多少个刻。\n- 增加一个重置按钮，把宇宙恢复到初始状态；再增加一个消灭按钮，毁灭所有细胞。\n- 当使用`Ctrl+Click`的时候，增加一个[glider](<https://en.wikipedia.org/wiki/Glider_(Conway%27s_Life)>)，使用`Shift+Click`增加一个 pulsar。\n\n## 性能日志(Time Profiling)\n\n本节我们将会提高这个游戏的性能，我们将会用 time profiling 来完成。\n\n### Time Profiling\n\n此部分将会讲解如何获得页面的性能分析，目标是提高 JavaScript 和 WebAssembly 之间的吞吐。\n\n> 永远使用`wasm-pack build`编译最新的代码，以确定你的优化正确。\n\n#### windows.performance.now()\n\n这个函数会返回以毫秒为单位的时间戳来计算页面加载速度。\n\n调用`performance.now()`的性能损耗低，所以我们可以利用它创造一个简单的测算工具而不是产生很大误差值。\n\n我们可以通过`web-sys`调用时间函数。\n\n```Rust\nextern crate web_sys;\n\nfn now() -> f64 {\n  web_sys::window()\n    .expect(\"should have window\")\n    .performance()\n    .expect(\"should have a Performance\")\n    .now()\n}\n```\n\n#### 开发者工具的性能查看器\n\n所有的浏览器的开发者工具都有性能查看器。这个查看器通过火焰图展示函数调用栈来表示哪一个函数耗时更长。\n\n如果你编译的时候打开了调试，则函数名将会显示在这里（如果没打开则显示一个不透明的名字，比如`wasm-function[123]`）。\n\n注意，因为性能查看器不会显示内联函数，又因为 Rust 和 LVVM 很重地依赖于内联函数，其结果就会让人感到头疼。\n\n![性能查看器无法处理内联函数](https://rustwasm.github.io/docs/book/images/game-of-life/profiler-with-rust-names.png)\n\n#### console.time 和 console.timeEnd\n\n这两个函数是浏览器的内置函数。以调用`console.time(\"foo\")`作为开始，以`console.time(\"foo\")`作为结束，参数是可选的。\n\n你可以通过 web-sys 调用`web_sys::console::time_with_label(\"foo\")`和`web_sys::console::time_end_with_label(\"foo\")`。\n\n如下是浏览器的截图。\n\n![使用console.time的截图](https://rustwasm.github.io/docs/book/images/game-of-life/console-time.png)\n\n另外，`console.time`和`console.timeEnd`会调用性能检查器统计出瀑布图。\n\n#### 使用#[bench]调用原生代码\n\n就像我们能使用原生的测试方法`#[test]`来测试代码，我们可以使用`#[bench]`通过操作系统的工具来查看函数性能。\n\n写好标准函数并放到`benches`文件夹下。确保`crate-type`已经引入 rlib，能使测试代码能够链接。\n\n无论如何，先搞明白你知道 WebAssembly 里面的瓶颈之后再花费精力去调查原生的性能调查器！用你的浏览器的性能调查器，或者使用这些时间去优化你的代码不是更好？\n\n### 利用 window.performance.now 创建一个计时器\n\n创建一个 FPS 的计时器用来调查游戏的渲染速度不失为一个好办法。\n\n我们在 JavaScript 增加 fps 对象。\n\n```JavaScript\nconst fps = new class {\n  constructor() {\n    this.fps = document.getElementById(\"fps\");\n    this.frames = [];\n    this.lastFrameTimeStamp = performance.now();\n  }\n\n  render() {\n    // Convert the delta time since the last frame render into a measure\n    // of frames per second.\n    const now = performance.now();\n    const delta = now - this.lastFrameTimeStamp;\n    this.lastFrameTimeStamp = now;\n    const fps = 1 / delta * 1000;\n\n    // Save only the latest 100 timings.\n    this.frames.push(fps);\n    if (this.frames.length > 100) {\n      this.frames.shift();\n    }\n\n    // Find the max, min, and mean of our 100 latest timings.\n    let min = Infinity;\n    let max = -Infinity;\n    let sum = 0;\n    for (let i = 0; i < this.frames.length; i++) {\n      sum += this.frames[i];\n      min = Math.min(this.frames[i], min);\n      max = Math.max(this.frames[i], max);\n    }\n    let mean = sum / this.frames.length;\n\n    // Render the statistics.\n    this.fps.textContent = `\nFrames per Second:\n         latest = ${Math.round(fps)}\navg of last 100 = ${Math.round(mean)}\nmin of last 100 = ${Math.round(min)}\nmax of last 100 = ${Math.round(max)}\n`.trim();\n  }\n};\n```\n\n接下来再每次迭代中调用 fps render 函数。\n\n```JavaScript\nconst renderLoop = () => {\n    fps.render(); //new\n\n    universe.tick();\n    drawGrid();\n    drawCells();\n\n    animationId = requestAnimationFrame(renderLoop);\n};\n```\n\n最后在 HTML 中增加 fps 的展示。\n\n```JavaScript\n<div id=\"fps\"></div>\n```\n\n增加 CSS，让它展示得更好。\n\n```CSS\n#fps {\n  white-space: pre;\n  font-family: monospace;\n}\n```\n\n好了，现在可以在页面上看到 FPS 计数器了。\n\n### 给每一刻计算时间\n\n每一刻开始调用`console.time`，结束的时候调用`console.timeEnd`。\n\n首先，要在`Cargo.toml`里面增加 web-sys。\n\n```toml\n[dependencies.web-sys]\nversion = \"0.3\"\nfeatures = [\n  \"console\",\n]\n```\n\n因为每次执行`console.time`后总要执行`console.timeEnd`，把他们包再[RAII](https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization)类型下就会更加便利。\n\n```Rust\nextern crate web_sys;\nuse web_sys::console;\n\npub struct Timer<'a> {\n    name: &'a str,\n}\n\nimpl<'a> Timer<'a> {\n    pub fn new(name: &'a str) -> Timer<'a> {\n        console::time_with_label(name);\n        Timer { name }\n    }\n}\n\nimpl<'a> Drop for Timer<'a> {\n    fn drop(&mut self) {\n        console::time_end_with_label(self.name);\n    }\n}\n```\n\n接下来，统计每一刻用的时间是多久，只需把初始化 Timer 放到 Universe 的构造函数里。\n\n```Rust\nlet _timer = Timer::new(\"Universe::tick\");\n```\n\n如下是每一刻执行的时间。\n\n![每一刻的执行时间](https://rustwasm.github.io/book/images/game-of-life/console-time.png)\n\n另外，通过使用`console.time`和`console.timeEnd`也能获得执行性能数据。\n\n![性能数据](https://rustwasm.github.io/book/images/game-of-life/console-time-in-profiler.png)\n\n### 增加宇宙大小\n\n> 本部分是拿火狐浏览器做例子，当然还有很多浏览器有类似的功能，只是有细微的差别。这个数据是一致的，但是部分命名和标量可能不一样。\n\n如果我们把宇宙修改的大一些，会发生什么？把 64x64 改成 128x128，结果会把 fps 从 60 降到 40。\n\n如果我们打开性能监控器，并看到它的瀑布图，我们可以看到动画帧用了 20 毫秒，回顾 60fps 时渲染一页则需要 16 毫秒，这不仅仅是 JavaScript 和 WebAssembly，还包括重绘的部分。\n\n![性能监视](https://rustwasm.github.io/book/images/game-of-life/drawCells-before-waterfall.png)\n\n如果仔细查看，可以看到`CanvasRenderingContext2D.fillStyle`的 setter 是很耗费时间的。\n\n> 再火狐，你可能看到的是\"DOM\"而不是\"CanvasRenderingContext2D.fillStyle\"，你需要打开\"展示 Gecko 平台数据\"。\n\n![火狐的性能监视器](https://rustwasm.github.io/book/images/game-of-life/profiler-firefox-show-gecko-platform.png)\n\n当然，这并不稀奇，40%的的时间都浪费在这个 setter 上面。\n\n> 我们可能期望性能瓶颈再 tik 函数上，但并不是。永远选择性能监视器观察，因为你可能浪费很多时间在无关的地方上面。\n\n在 drawCell 上面，fillStyle 在每次动画和每个细胞上面使用。\n\n```JavaScript\nfor (let row = 0; row < height; row++) {\n  for (let col = 0; col < width; col++) {\n    const idx = getIndex(row, col);\n\n    ctx.fillStyle = cells[idx] === DEAD\n      ? DEAD_COLOR\n      : ALIVE_COLOR;\n\n    ctx.fillRect(\n      col * (CELL_SIZE + 1) + 1,\n      row * (CELL_SIZE + 1) + 1,\n      CELL_SIZE,\n      CELL_SIZE\n    );\n  }\n}\n```\n\n现在我们知道 fillStyle 资源耗费比较多，那么我们该怎么避免他呢？我们需要判断细胞的生命状态来自决定 fillStyle 的值，设想，如果先设定`fillStyle = ALIVE_COLOR`，再绘制所有的活着的细胞，然后设置`fillStyle = DEAD_COLOR`，再设置所有的死细胞，最后我们只设置 fillStyle 两次。\n\n```JavaScript\n// Alive cells.\nctx.fillStyle = ALIVE_COLOR;\nfor (let row = 0; row < height; row++) {\n  for (let col = 0; col < width; col++) {\n    const idx = getIndex(row, col);\n    if (cells[idx] !== Cell.Alive) {\n      continue;\n    }\n\n    ctx.fillRect(\n      col * (CELL_SIZE + 1) + 1,\n      row * (CELL_SIZE + 1) + 1,\n      CELL_SIZE,\n      CELL_SIZE\n    );\n  }\n}\n\n// Dead cells.\nctx.fillStyle = DEAD_COLOR;\nfor (let row = 0; row < height; row++) {\n  for (let col = 0; col < width; col++) {\n    const idx = getIndex(row, col);\n    if (cells[idx] !== Cell.Dead) {\n      continue;\n    }\n\n    ctx.fillRect(\n      col * (CELL_SIZE + 1) + 1,\n      row * (CELL_SIZE + 1) + 1,\n      CELL_SIZE,\n      CELL_SIZE\n    );\n  }\n}\n```\n\n修改之后，刷新页面，此时的 fps 已经上升到 60。\n\n如果重新看原来的数据，现在每一刻只使用 10 毫秒。\n\n![更新后的性能检查](https://rustwasm.github.io/book/images/game-of-life/drawCells-after-waterfall.png)\n\n消除了 fillStyle 的性能瓶颈，发现比较消耗资源的是 fillRect，用来绘制每一个细胞的。\n\n![目前的性能损耗都在fillRect上面](https://rustwasm.github.io/book/images/game-of-life/drawCells-after-flamegraph.png)\n\n### 让时间变快\n\n有些人可能不喜欢等待，更希望一帧跑完九刻而不是一刻。我们可以通过修改 renderLoop 函数实现。\n\n```JavaScript\nfor (let i = 0; i < 9; i++) {\n  universe.tick();\n}\n```\n\n在机器上，fps 降到了 35，但是我们一定要到 60fps！\n\n现在我们知道性能瓶颈在 tick 函数上面，所以我们给函数的每一步都加上 Timer 监视，我猜测是创建向量和释放向量占用了很多资源造成的。\n\n```Rust\npub fn tick(&mut self) {\n    let _timer = Timer::new(\"Universe::tick\");\n\n    let mut next = {\n        let _timer = Timer::new(\"allocate next cells\");\n        self.cells.clone()\n    };\n\n    {\n        let _timer = Timer::new(\"new generation\");\n        for row in 0..self.height {\n            for col in 0..self.width {\n                let idx = self.get_index(row, col);\n                let cell = self.cells[idx];\n                let live_neighbors = self.live_neighbor_count(row, col);\n\n                let next_cell = match (cell, live_neighbors) {\n                    // Rule 1: Any live cell with fewer than two live neighbours\n                    // dies, as if caused by underpopulation.\n                    (Cell::Alive, x) if x < 2 => Cell::Dead,\n                    // Rule 2: Any live cell with two or three live neighbours\n                    // lives on to the next generation.\n                    (Cell::Alive, 2) | (Cell::Alive, 3) => Cell::Alive,\n                    // Rule 3: Any live cell with more than three live\n                    // neighbours dies, as if by overpopulation.\n                    (Cell::Alive, x) if x > 3 => Cell::Dead,\n                    // Rule 4: Any dead cell with exactly three live neighbours\n                    // becomes a live cell, as if by reproduction.\n                    (Cell::Dead, 3) => Cell::Alive,\n                    // All other cells remain in the same state.\n                    (otherwise, _) => otherwise,\n                };\n\n                next[idx] = next_cell;\n            }\n        }\n    }\n\n    let _timer = Timer::new(\"free old cells\");\n    self.cells = next;\n}\n```\n\n看这些时间戳，很明显我的猜测是错误的：大部分时间确实用在计算下一代细胞上面，每一刻都调用和释放向量竟然无足轻重。所以一定要使用性能监视器！\n\n![性能监视](https://rustwasm.github.io/book/images/game-of-life/console-time-in-universe-tick.png)\n\n下一部分需要`nightly`编译，因为我们将会使用[test-feature-gate](https://doc.rust-lang.org/unstable-book/library-features/test.html)来跑 benchmark（性能测试）。我们将会安装另一个工具[cargo-benchcmp](https://github.com/BurntSushi/cargo-benchcmp)。一个迷你的有`cargo bench`支持的性能测试工具。\n\n让我们写一个函数使用`#[bench]`属性，我们可以使用更成熟的测试工具测试它。\n\n```Rust\n#![feature(test)]\n\nextern crate test;\nextern crate wasm_game_of_life;\n\n#[bench]\nfn universe_ticks(b: &mut test::Bencher) {\n    let mut universe = wasm_game_of_life::Universe::new();\n\n    b.iter(|| {\n        universe.tick();\n    });\n}\n```\n\n我们也要注释掉所有`#[wasm_bindgen]`，否则\"cdylib\"或则其他编译流程会失败，\n\n此时，我们可以跑`cargo bench | tee before.txt`来编译项目查看性能日志了！\n\n```shell\n$ cargo bench | tee before.txt\n    Finished release [optimized + debuginfo] target(s) in 0.0 secs\n     Running target/release/deps/wasm_game_of_life-91574dfbe2b5a124\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n     Running target/release/deps/bench-8474091a05cfa2d9\n\nrunning 1 test\ntest universe_ticks ... bench:     664,421 ns/iter (+/- 51,926)\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out\n```\n\n他也告诉我们二进制文件的位置，我们可以跑第二次性能测试。但这次可以使用系统的性能测试工具。因为我用的是 Linux，所以 perf 就是我的测试工具。\n\n```shell\n$ perf record -g target/release/deps/bench-8474091a05cfa2d9 --bench\nrunning 1 test\ntest universe_ticks ... bench:     635,061 ns/iter (+/- 38,764)\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out\n\n[ perf record: Woken up 1 times to write data ]\n[ perf record: Captured and wrote 0.178 MB perf.data (2349 samples) ]\n```\n\n查看性能测试报告，得知所有的时间都如期使用在`Universe::tick`。\n\n![perf的结果](https://rustwasm.github.io/book/images/game-of-life/bench-perf-report.png)\n\nperf 会指明函数中到底是什么操作引起的性能损耗（译者：虽然我也没看出来）。\n\n![perf的结果](https://rustwasm.github.io/book/images/game-of-life/bench-perf-annotate.png)\n\n它告诉我们 26.67%的时间花在总和细胞数目，23.41%的时间花在获取列序号，另外 15.42%花在取得行序号。这三个性能瓶颈中，第二和第三都使用了比较耗费性能的 DIV 命令。这些 DIV 的实现是在`Universe::live_neighbor_count`。\n\n回想这个函数的定义：\n\n```Rust\nfn live_neighbor_count(&self, row: u32, column: u32) -> u8 {\n    let mut count = 0;\n    for delta_row in [self.height - 1, 0, 1].iter().cloned() {\n        for delta_col in [self.width - 1, 0, 1].iter().cloned() {\n            if delta_row == 0 && delta_col == 0 {\n                continue;\n            }\n\n            let neighbor_row = (row + delta_row) % self.height;\n            let neighbor_col = (column + delta_col) % self.width;\n            let idx = self.get_index(neighbor_row, neighbor_col);\n            count += self.cells[idx] as u8;\n        }\n    }\n    count\n}\n```\n\n使用取余运算是为了避免使用杂乱的 if 代码来处理边界，但导致我不得不用 DIV 这样比较耗费性能的指令。相反，如果用 if 处理边界，并展开循环，则分支条件将会比较适合 CPU 处理。\n\n```Rust\nfn live_neighbor_count(&self, row: u32, column: u32) -> u8 {\n    let mut count = 0;\n\n    let north = if row == 0 {\n        self.height - 1\n    } else {\n        row - 1\n    };\n\n    let south = if row == self.height - 1 {\n        0\n    } else {\n        row + 1\n    };\n\n    let west = if column == 0 {\n        self.width - 1\n    } else {\n        column - 1\n    };\n\n    let east = if column == self.width - 1 {\n        0\n    } else {\n        column + 1\n    };\n\n    let nw = self.get_index(north, west);\n    count += self.cells[nw] as u8;\n\n    let n = self.get_index(north, column);\n    count += self.cells[n] as u8;\n\n    let ne = self.get_index(north, east);\n    count += self.cells[ne] as u8;\n\n    let w = self.get_index(row, west);\n    count += self.cells[w] as u8;\n\n    let e = self.get_index(row, east);\n    count += self.cells[e] as u8;\n\n    let sw = self.get_index(south, west);\n    count += self.cells[sw] as u8;\n\n    let s = self.get_index(south, column);\n    count += self.cells[s] as u8;\n\n    let se = self.get_index(south, east);\n    count += self.cells[se] as u8;\n\n    count\n}\n```\n\n接下来再跑一次性能测试，将他输出到`after.txt`。\n\n```shell\n$ cargo bench | tee after.txt\n   Compiling wasm_game_of_life v0.1.0 (file:///home/fitzgen/wasm_game_of_life)\n    Finished release [optimized + debuginfo] target(s) in 0.82 secs\n     Running target/release/deps/wasm_game_of_life-91574dfbe2b5a124\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n     Running target/release/deps/bench-8474091a05cfa2d9\n\nrunning 1 test\ntest universe_ticks ... bench:      87,258 ns/iter (+/- 14,632)\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out\n```\n\n感觉性能提高了不少，现在对比一下前后的数据。\n\n```shell\n$ cargo benchcmp before.txt after.txt\n name            before.txt ns/iter  after.txt ns/iter  diff ns/iter   diff %  speedup\n universe_ticks  664,421             87,258                 -577,163  -86.87%   x 7.61\n```\n\n哇！提高了 7.61 倍！\n\nWebAssembly 意图和原生系统贴近，但是我们确实需要在 WebAssembly 环境下也作一次测试。\n\n从新编译程序，刷新浏览器页面，画面重新跑在 60fps，每一帧大概是 10 毫秒。\n\n成功！\n\n![测试结果](https://rustwasm.github.io/book/images/game-of-life/waterfall-after-branches-and-unrolling.png)\n\n### 练习\n\n- 现在，下一个性能瓶颈是`Universe::tick`调用和释放函数的部分，尝试缓存细胞状态，让 Universe 维护两个向量，永远不释放他们，也不掉用新的区间。\n- 换一种方式实现游戏，让 Rust 和 JavaScript 以细胞的列表交互，这样能让渲染画布更快吗？你能实现这个设计同时不在每个 tick 函数中调用新的列表吗？\n- 就性能显示来看 2D 画布渲染显然不够快，使用 WebGL 画布重新渲染，WebGL 能多快？使用 WebGL 能在遇到瓶颈前创建多大的宇宙空间？\n\n## 压缩.wasm 文件大小\n\nrustc 有很多配置项，可以让`.wasm`二进制文件更加小。在很多情况下更小的生成文件意味着更长的编译时间。另外更小的文件使得 WebAssembly 的运行时间更长。我们应该意识到这些方面上的牺牲。在这些情况下，当我们要减少编译文件大小时，我们应该考虑到使用性能监视器衡量一下这种改动是否值得。\n\n### 使用链接配置器编译\n\n在`Cargo.toml`，增加`lto=true`：\n\n```toml\n[profile.release]\nlto = true\n```\n\n者给予 LLVM 更多机会去内联和简化函数，不仅仅会使`.wasm`更小，还会让他在运行时运行得更快！但是会让他编译得更长。\n\n### 配置 LLVM 牺牲速度换文件大小\n\nLLVM 默认配置是为了运行速度，并不是大小。我们可以通过更改`Cargo.toml`去修改这一配置。\n\n```toml\n[profile.release]\nopt-level = 's'\n```\n\n或者，更激进的可以把它改成\"z\"。\n\n但是，配置为\"s\"的时候有的时候会比\"z\"更小，所以一定要做测量！\n\n### 使用 wasm-opt 工具\n\n[Binaryen](https://github.com/WebAssembly/binaryen)是一个关于 WebAssembly 编译工具的集合。他比 LLVM 更加后端，使用`wasm-opt`处理生成文件常常会节省 15%~20%的代码，同时又会提高运行速度。\n\n```\n# 输出为压缩的文件大小。\nwasm-opt -Os -o output.wasm input.wasm\n\n# 更激进的输出为压缩的文件大小。\nwasm-opt -Oz -o output.wasm input.wasm\n\n# 输出文件追求运行速度。\nwasm-opt -O -o output.wasm input.wasm\n\n# 输出文件更激进的追求运行速度。\nwasm-opt -O3 -o output.wasm input.wasm\n```\n\n#### 注意调试信息\n\n占用生成文件大小的主要成分是调试信息和函数名。`wasm-pack`能够默认移除调试信息。然而`wasm-opt`在使用`-g`参数时能删除函数名。\n\n这意味着，如果你按照以上操作，生成文件应该既没有调试信息也没有函数名。如果你想保留某些调试信息，请一定注意这一点。\n\n### 文件大小检查调查\n\n如果修改编译配置不能获得更小的文件大小，就应该调查一下是什么代码导致文件太大。\n\n> 就像做性能测试，我们应让工具来判断哪里出了问题，否则我们会浪费更多自己的时间。\n\n#### twiggy 代码检查器\n\n[twiggy](https://github.com/rustwasm/twiggy)是一个支持 WebAssembly 的代码大小检查器，他能分析二进制代码的调用图，并解决如下问题：\n\n- 为什么这个函数被编译到这段代码中。\n- 这个函数占用大小是多少？如果我删除这个函数以及其相关函数我能节省多大的空间？\n\n```\n$ twiggy top -n 20 pkg/wasm_game_of_life_bg.wasm\n Shallow Bytes │ Shallow % │ Item\n───────────────┼───────────┼────────────────────────────────────────────────────────────────────────────────────────\n          9158 ┊    19.65% ┊ \"function names\" subsection\n          3251 ┊     6.98% ┊ dlmalloc::dlmalloc::Dlmalloc::malloc::h632d10c184fef6e8\n          2510 ┊     5.39% ┊ <str as core::fmt::Debug>::fmt::he0d87479d1c208ea\n          1737 ┊     3.73% ┊ data[0]\n          1574 ┊     3.38% ┊ data[3]\n          1524 ┊     3.27% ┊ core::fmt::Formatter::pad::h6825605b326ea2c5\n          1413 ┊     3.03% ┊ std::panicking::rust_panic_with_hook::h1d3660f2e339513d\n          1200 ┊     2.57% ┊ core::fmt::Formatter::pad_integral::h06996c5859a57ced\n          1131 ┊     2.43% ┊ core::str::slice_error_fail::h6da90c14857ae01b\n          1051 ┊     2.26% ┊ core::fmt::write::h03ff8c7a2f3a9605\n           931 ┊     2.00% ┊ data[4]\n           864 ┊     1.85% ┊ dlmalloc::dlmalloc::Dlmalloc::free::h27b781e3b06bdb05\n           841 ┊     1.80% ┊ <char as core::fmt::Debug>::fmt::h07742d9f4a8c56f2\n           813 ┊     1.74% ┊ __rust_realloc\n           708 ┊     1.52% ┊ core::slice::memchr::memchr::h6243a1b2885fdb85\n           678 ┊     1.45% ┊ <core::fmt::builders::PadAdapter<'a> as core::fmt::Write>::write_str::h96b72fb7457d3062\n           631 ┊     1.35% ┊ universe_tick\n           631 ┊     1.35% ┊ dlmalloc::dlmalloc::Dlmalloc::dispose_chunk::hae6c5c8634e575b8\n           514 ┊     1.10% ┊ std::panicking::default_hook::{{closure}}::hfae0c204085471d5\n           503 ┊     1.08% ┊ <&'a T as core::fmt::Debug>::fmt::hba207e4f7abaece6\n```\n\n#### 手动修改 LLVM-IR\n\nLLVM-IR 是 LLVM 生成 WebAssembly 代码的最后一步。所以，他和最终生成的 WebAssembly 很像。更多的 LLVM-IR 代码意味着生成的文件越大，当一个函数占用了 LLVM-IR 中 25%的位置，则代表他占用了 25%的文件大小。当然这些数字只是个经验值，因为 LLVM-IR 还有一些 WebAssembly 没有的重要的信息（因为 WebAssembly 没有诸如 DWARF 调试信息）。\n\n你可以使用 cargo 生成 LLVM-IR 代码：\n\n```shell\ncargo rustc --release -- --emit llvm-ir\n```\n\n接下来你可以使用 find 命令去寻找存储在 cargo 生成目录(target)下的`.ll`文件。\n\n```shell\nfind target/release -type f -name '*.ll'\n```\n\n相关可以参考[LLVM 语言](https://llvm.org/docs/LangRef.html)\n\n#### 更激进的工具\n\n修改编译配置是比较好上手的。如果你想前进一个里程，你可以使用一些更激进的工具，像是重写代码以减少冗余。以下是一些不太优雅的代码，但是的确能减少生成文件大小。\n\n##### 避免字符串格式化\n\n`format!`,`to_string`等，能加入很多冗余代码。如果可能，在调试环境用格式化，而在发布环境使用静态字符串。\n\n##### 避免使用崩溃\n\n这很明显，使用 twiggy 之类的工具或者人工检查 LLVM-IR 能帮助你查出到底哪个函数崩溃。\n\n崩溃并不总是出现在`panic!()`宏，他们会在很多情况下出现。\n\n- 访问切片越界，如：`my_slice[i]`\n- 除 0，如：`dividend/divider`\n- 解 Option 类型或者 Result 类型，如：`opt.unwrap()`或者`res.unwrap()`\n\n前两个可以被改成第三个，访问切片可以使用`my_slice.get(i)`。除法可以使用`checked_div`，所以你只有一种需要处理的情况。\n\n解开`Option`或者`Result`有两种方法安全的和不安全的。\n\n安全的方式是使用 abort 方法而不是返回 None 和 Error 值。\n\n```Rust\n#[inline]\npub fn unwrap_abort<T>(o: Option<T>) -> T {\n  use std::process;\n  match o {\n    Some(t) => t,\n    None => process::abort(),\n  }\n}\n```\n\n最终，崩溃在`wasm32-unknown-unknown`被翻译成退出，因此不会造成代码冗余。\n\n相反的，[unreachable](https://crates.io/crates/unreachable)包为 Option 和 Result 类型提供不安全的[unchecked_unwrap](https://docs.rs/unreachable/1.0.0/unreachable/trait.UncheckedOptionExt.html#tymethod.unchecked_unwrap)方法。让 Rust 编译器假定 Option 类型是 Some 类型而 Result 类型是 Ok 类型。如果值是不正确的的情况是未被考虑的。你一定要在 110%确认的情况下使用这个包，因为编译器可没那么聪明能预估出错误。即使你这么做了，你一定要在调试环境下面做检查，而在发布环境下去掉检查。\n\n#### 避免调用内存或者使用 wee_alloc\n\nRust 的默认调用器是`dlmalloc`的一部分。它能达到 10KB。如果能够避免动态调用，你应该能省下 10KB。\n\n完全避免动态语言调用可能会非常困难。但是删除调用却在某些情况下很简单，在这些情况下，可以使用[`wee_alloc`](https://github.com/rustwasm/wee_alloc)代替全局的调用器可以从 10KB 中节省很多。`we_alloc`是当你想要一些调用器时的一个选择，并能同时减少代码大小。\n\n#### 使用 trait 来替代泛型\n\n当你创建一些泛型函数。\n\n```Rust\nfn whatever<T: MyTrait>(t: T) { ... }\n```\n\n`rustc`和 LLVM 会为不同类型生成新的函数拷贝。这为编译器提供了各种类型使用这个函数的机会。但会增加代码大小。\n\n如果你为对象提供 trait，如下：\n\n```Rust\nfn whatever(t: Box<MyTrait>) { ... }\n// or\nfn whatever(t: &MyTrait) { ... }\n// etc...\n```\n\n这样经过虚调用动态派遣（dynamic dispatch）的方法就被使用了，如此只会用一个函数会放在`.wasm`。这样的缺点是丢失了编译器自定义的机会，并且增加了不直接的，动态的语言调用。\n\n#### 使用 wasm-snip 工具\n\n[`wasm-snip`](https://github.com/fitzgen/wasm-snip)使用`unreachable`方法代替了 WebAssembly 的函数。这是一个又沉又钝的锤子，更像是徒手。\n\n也许你知道有些函数可能永远不会在运行时被调用，但是编译器不能保证？掐了他！执行`wasm-opt`加上`--dce`参数，所有无关函数就会被剪掉。\n\n这个工具对删除崩溃及其有用。\n\n### 我们能把生命游戏缩到多小？\n\n默认的配置下，WebAssembly 二进制大小为 29410 字节。\n\n```shell\n$ wc -c pkg/wasm_game_of_life_bg.wasm\n29410 pkg/wasm_game_of_life_bg.wasm\n```\n\n打开 LTO 之后设置`opt-level=\"z\"`执行`wasm-opt -Oz`，结果是 17317 字节。\n\n```shell\n$ wc -c pkg/wasm_game_of_life_bg.wasm\n17317 pkg/wasm_game_of_life_bg.wasm\n```\n\n如果使用 gzip 压缩，你能搞到 9045 字节！\n\n```shell\n$ gzip -9 < pkg/wasm_game_of_life_bg.wasm | wc -c\n9045\n```\n\n### 练习\n\n- 使用`wasm-snp`工具删掉会有崩溃的函数，它能减少多少字节？\n- 使用`wee_alloc`作为全局调用器，，修改`Cargo.toml`：\n\n```\n[features]\ndefault = [\"wee_alloc\"]\n```\n\n能够减少多少大小呢？\n\n- 我们只实现了一个 Universe，所以相比使用构造器，我们可以导出一个`static mut`实例，如果这个实例使用的是双向缓存，我们也可以让这些缓存也是全局`staic mut`。这样就移除了所有的动态调用，我们可以增加`#![no_std]`包取消掉调用器。这回能缩小多少大小？\n\n## 发布到 NPM\n\n首先，确保你登入了 npm。\n\n接着，使用`wasm-pack login`登入。\n\n### 发布\n\n确保已经执行`wasm-pack build`并且 pkg 文件已经编译好。\n\n已经准备好之后，跑`wasm-pack publish`上传包到 npm。\n\n这样就发布了！\n\n有哥们照着这个指导做完发布失败，是因为\"name\"字段存在重名\n\n```toml\n[package]\nname = \"wasm-game-of-life-my-username\"\n```\n\n接着，重新编译并发布\n\n```shell\nwasm-pack build\nwasm-pack publish\n```\n\n这会应该能行。\n\n## 与 JavaScript 相互交互\n\n### JavaScript 函数的输出和引用\n\n#### 在 Rust 一边\n\n在 JavaScript 为主的世界里使用 WebAssembly，引入和输出函数比较直接，有点类似于 C。\n\nWebAssembly 模块声明了一系列引入，每一个都有模块名。模块名可以使用`#[link(wasm_import_module)]`提供给`extern {...}`。\n\n导出的 WebAssembly 线性内存被导出作\"memory\"。\n\n```Rust\n// import a JS function called `foo` from the module `mod`\n#[link(wasm_import_module = \"mod\")]\nextern { fn foo(); }\n\n// export a Rust function called `bar`\n#[no_mangle]\npub extern fn bar() { /* ... */ }\n```\n\n因为 WebAssembly 的值类型有局限，这些函数只有基础的数字类型。\n\n#### 在 JavaScript 一边\n\n在 JavaScript 中，wasm 二进制文件转换成 ES6 模块。它必须被实例化为线性内存并由一系列函数能对应到这些引入。细节描述可在[MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiateStreaming)找到。\n\nES6 的模块包括从 Rust 暴露给 JavaScript 的函数，现在可以用 JavaScript 调用。\n\n[这里](https://www.hellorust.com/demos/add/index.html)有一个很简单的构建流程。\n\n### 除了数字\n\n当在 JavaScript 中使用 WebAssembly，WebAssembly 的内存和 JavaScript 的内存有很大的不同。\n\n- 每个 WebAssembly 模块的线性内存，JavaScript 可以自由访问。\n- 对应之下，WebAssembly 不能访问 JavaScript 的内存。\n\n所以，有两种复杂的交互。\n\n- 复制二进制数据到 WebAssembly 内存。\n- 建立一个在 JavaScript 上的堆内存，提供一堆地址。这样 WebAssembly 访问 JavaScript 对象，间接通过 JavaScript 访问。\n\n幸运的是，通过`bindgen`框架[`wasm-bindgen`](https://github.com/rustwasm/wasm-bindgen)可以帮助交互。这个框架可以将已习惯的 Rust 语言自动翻译到 JavaScript。\n\n### 自定义部分（译者：所以这个到底是干什么用的？）\n\n自定义部分允许随意继承人一的数据进入 WebAssembly 模块，这个数据是在编译时设置，不能在运行时修改。\n\n在 Rust 中，自定义部分是通过`#[link_section]`属性暴露的静态数组([T; size])。\n\n```Rust\n#[link_section = \"hello\"]\npub static SECTION: [u8; 24] = *b\"This is a custom section\";\n```\n\n这样给 wasm 增加一个 hello 部分，这个 SECTION 变量是随意的，但是无论怎么赋值，内容总是这些文字。\n\n这个自定义内容可以被 JavaScript 通过[`WebAssembly.Module.customSections`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Module/customSections)获得自定义部分，它返回一个`ArrayBuffer`，如果有同名的部分，他们会被放到一个数组中。\n\n```JavaScript\nWebAssembly.compileStreaming(fetch(\"sections.wasm\"))\n.then(mod => {\n  const sections = WebAssembly.Module.customSections(mod, \"hello\");\n\n  const decoder = new TextDecoder();\n  const text = decoder.decode(sections[0]);\n\n  console.log(text); // -> \"This is a custom section\"\n});\n```\n\n## 哪些包能在 WebAssembly 下面使用\n\n最简单的就是列出 WebAssembly 上能用的 Rust 包：如果避开了以下内容，则这些包可以在 WebAssembly 使用。如果一个包支持`#![no_std]`\n的包，这个包也可能支持 WebAssembly。\n\n### 以下包不能使用\n\n#### C 和系统级依赖\n\nWebAssembly 不提供系统一级别的库，所以任何链接系统库的地方都无法成功。\n\n使用 C 库可能不会成功，既然没有稳定的交叉编译 ABI，和提供给 WebAssembly 交叉链接的连接库。虽然 clang 已经发布 wasm32 的生成，但是还远远不足。\n\n#### 文件 I/O\n\nWebAssembly 没有访问文件系统的功能，所以访问文件系统的库都不能使用。\n\n#### 调用线程\n\n目前有计划[加入线程](https://rustwasm.github.io/2018/10/24/multithreading-rust-and-wasm.html)，但是还没被发布。尝试调用线程会导致崩溃。\n\n### 有哪些目的的包能在 WebAssembly 下面使用\n\n如果只是提供[算法](https://crates.io/categories/algorithms)和[数据结构](https://crates.io/categories/data-structures)的包。\n\n#### #![no-std]\n\n[不依赖于标准库的包](https://crates.io/categories/no-std)能够运行在 WebAssembly 下面。\n\n#### 解析器\n\n只要是接受输入且无需文件操作的[解析器](https://crates.io/categories/parser-implementations)就可能运行在 WebAssembly 下。\n\n#### 文字处理\n\n[复杂的语言处理](https://crates.io/categories/text-processing)可能会运行在 WebAssembly 下面。\n\n#### Rust 范式\n\n[适用于不同情况下的包](https://crates.io/categories/rust-patterns)可能运行在 WebAssembly 下。\n\n## 如何给常用库增加 WebAssembly 支持\n\n本部分讲解如何将常用库增加 WebAssembly 支持。后面的内容我就捡感兴趣的写了。\n\n### 在 CI 增加 wasm32-unknown-unknown\n\n保证 CI 中增加如下命令\n\n```shell\nrustup target add wasm32-unknown-unknown\ncargo check --target wasm32-unknown-unknown\n```\n\n举个例子，在 travis 的配置中增加如下配置：\n\n```yaml\nmatrix:\n  include:\n    - language: rust\n      rust: stable\n      name: \"check wasm32 support\"\n      install: rustup target add wasm32-unknown-unknown\n      script: cargo check --target wasm32-unknown-unknown\n```\n\n### 在 node.js 或者无头浏览器（译者：卧槽是这么翻译么）\n\n你可以使用`wasm-bindgen-test`和`wasm-pack test`去跑测试，详细内容上面已经提到。\n\n## 发布 WebAssembly 到线上\n\n> 发布过程几乎和任何 web 应用发布是一样的。\n\n为了发布 Web 应用，复制生成文件到线上环境，配置你的 HTTP 服务器让他们可访问。\n\n### 保证服务器支持 application/wasm\n\n为了让浏览器加载变快，[WebAssembly.instantiateStreaming](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiateStreaming)函数会使用管道传输文件（请确定你的打包器能够使用这个函数）。但是 instantiateStreaming 需要 HTTP 返回类型支持`application/wasm`，否则会丢出错误。\n\n- [如何配置 Apache 服务器](https://httpd.apache.org/docs/2.4/mod/mod_mime.html#addtype)\n- [如何配置 Nginx 服务器](https://nginx.org/en/docs/http/ngx_http_core_module.html#types)\n\n### 更多内容\n\n- [webpack 线上打包的最佳实践](https://webpack.js.org/guides/production/)\n","collection":"blog","data":{"type":"post","category":"fe","tag":["rust","wasm"]}},{"id":"2020/02/28/Movie-supplementary-file-plan-filial-piety-and-grandson.md","slug":"2020/02/28/movie-supplementary-file-plan-filial-piety-and-grandson","body":"\n# 电影补档计划：孝子贤孙伺候着\n\n![孝子贤孙伺候着](https://img9.doubanio.com/view/photo/l/public/p2376859119.webp)\n\n故事就是男主角（陈佩斯饰）在政府工作支持火葬，然而家里老人（赵丽蓉饰）不同意，老人装死试试孩子能不能真的去土葬，结果儿子大操大办整得一片慌乱，最终老人认清事实，同意火葬。\n\n很荒诞的喜剧，可惜画质已经不行了。\n","collection":"blog","data":{"type":"post","category":"movie"}},{"id":"2020/02/29/Movie-supplementary-program-imitate-the-game.md","slug":"2020/02/29/movie-supplementary-program-imitate-the-game","body":"\n# 电影补档计划：模仿游戏\n\n![the imitation game](https://img3.doubanio.com/view/photo/l/public/p2216739941.webp)\n\n阿兰图灵二战时期被安排秘密破译德军的电报「英格玛」，「英格玛」是一台每天变更配置的加密机器，即使已经截获了机器也无法破解，必须猜出配置，图灵希望制造一台机器来破译，然而和同事发生分歧。幸好图灵遇到了琼，琼成为了小组的粘合剂，终于使小组齐心协力完成了初代图灵机。图灵以自己的初恋命名其为 Christopher。然而 Christopher 还是无法快速解密，机缘巧合，图灵从琼的朋友口中得知可以通过几个固定词语解密。终于图灵机通过解密「希特勒万岁」解开密码，然而，为了让德国不知道英国已经解开秘密，不得不牺牲很多士兵。即使是战争结束，小组也不能泄露信息。\n\n后来图灵因为同性恋而被指控，接受激素治疗，最终选择自杀。而模拟游戏则是图灵提出的，通过对话判断对方是否是机器的方法。\n","collection":"blog","data":{"type":"post","category":"movie"}}]}