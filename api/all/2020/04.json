{"posts":[{"id":"2020/04/02/docker-mongodb.md","slug":"2020/04/02/docker-mongodb","body":"\n# docker 化的 mongodb 使用方案\n\n之前提到过[使用 watchtower 更新本地的 image 的方案](/tech/2020/03/15/Coding.net使用Jenkins实现自动部署CI&CD)，本来我的系统一直使用 sqlite 来做数据库，现在想改成 mongodb。\n\n涉及到 mongodb 就不得不需要考虑怎么本地化，并且如何做备份。数据本地化很好做，只需要 docker 的 volume 即可，编写`docker-compose.yml`，使用`docker-compose up -d`。\n\n```ini\nversion: '3.7'\n\nvolumes:\n  mongo:\n  strapi:\n\nservices:\n  mongo:\n    image: mongo\n    restart: always\n    volumes:\n      - mongo:/data/db\n    ports:\n      - 27017:27017\n  adminmongo:\n    image: mrvautin/adminmongo\n    ports:\n      - 1234:1234\n    environment:\n      - HOST=0.0.0.0\n      - CONN_NAME=mongo\n      - DB_HOST=mongo\n      - DB_PORT=27017\n      - PASSWORD=$ADMIN_MONGO_PASSWORD\n    links:\n      - mongo:mongo\n  strapi:\n      image: <strapi registry>\n      environment:\n        DATABASE_CLIENT: mongo\n        DATABASE_NAME: strapi\n        DATABASE_HOST: mongo\n        DATABASE_PORT: 27017\n      links:\n        - mongo:mongo\n      volumes:\n        - ./app:/srv/app\n      ports:\n        - '1337:1337'\n\n\n```\n\n## 备份\n\n使用如下命令备份\n\n```shell\ndocker-compose exec -T mongo mongodump --archive --gzip --db <database> > dump.gz\n```\n\n## 还原\n\n```shell\ndocker-compose exec -T mongo mongorestore --archive --gzip < dump.gz\n```\n\n## 可视化管理 docker\n\n使用 [portainer](https://www.portainer.io/) 能够可视化管理现在运行的 docker。执行如下命令，再访问 localhost:9000，嗒嗒！以后再也不需要执行`docker ps`了。\n\n```shell\ndocker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer\n```\n\n## 可视化管理 mongodb\n\n可以使用[adminmongo](https://github.com/mrvautin/adminMongo)提供一套简单可用的 WebUI，我已经写到了 docker compose 里面了。\n\n另外`environment`里面的`PASSWORD`并不好使，已经有[issue](https://github.com/mrvautin/adminMongo/issues/166)，不过已经是 2017 年的了，最快的解决方式就是删除`config/app.json`，只需要在 portainer 里面选择`Containers > mongodb_adminmongo_1` 点击 `Edit`，修改 `Command` 并重新部署。\n\n![portainer的设置](./portainer-config.jpg)\n","collection":"blog","data":{"type":"post","category":"tech","tag":["docker","portainer","mongodb"]}},{"id":"2020/04/04/ObservableHQ-JS-Jupyter.md","slug":"2020/04/04/observablehq-js-jupyter","body":"\n# ObservableHQ-JS 终于有自己的 Jupyter 笔记本了\n\n学习机器学习的时候用上 python 的 Jupyter notebook 是真好用，曾经就想，如果 JavaScript 也有一个就好了，没错[ObservableHQ](https://observablehq.com/)就是基于 D3.js 的数据可视化笔记本。\n\n官方的[入门](https://observablehq.com/@observablehq/a-taste-of-observable)讲的很详细，接下来一周我可能会专心于里面的[D3 教程](https://observablehq.com/@d3/learn-d3)，间或去学习 threejs fundamental。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["observablehq","JavaScript","d3","jupyter"]}},{"id":"2020/04/07/D3.md","slug":"2020/04/07/d3","body":"\n# 学习 D3 的新姿势\n\n今天用了半天的时间把 observable HQ 上面的 [Learn D3](https://observablehq.com/@d3/learn-d3) 学习了一遍，[这](https://observablehq.com/@gongbaodd/d3-js)是纯笔记版。\n\n不过今天真的是爽到了，没错，我终于找到了以前学习 D3 没动力的原因了，那么厚的一本书，基本上就是把 D3 gallery 抄了一遍。最开始基本上还要学一个 D3 版本的 jQuery 选择器，数据还要自己搞，基本读了两章就打算放弃。\n\n```JavaScript\nvalues = [...\"123456\"];\nimport {chart as chart1} with {values as data} from \"@d3/histogram\";\n```\n\n这就是一个柱状图了！！！爽到有没有？\n\n如果你想写一个控制界面\n\n```JavaScript\nviewof replay = html`<button>Replay</button>`\n```\n\n使用这个控制器\n\n```JavaScript\nreplay, html`\n<svg viewBox=\"0 0 ${width} ${height}\">\n  ${d3.select(svg`<g>`).call(shape_xAxis).node()}\n  ${d3.select(svg`<g>`).call(shape_yAxis).node()}\n  ${d3.select(svg`\n    <path\n      d=\"${line(shape_data)}\"\n      fill=\"none\"\n      stroke=\"steelblue\"\n      stroke-width=\"1.5\"\n      stroke-miterlimit=\"1\"\n      stroke-dasharray=\"0,1\"\n    >\n    </path>\n  `).call(reveal).node()}\n</svg>\n`\n```\n\n哈哈，有趣，这语法很有想象力，比 svelte 更加大胆，仿佛用 JavaScript 实现了一个类似于 python 的词法。如果你想创建一个复杂的变量，你可以：\n\n```JavaScript\nsum = {\n  let s = 0;\n  for (let i = 0; i < 10; ++i) {\n    s += i;\n  }\n  return s;\n}\n```\n\nObservable HQ 的每个语句类似于 react 的 render 函数，你甚至可以把它写成一个迭代器。当 replay 被点击，页面展示的数值会从 1 逐渐增加到 299。\n\n```JavaScript\n{\n  replay;\n  for (let i = 0, n = 300; i < n; ++i) {\n    yield i;\n  }\n}\n```\n\n另外可以参考[如何利用 Wikipedia 的数据](https://observablehq.com/@mbostock/working-with-wikipedia-data)进一步使用 observable HQ。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["observablehq","d3"]}},{"id":"2020/04/09/Amazon's-anti-drug-drama-zero-zero.md","slug":"2020/04/09/amazons-anti-drug-drama-zero-zero","body":"\n# 亚马逊年度禁毒大戏「零零零」\n\n前几天刷推特，都在传「零零零」这个剧怎么怎么火，说实话，关于黑帮和毒品的剧我还真不敢兴趣，试着抱一抱的心态看了一集，结果一发不可收拾把第一季全看完了，接下来，本文全是剧透！\n\n![截图](./zzz.jpg)\n\n第一集详细介绍了出场人物，分别是买方（buyer）、中间人（broker）以及卖方（seller）。\n\n买方是一对意大利爷孙，暂时称买方爷爷和买方孙子，买方爷爷正在培养孙子处理生意，而孙子则认为爷爷杀死了父亲而暗自结合朋友猪猪仔准备抢下爷爷的生意并复仇。\n\n中间人是美国的一家人，中间人爸爸带着子女两人（中间人姐姐，Emma 和中间人弟弟）相依为命，Emma 帮着父亲处理家庭生意而因为弟弟遗传了母亲的病，中间人爸爸出于保护不愿意给生意交给儿子，而弟弟却一直想出力。\n\n卖方在墨西哥买通缉毒警察，缉毒警察表面在缉毒，暗地里收了卖方的钱偷偷保护卖方，在一次出警时，虽然已经偷偷通知交易双方，但还是在枪战中杀死了中间人爸爸。\n\n中间人爸爸死后，Emma 哄骗弟弟说爸爸同意他们一起接手生意，弟弟很开心并要求自己亲手接管最新的一批可卡因。然而赶到美国参加追悼会的买家孙子认为姐弟俩太弱小，并且想换到自己的中间人手上来架空爷爷，偷偷买通运货的船长，制造船上事故。\n\n在运输中，船长放火打算把弟弟和船一起烧了，然而在船长逃离后，弟弟成功灭火，并一个人把船开到了非洲。Emma 和弟弟在非洲汇合，为了躲开海关检查，姐弟俩选择了一条穿过圣战分子占领的路前往摩洛哥的卡萨布兰卡，中途险些丧命。\n\n同时，卖方缉毒警察清理了自己部队里面的正义分子，完全黑化后和贩毒者发生金钱上的分歧，逐渐壮大之后，干脆干掉原来的卖方自己收钱。\n\n卖方爷爷得知孙子想复仇，来了一出杀猪儆孙（话说爷爷真的很有人格魅力，不愧是意大利黑帮），坦白自己当年杀儿子的原因。爷爷遭到追杀，孙子假装被爷爷打伤放走爷爷，可是因为演技太差被猪猪仔看出来，猪猪仔挟持孙子妻女，让孙子截下停留在卡萨布兰卡的货。\n\n赶到卡萨布兰卡的买方孙子找到中间人弟弟逼迫他说出货的位置，弟弟故意拖延，成功让货物运出，却因此丧了命。Emma 得知弟弟丧命，到意大利找到买方爷爷，买房爷爷为了保全生意，杀死孙子，并解决掉猪猪仔一帮人。\n\nEmma 来到墨西哥交付尾款，发现卖方已经被缉毒警取而代之，交接下一单的要求后，虽然面带微笑带心怀感伤的离开。而远在意大利，买方爷爷重出江湖处理毒品，并准备培养他的曾孙。\n\n所以，千万不要贩毒 😂。\n","collection":"blog","data":{"type":"post","category":"tv"}},{"id":"2020/04/13/threejs-fundamentals-threejs.md","slug":"2020/04/13/threejs-fundamentals-threejs","body":"\n# threejs fundamentals 名副其实的 threejs 入门书\n\n最近几天真是忙，除了读这本书，我的平板（酷比魔方 Mix Plus）突然进不去系统了，查了一下，原来山寨本硬盘质量不好，莫名其妙全清了（惊！），好在做了备份，当然因为不想花钱，没再买一个 SATA SSD 硬盘，花了一些时间重做系统。\n\n祸不单行，主力机 Dell inspiron 13 风扇坏了，虽然已经报修，但还在走流程，这使得我现在只能以 1.8GHz（关闭风扇） 工作 😭。\n\n正好，刚做完系统，所以这篇文章我争取在平板上写，以保证系统安装正确。\n\n另外，因为抢到了福田的消费券，所以这本书的实现，争取在本周完成。\n","collection":"blog","data":{"type":"post","category":"book","tag":["threejs","JavaScript","webGL"]}},{"id":"2020/04/16/CSS.md","slug":"2020/04/16/css","body":"\n# CSS 渐变利器\n\n[CSS gradient generator](https://mybrandnewlogo.com/color-gradient-generator)\n","collection":"blog","data":{"type":"post","category":"fe","tag":["css","gradient"],"series":{"slug":"tools","name":"利器"}}},{"id":"2020/04/21/threejs-mesh.md","slug":"2020/04/21/threejs-mesh","body":"\n# threejs 细化-创建一个 mesh、使用加载器、多个场景\n\n记录下最近几天的事，终于 Dell 的维修把我电脑的风扇修好了，不过感觉 inspiron 的风扇设计有 bug，新风扇估计也撑不了多久，但愿只是我多疑了。另外通过神奇的某宝，我将我手上的小米平板二升级了内存和硬盘，考虑到 8GB 内存对于 Atom Z8500 这个 CPU 有点多余，于是升级到了 4GB + 128GB，到手之后果然比 2GB 流畅（当然肯定没法比酷睿了），所以这个配置还是比较推荐的。\n\n回到主题，最近一周我都在使用 react-three-fiber 来学习 threejs，这里会做一个系列来详细整理一下。\n\n## 创建一个 mesh\n\n可以使用 JSX 创建 mesh, 因为 mesh 有 material 和 geometry 两个访问器，在 JSX 中可以作为属性使用。\n\n```JavaScript\nexport default () => (\n    <Canvas>\n        <mesh\n            name=\"mesh\"\n            material={new MeshBasicMaterial()}\n            geometry={new BoxBufferGeometry(1, 1, 1)}\n        />\n    </Canvas>\n);\n```\n\n当然作为参数也可以。\n\n```JavaScript\nexport default () => (\n    <Canvas>\n        <mesh arg={[new BoxBufferGeometry(1, 1, 1), new MeshBasicMaterial()]}/>\n    </Canvas>\n);\n```\n\n官网还提供了一个绝妙的方法。\n\n```JavaScript\n// 实现不了，不知道咋回事儿\nexport default () => (\n    <Canvas>\n        <mesh>\n            <boxBufferGeometry attach=\"geometry\" />\n            <meshBasicMaterial attach=\"material\" />\n        </mesh>\n    </Canvas>\n);\n```\n\n另外因为 Canvas 里面的元素和 JSX 的绑定使用的是 memo，所以如果使用 primitive 定义元素的时候会丢。\n\n```JavaScript\n// 这么做虽然会渲染出来，但是Box有的时候会丢\nconst Box = new Mesh(\n    new BoxBufferGeometry(1, 1, 1),\n    new MeshBasicMaterial(),\n);\n\nexport default () => (\n    <Canvas>\n        <primitive object={Box} />\n    </Canvas>\n);\n```\n\n## 加载器\n\n加载 texture 时，可以使用`useEffect`自己写，当然也有更优雅的方法，利用 react 自己的`useMemo`或者`useCallback`，再就是使用 react three fiber 的`useLoader`。\n\n```JavaScript\n// 使用 useMemo\nconst Plane = () => {\n    const texture = useMemo(() => new TextureLoader().load(\"xxx.jpg\"), [])\n    return <mesh\n        material={new MeshBasicMaterial({map: texture})}\n        geometry={new PlaneGeometry(1, 1)}\n    />\n}\n```\n\n```JavaScript\n// 使用 useLoader\nconst PlaneAsync = () => {\n    const [texture] = useLoader(TextureLoader, \"xxx.jpg\");\n\n    return <mesh\n        material={new MeshBasicMaterial({map: texture})}\n        geometry={new PlaneGeometry(1, 1)}\n    />\n}\n\nconst Plane = () => (\n        <Suspense fallback={<mesh />}>\n            <PlaneAsync />\n        </Suspense>\n    )\n```\n\n## 使用多个场景\n\nthree react fiber 会默认给一个场景(scene)、一个摄像头(camera)还有一个渲染器(render)。可是如果我需要多个场景，比如建模工具往往会给一个正交视图以及正视图，这种情况就需要多个场景。\n\n首先要使用`setDefaultCamera`将新建的摄像头代替默认摄像头。\n\n```TypeScript\nexport default () => {\n    const { setDefaultCamera } = useThree();\n    const camera = useRef<PerspectiveCamera>();\n\n    useLayoutEffect(() => camera.current && setDefaultCamera(camera.current), [])\n\n    return <perspectiveCamera\n      name=\"camera\"\n      ref={camera}\n    />\n}\n```\n\n接下来是创建场景，场景不需要代替原有场景，但是需要使用`useFrame`修改`render`方法。\n\n```TypeScript\n// 再原画面的左上角绘制场景\nexport default () => {\n    const scene = useRef<Scene>();\n    const {\n        size: {left, top, width, height},\n        camera,\n    } = useThree();\n\n    useFrame(({ gl }) => {\n        gl.autoClear = true;\n        gl.setScissor(left, top, width / 2, height / 2);\n        gl.setViewport(left, top, width / 2, height / 2);\n\n        scene.current && gl.render(scene, camera)\n    }, 10);\n\n    return (\n        <scene ref={scene}>\n            <mesh />\n        </scene>\n    );\n}\n```\n\n这里`useFrame`的第二个参数表示它的优先级，值越高，越先渲染，这意味着比它优先级低的场景渲染之前要把`gl.autoClear`设置为`false`，以避免被清除。\n\n## 其它\n\n另外可以看看京东的一篇博客[凹凸实验室](https://aotu.io/notes/2018/10/18/cannonjs/index.html)。\n","collection":"blog","data":{"type":"post","category":"fe","tag":["threejs","JavaScript","webGL"],"series":{"slug":"threejs-howto","name":"细品threejs"}}},{"id":"2020/04/22/Devs.md","slug":"2020/04/22/devs","body":"\n# Devs -配乐很美丽，故事有点虎头蛇尾的剧\n\n![Devs cover](./devs.jpg)\n\n本剧的主角 Lily 和她的男友在一家高端技术公司工作，男友因为项目表现优异被提拔到 Devs 项目中。当天晚上，男友因为帮助俄罗斯特工偷窃 Devs 的代码而被公司的保安男杀害。\n\n第二天 Lily 询问公司高管男友的踪迹被告知男友自杀，Lily 无意间发现男友手机内安装了加密软件，所以找到备胎前男友解锁。备胎前男友本着「当然还是原谅她」的原则帮她解锁并联系上了俄罗斯线人。线人准备拉 Lily 下水，但被 Lily 拒绝，这次联络被保安男发现，保安男解决掉线人，并打算送 Lily 去精神病院。\n\nLily 和备胎前男友发现男友的自杀证据有造假，确定男友是被谋杀，可是 Lily 被保安男胁迫去精神病院。备胎前男友偷偷带 Lily 逃离精神病院，并一同前往公司高管对峙什么是 Devs。\n\n公司高管告诉 Lily，Devs 通过算法用来预测过去与未来，并且这个机器预测到 Lily 和高管一起死亡后就宕机了。\n\n其实 Devs 是公司高管用来复活出车祸女儿的设备，在坚持单一宇宙观多次失败之后，一个工程师加入了多元宇宙的算法，最终能够近似地预测过去和未来，但因为打破 Devs 的初衷，这名工程师也被开除，被设计自杀。\n\nLily 决定不回公司，这样就能打破机器的预测。意外的是保安男将备胎前男友杀死，准备杀 Lily 的时候，被 Lily 家门口的乞丐男杀死。乞丐男是另一个俄罗斯特工，他要求 Lily 回到香港，这样能躲过追责，然而 Lily 最终还是先择走机器预测的路，回到了公司，高管和 Lily 一同看了宕机前得预测，原来 Lily 持枪和高管在电梯对峙，枪击中高管并破坏了电梯，两人跌落而亡。\n\n不过和预测不同的是，Lily 在和高管进入电梯时故意扔掉枪，这样就又打破了机器的预测。高管告诉 Lily，Devs 其实是 Deus，只是 u 设计得太像 v 了（王德发？）。可是电梯还是被认为失控，两人坠落而亡。\n\nLily 醒来，发现男友还在身旁，备胎前男友也活着，到公司发现高管和他的女儿都活着。原来高管将所有人复制到了 Deus 得世界中，所以即使现实两人已经死亡，只要 Deus 不关闭，他们总能生活在这个虚拟的平行空间中，全剧终（王德发？？？？）。\n","collection":"blog","data":{"type":"post","category":"tv"}},{"id":"2020/04/25/Tales.From.the.Loop.md","slug":"2020/04/25/talesfromtheloop","body":"\n# Tales from the Loop-北欧治愈风黑镜\n\n\n八个小故事，但又是发生在同一个小镇中的一群人中。安利[大聪说电影](https://www.bilibili.com/video/BV1Ze411x7sd/) 的解说，最喜欢的就是最后一集，时间转瞬即逝啊，珍惜吧，骚年。\n","collection":"blog","data":{"type":"post","category":"tv"}},{"id":"2020/04/26/Hunger-Platform-Direct-Reviewing-Class-Questions-Movies.md","slug":"2020/04/26/hunger-platform-direct-reviewing-class-questions-movies","body":"\n# 饥饿平台 直接评论阶级问题的电影\n\n听[黑水公园](https://music.163.com/#/program?id=2066839072)提到的电影，相比于「寄生虫」这里把阶级关系写的有点直接，本身出身比较低的我并不太想讨论这种话题，包括即刻里面的「你为什么考不上人大附」还有 B 站「你那么穷，就别发油管上，好象全国都很穷」之类的话题，因为没意义。就跟电影里面送上去的蛋糕一样，哪怕你送上去的是小女孩，又怎样？\n","collection":"blog","data":{"type":"post","category":"movie"}},{"id":"2020/04/27/threejs.md","slug":"2020/04/27/threejs","body":"\n# threejs 细化-在网格上渲染，停止渲染，使用物理引擎\n\n这是细化了解 threejs 的第二篇，[第一篇](/fe/2020/04/21/threejs细化-创建一个mesh、使用加载器、多个场景.html)\n\n## 在网格上渲染\n\n这里有一点类似于使用多个场景，设想如果想要做一个类似于水晶球的设计，水晶球有一个 scene1，水晶球自己又在另一个 scene0 里面，这里就需要使用 renderTarget 渲染 scene1 到水晶球上面。\n\n先创建一个 target。\n\n```typescript\nconst target = new WebGLRenderTarget(width, height);\n```\n\n再创建一个球，并使用 target 作为材料。\n\n```tsx\nconst ball = () => {\n  return (\n    <mesh name=\"ball\">\n      <sphereBufferGeometry attach=\"geometry\" args={[1, 32, 16]} />\n      <meshPhongMaterial attach=\"material\" map={target.texture} />\n    </mesh>\n  );\n};\n```\n\n然后创建 scene1。\n\n```ts\nconst scene1 = new Scene();\nconst camera = new PerspectiveCamera(75, 1, 0.1, 5, position: [0, 1, 2]);\n\n{\n  const light = new HemisphereLight();\n  scene1.add(light);\n}\n\n{\n  const mesh = new Mesh(\n    new BoxBufferGeometry(1, 1, 1),\n    new MeshPhongMaterial({ color: 0x8844aa }),\n  );\n  scene1.add(mesh);\n}\n```\n\n貌似 react-three-fiber 的 render 函数也可以把 JSX 渲染成 scene。但是使用的时候告诉我需要创建 context，难道是要用 React.createContext? 感觉坑很多，所以暂时没有尝试，以后再补充这里。\n\n```tsx\nconst scene = new Scene();\nconst context = createContext();\n\nrender(\n  <>\n    <perspectiveCamera />\n    <hemishpereLight />\n    <mesh>\n      <boxBufferGeometry args={[1, 1, 1]} attach=\"geometry\" />\n      <meshPhongMaterial color={0x8844aa} attach=\"material\" />\n    </mesh>\n  </>,\n  scene,\n  context\n);\n```\n\n好了，回到正题，现在需要在 target 上面渲染 scene1.\n\n```ts\nuseFrame(({ gl }) => {\n  gl.setRenderTarget(target);\n  gl.render(scene1, camera); // 这里的camera是scene1里面的camera\n  gl.setRenderTarget(null);\n});\n```\n\n和渲染两个 scene 一样，不管打算渲染几个场景，实际的渲染器只有一个，所以渲染好 target 后还要把要渲染的目标换回来。\n\n## 停止渲染\n\nreact-three-fiber 默认会一直渲染每一帧，而在网页上，我们往往不需要它一直耗费 GPU 时间，比如渲染好的动画，只需要它在特殊时间才运动，react-three-fiber 有一个 invalidateFrameloop 选项可以暂停渲染。\n\n```tsx\n<Canvas invalidateFrameloop />\n```\n\n另外`useThree().invalidate`也可以暂停渲染，但这个不太稳定，不确定是不是我的问题。\n\n比如加载进来一个模型，想让它动画结束后就停止 GPU 渲染。\n\n```tsx\nconst animate = useMemo(() => new AnimationMixer(obj));\nconst action = useMemo(() => {\n  const act = animate.clipAction(obj.animations[0]);\n  act.setLoop(LoopOnce, 1);\n  act.enabled = true;\n  act.clampedWhenFinished = true;\n  act.play();\n  return act;\n}, []);\n\nconst { invalidate } = useThree();\n\nuseFrame((_, delta) => {\n  animate.update(delta);\n  if (!act.isRunning()) {\n    invalidate();\n  }\n});\n```\n\n## 使用物理引擎\n\n物理引擎是使用 webGL 最爽的部分，主要是不用考虑那些公式，这里用`Cannon.js`打个比方，（感动常在）。\n\n首先创建世界，比如创建一个 z 轴加速度为 9.82 的世界，还需要 NaiveBroadphase 做碰撞检测。\n\n```ts\nconst world = new World();\nworld.gravity.set(0, 0, -9.82);\nworld.broadphase = new NaiveBroadphase();\n```\n\n接下来创建一个物体，包括它的形状（shape）和在世界中的细节参数（body）。\n\n```ts\nconst shape = new Sphere(1);\nconst body = new Body({ mass: 5, shape });\nworld.add(body);\n```\n\n接下来设置渲染的时间间隔。\n\n```ts\nuseFrame(() => world.step(1 / 60)); // 单位秒\n```\n\n好了，那么怎么和 react-three-fiber 玩耍呢？其实可以写一个[useCannon](https://github.com/gongbaodd/webgl_demos/blob/dev/hooks/useCannon.tsx)。\n\n但是考虑到有现成的 hooks，自己就不用写轮子了，[react-spring/use-cannon](https://github.com/react-spring/use-cannon)，他是用 web worker 跑的，性能肯定更好，直接看例子好了，白嫖真爽。\n\n```jsx\nimport { Canvas } from \"react-three-fiber\";\nimport { Physics, usePlane, useBox } from \"use-cannon\";\n\nfunction Plane(props) {\n  const [ref] = usePlane(() => ({ rotation: [-Math.PI / 2, 0, 0], ...props }));\n  return (\n    <mesh ref={ref}>\n      <planeBufferGeometry attach=\"geometry\" args={[100, 100]} />\n    </mesh>\n  );\n}\n\nfunction Cube(props) {\n  const [ref] = useBox(() => ({ mass: 1, position: [0, 5, 0], ...props }));\n  return (\n    <mesh ref={ref}>\n      <boxBufferGeometry attach=\"geometry\" />\n    </mesh>\n  );\n}\n\nReactDOM.render(\n  <Canvas>\n    <Physics>\n      <Plane />\n      <Cube />\n    </Physics>\n  </Canvas>,\n  document.getElementById(\"root\")\n);\n```\n","collection":"blog","data":{"type":"post","category":"fe","tag":["threejs","webgl"],"series":{"slug":"threejs-howto","name":"细品threejs"}}},{"id":"2020/04/28/keyLemon.md","slug":"2020/04/28/keylemon","body":"\n# keyLemon 让任何一个摄像头都支持人脸登入\n\nWindows hello 是一个用一次就回不去的功能，目前我的笔记本支持指纹登入，一台平板外接了一个指纹接收器，另一台只能 PIN 码登入。显然 PIN 码用起来就不是很爽，然而这机器还是用来看书的。\n\n然而 Windows Hello 对摄像头要求很苛刻，于是我在想，有没有类似于安卓的单镜头解锁方案，KeyLemon 就是，v3 版本已经支持 Windows 10，虽然网上有评论说这软件免费版只能用 7 天，但是软件中只看到三种授权方式，basic 仅支持一张人脸和无活体检测的人脸登录，貌似这个 basic 就是免费版。\n\n实际体验，这个软件受光照影响很大，晚上录入的脸到早上就不识别了，这时输入 PIN 码依然可以登入。\n","collection":"blog","data":{"type":"post","category":"tech","tag":["windows","facial-recognition","keyLemon"],"series":{"slug":"windows-howto","name":"Windows舒适指南"}}}]}