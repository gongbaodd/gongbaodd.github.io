{"posts":[{"id":"2018/08/22/mock-fs-io.md","slug":"2018/08/22/mock-fs-io","body":"# 单元测试时使用mock-fs模拟IO返回值\n\n最近换工作到了一家对测试要求比较高的公司，相比以前仅仅完成Appnium完全匹配不同，这里要求使用jest自动化测试覆盖率达到80%+，[此处应有jest cheat sheet](https://devhints.io/jest)。\n\n工作过程中有很多需要读配置文件的地方，做法是在本地对应位置放上文件，然后配置ignore掉这个文件进行测试，然而这并不是个很优雅的方式（尤其是当代码中有判断此配置是否存在时，需要手动移动文件），此时即可利用mock-fs。\n\n## 简单使用\n\n```javascript\nconst mock = require('mock-fs');\n\nmock({\n  'path/to/fake/dir': {\n    'some-file.txt': 'file content here',\n    'empty-dir': {/** empty directory */}\n  },\n  'path/to/some.png': Buffer.from([8, 6, 7, 5, 3, 0, 9]),\n  'some/other/path': {/** another empty directory */}\n});\n```\n\n指定的文件夹地址是默认相对于process.cwd()的，当然也可以配置其它地址。执行mock之后，所有有关IO的部分就都被修改了。\n\n## 需要注意的地方\n\n* 因为强制修改了IO，你会发现require也不好用了所以一般放在require之后\n* 记得要在每个用例执行之后回收mock状态\n\n```javascript\ndecribe('# test', () => {\n    const mockfs = require('mock-fs');\n    beforeEach(() => jest.resetModule());\n    afterEach(() => mockfs.restore());\n    it('should do ...', () => {\n        const foo = require('foo.js');\n        mockfs({...});\n        expect(foo)...\n    });\n})\n```","collection":"blog","data":{"type":"post","category":"fe"}}]}